<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-01-17T00:22:33.414740</updated>
  <id>7908975f-bd7b-4ca5-b3a9-196fb6c62077</id>

  
    <entry>
      <title>Distjoint Sets（互いに素な集合） -- disjoint_sets : リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html"/>
      <id>0876aae3f9108a6832681a1e3c182fa8d8448f4e:archive/boost_docs/libs/disjoint_sets.md</id>
      <updated>2015-01-17 00:22:20 +0900</updated>
      
        <content type="html">&lt;h1&gt;Distjoint Sets（互いに素な集合）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、互いに素な集合（素集合）の演算に 順位による和集合 および パス圧縮 を提供する。disjoint-sets のデータ構造は、素集合の S = {S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ..., S&lt;sub&gt;k&lt;/sub&gt;} というコレクションを維持する。 各集合は、集合のいくつかの要素である 代表値 によって識別される。 集合は、Parent プロパティマップの中の符号化された有向木によって表わされる。 2つの発見的手法: 「順位による和集合」 および 「パス圧縮」 は、 演算を高速化するのに使われる  [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#tarjan83&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#clr90&#34;&gt;2&lt;/a&gt;]。&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;boost/disjoint_sets.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Rank&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値型が整数型で、キー型が集合の要素型と等しい &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Parent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルで、かつ、キー型および値型は集合の要素型と等しくなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;disjoint_sets&lt;/code&gt; に対する典型的な使用法の手本は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/kruskal_minimum_spanning_tree.md.nolink&#34;&gt;&lt;code&gt;kruskal_minimum_spanning_tree()&lt;/code&gt;&lt;/a&gt; アルゴリズムで見ることができる。 この例では、&lt;code&gt;union_set()&lt;/code&gt; の代わりに &lt;code&gt;link()&lt;/code&gt; を呼び出す。 なぜなら、&lt;code&gt;u&lt;/code&gt; および &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;find_set()&lt;/code&gt; から得られ、したがって、既にそれら集合の代表値であるからだ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;...
disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; dsets(rank, p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (ui  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G).first; ui &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vertices(G).second; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ui)
  dsets.make_set(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ui);
...
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; ( &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;Q.empty() ) {
  e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Q.front();
  Q.pop();
  u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(source(e));
  v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(target(e));
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( u &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v ) {
    &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;out&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; e;
    dsets.link(u, v);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(Rank r, Parent p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(const disjoint_sets&amp;amp; x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void make_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Element x&lt;/code&gt; を含む単集合を作成する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void link(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; で表わされる 2つの集合を結合する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void union_set(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; を含む 2つの集合を結合する。 これは、&lt;code&gt;link(find_set(x),find_set(y))&lt;/code&gt; に相当する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Element find_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; を含む集合のための代表値を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;std::size_t count_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;素集合の個数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void compress_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;すべての要素の親がその代表値であるように親ツリーを平滑化する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Complexity&lt;/h2&gt;
&lt;p&gt;時間計算量は、O(m alpha(m,n)) である。alpha は逆アッカーマン関数、 m は disjoint-set の演算（&lt;code&gt;make_set()&lt;/code&gt;、&lt;code&gt;find_set()&lt;/code&gt;、および &lt;code&gt;link()&lt;/code&gt;）の総数、n は要素数である。 alpha 関数はとても遅く、log 関数よりもはるかに遅くなる。&lt;/p&gt;
&lt;p&gt;参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_connected_components.md.nolink&#34;&gt;&lt;code&gt;incremental_connected_components()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ID,InverseID,FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、順位および親のプロパティのための記憶領域を内部で管理する。 記憶領域は、要素IDにより索引付けされた配列の中にある。ゆえに、ID および InverseID ファンクタを必要とする。 順位および親のプロパティは、構築中に初期化される、 したがって、各要素は自動的に集合の中にある（従って、このクラスのオブジェクトを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.md.nolink#sec:initialize-incremental-components&#34;&gt;&lt;code&gt;initialize_incremental_components()&lt;/code&gt;&lt;/a&gt; 関数で初期化することは必要でない。）。 このクラスは、頂点プロパティを格納する場所を提供しない &lt;code&gt;edge_list&lt;/code&gt; グラフの（動的）接続している構成要素を計算する場合に特に有用である。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0からN（集合中の要素の総数）までの整数に要素を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;InverseID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素に整数を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;representative_with_full_path_compression&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;p&gt;このクラスは、以下のメンバだけでなく &lt;code&gt;disjoint_sets&lt;/code&gt; のすべてのメンバも持っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage(size_type n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
                           ID id &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ID(),
                           InverseID inv &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; InverseID())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンストラクタ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ElementIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;
  normalize_sets(ElementIterator first, ElementIterator last)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;各集合の代表値が最も小さな ID を備えた要素になるように代表値を再整理する。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事後条件: &lt;code&gt;v &amp;gt;= parent[v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事前条件: 素集合の構造は圧縮されていなければならない。 &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_path_halving&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; と同じ構成要素のための代表的な頂点を検索するファンクタである。 代表値木を横断している間、ファンクタは、さらに木の高さを短くするためにパス二分技術を適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_full_path_compression&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; が属する集合のための代表的な要素を検索するファンクタである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~llee1&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:llee1@lsc.nd.edu&#34;&gt;llee1@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:lums@lsc.nd.edu&#34;&gt;lums@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 IKOMA Yoshiki &lt;a href=&#34;mailto:ikoma@mb.i-chubu.ne.jp&#34;&gt;ikoma@mb.i-chubu.ne.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Improved Function Object Adapters -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Improved Function Object Adapters&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/functional/&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/functional/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準ライブラリの関数オブジェクトアダプタ(セクション 20.3.5 から 20.3.8)を強化する。この強化は主に二つの変更を行う。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我々は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;参照の参照&lt;/a&gt; 問題を回避し、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#args&#34;&gt;引数渡し&lt;/a&gt; の効率を良くするために、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; テンプレートを使う。&lt;/li&gt;
&lt;li&gt;我々は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html&#34;&gt;&lt;code&gt;ptr_fun&lt;/code&gt;&lt;/a&gt; の必要性を回避するために、このライブラリのアダプタとともに、ふたつの&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を使う。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;p&gt;このヘッダは以下の関数・クラステンプレートを含む:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分類&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;Function object traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_traits&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binary_traits&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクトや関数の引数型を決定するために使われる。&lt;code&gt;ptr_fun&lt;/code&gt;の必要性を除去する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html&#34;&gt;Negators&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binary_negate&lt;/code&gt;&lt;br /&gt; &lt;code&gt;not1&lt;/code&gt;&lt;br /&gt; &lt;code&gt;not2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.5 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html&#34;&gt;Binders&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;binder1st&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binder2nd&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bind1st&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bind2nd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.6 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html&#34;&gt;Adapters for pointers to functions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pointer_to_unary_function&lt;/code&gt;&lt;br /&gt; &lt;code&gt;pointer_to_binary_function&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptr_fun&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.7 に基づく。このライブラリとともに使用する場合はバインダやネゲータは関数に適合できるので不要である。しかし、サードパーティのアダプタに必要とされるかもしれない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html&#34;&gt;Adapters for pointers to member functions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mem_fun_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun1_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun1_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun1_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun1_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun_ref&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.8 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;これらのアダプタの使い方は標準関数オブジェクトアダプタの使い方にとてもよく似ている。唯一の違いは、&lt;code&gt;std::&lt;/code&gt; の代わりに &lt;code&gt;boost::&lt;/code&gt; と書く必要があることだけである。そうすればあなたの頭痛は軽減される。&lt;/p&gt;
&lt;p&gt;例えば、あなたが &lt;code&gt;set_name&lt;/code&gt; 関数を持つ&lt;code&gt;Person&lt;/code&gt;クラスを持っていると考えてほしい:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Person&lt;/span&gt;
{
  &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set_name(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;name);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;あなたは以下のように書くことによって、コレクション &lt;code&gt;c&lt;/code&gt; 中の &lt;code&gt;Person&lt;/code&gt; の束を改名できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Person&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set_name), &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Fred&#34;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もし代わりに標準アダプタが使われていれば、このコードは普通、コンパイルに失敗する。それは、&lt;code&gt;set_name&lt;/code&gt; が参照引数を取るからである。何故こうなるかを解明したければ、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;バインダのドキュメント&lt;/a&gt; の中のコメントを参照するとよい。&lt;/p&gt;
&lt;h2&gt;Compiler Compatibility&lt;/h2&gt;
&lt;p&gt;このヘッダと &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_test.cpp.html&#34;&gt;テストプログラム&lt;/a&gt; は以下のコンパイラでコンパイルされる:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;コンパイラ&lt;/th&gt;
&lt;th&gt;コメント&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Borland C++Builder 4 Update 2&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Borland C++ 5.5&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g++ 2.95.2&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft Visual C++ Service Pack 3&lt;/td&gt;
&lt;td&gt;コンパイラが部分特殊化版を欠いているため、このライブラリは標準アダプタによって提供されるより、少しだけしか多くの機能を提供しない。&lt;br /&gt; ・参照の参照問題を回避するための &lt;code&gt;call_traits&lt;/code&gt; メカニズムが使えない。それゆえ、このライブラリのアダプタはより少ない状況でしか使えないだろう。&lt;br /&gt; ・関数の引数や返り値型を特定するための &lt;code&gt;function_traits&lt;/code&gt; メカニズムが使えない。それゆえ、関数を適合させるため、&lt;code&gt;ptr_fun&lt;/code&gt; が引き続き必要になる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Future Directions&lt;/h2&gt;
&lt;p&gt;このライブラリの第一目的は、できる限り多くの標準ライブラリの互換性を 持つ、参照の参照問題に対する解である。これによって本や雑誌で読む技術を 今日のたくさんのコンパイラで使うことができる。&lt;/p&gt;
&lt;p&gt;長期的には、より良い解は以下のようなものだろう:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;幾人かの Boost のメンバは式テンプレートのライブラリを作成し ている。これらによって、関数の結合や適合が自然な文法で行えるだろう。 これは新しい技術なので、それが熟して、有名なコンパイラに広くサポートされるまでに時間がかかるかもしれないが、大きな成功となるだろう。それまでは、この functional.hpp ライブラリがギャップを埋める。&lt;/li&gt;
&lt;li&gt;標準委員会はテンプレートの実体化に際して参照の参照問題が起きることを認識していて、標準を修正する気になっている( &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Author&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/mark_rodgers.htm&#34; target=&#34;_blank&#34;&gt;Mark Rodgers&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/john_maddock.htm&#34; target=&#34;_blank&#34;&gt;John Maddock&lt;/a&gt; for suggesting the mechanism that allowed the function objects traits to work correctly. &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jens_maurer.htm&#34; target=&#34;_blank&#34;&gt;Jens Maurer&lt;/a&gt; provided invaluable feedback during the &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/more/formal_review_process.htm&#34; target=&#34;_blank&#34;&gt;formal review process&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Binders -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional/binders.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Binders&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.6): 由来のバインダ関数オブジェクトアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binder1st&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binder2nd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bind1st&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind2nd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準ライブラリにあるそれらの代わりに、これらのアダプタを使う主な便益は、それらが &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;参照の参照&lt;/a&gt; 問題を回避することにある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い方は標準バインダと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Foo&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34; name=&#34;refref&#34;&gt;References to References&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下の使用例を考えなさい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Foo&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これがもし &lt;code&gt;std::bind2nd&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt; を使って書かれているならば、コンパイルできないだろう。&lt;/p&gt;
&lt;p&gt;この問題は &lt;code&gt;bar&lt;/code&gt; が参照引数を取ることが原因で起こる。標準は &lt;code&gt;std::mem_fun_ref&lt;/code&gt; を &lt;code&gt;second_argument_type&lt;/code&gt; が &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; である関数オブジェクトを作るように定義する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind2nd&lt;/code&gt; 呼び出しは &lt;code&gt;binder2nd&lt;/code&gt; を作り、それは標準が以下のように定義している:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Operation&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;binder2nd&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;first_argument_type,
                            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;result_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
...
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  binder2nd(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x,
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;second_argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; y);
  ...
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々の &lt;code&gt;Operation&lt;/code&gt; の &lt;code&gt;second_argument_type&lt;/code&gt; は &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; であるから、コンストラクタの中の &lt;code&gt;y&lt;/code&gt; の型は &lt;code&gt;std::ostream&amp;amp;&amp;amp;&lt;/code&gt; となるだろう。参照の参照を作ることはできないから、参照の参照は C++ では非合法であるとしてこの時点でコンパイルエラーになる。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;このライブラリのバインダは Boost &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; テンプレートを使うことによってこの問題を回避している。&lt;/p&gt;
&lt;p&gt;コンストラクタは以下のように宣言される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;binder2nd(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x,
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
             &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; binary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;second_argument_type
          &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type y)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;結果、&lt;code&gt;y&lt;/code&gt; は &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; 型を持つ。そして、我々の例はコンパイルされる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Member Function Adapters -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional/mem_fun.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Member Function Adapters&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準ライブラリ (§ 20.3.8): 由来のメンバ関 数アダプタの全ての強化バージョンを含んでいる:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem_fun_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun1_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun1_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun1_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun1_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem_fun&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun_ref&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準のアダプタそれぞれから、以下の変更がなされている:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;first_argument_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; は &lt;code&gt;const_&lt;/code&gt; ファミリーのメンバ関数アダプタのために 修正されている。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#firstarg&#34;&gt;以下&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fun1_t&lt;/code&gt;やその変種に渡される引数は、メンバ関数の引数型として、&lt;code&gt;call_traits::param_type&lt;/code&gt; を用いて渡される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#firstarg&#34; name=&#34;firstarg&#34;&gt;first_argument_type&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;const_mem_fun1_t&lt;/code&gt; を例えば、以下のように指定する:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;S&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;const_mem_fun1_t&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;, A, S&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;const_mem_fun1_t&lt;/span&gt;(S (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;p)(A) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);
  S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, A x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;binary_function&lt;/code&gt; への第一引数が実際には &lt;code&gt;const T*&lt;/code&gt; であるにも関わらず、 &lt;code&gt;T*&lt;/code&gt; になっている点に注意しなさい。&lt;/p&gt;
&lt;p&gt;これはどういうことか？さて、我々が以下のように書くとき何が起こるかを考えなさい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Foo { &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;; };
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;cp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Foo;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind1st(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), cp);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は以下のようなものを効果的に含む &lt;code&gt;const_mem_fun1_t&lt;/code&gt; オブジェクトを作成した。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Foo&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; first_argument_type;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次に &lt;code&gt;bind1st&lt;/code&gt; はこの &lt;code&gt;typedef&lt;/code&gt; を &lt;code&gt;cp&lt;/code&gt; によって初期化されるメンバ型として用いる &lt;code&gt;binder1st&lt;/code&gt; オブジェクトを作成する。言い換えれば、我々は &lt;code&gt;Foo*&lt;/code&gt; メンバを &lt;code&gt;const Foo*&lt;/code&gt; メンバで初期化する必要がある！ 明らかに これは不可能であるので、標準ライブラリのベンダはこれを実装するために &lt;code&gt;cp&lt;/code&gt; の定数性を、おそらく &lt;code&gt;bind1st&lt;/code&gt; の本体の中で、キャストして取り除かなければならなかっただろう。&lt;/p&gt;
&lt;p&gt;このハックは改良された &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html&#34;&gt;バインダ&lt;/a&gt; とともに用いる場合十分ではないので、我々はメンバ関数アダプタの修正されたバージョンも同様に提供しなければならなかった。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;mem_fun1_t&lt;/code&gt; を例えば以下のように定義する (§20.3.8 ¶2):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;S&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;mem_fun1_t&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;, A, S&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;mem_fun1_t&lt;/span&gt;(S (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;p)(A));
  S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, A x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; の第二引数はメンバ関数の引数と全く同じであることに注意しなさい。もしこれが値型であれば、引数は二度値渡しされてコピーされる。&lt;/p&gt;
&lt;p&gt;しかしながら、もし我々が引数を代わりに &lt;code&gt;const A&amp;amp;&lt;/code&gt; として宣言することによってこの非効率性を削除しようとするならば、もし &lt;code&gt;A&lt;/code&gt; が参照型であれば、我々は参照の参照を持ってしまう。そしてそれは現在のところ非合法である。 (ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;operator()&lt;/code&gt; の引数を宣言する望ましい方法は、メンバ関数の引数が参照であるかないかに依っている。もしそれが参照であるならば、単純に &lt;code&gt;A&lt;/code&gt; と宣言したいのであり、もし値であれば &lt;code&gt;const A&amp;amp;&lt;/code&gt; と宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特殊化版を用いて正確にこの判断をを行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;call traits テンプレートはこの改良を実現するために使われる関数オブジェ クト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化の機能を持つコンパイラでのみ有効である。そうでないコンパイラでは、メンバ関数に渡される引数は(&lt;code&gt;mem_fun1_t&lt;/code&gt; ファミリの中で) 常に参照渡しとなるので、参照の参照の可能性を生みだすことになる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Negators -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional/negators.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Negators&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.5) 由来のネゲータアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binary_negate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;not1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このライブラリのネゲータは標準バージョンを二つの方法で改良する。&lt;/p&gt;
&lt;p&gt;適合関数オブジェクトではなく関数を否定する時、それらは &lt;code&gt;ptr_fun&lt;/code&gt; の必要を回避するために、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を用いる。&lt;/p&gt;
&lt;p&gt;それらは引数や適合された関数に渡す引数を宣言する最上の方法を決するため、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;call traits&lt;/a&gt; を用いる。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34;&gt;下記&lt;/a&gt;参照)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い型は標準ネゲータと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++ 標準 (§20.3.5) は unary negate をこのように定義 している。(binary negate も似ている):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type,&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; unary_negate(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; pred);
  &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であった場合、 &lt;code&gt;operator()&lt;/code&gt; の引数の型は参照の参照になることに注意しなさい。これは、現在の C++ では非合法である。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;しかしながら、もし代わりに &lt;code&gt;operator()&lt;/code&gt; を &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; を変更せずにそのまま採用して定義すると、それが値型であった場合不必要に非効率になってしまう。それは引数が二度コピーされることによる。一度は &lt;code&gt;unary_negate&lt;/code&gt; の &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時、さらに適合された関数で &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時にもう一度である。&lt;/p&gt;
&lt;p&gt;つまり&lt;code&gt;operator()&lt;/code&gt; を宣言する望ましい方法は、 &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であるか否かに依 る。もしそれが参照であれば、単純に &lt;code&gt;argument_type&lt;/code&gt; として宣言したいし、それが値であれば &lt;code&gt;const argument_type&amp;amp;&lt;/code&gt; として宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.html&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特 殊化版を用いて正確にこの判断を行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。実のところ、実際の宣言は関数オブジェクト特性を使うためもう少し複雑である。しかし効果は同様である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;この関数オブジェクト特性の両方と call traits はこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化版の機能を持つコンパイラでのみ有効である。 そうでないコンパイラでは、このライブラリのネゲータは標準内のそれらと非常に似た振る舞いをする - 関数に適合するために &lt;code&gt;ptr_fun&lt;/code&gt; が必要であるし、参照の参照は避けられないだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Function Pointer Adapters -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional/ptr_fun.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Function Pointer Adapters&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§ 20.3.7): 由来の関数ポインタアダプ タの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointer_to_unary_function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointer_to_binary_function&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ptr_fun&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;しかし、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を使用しているおかげで、このライブラリのアダプタと接続する場合、このアダプタを使う必要はない。しかしながら、あなたの実装が我々の特性クラスとともにきちんと働かない場合 (部分特殊化版が欠けていることによる) や、サードパーティの関数オブジェクトアダプタとともに使いたい場合に、使う必要があるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;これらのアダプタを使う必要がある場合、使い方は標準関数ポインタアダプタと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it
     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ptr_fun(bad)));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかしながら、このライブラリは関数オブジェクト特性をサポートする、強化された &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html&#34;&gt;ネゲータ&lt;/a&gt; を含んでいることに注意しなさい。それで、以上のソースと同様に以下のように書ける。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it
     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;pointer_to_unary_function&lt;/code&gt; をこのように定 義する(§20.3.8 ¶2):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Result&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;pointer_to_unary_function&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Arg, Result&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; pointer_to_unary_function(Result (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; f)(Arg));
  Result &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Arg x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; の引数はラップされる関数の引数と厳密に等しい型であることに注意しなさい。もしこれが値型であれば、引数は値渡しされ、二度コピーされる。&lt;code&gt;pointer_to_binary_function&lt;/code&gt; も同様の問題を持っている。&lt;/p&gt;
&lt;p&gt;しかしながら、引数を代わりに &lt;code&gt;const Arg&amp;amp;&lt;/code&gt; と宣言することによって非効率を削除しようとすると、&lt;code&gt;Arg&lt;/code&gt; が参照型であった場合、現 在では非合法な (ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)、参照の参照ができてしまう。&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;operator()&lt;/code&gt; の引数を宣言する望ましい方法は、ラップされる関数の引数が参照であるかないかに依っている。もしそれが参照であるならば、単純に &lt;code&gt;Arg&lt;/code&gt; と宣言したいのであり、もし値であれば &lt;code&gt;const Arg&amp;amp;&lt;/code&gt; と宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特殊化版を用いて正確にこの判断をを行う。&lt;code&gt;operator()&lt;/code&gt; を以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Result &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Arg&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;call traits テンプレートはこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化の機能を持つコンパイラでのみ有効である。そうでないコンパイラでは、関数に渡される引数は常に参照渡しとなるので、参照の参照の可能性を生みだすことになる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.Function Tutorial -- function : リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function/tutorial.html"/>
      <id>0f20049b631fa910713a22d5b01e2861891bf896:archive/boost_docs/libs/function/tutorial.md</id>
      <updated>2015-01-17 00:19:54 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost.Function Tutorial&lt;/h1&gt;
&lt;p&gt;Boost.Function には 2 種類の文法がある。推奨文法と互換文法である。推奨文法は C++ にフィットし、考慮するテンプレートパラメータの数も減り、可読性を高めることが多い。しかし、コンパイラのバグのせいで、推奨文法が使えないコンパイラもある。互換文法は Boost.Function がサポートする全てのコンパイラで使える。どちらの文法を使うかは、下の表を見て決めてほしい。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GNU C++ 2.95.x, 3.0.x, 3.1.x, 3.2&lt;br /&gt; Comeau C++ 4.2.45.2&lt;br /&gt; SGI MIPSpro 7.3.0&lt;br /&gt; Intel C++ 5.0, 6.0&lt;br /&gt; Compaq&#39;s cxx 6.2&lt;/td&gt;
&lt;td&gt;Microsoft Visual C++ 6.0, 7.0&lt;br /&gt; Borland C++ 5.5.1&lt;br /&gt; Sun WorkShop 6 update 2 C++ 5.3&lt;br /&gt; Metrowerks CodeWarrior 8.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;あなたのコンパイラが表になければ、推奨文法を試してみて、結果を Boost MLに報告してほしい。この表を最新に保つためだ。&lt;/p&gt;
&lt;h2&gt;Basic Usage&lt;/h2&gt;
&lt;p&gt;関数オブジェクトのラッパを定義するには、 &lt;code&gt;function&lt;/code&gt; クラステンプレートをインスタンス化するだけだ。テンプレート引数には、戻り値型と引数型を関数型形式で指定する。ある実装定義の最大値 (デフォルトは 10) までなら、引数は何個でもかまわない。以下に、 2 つの &lt;code&gt;int&lt;/code&gt; 型のパラメータを取り、&lt;code&gt;float&lt;/code&gt; 型を返す関数オブジェクトのラッパ f の定義を示す。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;float (int x, int y)&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function2&amp;lt;float, int, int&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトでは、関数オブジェクトのラッパは空である。 &lt;code&gt;f&lt;/code&gt; に代入する関数オブジェクトを作ろう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; int_div { 
  &lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; ((&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)x)&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;y; }; 
};

f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; int_div();
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これで、関数オブジェクト &lt;code&gt;int_div&lt;/code&gt; を呼び出す代わりに &lt;code&gt;f&lt;/code&gt; を使える。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt; には、互換性があれば、どんな関数オブジェクトでも代入できる。 &lt;code&gt;int_div&lt;/code&gt; が 2 つの &lt;code&gt;long&lt;/code&gt; 型の引数をとると宣言されていれば、自動的に暗黙の型変換が適用される。引数型に対する唯一の制限は、コピーコンストラクト可能なことである。だから、参照や配列さえ使える。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;void (int values[], int n, int&amp;amp; sum, float&amp;amp; avg)&amp;gt; sum_avg;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function4&amp;lt;void, int[], int, int&amp;amp;, float&amp;gt; sum_avg;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;do_sum_avg&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; values[], &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; sum, &lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; avg)
{
  sum &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;)
    sum &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; values[i];
  avg &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)sum &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; n;
}

sum_avg &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;do_sum_avg;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;関数オブジェクトを格納していないラッパを呼び出すのは事前条件違反である。ヌルの関数ポインタを呼び出そうとするようなものだ。関数オブジェクトのラッパが空かどうかは &lt;code&gt;empty()&lt;/code&gt; メソッドでチェックできる。もっと簡潔なのは、 &lt;code&gt;bool&lt;/code&gt; 型の文脈でラッパを使う方法だ。ラッパは、空でなければ &lt;code&gt;true&lt;/code&gt; と評価される。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (f)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;f has no target, so it is unsafe to call&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラッパを空にするには、 &lt;code&gt;clear()&lt;/code&gt; メンバ関数を使う。&lt;/p&gt;
&lt;h2&gt;Free functions&lt;/h2&gt;
&lt;p&gt;非メンバ関数へのポインタは、 &lt;code&gt;const&lt;/code&gt; な関数呼出し演算子を持つ (インスタンスが1つだけ存在する) 関数オブジェクトの一種とみなせる。よって、関数オブジェクトのラッパに直接代入できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;mul_ints&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; ((&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)x) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; y; }
f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;mul_ints;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Microsoft Visual C++ version 6 を使う場合を除けば、本当は &lt;code&gt;&amp;amp;&lt;/code&gt; は不要だ。&lt;/p&gt;
&lt;h2&gt;Member functions&lt;/h2&gt;
&lt;p&gt;多くのシステムで、コールバックは特定のオブジェクトのメンバ関数を呼び出すことが多い。これは「引数の束縛」と呼ばれ、 Boost.Function の守備範囲外である。しかし、 Boost.Function には直接メンバ関数を扱う方法がある。以下のコードのように使う。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X {
  &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; foo(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;int (X*, int)&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function2&amp;lt;int, X*, int&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;foo;

X x;
f(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;引数の束縛をサポートするライブラリはいくつかある。その内 3 つを以下に要約する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;Boost.Bind&lt;/a&gt;。このライブラリを使えば、あらゆる関数オブジェクトの引数を束縛できる。軽くて移植性が高い。&lt;/li&gt;
&lt;li&gt;C++ 標準ライブラリ。 &lt;code&gt;std::bind1st&lt;/code&gt; と &lt;code&gt;std::mem_fun&lt;/code&gt; を一緒に使って、メンバ関数ポインタと (その対象となる) オブジェクトを束縛したものは、 Boost.Function で使える。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X {
  &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; foo(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;X x;
f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind1st(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;foo), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;x);

f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// x.foo(5)を呼び出す&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/lambda.md.nolink&#34;&gt;Boost.Lambda&lt;/a&gt; ライブラリ。このライブラリは、自然な C++ の文法を使って関数オブジェクトを構築する強力な機構を提供する。 Lambda は、コンパイラが C++ 標準にかなり準拠していないと使えない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References to Functions&lt;/h2&gt;
&lt;p&gt;Boost.Function による関数オブジェクトのコピーが高価 (または不正) な場合がある。そんな場合は、 Boost.Function に実際の関数オブジェクトの「参照」を格納させることができる。&lt;code&gt;ref&lt;/code&gt; や &lt;code&gt;cref&lt;/code&gt; を使うことで、関数オブジェクトの参照のラッパを作成できる。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stateful_type a_function_object;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;f = ref(a_function_object);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f2(f);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;stateful_type a_function_object;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;f = ref(a_function_object);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f2(f);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;こうすれば、 &lt;code&gt;f&lt;/code&gt; も &lt;code&gt;f2&lt;/code&gt; も &lt;code&gt;a_function_object&lt;/code&gt; のコピーを作成しない。さらに、関数オブジェクトの参照を使えば、 Boost.Function は代入、構築時に例外を起こさない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Last modified: Fri Oct 11 05:40:00 EDT 2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list -- adjacency_list : リンク切れしているものにnolinkを付けた</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html"/>
      <id>f82546f4c450e0b17f2800c65d3c4d607db52efc:archive/boost_docs/libs/graph/adjacency_list.md</id>
      <updated>2015-01-17 00:18:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_list&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed,
               VertexProperties, EdgeProperties,
               GraphProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスは一般化された隣接リストグラフ構造を実装する。 テンプレート・パラメータは要求を最も満たすクラスのバージョンを選べるように多くの形態の選択肢を提供する。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34;&gt;adjacency-list&lt;/a&gt; は基本的に二次元の構造で、ここで最初の次元の各要素は頂点を表し、頂点の各々はその辺リストの一次元構造を含んでいる。 Figure 1 は有向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 1:有向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータは外部の二次元コンテナを表すためにどんな種類のコンテナが使われるかを制御する。 &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータは辺リストを表すためにどんな種類の コンテナが使われるかを制御する。&lt;code&gt;EdgeList&lt;/code&gt; と &lt;code&gt;VertexList&lt;/code&gt; の 選択はグラフ構造の空間計算量を決定するだろう、そして様々なグラフ操作の時間計算量を決定するだろう。可能な選択とトレード・オフは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#choosing-graph-type&#34;&gt;Choosing the Edgelist and VertexList&lt;/a&gt; 中で論じられる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータはグラフが有向か無向か、または 入辺と出辺の両方にアクセスする (これを双方向性と呼ぶ) 有向かを制御する。 双方向性グラフは各辺が出辺リストと入辺リストの両方に現れるため、辺当たり有向グラフの二倍の空間を取る。Figure 2 は無向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 2:無向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの使い方のチュートリアルは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink&#34;&gt;Using &lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/family-tree-eg.cpp.html&#34;&gt;&lt;code&gt;examples/family-tree-eg.cpp&lt;/code&gt;&lt;/a&gt; 中にある例は家族の木 (family tree) をグラフで表現する方法を示す。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各々の頂点の辺リストを表わすために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの頂点リストを表すために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向か、無向か、または双方向の辺アクセス (出辺と入辺の両方にアクセス する) の有向かを選ぶ選択子。選択肢は &lt;code&gt;directedS&lt;/code&gt;、&lt;code&gt;undirectedS&lt;/code&gt;、 そして &lt;code&gt;bidirectionalS&lt;/code&gt; である。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ・オブジェクトのためのプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.md.nolink&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.md.nolink&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Vertex and Edge Properties&lt;/h2&gt;
&lt;p&gt;色、距離、重み、そしてユーザ定義のプロパティのようなプロパティは、プロパティ を用いてグラフの頂点と辺に結びつけることができる。プロパティの値はグラフに よって提供されるプロパティ・マップ経由で読み書きできる。プロパティ・マップ は get(property, g) 関数経由で得られる。プロパティの使い方は 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#adjacency-list-properties&#34;&gt;Internal Properties&lt;/a&gt; 内で述べられている。プロパティ・マップは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.md.nolink&#34;&gt;Property Map Concepts&lt;/a&gt; 内で定義されているインターフェースを実装するオブジェクトである。 &lt;code&gt;adjacency_list&lt;/code&gt; クラスから得られるプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.md.nolink&#34;&gt;Lvalue Property Map&lt;/a&gt; コンセプトのモデルである。もし &lt;code&gt;adjacency_list&lt;/code&gt; が &lt;code&gt;const&lt;/code&gt; なら、 プロパティ・マップは定数である。さもなくばプロパティ・マップは変更可能である。&lt;/p&gt;
&lt;p&gt;もしグラフの &lt;code&gt;VertexList&lt;/code&gt; が &lt;code&gt;vecS&lt;/code&gt; なら、グラフは &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティのためのプロパティ・マップを経由して アクセスされた組み込みの頂点の添え字を持っている。添え字は &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲内に整列し、連続している。頂点が 削除される時、添え字はそれらのプロパティを持ち続けるよう調整される。 これらの添え字を外部のプロパティの記憶領域にアクセスするために使う際には いくらか気をつけなければならない。 頂点の添え字のためのプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;Readable Property Map&lt;/a&gt; のモデルである。&lt;/p&gt;
&lt;h2&gt;Iterator and Descriptor Stability/Invalidation&lt;/h2&gt;
&lt;p&gt;辺の追加や削除によってグラフの構造を変更する時はいくらか注意しなければならない。&lt;code&gt;adjacency_list&lt;/code&gt; の型と操作に依存して、グラフ内を指すイテレータや記述子オブジェクトのいくつかは無効になるかもしれない。 例えば、次のコードは未定義の (悪い) 振る舞いの結果となるだろう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, vecS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=vecS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これでもまだ間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これが問題である理由は &lt;code&gt;remove_vertex()&lt;/code&gt; を呼び出しており、そしてそれが &lt;code&gt;VertexList=vecS&lt;/code&gt; の &lt;code&gt;adjacency_list&lt;/code&gt; とともに使われたとき、グラフのための全てのイテレータと記述子 (例えば &lt;code&gt;vi&lt;/code&gt; や &lt;code&gt;vi_end&lt;/code&gt;) を無効にするために、ループの次の繰り返し中に災難を引き起こす。&lt;/p&gt;
&lt;p&gt;もし異なる種類の &lt;code&gt;adjacency_list&lt;/code&gt; を使い、そして &lt;code&gt;VertexList=listS&lt;/code&gt; ならば、イテレータが削除された実際の頂点を指してなければ &lt;code&gt;remove_vertex&lt;/code&gt; を呼ぶことによってイテレータは無効にならない。次のコードはこれを説明する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, listS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=listS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これは大丈夫である&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;安定性の問題は更に頂点記述子と辺記述子に影響を及ぼす。例えば、最短経路木中の頂点の親 (または先行点) の過程を保持するために頂点記述子の &lt;code&gt;vector&lt;/code&gt; を使ったとしよう (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ)。&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; を呼んで親の &lt;code&gt;vector&lt;/code&gt; を作成し、 それからグラフから頂点を削除する。続いて親の &lt;code&gt;vector&lt;/code&gt; を使おうと試みるが、全ての頂点記述子は無効になっているので、結果は正しくない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(num_vertices(G));
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(num_vertices(G));

dijkstra_shortest_paths(G, s, distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
  predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));

remove_vertex(s, G); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// まずい考えだ！親 vector 中の頂点記述子を無効にする&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 次は間違った結果を生じる&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(tie(vi, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; p[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; is the parent of &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この議論の中でイテレータと記述子の無効化は、操作によって &lt;strong&gt;直接影響を受けない&lt;/strong&gt; イテレータと記述子の無効化に携わっていることに注意しなさい。 例えば、&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の実行は、&lt;code&gt;adjacency_list&lt;/code&gt; の種類に関係なく、いつも &lt;code&gt;(u,v)&lt;/code&gt; のためのどの辺記述子も、また&lt;code&gt;(u,v)&lt;/code&gt; を指すどの辺記述子も無効にするだろう。 このイテレータと記述子の無効化の議論中で、他の辺 (&lt;code&gt;(u,v)&lt;/code&gt; ではない) を指す辺記述子とイテレータにおける &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の影響にのみ携わっている。&lt;/p&gt;
&lt;p&gt;一般的に頂点記述子と辺記述子を安定に (決して無効にならない) したければ、 &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; と &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;listS&lt;/code&gt; または &lt;code&gt;setS&lt;/code&gt; を使いなさい。もし記述子とイテレータの安定性に気をもまないけれどもメモリの 消費量とグラフの巡回速度をより心配するなら、&lt;code&gt;VertexList&lt;/code&gt; かつ／または &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;vecS&lt;/code&gt; を使いなさい。&lt;/p&gt;
&lt;p&gt;下記の表はどの操作が記述子とイテレータを無効にする原因となるかを要約する。 表中で、&lt;code&gt;EL&lt;/code&gt; は &lt;code&gt;EdgeList&lt;/code&gt; の省略形で &lt;code&gt;VL&lt;/code&gt; は &lt;code&gt;VertexList&lt;/code&gt; を意味する。 &lt;strong&gt;Adj Iter (隣接イテレータ)&lt;/strong&gt; カテゴリは &lt;code&gt;out_edge_iterator&lt;/code&gt;、&lt;code&gt;in_edge_iterator&lt;/code&gt;、そして &lt;code&gt;adjacency_iterator&lt;/code&gt; 型を含む。記述子とイテレータの無効化の より詳しい説明は各操作のドキュメント中で示されている。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;頂点記述子&lt;/th&gt;
&lt;th&gt;辺記述子&lt;/th&gt;
&lt;th&gt;頂点イテレータ&lt;/th&gt;
&lt;th&gt;辺イテレータ&lt;/th&gt;
&lt;th&gt;隣接イテレータ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_out_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_in_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table: 記述子とイテレータの無効化の要約&lt;/p&gt;
&lt;h2&gt;Associated Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;adjacency_list_traits&amp;lt;EdgeList, VertexList, Directed&amp;gt;::vertex_descriptor
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた頂点記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた辺記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;VertexList=vecS&lt;/code&gt; なら &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;EdgeList=vecS&lt;/code&gt; なら &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;adjacency_iterator&lt;/code&gt; は &lt;code&gt;out_edge_iterator&lt;/code&gt; と同じイテレータ・ コンセプトをモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフが有向 (&lt;code&gt;directed_tag&lt;/code&gt;) か、無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) かについての情報を提供する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これはグラフのクラスが多重辺 (同じ始点と終点を持つ辺) の挿入を許可するかどうかを述べる。二つのタグは &lt;code&gt;allow_parallel_edge_tag&lt;/code&gt; と &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;code&gt;setS&lt;/code&gt; と &lt;code&gt;hash_setS&lt;/code&gt; の亜種は多重辺を許可しない一方で他の型は多重辺を許可する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点に接続する辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点プロパティまたは辺プロパティのためのプロパティ・マップの型。 具体的なプロパティは &lt;code&gt;Property&lt;/code&gt; テンプレート引数で指定され、グラフのための &lt;code&gt;VertexProperties&lt;/code&gt; もしくは &lt;code&gt;EdgeProperties&lt;/code&gt; で指定されたプロパティのどちらか一つと一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Property&lt;/code&gt; タグで指定されたグラフのプロパティのためのプロパティの値型。&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;デフォルト・コンストラクタ。0 個の頂点と0 個の辺からなる空のグラフ・ オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コピー・コンストラクタ。辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーである新しいグラフを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;代入演算子。&lt;code&gt;this&lt;/code&gt; に 辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーを入れる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(vertices_size_type n, 
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と 0 個の辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;template &amp;lt;class EdgeIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               vertices_size_type n, 
               edges_size_type m = 0, 
               const GraphProperty&amp;amp; p = GraphProperty())&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;
`n` 個の頂点と、範囲 `[first, last)` で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 `EdgeIterator` は [`InputIterator`](http://www.sgi.com/tech/stl/InputIterator.html) のモデルでなければならない。`EdgeIterator` の値型は `std::pair` でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは `[0, n)` の範囲内に整列していなければならない。


***
```cpp
template &amp;lt;class EdgeIterator, class EdgePropertyIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               EdgePropertyIterator ep_iter,
               vertices_size_type n,
               vertices_size_type m = 0,
               const GraphProperty&amp;amp; p = GraphProperty())
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と、範囲 &lt;code&gt;[first, last)&lt;/code&gt; で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; と &lt;code&gt;EdgePropertyIterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;code&gt;EdgeIterator&lt;/code&gt; の値型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは &lt;code&gt;[0, n)&lt;/code&gt; の範囲内に整列していなければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperties&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear()
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから全ての辺と頂点を削除する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; のグラフの頂点、辺、そしてプロパティと、グラフ&lt;code&gt;x&lt;/code&gt;の頂点、辺、そしてプロパティを交換する。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;h3&gt;Structure Access&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; の出辺へのアクセスを提供するイテレータ範囲を返す。もしグラフが無向グラフなら、このイテレータ範囲は 頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。 有向グラフと無向グラフの両方で、出辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; に隣接する頂点の場合は &lt;code&gt;source(e, g) == u&lt;/code&gt; かつ &lt;code&gt;target(e, g) == v&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
in_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する イテレータ範囲を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに &lt;code&gt;bidirectionalS&lt;/code&gt; が指定されている場合にのみ利用できる。 入辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; に隣接している何らかの頂点 &lt;code&gt;u&lt;/code&gt; に対して、グラフが有向であろうと無向であろうと、&lt;code&gt;target(e, g) == v&lt;/code&gt; かつ &lt;code&gt;source(e, g) == u&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; を出て行く辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
in_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; に入ってくる辺の数を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに&lt;code&gt;bidirectionalS&lt;/code&gt;が指定されている場合にのみ利用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type
num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type
num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点リスト中の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; と頂点 &lt;code&gt;v&lt;/code&gt; を結ぶ辺を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge_range(vertex_descriptor u, vertex_descriptor v,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; への全ての多重辺のための範囲を与える出辺イテレータのペアを返す。この関数は &lt;code&gt;adjacency_list&lt;/code&gt; 用の &lt;code&gt;EdgeList&lt;/code&gt; が終点に従って出辺をソートし、かつ多重辺を考慮するコンテナである時にのみ動作する。&lt;code&gt;multisetS&lt;/code&gt; 選択子はそのようなコンテナを選択する。&lt;/p&gt;
&lt;h3&gt;Structure Modification&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフに辺 &lt;code&gt;(u,v)&lt;/code&gt; を付け加え、新しい辺のための辺記述子を返す。 多重辺を許可しないグラフにとっては、もし辺がすでにグラフ中にあるなら、二重には付け加えられず、&lt;code&gt;bool&lt;/code&gt; フラグは &lt;code&gt;false&lt;/code&gt; になるだろう。同様に、もし &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; が 同じ頂点のための記述子 (ループを作っている) であり、かつグラフが無向グラフならば、辺は付け加えられずフラグは &lt;code&gt;false&lt;/code&gt; になるだろう。 フラグが &lt;code&gt;false&lt;/code&gt; の時は、返された辺記述子は既に存在している辺を指す。&lt;/p&gt;
&lt;p&gt;出辺リスト中の新しい辺の配置は一般に不定である。もっとも出辺リストの順序付けは &lt;code&gt;EdgeList&lt;/code&gt; の選択を通じて成し遂げられるが。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;VertexList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; でありかつ頂点記述子 &lt;code&gt;u&lt;/code&gt; または &lt;code&gt;v&lt;/code&gt; (それは整数である) がグラフ中の現在の頂点の数より大きな値を持っているなら、頂点の数が &lt;code&gt;std::max(u,v) + 1&lt;/code&gt; に なるようにグラフが拡大される。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; であれば、この操作によって頂点 &lt;code&gt;u&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; も無効になるだろう。 これはもし &lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;push(container, x)&lt;/code&gt; が呼び出されたときにそのイテレータを無効にするようなユーザ定義のコンテナ (章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#custom-storage&#34;&gt;Customizing the Adjacency List Storage&lt;/a&gt; を見なさい) であれば同様にあてはまる。 もしグラフが同様に双方向であれば、&lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;in_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりに グラフが無向グラフならば &lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりにグラフが有向グラフならば、 &lt;code&gt;add_edge()&lt;/code&gt; は同様にどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフに付け加え、&lt;code&gt;p&lt;/code&gt; を辺の内部のプロパティの記憶領域の値として添える。さらなる詳細のために前の &lt;code&gt;add_edge()&lt;/code&gt; 非メンバ関数も見なさい。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから取り除く。&lt;/p&gt;
&lt;p&gt;この操作は辺 &lt;code&gt;(u,v)&lt;/code&gt; を指すどの発行済みの辺記述子もイテレータも無効となる原因になる。加えて、もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; ならば無向と双方向のグラフの場合この操作は頂点 &lt;code&gt;u&lt;/code&gt; とまた頂点 &lt;code&gt;v&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; をグラフから取り除く。これは多重グラフの場合 &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数とは違う。この &lt;code&gt;remove_edge(e, g)&lt;/code&gt; 関数は一つの辺だけを取り除くのに対して &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数は全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を取り除く。&lt;/p&gt;
&lt;p&gt;この操作は記述子 &lt;code&gt;e&lt;/code&gt; が指す同じ辺のためのどの発行済みの辺記述子も イテレータも無効にする。加えて、この操作は &lt;code&gt;target(e, g)&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはグラフのためのどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(out_edge_iterator iter, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;remove_edge(*iter, g)&lt;/code&gt; と同じ効果を持つ。違いはこの関数は有向グラフの場合定数の時間計算量を持つのに対し、&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は O(E/V) の時間計算量を持つ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_out_edge_if(vertex_descriptor u, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                        adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;u&lt;/code&gt; の出辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_in_edge_if(vertex_descriptor v, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                       adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;v&lt;/code&gt; の入辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向と双方向の &lt;code&gt;adjacency_list&lt;/code&gt; グラフに利用できるが、有向グラフには利用できない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge_if(&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての辺を取り除く。すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点をグラフに付け加え、新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
           adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;指定されたプロパティを持つ頂点をグラフに付け加える。新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; への、そして &lt;code&gt;u&lt;/code&gt; からの全ての辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点または終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_out_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての出辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点として 持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出す時のそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向グラフには適用できない (代わりに &lt;code&gt;clear_vertex()&lt;/code&gt; を使いなさい)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_in_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての入辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は双方向グラフにのみ適用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; をグラフの頂点集合から取り除く。頂点が削除されるとき、 頂点 &lt;code&gt;u&lt;/code&gt; への、また頂点 &lt;code&gt;u&lt;/code&gt; への辺は存在しないものと仮定する。 これを確実にする一つの手段はあらかじめ &lt;code&gt;clear_vertex()&lt;/code&gt; を呼ぶことである。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータが &lt;code&gt;vecS&lt;/code&gt; なら、グラフのための全ての頂点記述子、辺記述子、そしてイテレータ はこの操作によって無効にされる。各頂点のための組み込みの &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティは操作の後もなお頂点の添え字が連続した範囲 &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; に配列しているように番号が付け直される。 もし組み込みの頂点の添え字に基づく外部のプロパティの記憶領域を使って いるなら、外部の記憶領域は調整される必要があるだろう。 他の選択は組み込みの頂点の添え字を使用せずに独自の頂点の添え字プロパティを付け加えるためにプロパティを代わりに使うことである。 もしたびたび &lt;code&gt;remove_vertex()&lt;/code&gt; 関数を使用する必要があるなら、 &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータには &lt;code&gt;listS&lt;/code&gt; 選択子が非常によい選択である。&lt;/p&gt;
&lt;h3&gt;Property Map Accessors&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PropertyTag&lt;/code&gt; で指定される頂点プロパティのためのプロパティ・マップ・ オブジェクトを返す。&lt;code&gt;PropertyTag&lt;/code&gt; はグラフの &lt;code&gt;VertexProperty&lt;/code&gt; テンプレート引数中に指定されたプロパティの一つに一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; が頂点記述子か辺記述子のどちらか一方である場合、これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を &lt;code&gt;value&lt;/code&gt; にする。&lt;code&gt;x&lt;/code&gt; は頂点記述子か辺記述子のどちらか一方である。&lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_list, PropertyTag&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; と互換でなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.md.nolink&#34;&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_traits.md.nolink&#34;&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list -- adjacency_list : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html"/>
      <id>07c4d5d2b03fce8ffaf0569589780e1b19b76328:archive/boost_docs/libs/graph/adjacency_list.md</id>
      <updated>2015-01-17 00:14:36 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_list&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed,
               VertexProperties, EdgeProperties,
               GraphProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスは一般化された隣接リストグラフ構造を実装する。 テンプレート・パラメータは要求を最も満たすクラスのバージョンを選べるように多くの形態の選択肢を提供する。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34;&gt;adjacency-list&lt;/a&gt; は基本的に二次元の構造で、ここで最初の次元の各要素は頂点を表し、頂点の各々はその辺リストの一次元構造を含んでいる。 Figure 1 は有向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 1:有向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータは外部の二次元コンテナを表すためにどんな種類のコンテナが使われるかを制御する。 &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータは辺リストを表すためにどんな種類の コンテナが使われるかを制御する。&lt;code&gt;EdgeList&lt;/code&gt; と &lt;code&gt;VertexList&lt;/code&gt; の 選択はグラフ構造の空間計算量を決定するだろう、そして様々なグラフ操作の時間計算量を決定するだろう。可能な選択とトレード・オフは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#choosing-graph-type&#34;&gt;Choosing the Edgelist and VertexList&lt;/a&gt; 中で論じられる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータはグラフが有向か無向か、または 入辺と出辺の両方にアクセスする (これを双方向性と呼ぶ) 有向かを制御する。 双方向性グラフは各辺が出辺リストと入辺リストの両方に現れるため、辺当たり有向グラフの二倍の空間を取る。Figure 2 は無向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 2:無向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの使い方のチュートリアルは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink&#34;&gt;Using &lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/family-tree-eg.cpp.html&#34;&gt;&lt;code&gt;examples/family-tree-eg.cpp&lt;/code&gt;&lt;/a&gt; 中にある例は家族の木 (family tree) をグラフで表現する方法を示す。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各々の頂点の辺リストを表わすために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの頂点リストを表すために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向か、無向か、または双方向の辺アクセス (出辺と入辺の両方にアクセス する) の有向かを選ぶ選択子。選択肢は &lt;code&gt;directedS&lt;/code&gt;、&lt;code&gt;undirectedS&lt;/code&gt;、 そして &lt;code&gt;bidirectionalS&lt;/code&gt; である。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ・オブジェクトのためのプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.html&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.html&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Vertex and Edge Properties&lt;/h2&gt;
&lt;p&gt;色、距離、重み、そしてユーザ定義のプロパティのようなプロパティは、プロパティ を用いてグラフの頂点と辺に結びつけることができる。プロパティの値はグラフに よって提供されるプロパティ・マップ経由で読み書きできる。プロパティ・マップ は get(property, g) 関数経由で得られる。プロパティの使い方は 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#adjacency-list-properties&#34;&gt;Internal Properties&lt;/a&gt; 内で述べられている。プロパティ・マップは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.html&#34;&gt;Property Map Concepts&lt;/a&gt; 内で定義されているインターフェースを実装するオブジェクトである。 &lt;code&gt;adjacency_list&lt;/code&gt; クラスから得られるプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; コンセプトのモデルである。もし &lt;code&gt;adjacency_list&lt;/code&gt; が &lt;code&gt;const&lt;/code&gt; なら、 プロパティ・マップは定数である。さもなくばプロパティ・マップは変更可能である。&lt;/p&gt;
&lt;p&gt;もしグラフの &lt;code&gt;VertexList&lt;/code&gt; が &lt;code&gt;vecS&lt;/code&gt; なら、グラフは &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティのためのプロパティ・マップを経由して アクセスされた組み込みの頂点の添え字を持っている。添え字は &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲内に整列し、連続している。頂点が 削除される時、添え字はそれらのプロパティを持ち続けるよう調整される。 これらの添え字を外部のプロパティの記憶領域にアクセスするために使う際には いくらか気をつけなければならない。 頂点の添え字のためのプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルである。&lt;/p&gt;
&lt;h2&gt;Iterator and Descriptor Stability/Invalidation&lt;/h2&gt;
&lt;p&gt;辺の追加や削除によってグラフの構造を変更する時はいくらか注意しなければならない。&lt;code&gt;adjacency_list&lt;/code&gt; の型と操作に依存して、グラフ内を指すイテレータや記述子オブジェクトのいくつかは無効になるかもしれない。 例えば、次のコードは未定義の (悪い) 振る舞いの結果となるだろう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, vecS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=vecS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これでもまだ間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これが問題である理由は &lt;code&gt;remove_vertex()&lt;/code&gt; を呼び出しており、そしてそれが &lt;code&gt;VertexList=vecS&lt;/code&gt; の &lt;code&gt;adjacency_list&lt;/code&gt; とともに使われたとき、グラフのための全てのイテレータと記述子 (例えば &lt;code&gt;vi&lt;/code&gt; や &lt;code&gt;vi_end&lt;/code&gt;) を無効にするために、ループの次の繰り返し中に災難を引き起こす。&lt;/p&gt;
&lt;p&gt;もし異なる種類の &lt;code&gt;adjacency_list&lt;/code&gt; を使い、そして &lt;code&gt;VertexList=listS&lt;/code&gt; ならば、イテレータが削除された実際の頂点を指してなければ &lt;code&gt;remove_vertex&lt;/code&gt; を呼ぶことによってイテレータは無効にならない。次のコードはこれを説明する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, listS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=listS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これは大丈夫である&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;安定性の問題は更に頂点記述子と辺記述子に影響を及ぼす。例えば、最短経路木中の頂点の親 (または先行点) の過程を保持するために頂点記述子の &lt;code&gt;vector&lt;/code&gt; を使ったとしよう (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ)。&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; を呼んで親の &lt;code&gt;vector&lt;/code&gt; を作成し、 それからグラフから頂点を削除する。続いて親の &lt;code&gt;vector&lt;/code&gt; を使おうと試みるが、全ての頂点記述子は無効になっているので、結果は正しくない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(num_vertices(G));
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(num_vertices(G));

dijkstra_shortest_paths(G, s, distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
  predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));

remove_vertex(s, G); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// まずい考えだ！親 vector 中の頂点記述子を無効にする&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 次は間違った結果を生じる&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(tie(vi, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; p[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; is the parent of &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この議論の中でイテレータと記述子の無効化は、操作によって &lt;strong&gt;直接影響を受けない&lt;/strong&gt; イテレータと記述子の無効化に携わっていることに注意しなさい。 例えば、&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の実行は、&lt;code&gt;adjacency_list&lt;/code&gt; の種類に関係なく、いつも &lt;code&gt;(u,v)&lt;/code&gt; のためのどの辺記述子も、また&lt;code&gt;(u,v)&lt;/code&gt; を指すどの辺記述子も無効にするだろう。 このイテレータと記述子の無効化の議論中で、他の辺 (&lt;code&gt;(u,v)&lt;/code&gt; ではない) を指す辺記述子とイテレータにおける &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の影響にのみ携わっている。&lt;/p&gt;
&lt;p&gt;一般的に頂点記述子と辺記述子を安定に (決して無効にならない) したければ、 &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; と &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;listS&lt;/code&gt; または &lt;code&gt;setS&lt;/code&gt; を使いなさい。もし記述子とイテレータの安定性に気をもまないけれどもメモリの 消費量とグラフの巡回速度をより心配するなら、&lt;code&gt;VertexList&lt;/code&gt; かつ／または &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;vecS&lt;/code&gt; を使いなさい。&lt;/p&gt;
&lt;p&gt;下記の表はどの操作が記述子とイテレータを無効にする原因となるかを要約する。 表中で、&lt;code&gt;EL&lt;/code&gt; は &lt;code&gt;EdgeList&lt;/code&gt; の省略形で &lt;code&gt;VL&lt;/code&gt; は &lt;code&gt;VertexList&lt;/code&gt; を意味する。 &lt;strong&gt;Adj Iter (隣接イテレータ)&lt;/strong&gt; カテゴリは &lt;code&gt;out_edge_iterator&lt;/code&gt;、&lt;code&gt;in_edge_iterator&lt;/code&gt;、そして &lt;code&gt;adjacency_iterator&lt;/code&gt; 型を含む。記述子とイテレータの無効化の より詳しい説明は各操作のドキュメント中で示されている。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;頂点記述子&lt;/th&gt;
&lt;th&gt;辺記述子&lt;/th&gt;
&lt;th&gt;頂点イテレータ&lt;/th&gt;
&lt;th&gt;辺イテレータ&lt;/th&gt;
&lt;th&gt;隣接イテレータ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_out_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_in_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table: 記述子とイテレータの無効化の要約&lt;/p&gt;
&lt;h2&gt;Associated Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;adjacency_list_traits&amp;lt;EdgeList, VertexList, Directed&amp;gt;::vertex_descriptor
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた頂点記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた辺記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;VertexList=vecS&lt;/code&gt; なら &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;EdgeList=vecS&lt;/code&gt; なら &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;adjacency_iterator&lt;/code&gt; は &lt;code&gt;out_edge_iterator&lt;/code&gt; と同じイテレータ・ コンセプトをモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフが有向 (&lt;code&gt;directed_tag&lt;/code&gt;) か、無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) かについての情報を提供する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これはグラフのクラスが多重辺 (同じ始点と終点を持つ辺) の挿入を許可するかどうかを述べる。二つのタグは &lt;code&gt;allow_parallel_edge_tag&lt;/code&gt; と &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;code&gt;setS&lt;/code&gt; と &lt;code&gt;hash_setS&lt;/code&gt; の亜種は多重辺を許可しない一方で他の型は多重辺を許可する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点に接続する辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点プロパティまたは辺プロパティのためのプロパティ・マップの型。 具体的なプロパティは &lt;code&gt;Property&lt;/code&gt; テンプレート引数で指定され、グラフのための &lt;code&gt;VertexProperties&lt;/code&gt; もしくは &lt;code&gt;EdgeProperties&lt;/code&gt; で指定されたプロパティのどちらか一つと一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Property&lt;/code&gt; タグで指定されたグラフのプロパティのためのプロパティの値型。&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;デフォルト・コンストラクタ。0 個の頂点と0 個の辺からなる空のグラフ・ オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コピー・コンストラクタ。辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーである新しいグラフを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;代入演算子。&lt;code&gt;this&lt;/code&gt; に 辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーを入れる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(vertices_size_type n, 
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と 0 個の辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;template &amp;lt;class EdgeIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               vertices_size_type n, 
               edges_size_type m = 0, 
               const GraphProperty&amp;amp; p = GraphProperty())&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;
`n` 個の頂点と、範囲 `[first, last)` で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 `EdgeIterator` は [`InputIterator`](http://www.sgi.com/tech/stl/InputIterator.html) のモデルでなければならない。`EdgeIterator` の値型は `std::pair` でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは `[0, n)` の範囲内に整列していなければならない。


***
```cpp
template &amp;lt;class EdgeIterator, class EdgePropertyIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               EdgePropertyIterator ep_iter,
               vertices_size_type n,
               vertices_size_type m = 0,
               const GraphProperty&amp;amp; p = GraphProperty())
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と、範囲 &lt;code&gt;[first, last)&lt;/code&gt; で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; と &lt;code&gt;EdgePropertyIterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;code&gt;EdgeIterator&lt;/code&gt; の値型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは &lt;code&gt;[0, n)&lt;/code&gt; の範囲内に整列していなければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperties&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear()
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから全ての辺と頂点を削除する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; のグラフの頂点、辺、そしてプロパティと、グラフ&lt;code&gt;x&lt;/code&gt;の頂点、辺、そしてプロパティを交換する。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;h3&gt;Structure Access&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; の出辺へのアクセスを提供するイテレータ範囲を返す。もしグラフが無向グラフなら、このイテレータ範囲は 頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。 有向グラフと無向グラフの両方で、出辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; に隣接する頂点の場合は &lt;code&gt;source(e, g) == u&lt;/code&gt; かつ &lt;code&gt;target(e, g) == v&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
in_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する イテレータ範囲を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに &lt;code&gt;bidirectionalS&lt;/code&gt; が指定されている場合にのみ利用できる。 入辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; に隣接している何らかの頂点 &lt;code&gt;u&lt;/code&gt; に対して、グラフが有向であろうと無向であろうと、&lt;code&gt;target(e, g) == v&lt;/code&gt; かつ &lt;code&gt;source(e, g) == u&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; を出て行く辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
in_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; に入ってくる辺の数を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに&lt;code&gt;bidirectionalS&lt;/code&gt;が指定されている場合にのみ利用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type
num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type
num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点リスト中の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; と頂点 &lt;code&gt;v&lt;/code&gt; を結ぶ辺を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge_range(vertex_descriptor u, vertex_descriptor v,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; への全ての多重辺のための範囲を与える出辺イテレータのペアを返す。この関数は &lt;code&gt;adjacency_list&lt;/code&gt; 用の &lt;code&gt;EdgeList&lt;/code&gt; が終点に従って出辺をソートし、かつ多重辺を考慮するコンテナである時にのみ動作する。&lt;code&gt;multisetS&lt;/code&gt; 選択子はそのようなコンテナを選択する。&lt;/p&gt;
&lt;h3&gt;Structure Modification&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフに辺 &lt;code&gt;(u,v)&lt;/code&gt; を付け加え、新しい辺のための辺記述子を返す。 多重辺を許可しないグラフにとっては、もし辺がすでにグラフ中にあるなら、二重には付け加えられず、&lt;code&gt;bool&lt;/code&gt; フラグは &lt;code&gt;false&lt;/code&gt; になるだろう。同様に、もし &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; が 同じ頂点のための記述子 (ループを作っている) であり、かつグラフが無向グラフならば、辺は付け加えられずフラグは &lt;code&gt;false&lt;/code&gt; になるだろう。 フラグが &lt;code&gt;false&lt;/code&gt; の時は、返された辺記述子は既に存在している辺を指す。&lt;/p&gt;
&lt;p&gt;出辺リスト中の新しい辺の配置は一般に不定である。もっとも出辺リストの順序付けは &lt;code&gt;EdgeList&lt;/code&gt; の選択を通じて成し遂げられるが。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;VertexList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; でありかつ頂点記述子 &lt;code&gt;u&lt;/code&gt; または &lt;code&gt;v&lt;/code&gt; (それは整数である) がグラフ中の現在の頂点の数より大きな値を持っているなら、頂点の数が &lt;code&gt;std::max(u,v) + 1&lt;/code&gt; に なるようにグラフが拡大される。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; であれば、この操作によって頂点 &lt;code&gt;u&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; も無効になるだろう。 これはもし &lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;push(container, x)&lt;/code&gt; が呼び出されたときにそのイテレータを無効にするようなユーザ定義のコンテナ (章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#custom-storage&#34;&gt;Customizing the Adjacency List Storage&lt;/a&gt; を見なさい) であれば同様にあてはまる。 もしグラフが同様に双方向であれば、&lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;in_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりに グラフが無向グラフならば &lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりにグラフが有向グラフならば、 &lt;code&gt;add_edge()&lt;/code&gt; は同様にどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフに付け加え、&lt;code&gt;p&lt;/code&gt; を辺の内部のプロパティの記憶領域の値として添える。さらなる詳細のために前の &lt;code&gt;add_edge()&lt;/code&gt; 非メンバ関数も見なさい。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから取り除く。&lt;/p&gt;
&lt;p&gt;この操作は辺 &lt;code&gt;(u,v)&lt;/code&gt; を指すどの発行済みの辺記述子もイテレータも無効となる原因になる。加えて、もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; ならば無向と双方向のグラフの場合この操作は頂点 &lt;code&gt;u&lt;/code&gt; とまた頂点 &lt;code&gt;v&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; をグラフから取り除く。これは多重グラフの場合 &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数とは違う。この &lt;code&gt;remove_edge(e, g)&lt;/code&gt; 関数は一つの辺だけを取り除くのに対して &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数は全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を取り除く。&lt;/p&gt;
&lt;p&gt;この操作は記述子 &lt;code&gt;e&lt;/code&gt; が指す同じ辺のためのどの発行済みの辺記述子も イテレータも無効にする。加えて、この操作は &lt;code&gt;target(e, g)&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはグラフのためのどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(out_edge_iterator iter, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;remove_edge(*iter, g)&lt;/code&gt; と同じ効果を持つ。違いはこの関数は有向グラフの場合定数の時間計算量を持つのに対し、&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は O(E/V) の時間計算量を持つ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_out_edge_if(vertex_descriptor u, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                        adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;u&lt;/code&gt; の出辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_in_edge_if(vertex_descriptor v, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                       adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;v&lt;/code&gt; の入辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向と双方向の &lt;code&gt;adjacency_list&lt;/code&gt; グラフに利用できるが、有向グラフには利用できない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge_if(&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての辺を取り除く。すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点をグラフに付け加え、新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
           adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;指定されたプロパティを持つ頂点をグラフに付け加える。新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; への、そして &lt;code&gt;u&lt;/code&gt; からの全ての辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点または終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_out_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての出辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点として 持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出す時のそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向グラフには適用できない (代わりに &lt;code&gt;clear_vertex()&lt;/code&gt; を使いなさい)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_in_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての入辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は双方向グラフにのみ適用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; をグラフの頂点集合から取り除く。頂点が削除されるとき、 頂点 &lt;code&gt;u&lt;/code&gt; への、また頂点 &lt;code&gt;u&lt;/code&gt; への辺は存在しないものと仮定する。 これを確実にする一つの手段はあらかじめ &lt;code&gt;clear_vertex()&lt;/code&gt; を呼ぶことである。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータが &lt;code&gt;vecS&lt;/code&gt; なら、グラフのための全ての頂点記述子、辺記述子、そしてイテレータ はこの操作によって無効にされる。各頂点のための組み込みの &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティは操作の後もなお頂点の添え字が連続した範囲 &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; に配列しているように番号が付け直される。 もし組み込みの頂点の添え字に基づく外部のプロパティの記憶領域を使って いるなら、外部の記憶領域は調整される必要があるだろう。 他の選択は組み込みの頂点の添え字を使用せずに独自の頂点の添え字プロパティを付け加えるためにプロパティを代わりに使うことである。 もしたびたび &lt;code&gt;remove_vertex()&lt;/code&gt; 関数を使用する必要があるなら、 &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータには &lt;code&gt;listS&lt;/code&gt; 選択子が非常によい選択である。&lt;/p&gt;
&lt;h3&gt;Property Map Accessors&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PropertyTag&lt;/code&gt; で指定される頂点プロパティのためのプロパティ・マップ・ オブジェクトを返す。&lt;code&gt;PropertyTag&lt;/code&gt; はグラフの &lt;code&gt;VertexProperty&lt;/code&gt; テンプレート引数中に指定されたプロパティの一つに一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; が頂点記述子か辺記述子のどちらか一方である場合、これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を &lt;code&gt;value&lt;/code&gt; にする。&lt;code&gt;x&lt;/code&gt; は頂点記述子か辺記述子のどちらか一方である。&lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_list, PropertyTag&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; と互換でなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_map.html&#34;&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_traits.html&#34;&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>