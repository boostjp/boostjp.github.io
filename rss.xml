<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="https://boostjp.github.io" />
  <updated>2020-06-03T11:43:01.747518</updated>
  <id>ef4bdc5c-da85-4eab-946b-84376bcf713b</id>

  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Boost.Rationalの翻訳ドキュメントを移植(close #20)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>e89a3b43e52a34bc1f84036ce2000b465215e2cb:archive/boost_docs/libs.md</id>
      <updated>2020-06-03T20:41:07+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;各ライブラリの翻訳ドキュメント&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/function.html&#34;&gt;function&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;遅延呼び出し及びコールバックのための関数オブジェクトラッパ。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/functional.html&#34;&gt;functional&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;機能強化された関数オブジェクトアダプタ。 Mark Rodgers 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/graph.html&#34;&gt;graph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;汎用グラフコンポーネント及びアルゴリズム。 Jeremy Siek and a University of Notre Dame team 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/io/ios_state.html&#34;&gt;io state savers&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;入出力の状態を保存して、データが化けるのを防ぐ。 Daryle Walker 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda.html&#34;&gt;lambda&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;実際の呼び出し時の、小さな無名関数オブジェクトの定義。, from Jaakko Jävi and Gary Powell.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/math.html&#34;&gt;math&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学の領域での多くの貢献。様々な作者による。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/multi_array.html&#34;&gt;muti_array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリ上で連続したデータの配列のための多次元コンテナとアダプタ。 Ron Garcia 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/preprocessor.html&#34;&gt;preprocessor&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;繰り返しと再帰を含むプリプロセッサメタプログラミングツール群。 Vesa Karvonen 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/pool.html&#34;&gt;pool&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリプールの管理。Steve Cleary 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/random.html&#34;&gt;random&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;乱数生成のためのシステム一式。 Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/rational.html&#34;&gt;rational&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;有理数クラス。 Paul Moore 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex.html&#34;&gt;regex&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;正規表現ライブラリ。 John Maddock 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/signals.html&#34;&gt;signals&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;管理されたシグナルとスロットのコールバックでの実装。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/static_assert.html&#34;&gt;static_assert&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;静的アサート(コンパイル時アサート)。 John Maddock 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/smart_ptr.html&#34;&gt;smart_ptr&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;5つのスマートポインタクラステンプレート Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html&#34;&gt;tuple&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数の値を返す関数の簡単な定義など。 Jaakko Javi 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/type_traits.html&#34;&gt;type_traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型の基本的な特徴のためのテンプレート。 John Maddock, Steve Cleary, et al 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Rational Number Library -- Boost.Rationalの翻訳ドキュメントを移植(close #20)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/rational.html"/>
      <id>e89a3b43e52a34bc1f84036ce2000b465215e2cb:archive/boost_docs/libs/rational.md</id>
      <updated>2020-06-03T20:41:07+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Rational Number Library&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;rational.hpp ヘッダは有理数を扱うための実装を提供する。
有理数ライブラリは、ちょうど一般的な複素数クラスのようにテンプレートベースで実装されている。&lt;/p&gt;
&lt;p&gt;本ライブラリは一般的な用途を想定しており、数論への適用や、それ以外でも、数学的に厳密な演算が必要な場合には、もっと専門的な目的のライブラリを使うことを考えるべきである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/rational/rational.html&#34;&gt;ドキュメンテーション&lt;/a&gt; (HTML).&lt;/li&gt;
&lt;li&gt;Header &lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/boost/rational.hpp&#34; target=&#34;_blank&#34;&gt;ヘッダファイル（rational.hpp）&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;See the &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/rational/rational.html&#34;&gt;documentation&lt;/a&gt; サンプルプログラム&lt;/li&gt;
&lt;li&gt;Submitted by &lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/people/paul_moore.htm&#34; target=&#34;_blank&#34;&gt; Paul Moore&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Revised December 14, 1999&lt;/p&gt;
&lt;p&gt;(c) Copyright Paul Moore 1999.
Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies.
This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Rational Numbers -- Boost.Rationalの翻訳ドキュメントを移植(close #20)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/rational/rational.html"/>
      <id>e89a3b43e52a34bc1f84036ce2000b465215e2cb:archive/boost_docs/libs/rational/rational.md</id>
      <updated>2020-06-03T20:41:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/rational/rational.md b/archive/boost_docs/libs/rational/rational.md
new file mode 100644
index 0000000..e629d10
--- /dev/null
+++ b/archive/boost_docs/libs/rational/rational.md
@@ -0,0 +1,491 @@
+# Rational Numbers
+
+## &amp;lt;a name=&amp;#34;Contents&amp;#34;&amp;gt;コンテンツ&amp;lt;/a&amp;gt;
+
+1. [Class rational synopsis](#Class rational synopsis)
+2. [理論的根拠](#Rationale)
+3. [背景](#Background)
+4. [基本要素となる整数型の要件](#Integer Type Requirements)
+5. [インターフェイス](#Interface)
+	- [ユーティリティ関数](#Utility functions)
+	- [コンストラクタ](#Constructors)
+	- [算術演算子](#Arithmetic operations)
+	- [入出力](#Input and Output)
+	- [In-place assignment](#In-place assignment)
+	- [型変換](#Conversions)
+	- [分数表現（Numerator and Denominator）](#Numerator and Denominator)
+6. [パフォーマンス](#Performance)
+7. [例外](#Exceptions)
+8. [内部表現](#Internal representation)
+9. [デザインノート](#Design notes)
+	- [最小の実装（Minimal Implementation）](#Minimal Implementation)
+	- [範囲制限された整数型（Limited-range integer types）](#Limited-range integer types)
+	- [浮動小数点データからの型変換](#Conversion from floating point)
+	- [絶対値](#Absolute Value)
+10. [リファレンス](#References)
+11. [History and Acknowledgements](#History and Acknowledgements)
+
+## &amp;lt;a name=&amp;#34;Class rational synopsis&amp;#34;&amp;gt;Class rational synopsis&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/rational.hpp&amp;gt;
+
+namespace boost {
+
+template &amp;lt;typename I&amp;gt; I gcd(I n, I m);
+template &amp;lt;typename I&amp;gt; I lcm(I n, I m);
+
+class bad_rational;
+
+template&amp;lt;typename I&amp;gt; class rational {
+    typedef I int_type;
+
+    // コンストラクタ
+    rational();          // ゼロ
+    rational(I n);       // n/1 （つまり、整数値の n）
+    rational(I n, I d);  // n/d に等しい
+
+    // コピーコンストラクタと代入演算子
+
+    // 基本要素となる整数型からの代入
+    rational&amp;amp; operator=(I n);
+
+    // in place 代入
+    rational&amp;amp; assign(I n, I d);
+
+    // （内部の）表記へのアクセス
+    I numerator() const;
+    I denominator() const;
+
+    // 以下の演算子に加えて、継承した演算子が使用可能である。
+    // operators.hpp を参照のこと。
+
+    // 数値演算
+    rational&amp;amp; operator+= (const rational&amp;amp; r);
+    rational&amp;amp; operator-= (const rational&amp;amp; r);
+    rational&amp;amp; operator*= (const rational&amp;amp; r);
+    rational&amp;amp; operator/= (const rational&amp;amp; r);
+
+    // 整数型との数値演算
+    rational&amp;amp; operator+= (I i);
+    rational&amp;amp; operator-= (I i);
+    rational&amp;amp; operator*= (I i);
+    rational&amp;amp; operator/= (I i);
+
+    // インクリメントとデクリメント
+    const rational&amp;amp; operator++();
+    const rational&amp;amp; operator--();
+
+    // 否定演算
+    bool operator!() const;
+
+    // 比較演算
+    bool operator&amp;lt; (const rational&amp;amp; r) const;
+    bool operator== (const rational&amp;amp; r) const;
+
+    // 整数型との比較演算
+    bool operator&amp;lt; (I i) const;
+    bool operator&amp;gt; (I i) const;
+    bool operator== (I i) const;
+}
+
+// 単項演算子
+template &amp;lt;typename I&amp;gt; rational&amp;lt;I&amp;gt; operator+ (const rational&amp;lt;I&amp;gt;&amp;amp; r);
+template &amp;lt;typename I&amp;gt; rational&amp;lt;I&amp;gt; operator- (const rational&amp;lt;I&amp;gt;&amp;amp; r);
+
+// 整数型（と型コンパチブルな型）から有理数クラスを引く／割る演算子
+// Reversed order operators for - and / between (types convertible to) I and rational
+template &amp;lt;typename I, typename II&amp;gt; inline rational&amp;lt;I&amp;gt; operator- (II i, const rational&amp;lt;I&amp;gt;&amp;amp; r);
+template &amp;lt;typename I, typename II&amp;gt; inline rational&amp;lt;I&amp;gt; operator/ (II i, const rational&amp;lt;I&amp;gt;&amp;amp; r);
+
+// 絶対値
+template &amp;lt;typename I&amp;gt; rational&amp;lt;I&amp;gt; abs (const rational&amp;lt;I&amp;gt;&amp;amp; r);
+
+// 入出力
+template &amp;lt;typename I&amp;gt; std::istream&amp;amp; operator&amp;gt;&amp;gt; (std::istream&amp;amp; is, rational&amp;lt;I&amp;gt;&amp;amp; r);
+template &amp;lt;typename I&amp;gt; std::ostream&amp;amp; operator&amp;lt;&amp;lt; (std::ostream&amp;amp; os, const rational&amp;lt;I&amp;gt;&amp;amp; r);
+
+// 型変換
+template &amp;lt;typename T, typename I&amp;gt; T rational_cast (const rational&amp;lt;I&amp;gt;&amp;amp; r);
+```
+
+## &amp;lt;a name=&amp;#34;Rationale&amp;#34;&amp;gt;理論的根拠&amp;lt;/a&amp;gt;
+
+「数」の分類には種々のものがある。
+最も基本的なものとしては、自然数（非負の整数）、そして、整数と実数がある。
+こういった数は（数学的な厳密性は犠牲にされているものの）Ｃ＋＋において `unsigned int`, `int`, `float` （そして、おのおのに対応する異なったサイズのデータ型）として、組み込まれている。
+
+Ｃ＋＋標準ライブラリは、さらに複素数型の機能を提供している。
+
+本ライブラリでは、さらに、**有理数クラス** の機能を提供する。
+
+実際には、本ライブラリにおける **有理数クラス** は、標準ライブラリにおける **複素数** 型と同じくテンプレートベースで提供される。
+
+## &amp;lt;a name=&amp;#34;Background&amp;#34;&amp;gt;背景&amp;lt;/a&amp;gt;
+
+数学的に言えば、有理数とは分数――２つの整数の比で表される数のことである。
+このため、有理数の範囲では表現できない実数値（実数は、２の平方根など分数で表現できない数も表すことができる）も存在する。
+
+コンピュータにおいては数学的な概念を厳密に表現することはできず、数値の扱いにおいて、「妥協」が存在する。
+整数型では値を表現できる範囲に制限（しばしば、32bit幅）が存在し、実数値の近似では精度の限界が存在する。
+こういった、「妥協」は計算の目的に応じて採用されている。
+整数演算は表現範囲が狭いが正確な計算が可能であり、一方、実数演算であれば、精度を犠牲にしなければならないものの、表現できる数値の範囲はずっと広くなる。
+
+有理数ライブラリはこの表現範囲と精度の制限に対して、整数や実数で行われているのとは別の方法を実現するものである。
+有理数による演算は正確に行われる。
+依然として数値の表現範囲に限界があるものの、（通分が行われた後の）分子と分母のデータ長が、テンプレートで使用された整数型のデータ長の範囲である限りにおいては、数値を表現することができる。
+しかしながら、分母や分子の値がテンプレートで与えられた整数型の範囲を超える場合には、演算結果は未定義となる。
+
+有理数クラスは、プログラマが、基本要素となる整数型を適切に選択することによって、オーバーフローの発生を制御できるようにテンプレートクラスとして実装されている。
+たとえば、テンプレートで無限精度の整数型（に類する）クラスが与えられれば、有理数クラスの中でオーバーフローは発生することがなく、あらゆる環境に於いて正確な演算結果が得られる。
+
+## &amp;lt;a name=&amp;#34;Integer Type Requirements&amp;#34;&amp;gt;基本要素となる整数型の要件&amp;lt;/a&amp;gt;
+
+有理数クラスは、単一の型パラメータ `I` をとるテンプレートクラスである。
+この単一の整数型パラメータは、有理数クラスを構成する *基本要素* となる。
+C++ のすべての汎整数型は、型パラメータ `I` として使用できる。
+ユーザー定義の整数型も同様に使用できるが、ユーザー定義型を使用する場合には、ユーザー定義型の演算速度や能力が有理数クラスの演算に大きく影響することを考慮する必要がある。
+（考慮すべき点はしばしば複雑であり――そのため、詳細は後述する [パフォーマンス](#Performance) の項目を参照すること）
+
+補足：boost ライブラリは無限精度整数型をサポートする予定である。
+この無限精度整数型は、有理数クラスの基本要素として利用できるものである。
+
+ユーザー定義の整数型を有理数クラスの基本要素として利用する場合には、以下の関数を準備する必要がある。
+
+- 代入
+- デフォルトコンストラクタ
+- 比較演算子 `==`
+- 比較演算子 `&amp;lt;`
+
+Fさらに、基本要素として利用できる型は、整数型に類似していて、任意の２つのインスタンスの間で以下の演算が、整数型として自然に定義されていなければならない。
+
+- `n + m`
+- `n - m`
+- `n * m`
+- `n / m` （結果は切り捨てられること。また、`n`, `m` が正の場合には結果も正であること）
+- `n % m` （`n`, `m` が正の場合には結果も正であること）
+- 上記の演算結果が代入できること
+- `+n`, `-n`
+
+ユーザー定義整数型に、*０*および、*１* に相当する要素が存在でき。
+それらは、`I(0)` `I(1)` でそれぞれ、生成できなければならない。
+
+補足：この条件は必ずしも `int` 型と暗黙の型変換が可能であることを意味しない。
+`explicit` 修飾されたコンストラクタが存在してもよい。
+
+ユーザー定義整数型として、符号無しのものも許される。
+この場合、生成された有理数クラスもまた符号無しとなる。
+この場合には、引き算によるアンダーフローが発生した場合でも結果は負になることはなく、予測されない結果となる。
+
+- `rational_cast&amp;lt;T&amp;gt;(rational&amp;lt;I&amp;gt;)` が可能か否かは、`I` から `T` への `sataic_cast` が可能かどうかと等価である。
+	また、`x`, `y` がいずれも `T` 型であるときに、`x/y` は有効である。
+- 入出力のための演算子は、型パラメータ `I` における入出力演算子の動作と同様に動作する。
+
+## &amp;lt;a name=&amp;#34;Interface&amp;#34;&amp;gt;インターフェイス&amp;lt;/a&amp;gt;
+
+### &amp;lt;a name=&amp;#34;Utility functions&amp;#34;&amp;gt;ユーティリティ関数&amp;lt;/a&amp;gt;
+
+ユーティリティ関数として、以下の２個が提供される。
+
+|             |                                 |
+|-------------|---------------------------------|
+| `gcd(n, m)` | `n` と `m` の最大公約数を返す。 |
+| `lcm(n, m)` | `n` と `m` の最小公倍数を返す。 |
+
+これらのユーティリティ関数は、有理数クラスの基本要素となる整数型 `I` に対して定義される。
+この際、`I` において以下のオペレータが定義されていなければならない。
+
+`=`, `+=`, `*=`, `/=`, `%`, `&amp;lt;` そして、`I(0)` によって、ゼロ元にアクセスできること。
+
+補足：将来的にこの２つの関数は、別途「ユーティリティライブラリ」のなかで定義される可能性がある
+
+### &amp;lt;a name=&amp;#34;Constructors&amp;#34;&amp;gt;コンストラクタ&amp;lt;/a&amp;gt;
+
+有理数クラスは、２つの整数値（分子、分母）の組み合わせ、あるいは、単一の整数値から生成される。
+また、デフォルトコンストラクタは、値がゼロであるような有理数を生成する。
+コンストラクタとしては、以下の形が有効である。
+
+```cpp
+I n, d;
+rational&amp;lt;I&amp;gt; zero;
+rational&amp;lt;I&amp;gt; r1(n);
+rational&amp;lt;I&amp;gt; r2(n, d);
+```
+
+単一の整数値を取るコンストラクタは、`explicit` 修飾されて *いない* 。
+このため、基本要素となる整数型から有理数クラスへの暗黙の型変換が発生しうる。
+
+### &amp;lt;a name=&amp;#34;Arithmetic operations&amp;#34;&amp;gt;算術演算子&amp;lt;/a&amp;gt;
+
+有理数クラスにおいては、以下に示す標準的な算術演算子が定義される。
+
+```cpp
++    +=
+-    -=
+*    *=
+/    /=
+++   --    前置・後置の両方の演算子）
+==   !=
+&amp;lt;    &amp;gt;
+&amp;lt;=   &amp;gt;=
+```
+
+### &amp;lt;a name=&amp;#34;Input and Output&amp;#34;&amp;gt;入出力&amp;lt;/a&amp;gt;
+
+入出力のために、`&amp;lt;&amp;lt;`  および、`&amp;gt;&amp;gt;` のそれぞれの演算子が定義される。
+有理数クラスの外部での表現形（The external representation）は、`/` で区切られた２つの整数値である。
+入力の場合、`/` と整数値の間にホワイトスペースが存在してはならない。
+（入力においては、整数値の後間にホワイトスペースが存在せずに、`/` が続き、さらにその後にもホワイトスペースが存在せず）２番目の整数値が現れなければならない）整数値の表現形は基本要素となる整数型によって定義される形である。
+
+
+### &amp;lt;a name=&amp;#34;In-place assignment&amp;#34;&amp;gt;In-place assignment&amp;lt;/a&amp;gt;
+
+有理数クラスの任意のインスタンス `rational&amp;lt;I&amp;gt; r` に対して、`r.assign(n, m)`は、一時インスタンスを生成しないため、`r = rational&amp;lt;I&amp;amp;&amp;gt;(n, m);` より高速に処理を行うことができる。
+この機能は、基本要素となる整数型がＣ＋＋組み込みの場合であればそれほど有効ではないかもしれないが、たとえば、無限精度整数型の上に構成された有理数クラスの場合には有効である。
+
+### &amp;lt;a name=&amp;#34;Conversions&amp;#34;&amp;gt;型変換&amp;lt;/a&amp;gt;
+
+有理数クラスは暗黙には他の *いかなる型にも変換されない* 。
+しかしながら、明示的な型変換のためには、関数、 `rational_cast&amp;lt;T&amp;gt;(r)` を提供する。
+これは。
+
+```cpp
+rational r(22,7);
+double nearly_pi = boost::rational_cast&amp;lt;double&amp;gt;(r);
+```
+
+に示すように使用することができる。
+
+関数 `rational_cast&amp;lt;T&amp;gt;` は、分母と分子の両方が安全に `T` にキャストできない場合、あるいは、（`T` にキャストした後で）分子／分母 の（割り算の値が）`T` の範囲で正しく表現できない場合には、未定義動作となる。
+
+本質的には、型変換の際に数字としてみた値が保存され、また、演算結果は理にかなったものでなければならないということである。
+ここに述べるような制約が不都合である場合には、別途ユーザー定義の型変換を行った方がより適切であろう。
+
+*実装上の注意：*
+
+`ratinal_cast&amp;lt;T&amp;gt;` の具体的な実装は、
+
+```cpp
+template &amp;lt;typename Float, typename Int&amp;gt;
+Float rational_cast(const rational&amp;lt;Int&amp;gt;&amp;amp; src)
+{
+    return static_cast&amp;lt;Float&amp;gt;(src.numerator()) / src.denominator();
+}
+```
+
+である。
+しかしながら、この実装に依存するようなプログラムを書いてはならない。
+
+### &amp;lt;a name=&amp;#34;Numerator and Denominator&amp;#34;&amp;gt;分数表現（Numerator and Denominator）&amp;lt;/a&amp;gt;
+
+直接的に有理数クラスの内部表現にアクセスするためには２つの関数、 `numerator()` と、 `denominator()` を使用する。
+
+この２つの関数を使用することで、ユーザーは有理数を取り扱う上の任意の機能を追加することができる。
+とりわけ、上で示した `rational_cast` の実装がうまく動かない場合――基本要素として、無限精度の整数型を使用している場合にはありそうだが――に、ユーザーがもっと適切な浮動小数点型への型変換関数を、別途準備できることに注意したい。
+
+## &amp;lt;a name=&amp;#34;Performance&amp;#34;&amp;gt;パフォーマンス&amp;lt;/a&amp;gt;
+
+有理数クラスは、基本要素となる整数型が、組み込みの整数型と“類似の”振る舞いをすることを暗黙のうちに想定している。
+この基本要素となる整数型の振る舞いを明文化したものが、前述した [基本要素となる整数型の要件](#Integer Type Requirements) である。
+しかしながら、振る舞いの他にも、演算のパフォーマンスもまた組み込みの整数型と同等であることも、暗黙のうちに想定されている。
+
+有理数クラスにおける演算のパフォーマンスを精密に保証することはできない。
+その上、パフォーマンスにおける議論は（標準クラスライブラリに於いても同様であるが）ユーザーに詳細な演算コストを提供するためには、有用なものではない。
+その代わりに、このセクションでは有理数クラスの特性に関する一般的な情報を提供する。
+
+ここでは、[`&amp;lt;boost/rational.hpp&amp;gt;`](https://www.boost.org/doc/libs/1_31_0/boost/rational.hpp) に定義された演算子と、その演算子の実行にかかるコストの非公式なリストを示す。
+このリストの内容は、現時点の実装に依存しているものであり、将来変更される可能性があるととに注意されたし。
+
+- コンストラクタの実行は、本質的には２つの要素を基本要素の型で生成し、約分を行うことである。
+- インクリメントとデクリメントは、基本要素の型における加算および減算と同じ程度の負荷である。
+- 等号および、不等号の比較は、基本要素の型における同一の比較と同じ程度の負荷である。
+- I/O の負荷は低くはない。
+	しかしながら、本質的には I/O の動作自体の時間がほとんどである。
+- `gcd()` 関数は、本質的には剰余演算の繰り返しである。
+	このほかに、コンストラクタ・代入・０との比較が行われるが、これらの負荷は剰余演算に比べると、取るに足らないものである。
+- `lcm()` 関数は、本質的に `gcd()` を算出した後、２回の乗算と（１回の）除算を行うものである。
+- 加算と減算は複雑である。
+	加算と減算には基本要素となる整数型上で、平均して２回の `gcm()` 、３回の除算、３回の乗算と１回の加算が必要である。
+- 乗算と除算には、２回の ``gcd()、２回の乗算、そして、４回の除算が必要である。
+- 比較演算子の実行には、最悪の場合、２回の `gcd()` , ２回の乗算、４回の除算、そして比較が必要である。
+	しかしながら、`int` タイプにおける比較演算のコストが低い（そして、０との比較はさらに低コストである）と仮定すると、比較演算のオーバーヘッドを下げることのできる特別なケースがいくつか存在する。
+	特に、 `==` と `!=` の実行時間は、基本要素となる整数型の比較時間程度のコストで終了する。
+- 残りの基本的な演算は、約分である。
+	約分はコンストラクタの起動時と、内部での代入の際に暗黙のうちに実行される。
+	その他の演算結果も基本要素となる整数型の範囲に収まるように注意深く約分される。
+	約分のコストは、 `gcd()` １回と、除算が２回分に相当する。
+
+上記の議論の際に、注意すべきことは、基本要素となる整数型の演算は“常識的な”パフォーマンスで実行できることが暗黙のうちに仮定されているということ――すなわち、演算コストがかかるのは乗算・除算・剰余の計算であり、加算と減算のコストは比較的安価だと仮定されているということである。
+コンストラクタ（整数値０，１から生成される場合）と代入のコストはさらに安価だと仮定しているが、それでも、本有理数クラスライブラリにおいて、不要なコンストラクタやコピーが発生しないような配慮は行っている。
+また、比較（特に０に対する比較）の演算コストも低いと仮定している
+
+以上のような仮定に合致しない整数型は、有理数クラスの基本要素としては有用ではない。
+殊にパフォーマンスの点では、ひどく重く、最適化できない。
+
+## &amp;lt;a name=&amp;#34;Exceptions&amp;#34;&amp;gt;例外&amp;lt;/a&amp;gt;
+
+有理数クラスでは、分母がゼロとなることは決してない。
+（本ライブラリでは、NaN や無限大の表現形式としても、分母がゼロになることはない）
+そのため、分母の値が０となる場合には、`boost::bad_rational` 例外（これは、`std::domain_error` のサブクラスである）をスルーする。
+これは、ユーザーが分母を０としてコンストラクタを実行した場合と、任意の有理数クラス数値を、ゼロで除算しようとした際にのみ発生する。
+
+さらに、基本要素となる整数型での演算の結果、例外が発生した場合には、その例外は有理数クラスクラスに伝番する。
+原則はひとつである。基本要素となる整数型がスルーするあらゆる例外は、有理数クラスのあらゆる演算に於いてスルーされる。
+加えて、有理数クラスのコンストラクタは、正規化の段階に於いて基本要素クラスで発生した例外をスルーする。
+この事項に対する唯一の例外事項は、有理数クラスのデストラクタは、基本要素クラスのデストラクタがスルーした例外しかスルーしないということである（ただし、通常デストラクタの実行中に基本要素クラスで例外が発生することはない）
+
+## &amp;lt;a name=&amp;#34;Internal representation&amp;#34;&amp;gt;内部表現&amp;lt;/a&amp;gt;
+
+*補足：* ここで記述する内容は単純に情報を提供するためにのものにすぎない。
+プログラミングの際に、ここで述べるような実装の詳細に依存するようなプログラムを書くべきではない。
+
+内部的には有理数クラスは、分子・分母の２つの整数型（テンプレートで与えられる型パラメータである）の値として保持される。
+有理数クラスの内部表現に置いては、常に約分（すなわち、分子と分母の最大公約数が１となる状態）され、分母が正であるように正規化されている。
+
+## &amp;lt;a name=&amp;#34;Design notes&amp;#34;&amp;gt;デザインノート&amp;lt;/a&amp;gt;
+
+### &amp;lt;a name=&amp;#34;Minimal Implementation&amp;#34;&amp;gt;最小の構成となるような設計&amp;lt;/a&amp;gt;
+
+有理数クラスは数としての基本原則を崩さないように実装されている。
+有理数として持つべき最小限の機能しか持たないが、基本要素となる整数型にアクセスするための、 `numerator()` と `denominator()` の関数を持つことで、必要に応じて、どのような機能拡張も行うことができる。
+
+入出力と、 `rational_cast()` の関数については厳密には、有理数として持つべき最小構成の範囲からは逸脱している。
+入出力については明らかであろう。
+しかしながら、浮動小数点型の変数に型変換するたために、 `rational_cast()` が最善でない場合もある。
+（ことにユーザー定義型の浮動小数点型への変換は複雑である）
+こういった場合には、ユーザー定義の型変換関数を定義することができるし、また、すべきである。
+このユーザー定義による型変換関数が、 `rational_cast()` という名前である必要はない。
+そのため、 `rational_cast()` が、特殊化／オーバーロード可能な形で定義される *必要はない* 。
+
+### &amp;lt;a name=&amp;#34;Limited-range integer types&amp;#34;&amp;gt;基本要素の数値表現範囲（Limited-range integer types）&amp;lt;/a&amp;gt;
+
+有理数クラスは、表現範囲に制限のないような整数型を使用するように設計されている。
+このような整数型を要素として利用する場合には、演算結果は常に正確に表現され、桁落ちやオーバーフロー／アンダーフローの問題も発生することはない。
+
+不幸なことに、標準の C++ においては、このような整数型を使用することはできない（boost ライブラリにおいても、現時点では同様である）
+このような事情で、有理数クラスは、多分、C++ の `int` のような、数値表現の範囲に限界を持った型を基本要素として使用されるであろう。
+
+数値表現の範囲が限定されるような要素を基本要素として使用した場合、有理数クラスは、ちょうど浮動小数点型と同じような多くの精度の問題に見舞われる。
+しかしながら、有理数クラスがシンプルな使われ方をしている限りは精度の問題が表面化することは少ないものと考える。
+それでも、ユーザーは整数型の表現範囲が制限されることによる精度の問題が発生しうることを考慮しておくべきである。
+
+表現範囲が制限された整数型の影響による問題点を、C++ の `int` を 32bit の符号付きであるものとして説明する。
+この場合、 `rational&amp;lt;int&amp;gt;` として表現できるもっとも小さな正数値は、`1/0x7FFFFFFF` である。
+換言すれば、０の近辺では、 `rational&amp;lt;int&amp;gt;` で表現できる“粒度”は、約 4.66e-10 である。
+他方、 `rational&amp;lt;int&amp;gt;` で表現可能な最大の数は、`0x7FFFFFFF/1` であり、 `rational&amp;lt;int&amp;gt;` におけるその次に小さい数は、`0x7FFFFFFE/1` である。
+これは、表現可能な最大値付近では数値の粒度は１であることを意味している。
+このように、数値の粒度が数値の絶対値の影響を受けることがすなわち、浮動小数点数と同じ特徴なのである。
+しかしながら、このような性質は有理数クラスを使用する上で、自然なものとは“感じられない”だろう。
+
+有理数クラスの基本要素として、表現範囲が制限された整数型を使用することの得失に注意し、前もって意識するのはユーザー次第だということである。
+
+### &amp;lt;a name=&amp;#34;Conversion from floating point&amp;#34;&amp;gt;浮動小数点型からの型変換&amp;lt;/a&amp;gt;
+
+有理数クラスライブラリでは、浮動小数点型から有理数クラスへの型変換関数を提供していない。
+浮動小数点型から有理数クラスへの型変換関数を希望する意見をいくつか受け取ってはいる。
+しかしながら、boost における広範な議論の結果として、浮動小数点型からの型変換には“最適解”が存在しないという結論に達した。
+本ライブラリのユーザーが、その目的に適した型変換関数を作成することは可能であるが、そのいずれをも、“スタンダード”として採用することはできなかった。
+
+浮動小数点型からの型変換を行う際にもっとも大きな問題となるのは、浮動小数点型の演算における誤差をどう扱うかという点である。
+以下のコードで具体的な例を示す
+
+```cpp
+// 以下の２つの数値は、ユーザによる入力であったり、
+// 計測器からの入力であったりする。
+double x = 1.0;
+double y = 3.0;
+
+double z = x/y;
+
+rational&amp;lt;I&amp;gt; r = rational_from_double(z);
+```
+
+根本的な疑問は、この場合 `r` の値はどうなるかということである。
+自然な回答は、`1/3` ということになるが、これはたくさんの問題を無視しているものである。
+
+まず、`z` は厳密には `1/3` でないという点が挙げられる。
+浮動小数点型の持つ制度上の限界から、どのような表現形式を以てしても `1/3` を厳密に表現することはできないのである。
+それなら、`r` は、`z` それ自体の値を（厳密に）に表現すればよいのだろうか？
+`r` の値として、`33333333333333331/100000000000000000` を用いることが適切なのであろうか？
+
+しかし、`z` の厳密性を議論する前に、そもそも、`x` と `y` の厳密性について議論しなければならない。
+例えば、`x` や `y` の値がアナログ的な計測器の計測結果であったとしたら、常に有限の精度でしか評価できない。
+この場合、有理数クラスで勝手な桁数の精度を一律に仮定することは、元の精度を悪化させることになる。
+
+このような議論ののち、“単純な整数比のうちで、最も近いもの”を探すべきなのではないかと思うかもしれない。
+しかも、このような数値を求めるためのアルゴリズムは実際に存在する。
+しかしながら、すべてのアプリケーションでこの方法が最適であるとは限らない。
+別の例では、一連の計算における桁落ちを防止するために、有理数クラスへの変換の際に正確性が要求される。
+この場合には、たとえ数値表現の上で“不自然”であったとしても、厳密な値を表現する必要がある。
+
+このような相容れない要求に対して、万人を満足させる単一の解決方法を見いだすことはできなかった。
+その上に、有理数クラスの演算に対するアルゴリズムは複雑であり、また専門化されているため、アプリケーションに要求される事項を理解した上で、最適な実装を行うことが良いと考える。
+
+### &amp;lt;a name=&amp;#34;Absolute Value&amp;#34;&amp;gt;絶対値&amp;lt;/a&amp;gt;
+
+普通に考えれば、基本要素となる整数型の絶対値 `abs(IntType)` が定義されていれば、これを用いて、有理数クラスにおける絶対値（ `rational&amp;lt;IntType&amp;gt;` ）が定義されているべきであると考えられるだろう。
+しかしながら、絶対値を定義するにはいくつもの問題が存在する。
+
+最初の問題は、 `abs()` 関数の探索に関する問題である。
+`asb(IntType)` の実装を調べるためには、特に、`IntType` がユーザーの定義した形であり、ユーザー定義の名前空間にある場合、Koenig lookup （関数を引数の所属する名前空間で探索すること）が必須となる。
+現時点では、関数についてはこの機能をサポートしていないコンパイラも存在する。
+このような機能をサポートしないコンパイラを使用する場合には、ユーザーは意図的に、有理数クラスの動作と協調できるようなクラス設計を行う必要がある。
+
+次の問題は、標準的でない組込整数型の問題であり、こちらの方がより深刻な問題であると考えられる。
+`long long` や `__int64` のような標準的でない組み込み整数型に対して、コンパイラベンダーが `abs()` 関数を提供するという保証がないことである。
+これは、実装品質の問題ではあるが、しかしながら、`long long` のような型の追加自体が多分に場当たり的なものであるのだ。
+
+結論は、 `abs(IntType)` を使用して、 `abs(rational&amp;lt;IntType&amp;gt;)` を定義することは実用的ではないということだ。
+代わりに、以下のシンプルなインライン関数を使用している。
+
+```cpp
+template &amp;lt;typename IntType&amp;gt;
+inline rational&amp;lt;IntType&amp;gt; abs(const rational&amp;lt;IntType&amp;gt;&amp;amp; r)
+{
+    if (r.numerator() &amp;gt;= IntType(0))
+        return r;
+
+        return rational&amp;lt;IntType&amp;gt;(-r.numerator(), r.denominator());
+}
+```
+
+このことから、基本要素となる整数型の絶対値が他の場所で定義されたとしても、有理数クラスの絶対値はインライン関数で計算できるということがわかる。
+
+
+## &amp;lt;a name=&amp;#34;References&amp;#34;&amp;gt;リファレンス&amp;lt;/a&amp;gt;
+
+- 有理数クラスのヘッダファイル： [rational.hpp](https://www.boost.org/doc/libs/1_31_0/boost/rational.hpp)
+- サンプルコード： [rational_example.cpp](https://www.boost.org/doc/libs/1_31_0/libs/rational/rational_example.cpp)
+- 回帰テスト： [rational_test.cpp](https://www.boost.org/doc/libs/1_31_0/libs/rational/rational_test.cpp)
+
+## &amp;lt;a name=&amp;#34;History and Acknowledgements&amp;#34;&amp;gt;History and Acknowledgements&amp;lt;/a&amp;gt;
+
+1999年12月著者（原著者 Paul Moore）は、有理数クラスの最初の実装を行い、 [boost.org](http://www.boost.org/) メーリングリストに投稿した。
+メーリングリストにおいて、いくつかの議論が交わされた。
+殊に、Andrew D. Jewell は、オーバーフローとアンダーフローの発生を防止することの重要性を指摘するとともに、ほとんどの基本的な数値演算に於いてオーバーフローを回避するための実装方法を提供してくれた。
+`rational_cast` は、Kevlin Henney の提案によるものである。
+Ed Brey は、オリジナルのソースコードにあった、少なくないタイプミスについて、重要なコメントを与えてくれた。
+
+David Abrahams は、このドキュメントに於いて有用なフィードバックを行ってくれた
+
+浮動小数点型から、有理数クラスへの型変換関数を提供することについては、boost メーリングリストで、2000年11月に長い議論が交わされた。
+Reggie Seagraves, Lutz Kettner そして、Daniel Frey を含む、メンバーがこの点の中心メンバーとなった（もっとも、boost メーリングリストのほとんどのメンバーがそれぞれに、白熱した議論に参加していたのを感じているが）それでもなお、議論の最終結論としての実装は *行えなかった。*
+浮動小数点からの変換関数を巡る問題を理解するためには、このメーリングリストでの議論は価値のあるものである。
+
+Stephen Silver は、有理数クラスをユーザー定義の整数型の上で使用する際の、有用な知見を示してくれた。
+
+Nickolay Mladenov は、`operator+=` と `operator-=` の、現行の実装を提供してくれた。
+
+上述した、有理数クラスの理論的な説明部分、[絶対値](#Absolute Value) と、[Swap Operation](#Swap Operation) に現れた、Koenig lookup と、`std::swap` について議論は、2001年1月に、boost メーリングリストで行われた。
+
+Revised February 5, 2001
+
+(c) Copyright Paul Moore 1999-2001.
+Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies.
+This document is provided &amp;#34;as is&amp;#34; without express or implied warranty, and with no claim as to its suitability for any purpose.
+
+Japanese Translation Copyright (C) 2003 FUJIHARA Keiichi &amp;lt;keiichi@fujihara.name&amp;gt;.
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Appendices. -- Boost.Regexの翻訳ドキュメントを修正(#21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html"/>
      <id>cdcafeb6853d3125b6d11af5a2466534909da2c6:archive/boost_docs/libs/regex/appendix.md</id>
      <updated>2020-06-01T23:03:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/appendix.md b/archive/boost_docs/libs/regex/appendix.md
index 152cd40..1d1af68 100644
--- a/archive/boost_docs/libs/regex/appendix.md
+++ b/archive/boost_docs/libs/regex/appendix.md
@@ -434,13 +434,13 @@ Files: [`regex_timer.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/exam
 また boost の人々は私に *考え*させてくれた、以上。
 以下の人々は皆、有益なコメントや修正をしてくれた:
 Dave Abrahams, Mike Allison, Edan Ayal, Jayashree
-Balasubramanian, Jan BNBvlsche, Beman Dawes, Paul Baxter, David
+Balasubramanian, Jan BNBvlsche, Beman Dawes, Paul Baxter, David
 Bergman, David Dennerline, Edward Diener, Peter Dimov, Robert
 Dunn, Fabio Forno, Tobias Gabrielsson, Rob Gillen, Marc Gregoire,
 Chris Hecker, Nick Hodapp, Jesse Jones, Martin Jost, Boris
 Krasnovskiy, Jan Hermelink, Max Leung, Wei-hao Lin, Jens Maurer,
 Richard Peters, Heiko Schmidt, Jason Shirk, Gerald Slacik, Scobie
-Smith, Mike Smyth, Alexander Sokolovsky, HervNBi Poirier, Michael
+Smith, Mike Smyth, Alexander Sokolovsky, HervNBi Poirier, Michael
 Raykh, Marc Recht, Scott VanCamp, Bruno Voigt, Alexey Voinov,
 Jerry Waldorf, Rob Ward, Lealon Watts, Thomas Witt and Yuval
 Yosef. 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, FAQ. -- Boost.Regexの翻訳ドキュメントを修正(#21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/faq.html"/>
      <id>215bcda0a1e20b95b370a550468c9b7439c340d9:archive/boost_docs/libs/regex/faq.md</id>
      <updated>2020-06-01T22:57:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/faq.md b/archive/boost_docs/libs/regex/faq.md
index 959afd2..b68dfea 100644
--- a/archive/boost_docs/libs/regex/faq.md
+++ b/archive/boost_docs/libs/regex/faq.md
@@ -79,7 +79,7 @@ A. 静的なデータを含むテンプレートを結合できないコンパ
 regex++ のデフォルトの振る舞いは、 無名名前空間の中で &amp;#34;problem&amp;#34; テンプレートを宣言することにより、この問題を修復しようとするので、テンプレートは内部リンケージをもつ。
 これが、大量のコード膨張を引き起こすことに注意せよ。
 もしコンパイラが名前空間をサポートしていないか、コード膨張が問題になったら、単一翻訳単位の中に全てのテンプレートを置くための上のガイドラインに従うこと。
-そして、 boost/regex/config.hpp を編集し、 `BOOST_REGEX_NO_TEMPLATE_SWITCH_MERGE` を定義しないようにすること。
+そして、 `boost/regex/config.hpp` を編集し、 `BOOST_REGEX_NO_TEMPLATE_SWITCH_MERGE` を定義しないようにすること。
 
 ### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. 私は regex++ でエスケープ文字を使うことが出来ません。何が起こっているのですか？&amp;lt;/font&amp;gt;
 
@@ -100,7 +100,7 @@ A. POSIX 標準は、文字範囲表現がロケールに敏感であること
 後者の場合、もしロケールに敏感な照合を行いたくなければ、 `REG_NOCOLLATE` を `REG_BASIC` か `REG_EXTENDED` を組み合わせて使えばよい。
 *[注意: `regbase::nocollate` が作用しているとき、ライブラリは、実際にの設定値に関わらず、`_COLLATE` ロケートカテゴリーが常に &amp;#34;C&amp;#34; である &amp;#34;かのように&amp;#34; 振る舞う。]*
 
-### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;&amp;amp;nbsp;Q. なぜ私は、「簡易版の」 `query_match/reg_search/reg_grep/reg_format/reg_merge` を使うことが出来ないのですか?&amp;lt;/font&amp;gt;
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. なぜ私は、「簡易版の」 `query_match/reg_search/reg_grep/reg_format/reg_merge` を使うことが出来ないのですか?&amp;lt;/font&amp;gt;
 
 A. これらの簡易版はあなたのコンパイラの能力によって使えたり使えなかったりする。
 これらの関数の形式を決定する規則は極めて複雑である。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Traits Class Reference. -- Boost.Regexの翻訳ドキュメントを修正(#21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/traits_class_ref.html"/>
      <id>215bcda0a1e20b95b370a550468c9b7439c340d9:archive/boost_docs/libs/regex/traits_class_ref.md</id>
      <updated>2020-06-01T22:57:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/traits_class_ref.md b/archive/boost_docs/libs/regex/traits_class_ref.md
index ee91fed..d92cdb6 100644
--- a/archive/boost_docs/libs/regex/traits_class_ref.md
+++ b/archive/boost_docs/libs/regex/traits_class_ref.md
@@ -57,7 +57,7 @@ class mytraits
       syntax_digit = 17,                        // 0-9
       syntax_b = 18,                            // for \b
       syntax_B = 19,                            // for \B
-      syntax_left_word = 20,                    // for \&amp;amp;lt;
+      syntax_left_word = 20,                    // for \&amp;lt;
       syntax_right_word = 21,                   // for \
       syntax_w = 22,                            // for \w
       syntax_W = 23,                            // for \W
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;各ライブラリの翻訳ドキュメント&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/function.html&#34;&gt;function&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;遅延呼び出し及びコールバックのための関数オブジェクトラッパ。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/functional.html&#34;&gt;functional&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;機能強化された関数オブジェクトアダプタ。 Mark Rodgers 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/graph.html&#34;&gt;graph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;汎用グラフコンポーネント及びアルゴリズム。 Jeremy Siek and a University of Notre Dame team 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/io/ios_state.html&#34;&gt;io state savers&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;入出力の状態を保存して、データが化けるのを防ぐ。 Daryle Walker 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda.html&#34;&gt;lambda&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;実際の呼び出し時の、小さな無名関数オブジェクトの定義。, from Jaakko Jävi and Gary Powell.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/math.html&#34;&gt;math&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学の領域での多くの貢献。様々な作者による。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/multi_array.html&#34;&gt;muti_array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリ上で連続したデータの配列のための多次元コンテナとアダプタ。 Ron Garcia 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/preprocessor.html&#34;&gt;preprocessor&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;繰り返しと再帰を含むプリプロセッサメタプログラミングツール群。 Vesa Karvonen 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/pool.html&#34;&gt;pool&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリプールの管理。Steve Cleary 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/random.html&#34;&gt;random&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;乱数生成のためのシステム一式。 Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex.html&#34;&gt;regex&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;正規表現ライブラリ。 John Maddock 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/signals.html&#34;&gt;signals&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;管理されたシグナルとスロットのコールバックでの実装。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/static_assert.html&#34;&gt;static_assert&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;静的アサート(コンパイル時アサート)。 John Maddock 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/smart_ptr.html&#34;&gt;smart_ptr&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;5つのスマートポインタクラステンプレート Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html&#34;&gt;tuple&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数の値を返す関数の簡単な定義など。 Jaakko Javi 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/type_traits.html&#34;&gt;type_traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型の基本的な特徴のためのテンプレート。 John Maddock, Steve Cleary, et al 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>regex++, Index -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;regex++, Index&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;em&gt;(Version 3.31, 16th Dec 2001)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copyright (c) 1998-2001&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
Dr John Maddock makes no representations about the suitability of this software for any purpose.
It is provided &#34;as is&#34; without express or implied warranty.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/introduction.html#intro&#34;&gt;導入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/introduction.html#Installation&#34;&gt;インストールと設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#regbase&#34;&gt;テンプレートクラス及びアルゴリズムリファレンス&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Class &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#regbase&#34;&gt;regbase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Class &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#bad_expression&#34;&gt;bad_expression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Class &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_expression&#34;&gt;reg_expression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Class &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#regex_char_traits&#34;&gt;char_regex_traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Class &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_match&#34;&gt;match_results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithm &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#query_match&#34;&gt;regex_match&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithm &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_search&#34;&gt;regex_search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithm &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_grep&#34;&gt;regex_grep&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithm &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_format&#34;&gt;regex_format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithm &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_merge&#34;&gt;regex_merge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithm &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#regex_split&#34;&gt;regex_split&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithm &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#partial_matches&#34;&gt;Partial regular expression matches&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;クラス &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/hl_ref.html#RegEx&#34;&gt;RegEx&lt;/a&gt; リファレンス&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/posix_ref.html#posix&#34;&gt;POSIX 互換関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/syntax.html#syntax&#34;&gt;正規表現構文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/format_string.html#format_string&#34;&gt;書式文字列構文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#implementation&#34;&gt;付録&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#implementation&#34;&gt;実装における注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#threads&#34;&gt;スレッド安全性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#localisation&#34;&gt;地域化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#demos&#34;&gt;応用例&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_match_example.cpp&#34; target=&#34;_blank&#34;&gt;regex_match_example.cpp&lt;/a&gt;: ftp による regex_match の例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_search_example.cpp&#34; target=&#34;_blank&#34;&gt;regex_search_example.cpp&lt;/a&gt;: regex_search の例: C++ ファイルのクラス定義の検索&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_grep_example_1.cpp&#34; target=&#34;_blank&#34;&gt;regex_grep_example_1.cpp&lt;/a&gt;: regex_grep の例 1: C++ ファイルのクラス定義の検索&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_merge_example.cpp&#34; target=&#34;_blank&#34;&gt;regex_merge_example.cpp&lt;/a&gt;: regex_merge の例: C++ ファイルを構文をハイライトされた HTML に変換&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_grep_example_2.cpp&#34; target=&#34;_blank&#34;&gt;regex_grep_example_2.cpp&lt;/a&gt;: regex_grep の例 2: 大域コールバック関数を利用した、C++ ファイルのクラス定義の検索&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_grep_example_3.cpp&#34; target=&#34;_blank&#34;&gt;regex_grep_example_3.cpp&lt;/a&gt;: regex_grep の例 3: (オブジェクトに)束縛されたメンバ関数コールバックを利用した、 C++ ファイルのクラス定義の検索&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_grep_example_4.cpp&#34; target=&#34;_blank&#34;&gt;regex_grep_example_4.cpp&lt;/a&gt;: regex_grep の例 4: C++ Builder のクロージャをコールバックとして利用した、C++ ファイルのクラス定義の検索&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_split_example_1.cpp&#34; target=&#34;_blank&#34;&gt;regex_split_example_1.cpp&lt;/a&gt;: regex_split の例: 文字列をトークンに分割&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_split_example_2.cpp&#34; target=&#34;_blank&#34;&gt;regex_split_example_2.cpp&lt;/a&gt;: regex_split の例: リンクされた URL の抜き出し&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#headers&#34;&gt;ヘッダファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#redist&#34;&gt;再配布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#upgrade&#34;&gt;アップグレードに関する注記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html#furtherInfo&#34;&gt;更なる情報 (連絡と感謝)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/faq.html&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Copyright&lt;/em&gt; &lt;a href=&#34;mailto:John_Maddock@compuserve.com&#34;&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/a&gt; &lt;em&gt;1998-2001 all rights reserved.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:k_takahashi@cppll.jp&#34;&gt;Kohske Takahashi&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Appendices. -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/appendix.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/appendix.md b/archive/boost_docs/libs/regex/appendix.md
new file mode 100644
index 0000000..152cd40
--- /dev/null
+++ b/archive/boost_docs/libs/regex/appendix.md
@@ -0,0 +1,477 @@
+# Regex++, Appendices.
+
+*Copyright (c) 1998-2001*
+
+*Dr John Maddock*
+
+*Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
+Dr John Maddock makes no representations about the suitability of this software for any purpose.
+It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
+
+---
+
+### &amp;lt;a name=&amp;#34;implementation&amp;#34;&amp;gt;Appendix 1: Implementation notes&amp;lt;/a&amp;gt;
+
+これは boost ライブラリへ regex++ を導入した最初のものであり、 regex++ 2.x に基づいている。
+以前のバージョンからの変更の完全なリストについては changes.txt を見よ。
+Win32 地域化モデル (Win32 におけるデフォルトのライブラリ構築) が使われているときのみ、POSIX スタイルの等価クラスが正しいことを保証される、という点を除けば、機能的なバグは見つかっていない。
+
+C++ 信者はこのコードをいくつかの点で馬鹿げていると考えるであろう。
+特にアルゴリズムのいくつかでは goto が使われている。
+コードは、再帰的な実装に変更することで、よりきれいにすることができる。
+その場合は、おそらくより遅くなるだろうが。
+
+アルゴリズムのパフォーマンスは多くの場合、十分であるだろう。
+例えば、 ftp レスポンスの表現 &amp;#34;^([0-9]+)(\\-| |\$)(.\*)\$&amp;#34; が文字列 &amp;#34;100- this is a line of ftp response which contains a message string&amp;#34; に一致するのにかかる時間は: BSD の実装で 450 マイクロ秒, GNU の実装で 271 マイクロ秒, regex++ では 127 マイクロ秒である (Pentium P90, Win32 コンソールアプリ、 MS Windows 95 環境)。
+
+しかし、一致判定に指数オーダを必要とする、 &amp;#34;病的な&amp;#34; 正規表現があることも述べておかなければならないだろう。
+これらは全て、ネストされた繰り返し演算子にまつわるものである。
+例えば、正規表現 &amp;#34;(a\*a)\*b&amp;#34; を `N` 文字の a に一致させるには、 *2&amp;lt;sup&amp;gt;N&amp;lt;/sup&amp;gt;* に比例した時間を必要とする。
+これらの表現は 問題を避けるために、(ほとんど) いつも、別の方法で書き直すことが出来る。
+例えば、 &amp;#34;(a\*a)\*b&amp;#34; は &amp;#34;a\*b&amp;#34; として書き直すことが出来る。
+これは、一致を解決するのに `N` に線形的に比例した時間しかかからない。
+一般的に、ネストされていない繰り返し表現は *N&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;* に比例する時間を必要とする。
+しかし、もし句が相互排他的なら線形オーダの時間で一致させることが可能である。
+これは、&amp;#34;a\*b&amp;#34; の場合である。それぞれの文字に対して、一致判定は &amp;#34;a&amp;#34; か &amp;#34;b&amp;#34; か失敗のいずれかである。
+一方、&amp;#34;a\*a&amp;#34; では取るべき枝を一致判定者は伝えることが出来ないので(最初の &amp;#34;a&amp;#34; か2番目のものか解らない)、両方を試さなければならない。
+*正規表現をどう書くかに十分注意した方がよい。
+そして、もし可能ならネストした繰り返しを避けるべきである。
+このバージョンでの新しい点として、以前でのいくつかの病的なケースは直っている。
+特に、先行する繰り返しや先行するリテラル文字列を含む正規表現の検索は、以前に比べかなり速くなったと思う。
+リテラル文字列に対しては今は Knuth/Morris/Pratt アルゴリズムを使って検索されている(これは BM 法より好んで使われる。
+なぜなら、改行文字の追跡が可能だからである)。*
+
+*POSIX 正規表現構文のいくつかの点は、より明確に実装された:*
+
+- 一致するものを決定するための &amp;#34;最左最長&amp;#34; 規則は曖昧である。
+	このライブラリは &amp;#34;明確な&amp;#34; 解釈を持っている: 
+	最左一致を発見し、それからそれぞれの子表現の長さを最長にし、
+	そしてより前の順番の子表現をより後の順番の子表現より優先する。
+- マルチ文字照合要素の振る舞いは標準では曖昧である。
+	特に [a[.ae.]] のような表現は、それ自身に潜在したわずかな不調和を持っている。
+	この実装は次のような括弧表現に一致する: 表現がそれ自身に、或いは範囲の終端としてマルチ文字照合要素を持たない限り、全ての括弧表現が単一文字のみに一致する。
+	もしそうでなければ、表現は一文字以上に一致するかもしれない。
+- 繰り返しの null 表現は一度だけ繰り返される。
+	それらは表現により認められる最大数の繰り返しと一致した &amp;#34;かのように&amp;#34; 扱われる。
+- 後方参照の振る舞いは標準では曖昧である。
+	特に &amp;#34;((ab\*)\\2)+&amp;#34; という形の表現が許されるかどうかは不明瞭である。
+	この実装はそのような表現を認め、後方参照は最後の子表現の一致が何であれ、一致する。
+	これは一致の終端では、後方参照はそれが参照する子表現の最終的な値とは異なる一致文字列を持っているかもしれない、ということを意味する。
+
+---
+
+### &amp;lt;a name=&amp;#34;threads&amp;#34;&amp;gt;Appendix 2: スレッド安全性&amp;lt;/a&amp;gt;
+
+クラス `reg_expression&amp;lt;&amp;gt;` とその `typedef` である `regex` と `wregex` はスレッド安全性を実現している。
+コンパイルされた正規表現はスレッド間で安全に共有できる。
+一致判定アルゴリズム `regex_match`, `regex_search`, `regex_grep`, `regex_format`, `regex_merge` は全て、再入可能でスレッドセーフである。
+クラス `match_results` も今はスレッドセーフである。
+一致の結果はあるスレッドから別のスレッドに安全にコピーできる(例えばあるスレッドが一致を発見し、 `match_results` のインスタンスをキューに挿入しながら、別のスレッドがキューの逆端からそれを取り出すというようなことである)。
+そうでなければ、スレッドごとに `match_results` の実体を分けて使えばよい。
+
+POSIX API 関数は全て再入可能でスレッドセーフである。
+`regcomp` を伴ってコンパイルされた正規表現も異なるスレッド間で共有可能である。
+
+クラス `RegEx` はそれぞれのスレッドが自分の `RegEx` のインスタンスを持っているときのみスレッドセーフである(分割スレッド)。
+これは、`RegEx` が正規表現のコンパイルと一致判定の両方を扱っているからである。
+
+最後に、グローバルロケールを変更すると、コンパイルされた全ての正規表現が無効になるので、あるスレッドが正規表現を扱っている間に別のスレッドが `set_locale` を呼び出すと、
+予期できない結果を生む *だろう* ということに注意せよ。
+
+また、 `main()` の開始より前にはただひとつのスレッドだけが存在する、ということが要求されている。
+
+---
+
+### &amp;lt;a name=&amp;#34;localisation&amp;#34;&amp;gt;Appendix 3: Localization&amp;lt;/a&amp;gt;
+
+Regex++ は実行時地域化に対して拡張されたサポートを提供している。
+地域化モデルは2つの部分に分かれる: フロントエンドとバックエンドだ。
+
+フロントエンドの地域化はユーザが見るものすべてを扱う。
+つまり、エラーメッセージや、正規表現構文そのものである。
+例えば、フランス語のアプリケーションは [[:word:]] を [[:mot:]] に、そして \\w を \\m に変更することが出来るだろう。
+フロントエンドのロケールを変更することは、開発者による積極的なサポートを要求する。
+これは、地域化された文字列を含む、読み込むべきメッセージカタログと共にライブラリが提供されるということである。
+フロントエンドのロケールは `LC_MESSAGES` カテゴリのみに影響される。
+
+バックエンドの地域化は正規表現が解析された後に起こる全てのことを扱う。
+つまり、ユーザが見ない、或いは直接関わらないこと全てである。
+これは、大文字小文字の変換や、照合順序、文字クラスの要素などをあつかう。
+バックエンドのロケールは開発者のいかなる介入も要求しない。
+つまり、ライブラリは、ライブラリが現在のロケールに対して要求する全ての情報を、オペレーティングシステムやランタイムライブラリから得られるということである。
+これは、もしプログラムのユーザが正規表現を直接扱えない、例えば正規表現があなたの C++ コードに埋め込まれているような場合に、明示的な地域化が必要でないということを意味する。
+なぜならライブラリが、あなたのために全てをやってくれるからである。
+例えば、正規表現 [[:word:]]+ をあなたのコードに埋め込むと、常に全ての単語に一致する。
+もしプログラムが、仮にギリシャ語のロケール環境で走っていたとしても、全ての単語に一致するのである。
+しかし、その一致はラテン文字での一致ではなく、ギリシャ文字での一致である。
+バックエンドのロケールは `LC_TYPE` と `LC_COLLATE` のカテゴリに影響を受ける。
+
+regex++ がサポートする3つの異なる地域化機構がある:
+
+*Win32 localization model.*
+
+これはライブラリが Win32 環境でコンパイルされたときのデフォルトのモデルである。
+そして、 [`w32_regex_traits`](template_class_ref.md#regex_char_traits) によってカプセル化されている。
+このモデルが適用されているときは、ユーザのコントロールパネルに従った唯一のグローバルロケールがあり、それは GetUserDefaultLCID で返される。
+regex++ で使われる全ての設定は C ランタイムライブラリを通さず、オペレーティングシステムから直接得られる。
+フロントエンドの地域化は、ユーザ定義の文字列をもった文字列テーブルを含むリソースである dll を要求する。
+特性クラスは次の関数を export する：
+
+```cpp
+static std::string set_message_catalogue(const std::string&amp;amp; s);
+```
+
+これは、コードが何らかの正規表現をコンパイルする *前に* (しかし、必ずしも `reg_expression` のインスタンスを構築する前にではない)、リソースの dll の名前を識別する文字列を伴って呼び出される必要がある:
+
+```cpp
+boost::w32_regex_traits&amp;lt;char&amp;gt;::set_message_catalogue(&amp;#34;mydll.dll&amp;#34;);
+```
+
+この API が `w32_regex_traits` のナロウ文字とワイド文字 *両方* の特殊化のために dll の名前を設定することに注意すること。
+
+このモデルは現在は、(Windows NT での SetThreadLocale による) スレッドに特化したロケールをサポートしていない。
+ライブラリは NT での完全なユニコードのサポートを提供する。
+Windows 9x ではこの能力は多少落ちる - 0 から 255 の文字はサポートされているが、それ以外は &amp;#34;未知の&amp;#34; グラフ文字として扱われる。
+
+*C 地域化モデル*
+
+ライブラリが Win32 以外のオペレーティングシステムでコンパイルされたとき、これがデフォルトのモデルとなる。
+これは特性クラス [`c_regex_traits`](template_class_ref.md#regex_char_traits) によってカプセル化されている。
+Win32 のユーザはプリプロセッサで `BOOST_REGEX_USE_C_LOCALE` を定義することで、このモデルを有効にすることが出来る。
+このモデルが有効なとき、`setlocale` により設定された唯一のグローバルロケールが存在する。
+全ての設定はランタイムライブラリから得ることが出来るので、結果的にユニコードのサポートはランタイムライブラリの実装に依存する。
+フロントエンドの地域化は POSIX メッセージカタログを必要とする。
+特性クラスは以下の関数を export する:
+
+```cpp
+static std::string set_message_catalogue(const std::string&amp;amp; s);
+```
+
+これは、コードが何らかの正規表現をコンパイルする *前に* (しかし、必ずしも `reg_expression` のインスタンスを構築する前にではない)、リソースの dll の名前を識別する文字列を伴って呼び出される必要がある:
+
+```cpp
+boost::c_regex_traits&amp;lt;char&amp;gt;::set_message_catalogue(&amp;#34;mycatalogue&amp;#34;);
+```
+
+この API が `w32_regex_traits` のナロウ文字とワイド文字 *両方* の特殊化のために dll の名前を設定することに注意すること。
+もしランタイムライブラリが POSIX メッセージカタログをサポートしていなければ、 `&amp;lt;nl_types.h&amp;gt;` の独自の実装を提供するか、メッセージカタログによるフロントエンドの地域化を無効にするために `BOOST_RE_NO_CAT` を定義することが出来る。
+
+`setlocale` を呼び出すと、コンパイルされた全ての正規表現が無効になることに注意すること。
+`setlocale(LC_ALL, &amp;#34;C&amp;#34;)` を呼び出すと、ライブラリは、このライブラリのバージョン 1 を含む多くの伝統的な正規表現ライブラリと同じ振る舞いをする。
+
+*C++ 地域化 モデル*
+
+このモデルは、プリプロセッサシンボル `BOOST_REGEX_USE_CPP_LOCALE` を定義してライブラリをビルドした時のみ有効である。
+このモデルが有効なとき、 `reg_expression&amp;lt;&amp;gt;` のそれぞれのインスタンスは、自分自身の `std::locale` のインスタンスを持つ。
+クラス `reg_expression&amp;lt;&amp;gt;` はメンバ関数 `imbue` も持つ。
+これは、正規表現のロケールをインスタンスごとに設定することを可能にする。
+フロントエンドの地域化は POSIX メッセージカタログを必要とする。
+これは正規表現のロケールの `std::message` ファセットによって読み込まれる。
+特性クラスは以下のシンボルを export する:
+
+```cpp
+static std::string set_message_catalogue(const std::string&amp;amp; s);
+```
+
+これは、コードが何らかの正規表現をコンパイルする *前に* (しかし、必ずしも `reg_expression` のインスタンスを構築する前にではない)、メッセージカタログの名前を識別する文字列を伴って呼び出される必要がある:
+
+```cpp
+boost::cpp_regex_traits&amp;lt;char&amp;gt;::set_message_catalogue(&amp;#34;mycatalogue&amp;#34;);
+```
+
+`reg_expression&amp;lt;&amp;gt;::imbue` の呼び出しは、その `reg_expression&amp;lt;&amp;gt;` のインスタンスの現在コンパイルされた正規表現を無効にすることに注意すること。
+このモデルは C++ 標準ライブラリの思想にもっとも近いものである。
+しかし、最も遅いコードを生成するモデルでもある。
+そして現在の標準ライブラリの実装によって最もサポートされていないものである。
+例えば私は、メッセージカタログか、或いは &amp;#34;C&amp;#34; や &amp;#34;POSIX&amp;#34; 以外のロケールの、どちらかをサポートした `std::locale` の実装を見たことはない。
+
+最後に、もしライブラリをデフォルト以外の地域化モデルでビルドするなら、サポートライブラリをビルドするときにも、コードに `&amp;lt;boost/regex.hpp&amp;gt;` や `&amp;lt;boost/cregex.hpp&amp;gt;` をインクルードするときにも、適切なプリプロセッサシンボル (`BOOST_REGEX_USE_C_LOCALE` や `BOOST_REGEX_USE_CPP_LOCALE`) を定義しなければならないことに注意すること。
+これを確実にする最良の方法は、 `&amp;lt;boost/regex/detail/regex_options.hpp&amp;gt;` に `#define` を追加することである。
+
+*メッセージカタログの提供:*
+
+ライブラリのフロントエンドを地域化するためには、リソース dll の文字列テーブル (Win32 モデル) か、 POSIX メッセージカタログ (C または C++ モデル) を含んだ、ふさわしいメッセージ文字列をもったライブラリを提供する必要がある。
+後者の場合、&amp;lt;font color=&amp;#34;red&amp;#34;&amp;gt;メッセージはカタログのメッセージ集合ゼロに現れなければならない。&amp;lt;/font&amp;gt;
+メッセージとその ID は以下の通り:
+
+| メッセージ ID | 意味                                                       | 既定値       |
+|-----|----------------------------------------------------------------------|--------------|
+| 101 | 子表現の開始に使われる文字                                           | &amp;#34;(&amp;#34;          |
+| 102 | 子表現の終了に使われる文字                                           | &amp;#34;)&amp;#34;          |
+| 103 | 行末の明示を表す文字                                                 | &amp;#34;\$&amp;#34;         |
+| 104 | 行頭の明示を表す文字                                                 | &amp;#34;\^&amp;#34;         |
+| 105 | &amp;#34;あらゆる文字に一致する表現&amp;#34; を表す文字                              | &amp;#34;.&amp;#34;          |
+| 106 | 0回以上の一致繰り返し演算子                                          | &amp;#34;\*&amp;#34;         |
+| 107 | 1回以上の一致繰り返し演算子                                          | &amp;#34;+&amp;#34;          |
+| 108 | 0または1回の一致繰り返し演算子                                       | &amp;#34;?&amp;#34;          |
+| 109 | 文字集合の開始                                                       | &amp;#34;[&amp;#34;          |
+| 110 | 文字集合の終了                                                       | &amp;#34;]&amp;#34;          |
+| 111 | 排他演算子                                                           | &amp;#34;\|&amp;#34;         |
+| 112 | エスケープ文字                                                       | &amp;#34;\\\\&amp;#34;       |
+| 113 | ハッシュ文字 (今は使われていない)                                    | &amp;#34;#&amp;amp;&amp;#34;         |
+| 114 | 文字範囲演算子                                                       | &amp;#34;-&amp;#34;          |
+| 115 | 繰り返し演算子の開始                                                 | &amp;#34;{&amp;#34;          |
+| 116 | 繰り返し演算子の終了                                                 | &amp;#34;}&amp;#34;          |
+| 117 | 数字                                                                 | &amp;#34;0123456789&amp;#34; |
+| 118 | エスケープ文字に続いたとき、単語の境界の明示を表す文字               | &amp;#34;b&amp;#34;          |
+| 119 | エスケープ文字に続いたとき、非単語の境界の明示を表す文字             | &amp;#34;B&amp;#34;          |
+| 120 | エスケープ文字に続いたときに単語の開始を表す文字                     | &amp;#34;&amp;lt;&amp;#34;          |
+| 121 | エスケープ文字に続いたときに単語の終了を表す文字                     | &amp;#34;&amp;gt;&amp;#34;          |
+| 122 | エスケープ文字に続いたときに、あらゆる単語構成文字を表す文字         | &amp;#34;w&amp;#34;          |
+| 123 | エスケープ文字に続いたときに、あらゆる非-単語構成文字を表す文字      | &amp;#34;W&amp;#34;          |
+| 124 | エスケープ文字に続いたときに、バッファの先頭の明示を表す文字         | &amp;#34;\`A&amp;#34;        |
+| 125 | エスケープ文字に続いたときに、バッファの終端の明示を表す文字         | &amp;#34;&amp;#39;z&amp;#34;         |
+| 126 | 改行文字                                                             | &amp;#34;\\n&amp;#34;        |
+| 127 | コンマセパレータ                                                     | &amp;#34;,&amp;amp;&amp;#34;         |
+| 128 | エスケープ文字に続いたときに、ベル文字を表す文字                     | &amp;#34;a&amp;#34;          |
+| 129 | エスケープ文字に続いたときに、フォームフィード文字(FF)を表す文字     | &amp;#34;f&amp;#34;          |
+| 130 | エスケープ文字に続いたときに、改行文字を表す文字                     | &amp;#34;n&amp;#34;          |
+| 131 | エスケープ文字に続いたときに、復帰改行 (CR) 文字を表す文字           | &amp;#34;r&amp;#34;          |
+| 132 | エスケープ文字に続いたときにタブ文字を表す文字                       | &amp;#34;t&amp;#34;          |
+| 133 | エスケープ文字に続いたときに、垂直タブ文字を表す文字                 | &amp;#34;v&amp;#34;          |
+| 134 | エスケープ文字に続いたときに、16進定数の開始を表す文字               | &amp;#34;x&amp;#34;          |
+| 135 | エスケープ文字に続いたときに、 ASCII エスケープ文字の開始を表す文字  | &amp;#34;c&amp;#34;          |
+| 136 | コロン                                                               | &amp;#34;:&amp;#34;          |
+| 137 | イコール                                                             | &amp;#34;=&amp;#34;          |
+| 138 | エスケープ文字に続いたときに、 ASCII エスケープ文字を表す文字        | &amp;#34;e&amp;#34;          |
+| 139 | エスケープ文字に続いたときに、あらゆる小文字を表す文字               | &amp;#34;l&amp;#34;          |
+| 140 | エスケープ文字に続いたときに、あらゆる非-小文字を表す文字            | &amp;#34;L&amp;#34;          |
+| 141 | エスケープ文字に続いたときに、あらゆる大文字を表す文字               | &amp;#34;u&amp;#34;          |
+| 142 | エスケープ文字に続いたときに、あらゆる非-大文字を表す文字            | &amp;#34;U&amp;#34;          |
+| 143 | エスケープ文字に続いたときに、あらゆる空白文字を表す文字             | &amp;#34;s&amp;#34;          |
+| 144 | エスケープ文字に続いたときに、あらゆる非-空白文字を表す文字          | &amp;#34;S&amp;#34;          |
+| 145 | エスケープ文字に続いたときに、あらゆる数字を表す文字。               | &amp;#34;d&amp;#34;          |
+| 146 | エスケープ文字に続いたときに、あらゆる非-数字を表す文字              | &amp;#34;D&amp;#34;          |
+| 147 | エスケープ文字に続いたときに、終了引用符を表す文字                   | &amp;#34;E&amp;#34;          |
+| 148 | エスケープ文字に続いたときに、開始引用符を表す文字                   | &amp;#34;Q&amp;#34;          |
+| 149 | エスケープ文字に続いたときに、ユニコード複合文字シーケンスを表す文字 | &amp;#34;X&amp;#34;          |
+| 150 | エスケープ文字に続いたときに、あらゆる単一文字を表す文字             | &amp;#34;C&amp;#34;          |
+| 151 | エスケープ文字に続いたときに、バッファ終了演算子を表す文字           | &amp;#34;Z&amp;#34;          |
+| 152 | エスケープ文字に続いたときに、連続の明示を表す文字                   | &amp;#34;G&amp;#34;          |
+| 153 |  (? に続いたときにゼロ幅の否定前方一致の明示を表す文字               | !            |
+
+カスタムのエラーメッセージは以下のように読み込まれる:
+
+| メッセージ ID | エラーメッセージ ID | 既定文字列               |
+|-----|-----------------|----------------------------------------|
+| 201 | `REG_NOMATCH`   | &amp;#34;No match&amp;#34;                             |
+| 202 | `REG_BADPAT`    | &amp;#34;Invalid regular expression&amp;#34;           |
+| 203 | `REG_ECOLLATE`  | &amp;#34;Invalid collation character&amp;#34;          |
+| 204 | `REG_ECTYPE`    | &amp;#34;Invalid character class name&amp;#34;         |
+| 205 | `REG_EESCAPE`   | &amp;#34;Trailing backslash&amp;#34;                   |
+| 206 | `REG_ESUBREG`   | &amp;#34;Invalid back reference&amp;#34;               |
+| 207 | `REG_EBRACK`    | &amp;#34;Unmatched [ or [\^&amp;#34;                   |
+| 208 | `REG_EPAREN`    | &amp;#34;Unmatched ( or \\\\(&amp;#34;                 |
+| 209 | `REG_EBRACE`    | &amp;#34;Unmatched \\\\{&amp;#34;                      |
+| 210 | `REG_BADBR`     | &amp;#34;Invalid content of \\\\{\\\\}&amp;#34;        |
+| 211 | `REG_ERANGE`    | &amp;#34;Invalid range end&amp;#34;                    |
+| 212 | `REG_ESPACE`    | &amp;#34;Memory exhausted&amp;#34;                     |
+| 213 | `REG_BADRPT`    | &amp;#34;Invalid preceding regular expression&amp;#34; |
+| 214 | `REG_EEND`      | &amp;#34;Premature end of regular expression&amp;#34;  |
+| 215 | `REG_ESIZE`     | &amp;#34;Regular expression too big&amp;#34;           |
+| 216 | `REG_ERPAREN`   | &amp;#34;Unmatched ) or \\\\)&amp;#34;                 |
+| 217 | `REG_EMPTY`     | &amp;#34;Empty expression&amp;#34;                     |
+| 218 | `REG_E_UNKNOWN` | &amp;#34;Unknown error&amp;#34;                        |
+
+カスタムの文字クラス名は次のように読み込まれる:
+
+| メッセージ ID | 解説            | 等価な既定のクラス名 |
+|-----|--------------------------------------|-----------|
+| 300 | 英数字の文字クラス名                 | &amp;#34;alnum&amp;#34;   |
+| 301 | アルファベット文字の文字クラス名     | &amp;#34;alpha&amp;#34;   |
+| 302 | コントロール文字の文字クラス名       | &amp;#34;cntrl&amp;#34;   |
+| 303 | 数字の文字クラス名                   | &amp;#34;digit&amp;#34;   |
+| 304 | 空白以外の印字可能文字の文字クラス名 | &amp;#34;graph&amp;#34;   |
+| 305 | 小文字の文字クラス名                 | &amp;#34;lower&amp;#34;   |
+| 306 | 印字可能文字の文字クラス名           | &amp;#34;print&amp;#34;   |
+| 307 | 句読点の文字クラス名                 | &amp;#34;punct&amp;#34;   |
+| 308 | 空白文字の文字クラス名               | &amp;#34;space&amp;#34;   |
+| 309 | 大文字の文字クラス名                 | &amp;#34;upper&amp;#34;   |
+| 310 | 16進文字の文字クラス名               | &amp;#34;xdigit&amp;#34;  |
+| 311 | ブランク文字の文字クラス名           | &amp;#34;blank&amp;#34;   |
+| 312 | 単語構成文字の文字クラス名           | &amp;#34;word&amp;#34;    |
+| 313 | ユニコード文字の文字クラス名         | &amp;#34;unicode&amp;#34; |
+
+最後に、カスタムの照合要素名がメッセージ ID 400 から始まって読み込まれ、最初の読み込みがその後失敗したときに終了する。
+それぞれのメッセージは次のようだろう: &amp;#34;tagname string&amp;#34; `tagname` は [[.tagname.]] の内側で使われる名前であり、 *string* は照合要素の実際のテキストである。
+照合要素の値 [[.zero.]] は文字列から数字への変換のために使われていることに注意せよ。
+もしこれを他の値で書き換えたら、それが文字列解析に使われることになる。
+例えば、ラテン数字の代わりに、ユニコードのアラビア-インド数字を正規表現の中で使いたければ、 [[.zero.]] にユニコード文字 0x0660 を使えばよい。
+
+POSIX が定義した文字クラス名と照合要素は常に利用可能であることに注意せよ。
+たとえカスタムの名前が定義されても、逆にカスタムのエラーメッセージとカスタムの構文メッセージはデフォルトのもので置き換えられる。
+
+---
+
+### &amp;lt;a name=&amp;#34;demos&amp;#34;&amp;gt;Appendix 4: 応用例 &amp;lt;/a&amp;gt;
+
+このライブラリに関する3つのデモアプリケーションがある。
+Borland, Microsoft, gcc コンパイラのメイクファイルは付属しているが、それ以外は自分でメイクファイルを作成しなければならない
+
+**regress.exe:**
+
+一致判定、検索アルゴリズムを完全に試すための、退行テストアプリケーションである。
+このプログラムが動けば、少なくともこれらの試されたものが関わる限りは、ライブラリが要求通りに動くであろうことを保証する。
+もし誰かが、何か試されていないものを見つけたら、それについて聞けると私はうれしい。
+
+Files: [`parse.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/test/regress/parse.cpp), [`regress.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/test/regress/regress.cpp), [`tests.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/test/regress/tests.cpp).
+
+**jgrep.exe**
+
+単純な grep の実装。利用法を調べるためには、コマンドラインオプションをつけずに走らせてみること。
+regex++ や他の STL アルゴリズムで使うことが出来る &amp;#34;賢い&amp;#34; 双方向イテレータの例を見るには、
+[`fileiter.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/src/fileiter.cpp)/fileiter.hpp およびそのマップファイルクラスを参考にせよ。
+
+Files: [`jgrep.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/jgrep/jgrep.cpp), [`main.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/jgrep/main.cpp).
+
+**timer.exe**
+
+単純な対話式一致判定アプリケーション。
+全ての一致の結果が時間測定されるので、プログラマはパフォーマンスが重要なときに、正規表現を最適化することが出来る。
+
+Files: [`regex_timer.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/timer/regex_timer.cpp).
+
+断片的な例はこのドキュメントで使われたコードの例を含んでいる。
+
+[`regex_match_example.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_match_example.cpp): ftp に基づく `regex_match` の例
+
+[`regex_search_example.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_search_example.cpp): `regex_search` の例: cpp ファイルのクラス定義を検索する。
+
+[`regex_grep_example_1.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_grep_example_1.cpp): `regex_grep` の例: cpp ファイルのクラス定義を検索する。
+
+[`regex_merge_example.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_merge_example.cpp): `regex_merge` の例: C++ ファイルを、構文がハイライトされた HTML に変換する。
+
+[`regex_grep_example_2.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_grep_example_2.cpp): `regex_grep` の例 2: グローバルコールバック関数を使って、cpp ファイルのクラス定義を検索する。
+
+[`regex_grep_example_3.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_grep_example_3.cpp): `regex_grep` の例 3: 束縛されたメンバ関数コールバックを使って、cpp ファイルのクラス定義を検索する。
+
+[`regex_grep_example_4.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_grep_example_4.cpp): `regex_grep` の例 4: C++ Builder のクロージャをコールバックとして使って、cpp ファイルのクラス定義を検索する。
+
+[`regex_split_example_1.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_split_example_1.cpp): `regex_split` の例: 文字列をトークンに分割する。
+
+[`regex_split_example_2.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/snippets/regex_split_example_2.cpp): `regex_split` の例: リンクされた URL を吐き出す。
+
+---
+
+### &amp;lt;a name=&amp;#34;headers&amp;#34;&amp;gt;Appendix 5: ヘッダファイル&amp;lt;/a&amp;gt;
+
+このライブラリが使う2つの主要なヘッダファイルがある:
+`&amp;lt;boost/regex.hpp&amp;gt;` は完全なライブラリへの完全なアクセスを提供する。
+`&amp;lt;boost/cregex.hpp&amp;gt;` は高水準クラス `RegEx` と POSIX API 関数へのアクセスのみを提供する。
+
+---
+
+### &amp;lt;a name=&amp;#34;redist&amp;#34;&amp;gt;Appendix 6: 再配布&amp;lt;/a&amp;gt;
+
+もし Microsoft か Borland C++ を使っていて、 dll 版のランタイムライブラリにリンクしているなら、 regex++ の dll のひとつのバージョンにもリンクしているだろう。
+これらの dll は再配布可能だが、 &amp;#34;標準の&amp;#34; バージョンというものが存在しないので、ユーザの PC にインストールするとき、これらを、PC のディレクトリパスにではなく、アプリケーションのプライベートディレクトリに置くべきである。
+もしスタティックバージョンのランタイムライブラリとリンクしているなら、 regex++ ともリンクしていて、 dll が配布される必要はないだろう。
+可能な regex++ dll とライブラリの名前は次の公式に従って導き出される:
+
+`&amp;#34;boost_regex_&amp;#34;`&amp;lt;br/&amp;gt;
+\+ `BOOST_LIB_TOOLSET`&amp;lt;br/&amp;gt;
+\+ `&amp;#34;_&amp;#34;`&amp;lt;br/&amp;gt;
+\+ `BOOST_LIB_THREAD_OPT`&amp;lt;br/&amp;gt;
+\+ `BOOST_LIB_RT_OPT`&amp;lt;br/&amp;gt;
+\+ `BOOST_LIB_LINK_OPT`&amp;lt;br/&amp;gt;
+\+ `BOOST_LIB_DEBUG_OPT`&amp;lt;br/&amp;gt;
+
+これらは次のように定義されている:
+
+`BOOST_LIB_TOOLSET`: コンパイラのツールセットの名前 (vc6, vc7, bcb5 など)
+
+`BOOST_LIB_THREAD_OPT`: &amp;#34;s&amp;#34; はシングルスレッドビルドを表す。
+&amp;#34;m&amp;#34; はマルチスレッドビルドを表す。
+
+`BOOST_LIB_RT_OPT`: &amp;#34;s&amp;#34; はスタティックランタイムをあらわす。
+&amp;#34;d&amp;#34; はダイナミックランタイムを表す。
+
+`BOOST_LIB_LINK_OPT`: &amp;#34;s&amp;#34; はスタティックリンクを表す。
+&amp;#34;i&amp;#34; はダイナミックリンクを表す。
+
+`BOOST_LIB_DEBUG_OPT`: 未定義ならリリースビルドを表す。
+&amp;#34;d&amp;#34; はデバッグビルドを表す。
+&amp;#34;dd&amp;#34; は診断デバッグビルドを表す。
+(`_STLP_DEBUG`)
+
+注意: シンボル `BOOST_REGEX_NO_LIB` をコンパイル時に定義することで、ライブラリの自動選択を不可能にすることが出来る。
+これは、ランタイムライブラリの dll バージョンを使っていても、スタティックリンクをしたいようなときや、 regex++ をデバッグする必要があるときに役に立つ。
+
+---
+
+### &amp;lt;a name=&amp;#34;upgrade&amp;#34;&amp;gt;アップグレードに関する注記&amp;lt;/a&amp;gt;
+
+このバージョンの regex++ は [boost](http://www.boost.org/) プロジェクトに移植された最初のものであり、結果的に、boost コーディングガイドラインに従うために、多くの変更が為された。
+
+ヘッダファイルは `&amp;lt;header&amp;gt;` や `&amp;lt;header.h&amp;gt;` から `&amp;lt;boost/header.hpp&amp;gt;` に変更された。
+
+ライブラリの名前空間は &amp;#34;jm&amp;#34; から &amp;#34;boost&amp;#34; に変更された。
+
+`reg_xxx` アルゴリズムは (名前付けの一貫性を改善するために) `regex_xxx` に改名された。
+
+アルゴリズム `query_match` は `regex_match` に改名された。
+また、正規表現が入力文字列の全体に一致するときのみ `true` を返すようになった
+(入力データの検証を考えている)。
+
+*既存のコードのコンパイル:*
+
+ディレクトリ `libs/regex/old_include` には、このバージョンの regex++ が以前のライブラリとの互換性を持つためのヘッダファイル群が含まれている。
+このディレクトリをインクルードパスに追加するか、これらのヘッダファイルを boost をインストールしたルートディレクトリにコピーすればよい。
+これらのヘッダファイルの内容は推奨されていないし、ドキュメントも提供されていない。
+これらは本当に、ただ既存のコードのためだけに存在している。
+新しいプロジェクトには、新しいヘッダ形式を使うこと。
+
+---
+
+### &amp;lt;a name=&amp;#34;furtherInfo&amp;#34;&amp;gt;より多くの情報 (連絡と謝辞)&amp;lt;/a&amp;gt;
+
+作者への連絡は [John_Maddock@compuserve.com](mailto:John_Maddock@compuserve.com) で可能である。
+このライブラリのためのホームページは [http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm](http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm) にある。
+公式の boost のバージョンは [www.boost.org/libs/](https://www.boost.org/libs/) から入手できる。
+
+私は Robert Sedgewick 著 &amp;#34;Algorithms in C++&amp;#34; に大変感謝している。
+これは私にアルゴリズムとパフォーマンスについて考えさせてくれた。
+また boost の人々は私に *考え*させてくれた、以上。
+以下の人々は皆、有益なコメントや修正をしてくれた:
+Dave Abrahams, Mike Allison, Edan Ayal, Jayashree
+Balasubramanian, Jan BNBvlsche, Beman Dawes, Paul Baxter, David
+Bergman, David Dennerline, Edward Diener, Peter Dimov, Robert
+Dunn, Fabio Forno, Tobias Gabrielsson, Rob Gillen, Marc Gregoire,
+Chris Hecker, Nick Hodapp, Jesse Jones, Martin Jost, Boris
+Krasnovskiy, Jan Hermelink, Max Leung, Wei-hao Lin, Jens Maurer,
+Richard Peters, Heiko Schmidt, Jason Shirk, Gerald Slacik, Scobie
+Smith, Mike Smyth, Alexander Sokolovsky, HervNBi Poirier, Michael
+Raykh, Marc Recht, Scott VanCamp, Bruno Voigt, Alexey Voinov,
+Jerry Waldorf, Rob Ward, Lealon Watts, Thomas Witt and Yuval
+Yosef. 
+私はまた、Henry Spencer の Perl and GNU regular expression libraries
+に関するマニュアルにも感謝している。
+可能であれば常に、これらのライブラリ、そして POSIX 標準との互換性を保とうとした。
+しかしコードは完全に私自身のものであり、バグを含んでいる!
+私は、私が知らないどんなバグも直すことが出来ないだろうと、自信を持って保証できる。
+だからもし、あなたが何かコメントをもっていたり、バグを発見したりしたら、ぜひ教えて欲しい。
+
+役立つ情報は更に、次の場所で得ることが出来る:
+
+正規表現に関する簡単なチュートリアルは [ここで見ることが出来る。](http://www.devshed.com/Server_Side/Administration/RegExp/)
+
+[Open Unix Specification](http://www.opengroup.org/onlinepubs/7908799/toc.htm) は、正規表現構文やその仕様 [`&amp;lt;regex.h&amp;gt;`](http://www.opengroup.org/onlinepubs/7908799/xsh/regex.h.html) [`&amp;lt;nl_types.h&amp;gt;`](http://www.opengroup.org/onlinepubs/7908799/xsh/nl_types.h.html) などを含む、役立つ資料を多く含んでいる。
+
+[Pattern Matching Pointers](http://www.cs.ucr.edu/~stelo/pattern.html) サイトは &amp;#34;must visit&amp;#34; パターンマッチに興味を持つものなら誰もが訪ねなければならない情報資源である。
+
+[Glimpse and Agrep](http://glimpse.cs.arizona.edu/) はより高速な探索時間を実現するために、単純化された正規表現構文を使っている
+
+[Udi Manber](http://glimpse.cs.arizona.edu/udi.html) と [Ricardo Baeza-Yates](http://www.dcc.uchile.cl/~rbaeza/) は両方とも、関連するウェブサイトから利用可能な、役立つパターンマッチの文書を集めたものである。
+
+---
+
+*Copyright* [*Dr John Maddock*](mailto:John_Maddock@compuserve.com) *1998-2001 all rights reserved.*
+
+---
+
+*Japanese Translation Copyright (C) 2003 [Kohske Takahashi](mailto:k_takahashi@cppll.jp)*
+
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, FAQ. -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/faq.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/faq.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/faq.md b/archive/boost_docs/libs/regex/faq.md
new file mode 100644
index 0000000..959afd2
--- /dev/null
+++ b/archive/boost_docs/libs/regex/faq.md
@@ -0,0 +1,131 @@
+# Regex++, FAQ.
+
+*Copyright (c) 1998-2001*
+
+*Dr John Maddock*
+
+*Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
+Dr John Maddock makes no representations about the suitability of this software for any purpose.
+It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
+
+---
+
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. 正規表現の中で丸括弧を使うと、なぜ一致の結果が変わるのですか? &amp;lt;/font&amp;gt;
+
+丸括弧は印付けをするだけではない。
+同様に、何が最も一致するかを決定する。
+regex++ の特性は、何が一致するかを決定するのに 最左・最長という POSIX 標準に従っている。
+だからもし全ての表現を検討した上で、ひとつ以上の可能な一致があれば、最初の子表現、第2の子表現、第3の・・・と優先されて一致する。
+つまり、
+
+`&amp;#34;(0*)([0-9]*)&amp;#34; against &amp;#34;00123&amp;#34;` は次のものを作る:
+
+```cpp
+$1 = &amp;#34;00&amp;#34;
+$2 = &amp;#34;123&amp;#34;
+```
+
+一方、
+
+`&amp;#34;0*([0-9)*&amp;#34; against &amp;#34;00123&amp;#34;` は次のものを作る:
+
+```cpp
+$1 = &amp;#34;00123&amp;#34;
+```
+
+$1が &amp;#34;123&amp;#34; とだけ一致するとしたら、それは最左最長の一致である &amp;#34;00123&amp;#34; との一致よりも望ましくない。
+もし $1 を &amp;#34;123&amp;#34; とのみ一致させたければ、次のようなものを使う必要がある。
+つまり:
+
+`&amp;#34;0*([1-9][0-9]*)&amp;#34;`
+
+という表現である。
+
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. コンフィギュアは、私のコンパイラがテンプレートの実体を結合出来ないと言ってきます。これはどういう意味ですか?&amp;lt;/font&amp;gt;
+
+A. あなたがテンプレートコードをコンパイルするとき、最終的には複数の翻訳単位で同じテンプレートの実体が出来る。
+このため、もしあなたのコンパイラ/リンカが、これらのテンプレートの実体を実行ファイルの中のひとつのレコードに結合するのに十分賢くなければ、リンク時のエラーが起きる。
+コンフィギュアを実行した後にこの警告が出ても、次のような場合には libregex++.a とリンクすることが可能である。
+
+1. 低水準テンプレートクラス(`reg_expression&amp;lt;&amp;gt;`, `match_results&amp;lt;&amp;gt;`, etc.) のみを単一の翻訳単位から使っていて、regex++ の他の部分は使っていない場合。
+2. POSIX API 関数(`regcomp`, `regexec`, etc.)だけを使っていて、 regex++ の他の部分を使っていない場合。
+3. 高水準のクラス `RegEx` だけを使っていて、 regex++ の他の部分を使っていない場合。
+
+もうひとつの選択肢は、最上位インクルードファイルを作成することである。
+これには regex++ のソースファイル全て、あなたが regex++ を利用しているソースファイル全てをインクルードする。
+そしてこの最上位インクルードファイルを単一の翻訳単位として、コンパイルしリンクする。
+
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. コンフィギュアは私のコンパイラがアーカイブファイルからテンプレートの実体を結合できないと言ってきます。これはどういう意味ですか?&amp;lt;/font&amp;gt;
+
+A. あなたがテンプレートコードをコンパイルするとき、最終的に複数の翻訳単位に同じテンプレートの実体が出来る。
+これにより、もしあなたのコンパイラ/リンカが、これらのテンプレートの実体を実行ファイルの中のひとつのレコードに結合するのに十分賢くなければ、リンク時にエラーが起きる。
+通常の .cpp ファイルと .o ファイルに対してはこれが可能だが、オブジェクトファイルがライブラリアーカイブに置かれていると、これに失敗するコンパイラもある。
+コンフィギュアを実行した後にこの警告が出ても、次のような場合は libregex++.a とリンクすることが可能である。
+
+1. 低水準テンプレートクラス(`reg_expression&amp;lt;&amp;gt;`, `match_results&amp;lt;&amp;gt;`, etc.) のみを単一の翻訳単位から使っていて、regex++ の他の部分は使っていない場合。
+2. POSIX API 関数(`regcomp`, `regexec`, etc.)だけを使っていて、 regex++ の他の部分を使っていない場合。
+3. 高水準のクラス `RegEx` だけを使っていて、 regex++ の他の部分を使っていない場合。
+
+もう一つの選択肢は、 libregex++.a をリンクする代わりに、 regex++ のソースファイルを直接あなたのプロジェクトに追加することである。
+これは通常、 libregex++.a でリンク時エラーが起きる場合のみ、行うべきである。
+
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. コンフィギュアは、私のコンパイラが switch 文を含むテンプレートを結合出来ないと言ってきます。これはどういう意味ですか?&amp;lt;/font&amp;gt;
+
+A. 静的なデータを含むテンプレートを結合できないコンパイラもある。
+これには、コードと同様に、しかし暗黙的に静的データを生成する switch 文も含む。
+主にこれは、 egcs コンパイラに影響する (しかし gcc 2.81 も同じ問題を持っていることに注意せよ)。
+コンパイラはコードをコンパイルし、リンクすることが出来る。
+しかしコードと、コードが使う静的データは分離してしまうので、そのコードは実行できない。
+regex++ のデフォルトの振る舞いは、 無名名前空間の中で &amp;#34;problem&amp;#34; テンプレートを宣言することにより、この問題を修復しようとするので、テンプレートは内部リンケージをもつ。
+これが、大量のコード膨張を引き起こすことに注意せよ。
+もしコンパイラが名前空間をサポートしていないか、コード膨張が問題になったら、単一翻訳単位の中に全てのテンプレートを置くための上のガイドラインに従うこと。
+そして、 boost/regex/config.hpp を編集し、 `BOOST_REGEX_NO_TEMPLATE_SWITCH_MERGE` を定義しないようにすること。
+
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. 私は regex++ でエスケープ文字を使うことが出来ません。何が起こっているのですか？&amp;lt;/font&amp;gt;
+
+A. もし C++ コードの中に正規表現を埋め込んでいるなら、エスケープ文字が2度処理されることを忘れないこと: 一度は C++ コンパイラによって、もう一度は regex++ 正規表現コンパイラによってである。
+正規表現 \\d+ を regex++ に渡すには、 &amp;#34;\\\\d+&amp;#34; をコードに埋め込む必要がある。
+同様にリテラルとしてバックスラッシュに一致するには、コードに &amp;#34;\\\\\\\\&amp;#34; を埋め込む必要があるだろう。
+
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. なぜ文字範囲が適切に動作しないのですか?&amp;lt;/font&amp;gt;
+
+A. POSIX 標準は、文字範囲表現がロケールに敏感であること明示している。
+例えば正規表現 [A-Z] は &amp;#39;A&amp;#39; と &amp;#39;Z&amp;#39; の間に並ぶあらゆる照合要素に一致する。
+これは、 &amp;#34;C&amp;#34; や &amp;#34;POSIX&amp;#34; 以外のほとんどのロケールで、例えば[A-Z] は単一文字 &amp;#39;t&amp;#39; にマッチする。
+これはあまり期待されていない動作である。
+また、少なくとも正規表現エンジンによってこうなることは、多くの場合期待されていないだろう。
+この理由で、 regex++ のデフォルトの振る舞いは、コンパイル時フラグ `regbase::nocollate` を設定することでロケールに敏感な照合を行わない (このフラグは `regbase::normal` により設定されている)。
+しかしもし、デフォルトでないコンパイル時フラグを設定すれば (例えば `regbase::extended` や `regbase::basic`) ロケールに依存する照合が可能になる。
+これはまた、内部的に `regbase::extended` や `regbase::basic` を使っている POSIX API 関数にも適用される。
+後者の場合、もしロケールに敏感な照合を行いたくなければ、 `REG_NOCOLLATE` を `REG_BASIC` か `REG_EXTENDED` を組み合わせて使えばよい。
+*[注意: `regbase::nocollate` が作用しているとき、ライブラリは、実際にの設定値に関わらず、`_COLLATE` ロケートカテゴリーが常に &amp;#34;C&amp;#34; である &amp;#34;かのように&amp;#34; 振る舞う。]*
+
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;&amp;amp;nbsp;Q. なぜ私は、「簡易版の」 `query_match/reg_search/reg_grep/reg_format/reg_merge` を使うことが出来ないのですか?&amp;lt;/font&amp;gt;
+
+A. これらの簡易版はあなたのコンパイラの能力によって使えたり使えなかったりする。
+これらの関数の形式を決定する規則は極めて複雑である。
+そして標準に準拠しているコンパイラで利用可能な版は、ヘルプの中に記載されている。
+あなたのコンパイラが何をサポートしているかを見るには、あなたの C++ プリプロセッサで、 `&amp;lt;boost/regex.hpp&amp;gt;` を実行し、あなたが感心のある関数をその出力ファイルで探せばよい。
+
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. なぜどの関数にも、例外仕様がないのですか?ライブラリはどんな例外を投げるのですか?&amp;lt;/font&amp;gt;
+
+A. 全てのコンパイラが、例外仕様をサポートしたり、支持しているわけではない。
+それをサポートしていても、あまり効果を持たせていないものもある。
+例外仕様はコンパイラがこれをもう少しちゃんと扱い始めたら、その時に付け加えられるだろう。
+ライブラリは 3 つの型の例外のみを投げる。
+`boost::bad_expression` は 正規表現のコンパイル時に `reg_expression` によって投げられる。
+`std::runtime_error` は `reg_expression::imbue` の呼び出しが、存在しないメッセージカタログを開こうとしたときか、 `RegEx::GrepFiles` や `RegEx::FindFiles` が開くことの出来ないファイルを開こうとしたときに投げられる。
+最後に、 `std::bad_alloc` はこのライブラリのおおよそどの関数でも投げられる。
+
+---
+
+*Copyright* [*Dr John Maddock*](mailto:John_Maddock@compuserve.com) *1998-2001 all rights reserved.*
+
+---
+
+*Japanese Translation Copyright (C) 2003 [Kohske Takahashi](mailto:k_takahashi@cppll.jp)*
+
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Format String Reference. -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/format_string.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/format_string.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Regex++, Format String Reference.&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;em&gt;Copyright (c) 1998-2001&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
Dr John Maddock makes no representations about the suitability of this software for any purpose.
It is provided &#34;as is&#34; without express or implied warranty.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;a name=&#34;format_string&#34;&gt;Format String Syntax&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;書式文字列は、アルゴリズム &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_format&#34;&gt;regex_format&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_merge&#34;&gt;regex_merge&lt;/a&gt;&lt;/code&gt; で使われている。
これは、一つの文字列を別の文字列に変形するために使われる。&lt;/p&gt;
&lt;p&gt;3種類の書式文字列がある: sed, perl, そして拡張である。
拡張構文はデフォルトなので、最初にこれについて説明する。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拡張文字列構文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;書式文字列では、次のものを除く全ての文字はリテラルとして扱われる: ()\$\?: &lt;/p&gt;
&lt;p&gt;これらをリテラルとして使うには、エスケープ文字 \ を前につけなければならない。&lt;/p&gt;
&lt;p&gt;次の特別なシーケンスを扱うことが出来る。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;グループ化:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;書式文字列の中で子表現をグループ化するには、丸括弧 ( と ) を使うこと。
リテラル &#39;(&#39; と &#39;)&#39; をあらわすには、 \( と \) を使う。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;子表現展開:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次の perl のような表現は、特定の一致した子表現を展開する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\$`&lt;/td&gt;
&lt;td&gt;前の一致の終端から現在の一致の先頭までの全てのテキストを展開する。もし現在の一致の操作中に前の一致がなければ、入力文字列の先頭から現在の一致の先頭までの全てが展開される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\$&#39;&lt;/td&gt;
&lt;td&gt;一致の終端から入力文字列の終端までの全てのテキストを展開する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\$&amp;amp;&lt;/td&gt;
&lt;td&gt;現在の一致を全て展開する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\$0&lt;/td&gt;
&lt;td&gt;現在の一致を全て展開する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\$N&lt;/td&gt;
&lt;td&gt;子表現 &lt;em&gt;N&lt;/em&gt; に一致したテキストを展開する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;条件付表現:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;条件付表現は二つの異なる書式文字列を、子表現が入力文字列に一致したかどうかに依存して選択することを可能にする：&lt;/p&gt;
&lt;p&gt;?N 真表現 : 偽表現&lt;/p&gt;
&lt;p&gt;もし子表現 &lt;em&gt;N&lt;/em&gt; が一致していれば、 真表現が実行される。
そうでなければ偽表現が実行される。&lt;/p&gt;
&lt;p&gt;例: &#34;(while)|(for)&#34; を検索した時、書式文字列 &#34;?1WHILE:FOR&#34; は一致したものを大文字にして出力する。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;エスケープシーケンス:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次のエスケープシーケンスが可能である:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\a&lt;/td&gt;
&lt;td&gt;ベル文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;フォームフィード(FF)文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;改行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;復帰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;タブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;垂直タブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\x&lt;/td&gt;
&lt;td&gt;16進文字 - 例えば: \x0D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\x{}&lt;/td&gt;
&lt;td&gt;可能なユニコード16進文字 - 例えば \x{1A0}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\cx&lt;/td&gt;
&lt;td&gt;ASCII エスケープ文字 x 、例えば \c@ は escape-@ と等価。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\e&lt;/td&gt;
&lt;td&gt;ASCII エスケープ文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\dd&lt;/td&gt;
&lt;td&gt;8進文字定数、例えば \10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Perl 書式文字列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Perl 書式文字列は文字 ()?: が特別な意味を持たないこと以外は、
デフォルト構文と同じである。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sed 書式文字列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sed 書式文字列は、文字 \ と &amp;amp; のみを特殊文字として使う。&lt;/p&gt;
&lt;p&gt;n が数字のとき、 \n は n 番目の子表現に展開される。&lt;/p&gt;
&lt;p&gt;&amp;amp; は一致全体に展開される。
( \0 と等価)。&lt;/p&gt;
&lt;p&gt;他のエスケープシーケンスはデフォルト構文と同じように展開される。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Copyright&lt;/em&gt; &lt;a href=&#34;mailto:John_Maddock@compuserve.com&#34;&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/a&gt; &lt;em&gt;1998-2001 all rights reserved.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:k_takahashi@cppll.jp&#34;&gt;Kohske Takahashi&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Class RegEx -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/hl_ref.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/hl_ref.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/hl_ref.md b/archive/boost_docs/libs/regex/hl_ref.md
new file mode 100644
index 0000000..9bb8217
--- /dev/null
+++ b/archive/boost_docs/libs/regex/hl_ref.md
@@ -0,0 +1,262 @@
+# Class RegEx
+
+*Copyright (c) 1998-2001*
+
+*Dr John Maddock*
+
+*Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
+Dr John Maddock makes no representations about the suitability of this software for any purpose.
+It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
+
+---
+
+```cpp
+#include &amp;lt;boost/cregex.hpp&amp;gt;
+```
+
+クラス `RegEx` は正規表現ライブラリに対する高水準の単純化されたインタフェースを提供する。
+このクラスはナロウキャラクタ文字列のみを扱い、正規表現は常に &amp;#34;通常の&amp;#34; 構文に従う。
+つまり、標準 POSIX 拡張構文と同じであるが、ロケールに特殊な照合は不可能であり、文字集合宣言の中でのエスケープ文字が許されている。
+
+```cpp
+typedef bool (*GrepCallback)(const RegEx&amp;amp; expression);
+typedef bool (*GrepFileCallback)(const char* file, const RegEx&amp;amp; expression);
+typedef bool (*FindFilesCallback)(const char* file);
+
+class RegEx
+{
+public:
+   RegEx();
+   RegEx(const RegEx&amp;amp; o);
+   ~RegEx();
+   RegEx(const char* c, bool icase = false);
+   explicit RegEx(const std::string&amp;amp; s, bool icase = false);
+   RegEx&amp;amp; operator=(const RegEx&amp;amp; o);
+   RegEx&amp;amp; operator=(const char* p);
+   RegEx&amp;amp; operator=(const std::string&amp;amp; s);
+   unsigned int SetExpression(const char* p, bool icase = false);
+   unsigned int SetExpression(const std::string&amp;amp; s, bool icase = false);
+   std::string Expression()const;
+   //
+   // now matching operators: 
+   //
+   bool Match(const char* p, unsigned int flags = match_default);
+   bool Match(const std::string&amp;amp; s, unsigned int flags = match_default); 
+   bool Search(const char* p, unsigned int flags = match_default); 
+   bool Search(const std::string&amp;amp; s, unsigned int flags = match_default); 
+   unsigned int Grep(GrepCallback cb, const char* p, unsigned int flags = match_default); 
+   unsigned int Grep(GrepCallback cb, const std::string&amp;amp; s, unsigned int flags = match_default); 
+   unsigned int Grep(std::vector&amp;lt;std::string&amp;gt;&amp;amp; v, const char* p, unsigned int flags = match_default); 
+   unsigned int Grep(std::vector&amp;lt;std::string&amp;gt;&amp;amp; v, const std::string&amp;amp; s, unsigned int flags = match_default); 
+   unsigned int Grep(std::vector&amp;lt;unsigned int&amp;gt;&amp;amp; v, const char* p, unsigned int flags = match_default); 
+   unsigned int Grep(std::vector&amp;lt;unsigned int&amp;gt;&amp;amp; v, const std::string&amp;amp; s, unsigned int flags = match_default); 
+   unsigned int GrepFiles(GrepFileCallback cb, const char* files, bool recurse = false, unsigned int flags = match_default); 
+   unsigned int GrepFiles(GrepFileCallback cb, const std::string&amp;amp; files, bool recurse = false, unsigned int flags = match_default); 
+   unsigned int FindFiles(FindFilesCallback cb, const char* files, bool recurse = false, unsigned int flags = match_default); 
+   unsigned int FindFiles(FindFilesCallback cb, const std::string&amp;amp; files, bool recurse = false, unsigned int flags = match_default); 
+   std::string Merge(const std::string&amp;amp; in, const std::string&amp;amp; fmt, bool copy = true, unsigned int flags = match_default); 
+   std::string Merge(const char* in, const char* fmt, bool copy = true, unsigned int flags = match_default); 
+   unsigned Split(std::vector&amp;lt;std::string&amp;gt;&amp;amp; v, std::string&amp;amp; s, unsigned flags = match_default, unsigned max_count = ~0);
+   //
+   // now operators for returning what matched in more detail: 
+   //
+   unsigned int Position(int i = 0)const; 
+   unsigned int Length(int i = 0)const; 
+   bool Matched(int i = 0)const;
+   unsigned int Line()const; 
+   unsigned int Marks() const; 
+   std::string What(int i)const; 
+   std::string operator[](int i)const;
+
+   static const unsigned int npos;
+};
+```
+
+クラス RegEx のメンバ関数は以下のように定義されている:
+
+- `RegEx();`
+	- デフォルトコンストラクタ:
+		有効な正規表現を持たない `RegEx` のインスタンスを構築する。
+- `RegEx(const RegEx&amp;amp; o);`
+	- コピーコンストラクタ:
+		引数 `o` の全てのプロパティがコピーされる。
+- `RegEx(const char* c, bool icase = false);`
+	- 正規表現を `c` に設定して、`RegEx` のインスタンスを構築する。
+		もし `icase` が `true` なら一致は大文字小文字によらない。
+		そうでなければ、大文字小文字を区別して一致が行われる。
+		失敗したときは `bad_expression` が投げられる。
+- `RegEx(const std::string&amp;amp; s, bool icase = false);`
+	- 正規表現を `s` に設定して、`RegEx` のインスタンスを構築する。
+		もし `icase` が `true` なら一致は大文字小文字によらない。
+		そうでなければ、大文字小文字を区別して一致が行われる。
+		失敗したときは `bad_expression` が投げられる。
+- `RegEx&amp;amp; operator=(const RegEx&amp;amp; o);`
+	- デフォルトの代入演算子
+- `RegEx&amp;amp; operator=(const char* p);`
+	- 代入演算子。
+		`SetExpression(p, false)` を呼び出すのと等価である。
+		失敗すれば `bad_expression` が投げられる。
+- `RegEx&amp;amp; operator=(const std::string&amp;amp; s);`
+	- 代入演算子。
+		`SetExpression(s, false)` を呼び出すのと等価である。
+		失敗すれば `bad_expression` が投げられる。
+- `unsigned int SetExpression(constchar* p, bool icase = false);`
+	- 現在の正規表現を `p` に設定する。
+		もし `icase` が `true` なら一致は大文字小文字によらない。
+		そうでなければ、大文字小文字を区別して一致が行われる。
+		失敗したときは `bad_expression` が投げられる。
+- `unsigned int SetExpression(const std::string&amp;amp; s, bool icase = false);`
+	- 現在の正規表現を `s` に設定する。
+		もし `icase` が `true` なら一致は大文字小文字によらない。
+		そうでなければ、大文字小文字を区別して一致が行われる。
+		失敗したときは `bad_expression` が投げられる。
+- `std::string Expression()const;`
+	- 現在の正規表現のコピーを返す。
+- `bool Match(const char* p, unsigned int flags = match_default);`
+	- テキスト `p` に対してマッチフラグ `flags` を使って現在の正規表現の一致判定を行う。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		正規表現が入力文字列全体と一致すれば `true` を返す。
+- `bool Match(const std::string&amp;amp; s, unsigned int flags = match_default) ;`
+	- テキスト `s` に対してマッチフラグ `flags` を使って現在の正規表現の一致判定を行う。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		正規表現が入力文字列全体と一致すれば `true` を返す。
+- `bool Search(const char* p, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、テキスト `p` のどこかに現在の正規表現との一致があるかを判定する。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		もし一致が発見されたら `true` を返す。
+- `bool Search(const std::string&amp;amp; s, unsigned int flags = match_default) ;`
+	- マッチフラグ `flags` を使って、テキスト `s` のどこかに現在の正規表現との一致があるかを判定する。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		もし一致が発見されたら `true` を返す。
+- `unsigned int Grep(GrepCallback cb, const char* p, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、テキスト `p` の中にある、現在の正規表現との一致を全て発見する。
+		[match flags](template_class_ref.md#match_type)を見よ。
+		それぞれの一致が発見されるたびに、コールバック関数 `cb` が `cb(*this)` という形で呼ばれる。
+	- どの段階でも、コールバック関数が false を返せば、grep 操作は終了し、そうでなければ、一致がそれ以上発見されなくなるまで続けられる。
+		発見された一致の数を返す。
+- `unsigned int Grep(GrepCallback cb, const std::string&amp;amp; s, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、テキスト `s` の中にある、現在の正規表現との一致を全て発見する。
+		[match flags](template_class_ref.md#match_type)を見よ。
+		それぞれの一致が発見されるたびに、コールバック関数 `cb` が `cb(*this)` という形で呼ばれる。
+	- どの段階でも、コールバック関数が `false` を返せば、`grep` 操作は終了し、そうでなければ、一致がそれ以上発見されなくなるまで続けられる。
+		発見された一致の数を返す。
+- `unsigned int Grep(std::vector&amp;lt;std::string&amp;gt;&amp;amp; v, const char* p, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、テキスト `p` の中にある、現在の正規表現との一致を全て発見する。
+		[match flags](template_class_ref.md#match_type)を見よ。
+		それぞれの一致のたびに、一致したもののコピーが `v` に送られる。
+		発見された一致の数を返す。
+- `unsigned int Grep(std::vector&amp;lt;std::string&amp;gt;&amp;amp; v, const std::string&amp;amp; s, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、テキスト `s` の中にある、現在の正規表現との一致を全て発見する。
+		[match flags](template_class_ref.md#match_type)を見よ。
+		それぞれの一致のたびに、一致したもののコピーが `v` に送られる。
+		発見された一致の数を返す。
+- `unsigned int Grep(std::vector&amp;lt;unsigned int&amp;gt;&amp;amp; v, const char* p, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、テキスト `p` の中にある、現在の正規表現との一致を全て発見する。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		それぞれの一致のたびに、一致したものの開始インデックスが `v` に送られる。発見された一致の数を返す。
+- `unsigned int Grep(std::vector&amp;lt;unsigned int&amp;gt;&amp;amp; v, const std::string&amp;amp; s, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、テキスト `s` の中にある、現在の正規表現との一致を全て発見する。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		それぞれの一致のたびに、一致したものの開始インデックスが `v` に送られる。
+		発見された一致の数を返す。
+- `unsigned int GrepFiles(GrepFileCallback cb, const char* files, bool recurse = false, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、ファイル `files` の中にある、現在の正規表現との一致を全て発見する。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		それぞれの一致が発見されるたびに、コールバック関数 `cb` が呼ばれる。
+	- コールバック関数が `false` を返せば、アルゴリズムは現在のファイル、ほかのファイルの中のそれ以降の一致を発見しないで終了する。
+	- 引数 `files` はワイルドカード文字 `*` と `?` を含むことが出来る。
+		もし引数 `recurse` が `true` なら、一致するファイル名のサブディレクトリも検索する。
+	- 発見された一致の総数を返す。
+	- ファイル入出力が失敗すれば、 `std::runtime_error` から派生した 例外が投げられるだろう。
+- `unsigned int GrepFiles(GrepFileCallback cb, const std::string&amp;amp; files, bool recurse = false, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、ファイル `files` の中にある、現在の正規表現との一致を全て発見する。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		それぞれの一致が発見されるたびに、コールバック関数 `cb` が呼ばれる。
+	- コールバック関数が `false` を返せば、アルゴリズムは現在のファイル、ほかのファイルの中のそれ以降の一致を発見しないで終了する。
+	- 引数 `files` はワイルドカード文字 `*` と `?` を含むことが出来る。
+		もし引数 `recurse` が `true` なら、一致するファイル名のサブディレクトリも検索する。
+	- 発見された一致の総数を返す。
+	- ファイル入出力が失敗すれば、 `std::runtime_error` から派生した例外が投げられるだろう。
+- `unsigned int FindFiles(FindFilesCallback cb, const char* files, bool recurse = false, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、 `files` を検索し、現在の正規表現と少なくとも一つの一致を持つ全てのファイルを発見する。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		それぞれの一致が発見されるたびに、コールバック関数 `cb` が呼ばれる。
+	- コールバック関数が `false` を返せば、アルゴリズムはそれ以降のファイルを考慮せずに終了する。
+	- 引数 `files` はワイルドカード文字 `*` と `?` を含むことが出来る。
+		もし引数 `recurse` が `true` なら、一致するファイル名のサブディレクトリも検索する。
+	- 発見されたファイルの総数を返す。
+	- ファイル入出力が失敗すれば、 `std::runtime_error` から派生した例外が投げられるだろう。
+- `unsigned int FindFiles(FindFilesCallback cb, const std::string&amp;amp; files, bool recurse = false, unsigned int flags = match_default);`
+	- マッチフラグ `flags` を使って、 `files` を検索し、現在の正規表現と少なくとも一つの一致を持つ全てのファイルを発見する。
+		[match flags](template_class_ref.md#match_type) を見よ。
+		それぞれの一致が発見されるたびに、コールバック関数 `cb` が呼ばれる。
+	- コールバック関数が `false` を返せば、アルゴリズムはそれ以降のファイルを考慮せずに終了する。
+	- 引数 `files` はワイルドカード文字 `*` と `?` を含むことが出来る。
+		もし引数 `recurse` が `true` なら、一致するファイル名のサブディレクトリも検索する。
+	- 発見されたファイルの総数を返す。
+	- ファイル入出力が失敗すれば、 `std::runtime_error` から派生した例外が投げられるだろう。
+- `std::string Merge(const std::string&amp;amp; in, const std::string&amp;amp; fmt, bool copy = true, unsigned int flags = match_default);`
+	- 検索と置換の操作を行う:
+		文字列 `in` を最初から最後まで検索し現在の正規表現との一致を全て発見する。
+		一致のたびに、書式文字列 `fmt` で置換を行う。
+		何が一致するか、書式文字列がどう扱われるかを決定するために `flags` を利用する。
+		もし `copy` が `true` なら入力のうち全ての一致しなかった部分が、変更されることなく出力にコピーされる。
+		もしフラグ `format_first_only` が設定されていれば、発見された最初のパターンだけが置換される。
+		新しい文字列を返す。
+		[書式文字列構文](format_string.md#format_string), [match flags](template_class_ref.md#match_type), [format flags](template_class_ref.md#format_flags) も参考にせよ。
+- `std::string Merge(const char* in, const char* fmt, bool copy = true, unsigned int flags = match_default);`
+	- 検索と置換の操作を行う:
+		文字列 `in` を最初から最後まで検索し現在の正規表現との一致を全て発見する。
+		一致のたびに、書式文字列 `fmt` で置換を行う。
+		何が一致するか、書式文字列がどう扱われるかを決定するために `flags` を利用する。
+		もし `copy` が `true` なら入力のうち全ての一致しなかった部分が、変更されることなく出力にコピーされる。
+		もしフラグ `format_first_only` が設定されていれば、発見された最初のパターンだけが置換される。
+		新しい文字列を返す。
+		[書式文字列構文](format_string.md#format_string), [match flags](template_class_ref.md#match_type), [format flags](template_class_ref.md#format_flags) も参考にせよ。
+- `unsigned Split(std::vector&amp;lt;std::string&amp;gt;&amp;amp; v, std::string&amp;amp; s, unsigned flags = match_default, unsigned max_count = ~0);`
+	- 入力文字列を分割し、`vector` に送る。
+		もし正規表現が印付けされた子表現(訳注: 印付けされた子表現 `marked-expression` とは、正規表現中の `()` で囲まれたものであり、かつ `(?` で始まらないものである。)
+		を含んでいなければ、正規表現に一致しなかった入力のそれぞれの部分につき一つの文字列が出力される。
+		もし正規表現が印付けされた子表現を含んでいれば、それぞれの一致で印付けされた子表現につき一つの文字列が出力される。
+		`max_count` 以上の文字列は出力されない。
+		この関数から戻る前に、入力文字列 `s` から、処理された全ての入力を削除する (もし `max_count` に達しなければ、文字列全て)。
+		`vector` に送られた文字列の数を返す。
+- `unsigned int Position(int i = 0)const;`
+	- `i` 番目の子表現が一致したものの位置を返す。
+		もし `i = 0` なら、全体の一致の位置を返す。
+		もし与えられたインデックスが無効なら、または指定された子表現が一致していなかったら、 `RegEx::npos` を返す。
+- `unsigned int Length(int i = 0)const;`
+	- `i` 番目の子表現と一致したものの長さを返す。
+		もし `i = 0` なら全体の一致の長さを返す。
+		もし `i = 0` なら、全体の一致の位置を返す。
+		もし与えられたインデックスが無効なら、または指定された子表現が一致していなかったら、 `RegEX::npos` を返す。
+- `bool Matched(int i = 0)const;`
+	- `i` 番目の子表現が一致していたら `true` を、そうでなければ `false` を返す。
+- `unsigned int Line()const;`
+	- 一致があった行番号を返す。
+		番号は `0` でなく `1` で始まる。
+		一致がなければ、 `RegEx::npos` を返す。
+- `unsigned int Marks() const;`
+	- 正規表現に含まれる、印付けされた子表現の数を返す。
+		これはマッチ全体(子表現ゼロ)も含むことに注意すること。
+		つまり、戻り値は常に `&amp;gt;= 1` である。
+- `std::string What(int i)const;`
+	- `i` 番目の子表現に一致したもののコピーを返す。
+		もし `i = 0` なら全体の一致のコピーを返す。
+		インデックスが無効であったり、指定された子表現が一致していなかったら、 `null` 文字列を返す。
+- `std::string operator[](int i)const ;`
+	- `what(i);` を返す。
+	- 子表現の一致への簡単なアクセスに使うことが出来て、perl-like な利用法を可能にする。
+
+---
+
+*Copyright* [*Dr John Maddock*](mailto:John_Maddock@compuserve.com) *1998-2001 all rights reserved.*
+
+---
+
+*Japanese Translation Copyright (C) 2003 [Kohske Takahashi](mailto:k_takahashi@cppll.jp)*
+
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>&lt;a id=&#34;intro&#34;&gt;Introduction&lt;/a&gt; -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/introduction.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/introduction.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/introduction.md b/archive/boost_docs/libs/regex/introduction.md
new file mode 100644
index 0000000..4780aaf
--- /dev/null
+++ b/archive/boost_docs/libs/regex/introduction.md
@@ -0,0 +1,335 @@
+# &amp;lt;a id=&amp;#34;intro&amp;#34;&amp;gt;Introduction&amp;lt;/a&amp;gt;
+
+*Copyright (c) 1998-2001*
+
+*Dr John Maddock*
+
+*Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
+Dr John Maddock makes no representations about the suitability of this software for any purpose.
+It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
+
+---
+
+## Introduction
+
+正規表現はテキスト処理によく使われるパターンマッチングのひとつである。
+多くのユーザは *grep*,*sed*,*awk* などのUnixのユーティリティや、プログラミング言語である *perl* をよく知っているだろう。
+それらは正規表現の拡張である。
+伝統的に、C++ユーザは正規表現を操作するのに、POSIX C APIのものに限られてきた。
+regex++はこれらのAPIを提供するが、これらの API を使うのは regex++ ライブラリの最良の利用法ではない｡
+例えば、regex++はワイドストリングを扱うことが可能であり、伝統的なCライブラリが出来なかった、(sedやperlと似たようなやり方での)検索や置換の操作が可能である。
+
+[`boost::reg_expression`](template_class_ref.md#reg_expression) クラスはこのライブラリの中心となるクラスである。
+このクラスは「機械によって可読な」正規表現を表し、 `std::basic_string` の上で、厳密につくられている。
+それが文字列であり、さらに正規表現アルゴリズムが要求する実際のstate-machineでもあるからだ。
+`std::basic_string` と同様に、このクラスには2つのtypedefがあり、それらは、このクラスを示すために非常によく使われる。
+
+```cpp
+namespace boost{
+
+template &amp;lt;class charT,
+          class traits = regex_traits&amp;lt;charT&amp;gt;, 
+          class Allocator = std::allocator&amp;lt;charT&amp;gt; &amp;gt;
+class reg_expression;
+
+typedef reg_expression&amp;lt;char&amp;gt; regex;
+typedef reg_expression&amp;lt;wchar_t&amp;gt; wregex;
+
+}
+```
+
+このライブラリの使い方を見るために、クレジットカード処理を行うアプリケーションを開発していることにしよう。
+クレジットカードの番号は一般的に16桁の数字であり、4桁ずつのグループに分かれていて、スペースかハイフンで区切られている。
+クレジットカードの番号をデータベースに保存する前に(あなたの顧客が必ずしも理解している必要はないが)、その番号が正しい形式なのか確かめたいだろう。
+数字に一致させるには、`[0-9]` という正規表現を使うことが出来るが、このような文字範囲は実際は環境依存である。
+代わりにPOSIX標準形式 `[[:digit:]]` か、regex++とperlの略記 `\d` を使うべきである(多くの古いライブラリはCの環境に厳密にコードされていて、結果的にこれが古いライブラリでは使えないことに、注意が必要である。)
+これにより、クレジットカードの番号の形式を確かめるには次の正規表現を使うことが出来る。
+
+```cpp
+(\d{4}[- ]){3}\d{4}
+```
+
+ここでは丸括弧 `()` は子表現(sub-expressoins)のグループとして働く(そして、前方参照の印となる)。
+`{4}` は「4回繰り返す」ことを意味する。
+これは、perl,awk,egrepで使われる拡張正規表現構文の一例である。
+regex++も、sedやgrepで使われる古くて「基本的な」構文をサポートしているが、再利用する必要のある基本的な正規表現が既にあるのでない限り、一般的にあまり使えない。
+
+では、その表現を使って、クレジットカードの番号の形式を確かめるC++のコードをつくってみよう
+
+```cpp
+bool validate_card_format(const std::string s)
+{
+   static const boost::regex e(&amp;#34;(\\d{4}[- ]){3}\\d{4}&amp;#34;);
+   return regex_match(s, e);
+}
+```
+* boost::regex[link template_class_ref.md#reg_expression]
+* regex_match[link template_class_ref.md#query_match]
+
+表現に余計なエスケープを加えていることに注意すること。
+エスケープは、正規表現エンジンに通される前に、一度C++コンパイラを通されるので、正規表現でのエスケープはC/C++コードの中では2倍にされなければならないことを覚えておくこと。
+また、ここでの全ての例は、コンパイラがKoenig lookupをサポートしていることを仮定している。
+もし(例えばVC6のように)そうでなければ、例の中の関数呼び出しの幾つかには、`boost::` という接頭辞をつける必要がある。
+
+(※訳注) Koenig lookupとは引数に依存して関数を検索すること
+
+クレジットカードの処理をよく知っている者なら、上で使われた形式が、人間にとってカードの番号を読むのには適切であるが、オンラインのクレジットカードシステムが要求する形式を満たしていないことが解るだろう。
+システムはその番号が、16(或いは15かもしれない)桁で、余計なスペースがないことを要求する。
+我々に必要なのは、二つの形式を簡単に変換する手段である。
+そしてここで検索と置換が登場する。
+*sed* や *perl* といったユーティリティをよく知っている者なら、ここは読みとばしていいだろう。
+我々には2つの文字列が必要である。
+ひとつは正規表現、もう一つは &amp;#34;[書式文字列(format string)](format_string.md)&amp;#34; である。
+これは一致したものを置換するためのテキストの定義を与える。
+regex++ではこの検索と置換の操作は `regex_merge` というアルゴリズムで行われている。
+クレジットカードの例ではこれと同様の、フォーマット変換を提供する2つのアルゴリズムを書くことが出来る。
+
+```cpp
+// match any format with the regular expression:
+const boost::regex e(&amp;#34;\\A(\\d{3,4})[- ]?(\\d{4})[- ]?(\\d{4})[- ]?(\\d{4})\\z&amp;#34;);
+const std::string machine_format(&amp;#34;\\1\\2\\3\\4&amp;#34;);
+const std::string human_format(&amp;#34;\\1-\\2-\\3-\\4&amp;#34;);
+
+std::string machine_readable_card_number(const std::string s)
+{
+   return regex_merge(s, e, machine_format, boost::match_default | boost::format_sed);
+}
+
+std::string human_readable_card_number(const std::string s)
+{
+   return regex_merge(s, e, human_format, boost::match_default | boost::format_sed);
+}
+```
+* regex_merge[link template_class_ref.md#reg_merge]
+
+ここでは正規表現の中で、カード番号の4つの部分を異なるフィールドとして分けるために、印付き子表現(sub-expressions)が使われている。
+置換文字列はsedの様な構文を使い、一致したテキストを新しい形式で置換している。
+
+上の例では正規表現の一致の結果を直接操作することは出来ない。
+しかし一般的に一致の結果は、全体の一致に加え、多くの子表現の一致を含む。
+ライブラリが正規表現の一致の結果を必要な時は、 [`match_results`](template_class_ref.md#reg_match) クラスのインスタンスを利用することで得ることが出来る。
+前述のクラスと同様、多くの場合に使えるtypedefがある:
+
+```cpp
+namespace boost{
+typedef match_results&amp;lt;const char*&amp;gt; cmatch;
+typedef match_results&amp;lt;const wchar_t*&amp;gt; wcmatch;
+typedef match_results&amp;lt;std::string::const_iterator&amp;gt; smatch;
+typedef match_results&amp;lt;std::wstring::const_iterator&amp;gt; wsmatch; 
+}
+```
+
+[`regex_search`](template_class_ref.md#reg_search) と [`regex_grep`](template_class_ref.md#reg_grep) アルゴリズム(これは文字列中の全ての一致を発見する)は `match_results` を利用して、何が一致したのかを報告する。
+
+これらのアルゴリズムは正規のC-文字列の検索に制限されず、双方向イテレータであればどんなものでも検索が可能であり、ほとんどあらゆる種類のデータに対しても検索を可能にしていることに注意すること。
+
+検索と置換操作では、すでに見てきた [`regex_merge`](template_class_ref.md#reg_merge)アルゴリズムに加え、[`regex_format`](template_class_ref.md#reg_format) アルゴリズムは、一致の結果を得て、文字列をフォーマットし、二つを合わせることで新しい文字列を作り出す。
+
+テンプレートを嫌う人のために、ハイレベルのラッパクラス `RegEx` があり、ローレベルのテンプレートコードをカプセル化している。
+これは、ライブラリの全ての能力を必要としない人のために、シンプルなインタフェースを提供する。
+そして、narrow charactersと「拡張された」正規表現構文だけをサポートする。
+
+[POSIX API](posix_ref.md#posix) 関数: regcomp, regexec, regfree, regerrorはnarrow characterとUnicode両方で利用可能で、これらのAPIとの互換性が必要な人のために提供されている。
+
+最後に、ライブラリがランタイム [localization](appendix.md#localisation) をサポートしていること、そして、完全なPOSIX正規表現構文をサポートしていること(これはマルチキャラクタ照合要素、等価クラスのような先進的な特徴を含む)、同様に、GNUとBSD4正規表現パッケージ、そして限られてはいるがperl5、を含む他の正規表現ライブラリとの互換性を提供していることに注意すること。
+
+## &amp;lt;a id=&amp;#34;Installation&amp;#34;&amp;gt;Installation and Configuration Options&amp;lt;/a&amp;gt;
+
+*[* **重要**: *もしこのライブラリのversion2.xからアップグレードするなら、ドキュメント化されたヘッダの名前とライブラリのインタフェースに多くの変更がある。しかし既存のコードは変更なしにコンパイルするべきである。
+[Note for Upgraders](appendix.md#upgrade) を参考のこと。]*
+
+ライブラリをzipファイルから解凍したら、内部のディレクトリ構造を維持する必要がある(例えば-dオプションを使って解凍する)。
+そうしていなければ、これを読むのをやめて解凍したファイルを削除して、再び解凍作業を行うべきである。
+
+このライブラリは利用する前に設定することは必要ない。
+多くの一般的なコンパイラ、標準ライブラリ、プラットフォームはすでに「そのまま(as is)」でサポートされている。
+もし設定の問題を経験したなら、或いはあなたのコンパイラでの設定を試したいなら、その手続きはboostの全てのライブラリと同じである。
+*configuration library documentation* を参考のこと。
+
+ライブラリは `namespace boost` の中に全てのコードを入れている。
+
+他のいくつかのテンプレートライブラリとは異なり、このライブラリはテンプレートコード(ヘッダの中にある)と、スタティックなコードとデータ(cppファイルの中にある)の両方で構成されている。
+つまり使う前に、ライブラリのコードをライブラリファイルやアーカイブファイルにビルドすることが必要である。
+プラットフォーム特有の指示は以下の通りである:
+
+**Borland C++ Builder:**
+
+- コンソールを開き、カレントディレクトリを `&amp;lt;boost&amp;gt;\libs\regex\build` に変更する。 
+- 適切なmakefileを選択する。
+	(bcb4.mak for C++ Builder 4, bcb5.mak for C++ Builder 5, and bcb6.mak for C++ Builder 6)
+- makefileを呼び出す(もし二つ以上のヴァージョンがインストールされているなら、makeのフルパスを渡すこと。
+	makefileはmakeのパスによって、C++ Builderがインストールされたディレクトリとツールを得る。)
+	例えば
+
+```
+make -fbcb5.mak
+```
+
+ビルドプロセスは多くの.libと.dllファイルをビルドする(正確な数は利用したBorlandのツールのヴァージョンによる)。
+.libと.dllファイルはmakefileが使ったものに従いbcb4またはbcb5というサブディレクトリの中にある。
+ライブラリを開発システムにインストールするためには:
+
+```
+make -fbcb5.mak install
+```
+
+ライブラリファイルは `&amp;lt;BCROOT&amp;gt;/lib` にコピーされ、 .dllファイルは `&amp;lt;BCROOT&amp;gt;/bin` にコピーされる。
+`&amp;lt;BCROOT&amp;gt;` の場所はBorland C++のツールがインストールされている場所に対応する。
+
+次のようにすれば、ビルドプロセスの間に作られた一時的なファイル(.libと.dllファイルを除く)を削除することが出来る:
+
+```
+make -fbcb5.mak clean
+```
+
+最後に、regex++を使うときに唯一必要なことは `&amp;lt;boost&amp;gt;` ルートディレクトリをプロジェクトのインクルードディレクトリのリストに加えることである。
+.libファイルをプロジェクトに手動で加えることは必要ではない。
+ヘッダは自動的に、ビルドモードに適切な.libファイルを選択し、リンカにそれをインクルードするように伝える。
+しかしひとつ警告することがある: ライブラリは、コマンドラインからGUIアプリケーションをビルドする時に、ビルドを可能にするためのVCLと非VCLの違いを見分けられない。
+もし5.5コマンドラインツールでコマンドラインからビルドするなら、正しいリンクライブラリが選択されるように、プリプロセッサで `_NO_VCL` を定義しなければならない: C++ Builder IDEは通常これを自動的に設定する。
+5.5コマンドラインツールのユーザはこのオプションを恒久的にするために、`-D_NO_VCL` をbcc32.cfgに加えればいいだろう。
+
+もしdllランタイムを使うときでも、regexライブラリとスタティックリンクをしたいなら、`BOOST_REGEX_STATIC_LINK` を定義すればよい。
+もし一緒に、自動的なリンクを抑制したいなら(そして好きな.libを使いたいなら) `BOOST_REGEX_NO_LIB` を定義すればよい。
+
+もしC++ Builder 6でビルドするなら、`&amp;lt;boost/regex.hpp&amp;gt;` はプリコンパイルドヘッダの中で利用できない(実際の問題は `&amp;lt;locale&amp;gt;` の中にある。
+これは `&amp;lt;boost/regex.hpp&amp;gt;` の中でインクルードされている)。
+もしこれが問題なら、ビルドするときに `BOOST_NO_STD_LOCALE` を定義してみること。
+これはboostのいくらかのものを利用できなくするが、コンパイル時間を短縮する。
+
+**Microsoft Visual C++ 6 and 7**
+
+このライブラリをビルドするにはMSVCのバージョン6が必要である。
+VC5を使っているなら、この [ライブラリ](http://ourworld.compuserve.com/homepages/john_maddock/regexpp.htm) の以前のリリースのひとつを見た方がよい。
+
+コマンドプロンプトを開く。
+必要なMSVCの環境変数が定義されていなければならない(例えば、Visual Studioのインストールによって同時にインストールされたVcvars32.batファイルを利用できる。)
+そして `&amp;lt;boost&amp;gt;\libs\regex\build` ディレクトリに移動する。
+
+正しいmakefileを選択する。
+vc6.makは「オーソドックスな」Visual C++ 6 のためのものであり、STLPortを利用しているなら、vc6-stlport.makを選択すること。
+
+以下のようにmakefileを呼び出す。
+
+```
+nmake -fvc6.mak
+```
+
+「vc6」というサブディレクトリの中に、多くの.libと.dllファイルが出来ている。
+これらを開発環境にインストールするために:
+
+```
+nmake -fvc6.mak install
+```
+
+.libファイルは `&amp;lt;VC6&amp;gt;\lib` ディレクトリにコピーされ、.dllファイルは `&amp;lt;VC6&amp;gt;\bin` にコピーされる。
+`&amp;lt;VC6&amp;gt;` の場所は Visual C++ 6 のインストールのルートである。
+
+次のようにすれば、ビルドプロセスの間に作られた一時的なファイル(.libと.dllファイルを除く)を削除することが出来る:
+
+```
+nmake -fvc6.mak clean 
+```
+
+最後に、regex++を使うときに唯一必要なことは `&amp;lt;boost&amp;gt;` ルートディレクトリをプロジェクトのインクルードディレクトリのリストに加えることである。
+.libファイルをプロジェクトに手動で加えることは必要ではない。
+ヘッダは自動的に、ビルドモードに適切な.libファイルを選択し、リンカにそれをインクルードするように伝える。
+
+もしダイナミックC++ランタイムを使うときにregexライブラリにスタティックリンクしたいなら、プロジェクトをビルドするときに `BOOST_REGEX_STATIC_LINK` を定義すること(これはリリースビルドでのみ効果を持つ)。
+もしプロジェクトにソースコードを直接加えたいなら、`BOOST_REGEX_NO_LIB` を定義すれば、ライブラリの自動選択を抑止できる。
+
+**重要**: コンパイラ最適化のバグがこのライブラリに影響するという報告がいくつかある(とくにVC6のSP5以前で)。
+次善策は、/O2オプションでなく/Oityb1オプションを使ってライブラリをビルドすることである。
+これは/Oa以外の全ての最適化を行う。
+この問題はいくつかの標準ライブラリにも影響するという報告がある(実際、この問題がregexのコードとのものなのか、regexの中の標準ライブラリとのものなのか不明である)ので、この次善策をどんな場合にも行ってみることはおそらく価値がある。
+
+注記: もしVC6付属のC++標準ライブラリではないものを使っているなら、regex++ライブラリをビルドするときに `&amp;#34;INCLUDE&amp;#34;` と `&amp;#34;LIB&amp;#34;` の環境変数は、新しいライブラリのインクルードパスとライブラリパスを反映するように設定されなければならない。
+詳細はvcvars32.bat (Visual Studioについてくる)を参考のこと。
+あるいはSTLPortがc:/stlportにあるなら次のようにすればよい:
+
+```
+nmake INCLUDES=&amp;#34;-Ic:/stlport/stlport&amp;#34; XLFLAGS=&amp;#34;/LIBPATH:c:/stlport/lib&amp;#34;
+-fvc6-stlport.mak
+```
+
+もし、完全なSTLPortバージョン4.xでビルドするなら、vc6-stlport.makファイルを使えばSTLportをインストールした場所を示す環境変数 `STLPORT_PATH` が設定される(完全なSTLPortライブラリはシングルスレッド・スタティックビルドをサポートしていないことに注意すること)。
+
+**GCC(2.95)**
+
+g++コンパイラのための確実なmakefileがある。
+コマンドプロンプトから `&amp;lt;boost&amp;gt;/libs/regex/build` ディレクトリに移動し次のようにタイプせよ:
+
+```
+make -fgcc.mak 
+```
+
+ビルドプロセスの最後に、ライブラリのリリースバージョンとデバッグバージョンが入ったgccというサブディレクトリができる(`libboost_regex.a` と `libboost_regex_debug.a`)。
+regex++を使ったプロジェクトをビルドする時は、boostをインストールしたディレクトリをインクルードパスのリストに加え、`&amp;lt;boost&amp;gt;/libs/regex/build/gcc/libboost_regex.a` をライブラリファイルのリストに加える必要がある。
+
+共有ライブラリとしてライブラリをビルドするためのmakefileもある。
+
+```
+make -fgcc-shared.mak
+```
+
+これは `libboost_regex.so` と `libboost_regex_debug.so` を作る。
+
+これらのmakefileは両方とも以下の環境変数をサポートしている。
+
+- CXXFLAGS: 追加のコンパイルオプション - これらはデバッグビルドとリリースビルド両方で適用される。
+- INCLUDES: 追加のインクルードディレクトリ
+- LDFLAGS: 追加のリンカオプション
+- LIBS: 追加のライブラリファイル
+
+もっと冒険したければ、`&amp;lt;boost&amp;gt;/libs/config` にコンフィギュアスクリプトがある。
+*config library documentation* を参考にすること。
+
+**Sun Workshop 6.1**
+
+sun (6.1) コンパイラ (C++ version 3.12)用のmakefileがある。
+コマンドプロンプトから `&amp;lt;boost&amp;gt;/libs/regex/build` ディレクトリに移動して、次のようにすること:
+
+```
+dmake -f sunpro.mak
+```
+
+ビルドプロセスの最後にこのライブラリのシングルそしてマルチスレッドバージョンが入ったsunproサブディレクトリが出来ている(`libboost_regex.a`, `libboost_regex.so`, `libboost_regex_mt.a` そして `libboost_regex_mt.so`)。
+regex++を使うプロジェクトをビルドするときには、boostインストールディレクトリをインクルードパスのリストに、`&amp;lt;boost&amp;gt;/libs/regex/build/sunpro/` をライブラリ検索パスに加える必要がある。
+
+makefileは以下の環境変数をサポートしている。
+
+- CXXFLAGS: 追加のコンパイルオプション - これらはデバッグビルドとリリースビルド両方で適用される。
+- INCLUDES: 追加のインクルードディレクトリ
+- LDFLAGS: 追加のリンカオプション
+- LIBS: 追加のライブラリファイル
+- LIBSUFFIX: ライブラリのネームマングリングのための接尾辞(デフォルトでは何もつけない)
+
+このmakefileは-xarch=v9のような構造(architecture)特有のオプションを設定しないので、適切なマクロを定義してこれらを設定する必要がある。
+例えば:
+
+```
+dmake CXXFLAGS=&amp;#34;-xarch=v9&amp;#34; LDFLAGS=&amp;#34;-xarch=v9&amp;#34;
+LIBSUFFIX=&amp;#34;_v9&amp;#34; -f sunpro.mak
+```
+
+これは `libboost_regex_v9.a` 等と名付けられたregexライブラリのv9用のものをビルドする。
+
+**Other compilers:**
+
+汎用のmakefile([generic.mak](build/generic.mak))が `&amp;lt;boost-root&amp;gt;/libs/regex/build` にある。
+使う前に設定が必要な環境変数の詳細は、このmakefileを見よ。
+もしくは *Jam based build system* を使うことが出来る。
+もしプラットフォームのためにライブラリの構成が必要なら *config library documentation* を参考にすること。
+
+---
+
+*Copyright* [*Dr John Maddock*](mailto:John_Maddock@compuserve.com) *1998-2001 all rights reserved.*
+
+---
+
+*Japanese Translation Copyright (C) 2003 [Kohske Takahashi](mailto:k_takahashi@cppll.jp)*
+
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, POSIX API Reference -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/posix_ref.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/posix_ref.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/posix_ref.md b/archive/boost_docs/libs/regex/posix_ref.md
new file mode 100644
index 0000000..fff543b
--- /dev/null
+++ b/archive/boost_docs/libs/regex/posix_ref.md
@@ -0,0 +1,157 @@
+# Regex++, POSIX API Reference
+
+*Copyright (c) 1998-2001*
+
+*Dr John Maddock*
+
+*Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
+Dr John Maddock makes no representations about the suitability of this software for any purpose.
+It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
+
+---
+
+### &amp;lt;a name=&amp;#34;posix&amp;#34;&amp;gt;POSIX compatibility library&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/cregex.hpp&amp;gt;
+```
+
+*or*:
+
+```cpp
+#include &amp;lt;boost/regex.h&amp;gt;
+```
+
+次の関数は POSIX 互換 C ライブラリが必要なユーザにとって役立つ。
+これらは Unicode版 とナロウ文字版両方で利用可能である。
+POSIX 標準 API の名前は、 UNICODE が定義されているかによりどちらかの版を拡張したマクロである。
+
+**重要**: ここで定義されるシンボルは、`&amp;lt;boost/regex.h&amp;gt;` がインクルードされない限り、C++ プログラムで使われるときは全て、名前空間 *boost* の中にあることに注意せよ。
+`&amp;lt;boost/regex.h&amp;gt;` がインクルードされていても、シンボルは名前空間 `boost` の中で定義されているが、グローバル名前空間と同じように利用することが出来る。
+
+関数は次のように定義されている。
+
+```cpp
+extern &amp;#34;C&amp;#34; {
+int regcompA(regex_tA*, const char*, int);
+unsigned int regerrorA(int, const regex_tA*, char*, unsigned int);
+int regexecA(const regex_tA*, const char*, unsigned int, regmatch_t*, int);
+void regfreeA(regex_tA*);
+
+int regcompW(regex_tW*, const wchar_t*, int);
+unsigned int regerrorW(int, const regex_tW*, wchar_t*, unsigned int);
+int regexecW(const regex_tW*, const wchar_t*, unsigned int, regmatch_t*, int);
+void regfreeW(regex_tW*);
+
+#ifdef UNICODE
+#define regcomp regcompW
+#define regerror regerrorW
+#define regexec regexecW
+#define regfree regfreeW
+#define regex_t regex_tW
+#else
+#define regcomp regcompA
+#define regerror regerrorA
+#define regexec regexecA
+#define regfree regfreeA
+#define regex_t regex_tA
+#endif
+}
+```
+
+全ての関数は構造体 `regex_t` に対して作用する。
+構造体 `regex_t` は二つの公開メンバを持っている。
+
+`unsigned int re_nsub` これは `regcomp` によって書き込まれ、正規表現に含まれる子表現の数を表している。
+
+`const TCHAR* re_endp` はフラグ `REG_PEND` が設定されているとき、コンパイルする正規表現の末端を指す。
+
+*脚注: `regex_t` は実際はマクロ定義である。
+これは `UNICODE` が定義されているかどうかに依存して、 `regex_tA` か `regex_tW` を定義している。
+`TCHAR` は マクロ `UNICODE` に依存した、`char` か `wchar_t` の再定義である。*
+
+`regcomp` は `regex_t` へのポインタを受け取る。
+このポインタはコンパイルする正規表現と、組み合わせることの出来るフラグパラメータを指す。
+
+- `REG_EXTENDED`
+	- モダンな正規表現をコンパイルする。
+		`regbase::char_classes | regbase::intervals | regbase::bk_refs` と等価である。
+- `REG_BASIC`
+	- 基本的な(時代遅れの)正規表現構文をコンパイルする。
+		`regbase::char_classes | regbase::intervals | regbase::limited_ops | regbase::bk_braces | regbase::bk_parens | regbase::bk_refs` と等価である。
+- `REG_NOSPEC`
+	- 全ての文字は通常の文字であり、正規表現はリテラル文字列である。
+- `REG_ICASE`
+	- 大文字小文字の区別なく一致するためのコンパイル
+- `REG_NOSUB`
+	- このライブラリでは何の作用もない。
+- `REG_NEWLINE`
+	- このフラグが設定されているとき、ドット文字は改行文字に一致しない。
+- `REG_PEND`
+	- このフラグが設定されているとき、 `regex_t` 構造体の `re_endp` パラメータは翻訳する正規表現の終端を指していなければならない。
+- `REG_NOCOLLATE`
+	- このフラグが設定されているとき、ロケールに依存した文字範囲の照合は行われない。
+- `REG_ESCAPE_IN_LISTS`
+	`, , , `
+	- このフラグが設定されているとき、大括弧表現(文字集合)のなかでエスケープシーケンスが許される。
+- `REG_NEWLINE_ALT`
+	- このフラグが設定されているとき、改行文字は排他演算子 `|` と等価である。
+- `REG_PERL`
+	- perl のような振る舞いの略記:
+		`REG_EXTENDED | REG_NOCOLLATE | REG_ESCAPE_IN_LISTS`
+- `REG_AWK`
+	- awk のような振る舞いの略記: `REG_EXTENDED | REG_ESCAPE_IN_LISTS`
+- `REG_GREP`
+	- grep のような振る舞いの略記: `REG_BASIC | REG_NEWLINE_ALT`
+- `REG_EGREP`
+	- egrep のような振る舞いの略記: `REG_EXTENDED | REG_NEWLINE_ALT`
+
+
+`regerror` は次のパラメータを受け取る。
+これはエラーコードを人間に可読な文字列に変換する。
+
+| int code                | エラーコード                       |
+|-------------------------|------------------------------------|
+| `const regex_t* e`      | 正規表現( null でもよい)           |
+| `char* buf`             | エラーメッセージを書き込むバッファ |
+| `unsigned int buf_size` | バッファサイズ                     |
+
+もし、エラーコードが `REG_ITOA` を含む(訳注: `code &amp;amp; REG_ITOA` が真)なら、その結果のメッセージは、メッセージというよりは、例えば `REG_BADPAT` のような印字可能なコード名である。
+コードが `REG_ATIO` なら `e` は `null` であってはならない。
+そして `e-&amp;gt;re_pend` は印字可能なエラーコードを指していなければならない。
+その時の戻り値は、エラーコードの値である。
+`code` がそれ以外ならどんな値の時にも、戻り値はエラーメッセージの文字数である。
+戻り値が `buf_size` と同じか、それより大きければ、 `regerror` はより大きなバッファでもう一度呼ばれなければならない。
+
+`regexec` は文字列 `buf` の中の最初の正規表現 `e` を発見する。
+もし `len` が非0なら、 `*m` には何が正規表現に一致したかを書き込まれる。
+`m[0]` は文字列全体と一致したものを持ち、 `m[1]` は最初の子表現であり、以下同様である。
+より詳細は、ヘッダファイルでの `regmatch_t` の宣言を見よ。
+`eflags` パラメータは次の値の組み合わせである:
+
+- `REG_NOTBOL`
+	- パラメータ `buf` は行のはじめを表さない。
+- `REG_NOTEOL`
+	- パラメータ `buf` は行の終端で終わらない。
+- `REG_STARTEND`
+	- 検索される文字列は、 `buf + pmatch[0].rm_so` で始まり、 `buf + pmatch[0].rm_eo` で終わる。
+
+最後に `regfree` は `regcomp` によって割り当てられた全てのメモリを解放する。
+
+*脚注: これは POSIX API 関数の簡略したリファレンスであり、(もし C++ 以外の言語からアクセスする必要がなければ)新しいコードでこれらの API を使うためというよりは他のライブラリとの互換性を提供する。
+これらの関数のこのバージョンは、幸いなことに他のバージョンと共存できる。
+使われる名前は、実際の関数名を拡張したマクロだからだ。*
+
+
+---
+
+*Copyright* [*Dr John Maddock*](mailto:John_Maddock@compuserve.com) *1998-2001 all rights reserved.*
+
+---
+
+*Japanese Translation Copyright (C) 2003 [Kohske Takahashi](mailto:k_takahashi@cppll.jp)*
+
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Regular Expression Syntax -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/syntax.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/syntax.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Regex++, Regular Expression Syntax&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;em&gt;Copyright (c) 1998-2001&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
Dr John Maddock makes no representations about the suitability of this software for any purpose.
It is provided &#34;as is&#34; without express or implied warranty.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;a name=&#34;syntax&#34;&gt;Regular expression syntax&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;この章では、このライブラリで使われる正規表現文法について述べる。
これは、プログラマーズガイドであって、プログラムの中でユーザに与えられる実際の文法は正規表現の翻訳の間に使われるフラグに依存する。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Literals&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以下のものを除く全ての文字はリテラルである: &#34;.&#34;, &#34;|&#34;, &#34;*&#34;, &#34;?&#34;, &#34;+&#34;, &#34;(&#34;, &#34;)&#34;, &#34;{&#34;, &#34;}&#34;, &#34;[&#34;, &#34;]&#34;, &#34;\^&#34;, &#34;\$&#34;, &#34;\&#34; 。
これらの文字列は、&#34;\&#34; に続いたときはリテラルである。
リテラルはそれ自身にマッチするか、または、 &lt;code&gt;traits_type::translate()&lt;/code&gt; の結果にマッチする文字である。
&lt;code&gt;traits_type&lt;/code&gt; は &lt;code&gt;reg_expression&lt;/code&gt; クラスの特性テンプレートパラメータである。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ワイルドカード&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ドット文字 &#34;.&#34; はあらゆる1文字にマッチする。
例外: &lt;code&gt;match_not_dot_null&lt;/code&gt; がマッチアルゴリズムに渡されたときは、ドットはヌル文字にはマッチしない。
&lt;code&gt;match_not_dot_newline&lt;/code&gt; がマッチアルゴリズムに渡されたときは、ドットは改行文字にはマッチしない。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;繰り返し&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;繰り返しは任意の回数繰り返される正規表現である。
&#34;*&#34; が続く正規表現はゼロを含む何回の繰り返しも可能である。
&#34;+&#34; が続く正規表現は1回以上の何回の繰り返しも可能である。
もし正規表現が &lt;code&gt;regbase::bk_plus_qm&lt;/code&gt; フラグ付きで翻訳されるなら、 &#34;+&#34; は通常の文字であり、 &#34;\+&#34; が1回以上の繰り返しを表す。
&#34;?&#34; が続く正規表現は0回か1回の繰り返しである。
もし正規表現が &lt;code&gt;regbase::bk_plus_qm&lt;/code&gt; フラグ付きで翻訳されるなら、 &#34;?&#34; は通常の文字であり、 &#34;\?&#34; が0回か1回の繰り返しを示す。
繰り返しの最小回数と最大回数を明示する必要があるなら、範囲指定子 &#34;{}&#34; が使われる。
&#34;a{2}&#34; は、ちょうど2回だけ繰り返される文字 &#34;a&#34; である。
&#34;a{2,4}&#34; は2回以上4回以下繰り返される文字 &#34;a&#34; であり、 &#34;a{2,}&#34; は2回以上上限なく繰り返される文字 &#34;a&#34; である。
{}の中に空白があってはいけないこと、最小回数と最大回数の指定に上限がないことに注意せよ。
正規表現が &lt;code&gt;regbase::bk_braces&lt;/code&gt; フラグ付で翻訳されるとき、 &#34;{&#34; と &#34;}&#34; は通常の文字であり、代わりに &#34;\{&#34; と &#34;\}&#34; が範囲指定に使われる。
全ての繰り返し表現は、可能な限り短く、前方の子表現を参照する。
例えば、1文字、文字集合、 &#34;()&#34; で囲まれた子表現を参照する。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;&#34;ba*&#34; は &#34;b&#34;, &#34;ba&#34;, &#34;baaa&#34; などの全てにマッチする。&lt;/p&gt;
&lt;p&gt;&#34;ba+&#34; は &#34;ba&#34; や &#34;baaaa&#34; にマッチするが、 例えば &#34;b&#34; にはマッチしない。&lt;/p&gt;
&lt;p&gt;&#34;ba?&#34; は &#34;b&#34; と &#34;ba&#34; にマッチする。&lt;/p&gt;
&lt;p&gt;&#34;ba{2,4}&#34; は &#34;baa&#34; と  &#34;baaa&#34; と &#34;baaaa&#34; にマッチする。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;貪欲でない繰り返し&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;「拡張」正規表現構文が(デフォルトで)使われるときはいつでも、繰り返しのあとに &#39;?&#39; を付け足すことで、貪欲でない繰り返しが可能である。
貪欲でない繰り返しとは、 可能な限り &lt;em&gt;もっとも短い&lt;/em&gt; 文字列にマッチするものである。&lt;/p&gt;
&lt;p&gt;例えば、一組の html タグのマッチには次のようにすることができる:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;\s*tagname[^&amp;gt;]*&amp;gt;(.*?)&amp;lt;\s*/tagname\s*&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;この場合、 &lt;code&gt;\$1&lt;/code&gt; はタグに挟まれたテキストを保持する。
これが、可能な限り最も短い文字列である。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;丸括弧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;丸括弧はふたつの目的で使われる。
一つは子表現をまとめることであり、もう一つはマッチを生成したものを印付けることである。
例えば、正規表現 &#34;(ab)*&#34; は文字列 &#34;ababab&#34; の全てにマッチする。
マッチアルゴリズム &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#query_match&#34;&gt;regex_match&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_search&#34;&gt;regex_search&lt;/a&gt;&lt;/code&gt; はそれぞれ、何がマッチを引き起こしたかを報告する、 &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_match&#34;&gt;match_results&lt;/a&gt;&lt;/code&gt; のインスタンスを得る。
これらの関数から抜けるとき、 &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_match&#34;&gt;match_results&lt;/a&gt;&lt;/code&gt; 正規表現全体が何とマッチしたか、そしてそれぞれの子表現が何とマッチしたかについての情報を保持している。
上の例では、 &lt;code&gt;match_results[1]&lt;/code&gt; はマッチした文字列の最後の &#34;ab&#34; を示す一組のイテレータを保持している。
子表現がヌル文字列にマッチすることも許されている。
もし子表現がどの部分ともマッチしなければ、例えばそれが、マッチしなかった選択肢の一部なら、その子表現に対して返される両方のイテレータは、入力文字列の終端を指していて、 その子表現に対する &lt;code&gt;matched&lt;/code&gt; パラメータは &lt;code&gt;false&lt;/code&gt; である。
子表現は1で始まり左から右に数えられる。
子表現 0 は正規表現全体である。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;印付けをしない丸括弧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;丸括弧で子表現をグループ化したいが、丸括弧に子表現の印を作って欲しくないようなときは、印付けをしない丸括弧 (?:expression) を使うことができる。
例えば、 次の正規表現は子表現を作らない: (訳注: 子表現を作らないいうよりは、子表現に印付けをしないということ)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&#34;(?:abc)*&#34;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;前方先読み宣言&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;これにはふたつの形式がある。
一つは肯定的前方先読み宣言であり、もう一つは否定的前方先読み宣言である:&lt;/p&gt;
&lt;p&gt;&#34;(?=abc)&#34; はゼロ文字列に正規表現 &#34;abc&#34; が続くときのみ、そのゼロ文字列にマッチする。&lt;/p&gt;
&lt;p&gt;&#34;(?!abc)&#34; はゼロ文字列に正規表現 &#34;abc&#34; 続かないときのみ、そのゼロ文字列にマッチする。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;選択&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;選択は、正規表現がある子表現か、別の子表現のいずれかにマッチするときに起こる。
それぞれの選択肢は &#34;|&#34; か、 &lt;code&gt;regbase::bk_vbar&lt;/code&gt; フラグが設定されているなら &#34;\|&#34; または &lt;code&gt;regbase::newline_alt&lt;/code&gt; フラグが設定されていれば改行文字によって区切られる。
それぞれの選択肢は先行する可能な限り大きな子表現である。
これは繰り返し演算子とは逆の動作である。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;&#34;a(b|c)&#34; は &#34;ab&#34; または &#34;ac&#34; にマッチする。&lt;/p&gt;
&lt;p&gt;&#34;abc|def&#34; は &#34;abc&#34; または &#34;def&#34; にマッチする。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;集合&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;集合は、集合の要素であるあらゆる1文字とマッチすることができる文字集合である。
文字集合は &#34;[&#34; と &#34;]&#34; で囲まれていて、リテラル、文字範囲、文字クラス、照合要素、等価クラスを含むことができる。
&#34;\^&#34; で始まる文字集合の宣言は、それに続く要素以外を含む。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;文字リテラル:&lt;/p&gt;
&lt;p&gt;&#34;[abc]&#34; は &#34;a&#34; , &#34;b&#34; , &#34;c&#34; のいずれかとマッチする。&lt;/p&gt;
&lt;p&gt;&#34;[\^abc]&#34; は &#34;a&#34;, &#34;b&#34;, or &#34;c&#34; 以外のあらゆる文字にマッチする。&lt;/p&gt;
&lt;p&gt;文字範囲:&lt;/p&gt;
&lt;p&gt;&#34;[a-z]&#34; は &#34;a&#34; から &#34;z&#34; の範囲にあるあらゆる文字にマッチする。 &lt;/p&gt;
&lt;p&gt;&#34;[\^A-Z]&#34; は &#34;A&#34; から &#34;Z&#34; の範囲にある文字以外の、あらゆる文字にマッチする。&lt;/p&gt;
&lt;p&gt;文字範囲は、ロケールに強く依存することに注意せよ: これは、その範囲の両端の間に並んでいる、あらゆる文字にマッチする。
デフォルトの &#34;C&#34; ロケールが有効なときは、文字範囲は ASCII に基づいて振舞うだけである。
しかし、例えばライブラリが、 Win32 ロケールモデルでコンパイルされていれば、 &#34;[a-z]&#34; は ASCII 文字 a-z 、そして &#39;A&#39;、&#39;B&#39;などにもマッチするが、 &#39;z&#39;のすぐあとに並んでいる &#39;Z&#39;にはマッチしない。
このロケール特有の振る舞いは翻訳するときに &lt;code&gt;regbase::nocollate&lt;/code&gt; フラグを設定することで、不可能にすることができる。
これは &lt;code&gt;regbase::normal&lt;/code&gt; を使ったときのデフォルトの振る舞いであり、文字範囲が ASCII 文字コードに基づいて並んでいることを強制する。
同様に、もし POSIX C API 関数をつかうなら、 &lt;code&gt;REG_NOCOLLATE&lt;/code&gt; を設定することでロケールに依存する並びを無効にすることができる。&lt;/p&gt;
&lt;p&gt;文字クラスは、文字集合の中で、構文 &#34;[:classname:]&#34; を使うことで表現される。
例えば、 &#34;[[:space:]]&#34; は全ての空白文字の集合である。
文字クラスは &lt;code&gt;regbase::char_classes&lt;/code&gt; フラグが設定されているときのみ利用できる。
利用できる文字クラスは:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alnum&lt;ul&gt;
&lt;li&gt;全ての数字とアルファベット&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;alpha&lt;ul&gt;
&lt;li&gt;a-z と A-Z の全てのアルファベット。
    ロケールによっては他の文字も含まれるかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;blank&lt;ul&gt;
&lt;li&gt;スペースかタブの、あらゆる空白文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cntrl&lt;ul&gt;
&lt;li&gt;全ての制御文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;digit&lt;ul&gt;
&lt;li&gt;0-9 の全ての数字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;graph&lt;ul&gt;
&lt;li&gt;空白以外の印刷可能文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lower&lt;ul&gt;
&lt;li&gt;a-z の全ての小文字。
    ロケールによっては他の文字も含まれるかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;print&lt;ul&gt;
&lt;li&gt;全ての印刷可能な文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;punct&lt;ul&gt;
&lt;li&gt;全ての句読点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;space&lt;ul&gt;
&lt;li&gt;全ての空白文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;upper&lt;ul&gt;
&lt;li&gt;A-Z の全ての大文字。
    ロケールによっては他の文字も含まれるかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;xdigit&lt;ul&gt;
&lt;li&gt;全ての16進文字。
    0-9, a-f, A-F。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;word&lt;ul&gt;
&lt;li&gt;全ての単語形成文字。
    つまり、全てのアルファベットとアンダースコア。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;unicode&lt;ul&gt;
&lt;li&gt;文字コードが 255 より大きい全ての文字。
    これはワイド文字特性クラスだけに適用される。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文字クラスの代わりに使うことができる略記がいくつかある。
これらは &lt;code&gt;regbase::escape_in_lists&lt;/code&gt; フラグが設定されていときに使うことができる。&lt;/p&gt;
&lt;p&gt;\w in place of [:word:]&lt;/p&gt;
&lt;p&gt;\s in place of [:space:]&lt;/p&gt;
&lt;p&gt;\d in place of [:digit:]&lt;/p&gt;
&lt;p&gt;\l in place of [:lower:]&lt;/p&gt;
&lt;p&gt;\u in place of [:upper:] &lt;/p&gt;
&lt;p&gt;照合要素は文字集合宣言の中での [.tagname.] という一般的な形式をとる。
&lt;em&gt;tagname&lt;/em&gt; は一文字か、照合要素の名前である。
たとえば、 [[.a.]] は [a] と等価であり、 [[.comma.]] は [,] と等価である。
ライブラリは全ての標準 POSIX の照合要素名に加えて、以下の連字サポートしている: &#34;ae&#34;, &#34;ch&#34;, &#34;ll&#34;, &#34;ss&#34;, &#34;nj&#34;, &#34;dz&#34;, &#34;lj&#34;, それぞれ小文字、大文字、タイトルケース版がある。
マルチ文字照合要素は結局、一文字より多くにマッチする集合である。
例えば、 [[.ae.]] は2文字にマッチするが、 [\^[.ae.]] は一文字にしかマッチしないことに注意せよ。&lt;/p&gt;
&lt;p&gt;等価クラスは文字集合宣言の中で [=tagname=] という一般的な形式をとる。
&lt;em&gt;tagname&lt;/em&gt; は一文字か、照合要素の名前である。
これは、照合要素 [.tagname.] と同じ第一等価クラスの要素である、あらゆる文字とマッチする。
等価クラスは照合順序が同じ文字集合である。
第一等価クラスは、第一のソートキーがすべて同じである文字集合である(例えば文字列は典型的に文字によって並べられ、続いてアクセント、そして大文字/小文字によって並べられる。
この時、第一のソートキーは文字に関係し、第二のそれはアクセントに、第三のそれは大文字/小文字である)。
もし &lt;em&gt;tagname&lt;/em&gt; に対応する等価クラスがなければ、[=tagname=] は実際には [.tagname.] と同じである。
不幸にも、Win32 環境を除いては、文字に対する第一のソートキーをロケールに依存しないで得る方法はない。
他のOSでは、ライブラリは (&lt;code&gt;strxfrm&lt;/code&gt; から得た)全部のソートキーから、第一のソートキーを「推測する」ので、等価クラスはおそらく、 Win32 以外の OS では最も不確実だと考えられる。&lt;/p&gt;
&lt;p&gt;文字集合の中にリテラル &#34;-&#34; を含むためには、それを 開き括弧 &#34;[&#34; 、 &#34;[\^&#34; 、範囲指定の端、または照合要素に続く最初の文字にしなければならない。
&lt;code&gt;regbase::escape_in_lists&lt;/code&gt; フラグが設定されているなら、 &#34;[\-]&#34; のようにエスケープ文字に続けてもよい。
リテラル &#34;[&#34; 、 &#34;]&#34; と &#34;\^&#34; を文字集合に含めるには、範囲指定の端、照合要素、またはもし &lt;code&gt;regbase::escape_in_lists&lt;/code&gt; フラグが設定されているなら、エスケープ文字に続けてもよい。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ラインアンカ&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;アンカは 行頭及び行末で null 文字に一致するものである: &#34;\^&#34; は行頭の null 文字に一致し、 &#34;\$&#34; は行末の null 文字に一致する。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;後方参照&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;後方参照は、既に一致した、先行する子表現への参照である。
これは、一致した子表現に対する参照であり、表現そのものに対する参照ではない。
後方参照はエスケープ文字 &#34;\&#34; に数字 &#34;1&#34; から &#34;9&#34; を続けることで出来る。
&#34;\1&#34; は最初の子表現に、 &#34;\2&#34; は2番目の正規表現に、といった具合である。
例えば正規表現 &#34;(.*)\1&#34; は中間点について繰り返されるあらゆる文字列に一致する(訳注:文字列の前半と後半が同じであるということ)。
例えば、 &#34;abcabc&#34; や &#34;xyzxyz&#34; である。
どんな一致も起こらない子表現への後方参照は、 null 文字列に一致する: これが他のいくつかの正規表現の一致とは異なることに注意せよ。
後方参照は正規表現がフラグ &lt;code&gt;regbase::bk_refs&lt;/code&gt; を設定されてコンパイルされた時のみ利用できる。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;コードによる文字&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;これは他のライブラリでは利用できないアルゴリズムへの拡張である。
コードはエスケープ文字と、それに続く数字 &#34;0&#34; と、更にそれに、8進数の文字コードを続けることで成り立つ。
例えば、 &#34;\023&#34; はその8進文字コードが 23 である文字をあらわす。
曖昧になるような場合、正規表現を区切るのに丸括弧を利用すること: &#34;\0103&#34; は文字コードが 103 の文字をあらわし、 &#34;(\010)3&#34; は文字コードが 10 の文字と、それに続く &#34;3&#34; をあらわす。
16進コードで文字を一致させるには、 \x に 16 進の文字列を続ける。
この文字列は {} の中に閉じ込めることも可能である。
例えば、 \xf0 や \x{aff} など。
後者はユニコード文字である。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;単語演算子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次の演算子は GNU 正規表現ライブラリとの互換性のために提供されている。&lt;/p&gt;
&lt;p&gt;&#34;\w&#34; は &#34;word&#34; 文字クラスの要素であるあらゆる1文字に一致する。
これは表現 &#34;[[:word:]]&#34; と同じである。&lt;/p&gt;
&lt;p&gt;&#34;\W&#34; は &#34;word&#34; 文字クラスの要素ではないあらゆる1文字に一致する。
これは表現 &#34;[\^[:word:]]&#34; と同じである。&lt;/p&gt;
&lt;p&gt;&#34;\&amp;lt;&#34; は単語の先頭の null 文字列に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\&amp;gt;&#34; は単語の終端の null 文字列に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\b&#34; は単語の先頭及び終端の null 文字列に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\B&#34; は単語の中の null 文字列に一致する。&lt;/p&gt;
&lt;p&gt;一致判定アルゴリズムに渡されるシーケンスの先頭は、フラグ &lt;code&gt;match_not_bow&lt;/code&gt; が設定されていない限り、単語の先頭の可能性があると考えられる。
一致判定アルゴリズムに渡されるシーケンスの終端は、フラグ &lt;code&gt;match_not_eow&lt;/code&gt; が設定されていない限り、単語の終端の可能性があると考えられる。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;バッファ演算子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次の演算子は GNU 正規表現ライブラリ、及び Perl 正規表現との互換性のために提供されている:&lt;/p&gt;
&lt;p&gt;&#34;\`&#34; はバッファの先頭に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\A&#34; はバッファの先頭に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\&#39;&#34; はバッファの終端に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\z&#34; はバッファの終端に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\Z&#34; はバッファの終端に一致する。
または可能であれば、バッファの終端が続く1つ以上の改行文字に一致する。&lt;/p&gt;
&lt;p&gt;フラグ &lt;code&gt;match_not_bob&lt;/code&gt; 及び &lt;code&gt;match_not_eob&lt;/code&gt; が設定されていない限り、バッファは一致判定アルゴリズムに渡されるシーケンス全体で出来ていると考えられる。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;エスケープ演算子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;エスケープ文字 &#34;\&#34; は多くの一致を持つ。&lt;/p&gt;
&lt;p&gt;集合宣言の中ではエスケープ文字は、フラグ &lt;code&gt;regbase::escape_in_lists&lt;/code&gt; が設定されていない限り通常の文字である。
この場合、エスケープに続くどんな文字も、その通常の意味に関わらずリテラル文字である。&lt;/p&gt;
&lt;p&gt;エスケープ演算子は例えば、後方参照や単語演算子などの演算子を導入する。&lt;/p&gt;
&lt;p&gt;エスケープ演算子は、それに続く文字を通常の文字にすることもある。
例えば、&#34;\*&#34; は繰り返し演算子ではなく、リテラル &#34;*&#34; をあらわす。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;単一文字エスケープシーケンス&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次のエスケープシーケンスは単一文字の略記である:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;エスケープシーケンス&lt;/th&gt;
&lt;th&gt;文字コード&lt;/th&gt;
&lt;th&gt;意味&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\a&lt;/td&gt;
&lt;td&gt;0x07&lt;/td&gt;
&lt;td&gt;ベル文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;0x0C&lt;/td&gt;
&lt;td&gt;フォームフィード(FF)文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;0x0A&lt;/td&gt;
&lt;td&gt;改行文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;0x0D&lt;/td&gt;
&lt;td&gt;復帰(キャリッジリターン)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;0x09&lt;/td&gt;
&lt;td&gt;タブ文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;0x0B&lt;/td&gt;
&lt;td&gt;垂直タブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\e&lt;/td&gt;
&lt;td&gt;0x1B&lt;/td&gt;
&lt;td&gt;ASCII エスケープ文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\0dd&lt;/td&gt;
&lt;td&gt;0dd&lt;/td&gt;
&lt;td&gt;8進文字コード。 &lt;em&gt;dd&lt;/em&gt; は1文字以上の8進文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\xXX&lt;/td&gt;
&lt;td&gt;0xXX&lt;/td&gt;
&lt;td&gt;16進文字コード。 XX は1文字以上の16進文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\x{XX}&lt;/td&gt;
&lt;td&gt;0xXX&lt;/td&gt;
&lt;td&gt;16進文字コード。 XX は1文字以上の16進文字。 ユニコード文字でもよい。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\cZ&lt;/td&gt;
&lt;td&gt;z-@&lt;/td&gt;
&lt;td&gt;ASCII エスケープシーケンス control-Z。 Z は &#39;@&#39; の文字コードに等しいか、それより大きければどんな ASCII 文字でもよい。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;様々なエスケープシーケンス&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次のものの多くは perl との互換性のために提供されている。
しかし、 \l \L \u \U の意味はいくらか異なることに注意せよ。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;[[:word:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;[\^[:word:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;[[:space:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;[\^[:space:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;[[:digit:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;[\^[:digit:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\l&lt;/td&gt;
&lt;td&gt;[[:lower:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\L&lt;/td&gt;
&lt;td&gt;[\^[:lower:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\u&lt;/td&gt;
&lt;td&gt;[[:upper:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\U&lt;/td&gt;
&lt;td&gt;[\^[:upper:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\C&lt;/td&gt;
&lt;td&gt;あらゆる1文字。 &#39;.&#39; と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\X&lt;/td&gt;
&lt;td&gt;あらゆるユニコード複合文字シーケンスに一致する。 例えば、 &#34;a\x 0301&#34; (鋭アクセントをもつ文字)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\Q&lt;/td&gt;
&lt;td&gt;引用符開始演算子。 これに続く全ては 引用符終了演算子 \E が発見されるまでリテラル文字として扱われる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\E&lt;/td&gt;
&lt;td&gt;引用符終了演算子。 \Q で始まったシーケンスを終了させる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;何が一致するのか?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;正規表現ライブラリは、可能な限り最初の一致文字列と一致する。
もし与えられた場所で始まる一つ以上の文字列が一致可能なら、フラグ &lt;code&gt;match_any&lt;/code&gt; が設定されていない限り、可能な限り長い文字列に一致する。
そして出会った最初の一致が返される。
&lt;code&gt;match_any&lt;/code&gt; フラグを設定することで、一致を発見するのにかかる時間を削減することが出来る。
しかしこれは、ユーザが何が一致するかに関心がないときのみ役に立つ。
例えば、検索と置換の操作には適していない。
同じ場所で始まる複数の可能な一致があるような場合、そしてそれら全てが同じ長さである場合、選ばれる一致は最も長い最初の子表現を持つものである。
ふたつ目以上の一致でもそれが同じなら、2番目の子表現が試され、3番目・・・と続いていく。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Copyright&lt;/em&gt; &lt;a href=&#34;mailto:John_Maddock@compuserve.com&#34;&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/a&gt; &lt;em&gt;1998-2001 all rights reserved.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:k_takahashi@cppll.jp&#34;&gt;Kohske Takahashi&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++ template class reference. -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/template_class_ref.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/template_class_ref.md b/archive/boost_docs/libs/regex/template_class_ref.md
new file mode 100644
index 0000000..1b8d70e
--- /dev/null
+++ b/archive/boost_docs/libs/regex/template_class_ref.md
@@ -0,0 +1,1598 @@
+# Regex++ template class reference.
+
+*Copyright (c) 1998-2001*
+
+*Dr John Maddock*
+
+*Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
+Dr John Maddock makes no representations about the suitability of this software for any purpose.
+It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
+
+---
+
+## &amp;lt;a name=&amp;#34;regbase&amp;#34;&amp;gt;class regbase&amp;lt;/a&amp;gt;
+
+```cpp
+#include boost/regex.hpp&amp;gt;
+```
+
+`regbase` クラスは `reg_expression` のためのテンプレート引数に依存しない基底クラスである。
+唯一の公開メンバは 列挙型の値 `flag_type` であり、これは正規表現がどのように解釈されるかを決定する
+
+```cpp
+class regbase
+{
+public:
+   enum flag_type_
+   {
+      escape_in_lists = 1,                          // &amp;#39;\\&amp;#39; special inside [...] 
+      char_classes = escape_in_lists &amp;lt;&amp;lt; 1,          // [[:CLASS:]] allowed 
+      intervals = char_classes &amp;lt;&amp;lt; 1,                // {x,y} allowed 
+      limited_ops = intervals &amp;lt;&amp;lt; 1,                 // all of + ? and | are normal characters 
+      newline_alt = limited_ops &amp;lt;&amp;lt; 1,               // \n is the same as | 
+      bk_plus_qm = newline_alt &amp;lt;&amp;lt; 1,                // uses \+ and \? 
+      bk_braces = bk_plus_qm &amp;lt;&amp;lt; 1,                  // uses \{ and \} 
+      bk_parens = bk_braces &amp;lt;&amp;lt; 1,                   // uses \( and \) 
+      bk_refs = bk_parens &amp;lt;&amp;lt; 1,                     // \d allowed 
+      bk_vbar = bk_refs &amp;lt;&amp;lt; 1,                       // uses \| 
+      use_except = bk_vbar &amp;lt;&amp;lt; 1,                    // exception on error 
+      failbit = use_except &amp;lt;&amp;lt; 1,                    // error flag 
+      literal = failbit &amp;lt;&amp;lt; 1,                       // all characters are literals 
+      icase = literal &amp;lt;&amp;lt; 1,                         // characters are matched regardless of case 
+      nocollate = icase &amp;lt;&amp;lt; 1,                       // don&amp;#39;t use locale specific collation 
+
+      basic = char_classes | intervals | limited_ops | bk_braces | bk_parens | bk_refs,
+      extended = char_classes | intervals | bk_refs,
+      normal = escape_in_lists | char_classes | intervals | bk_refs | nocollate,
+      emacs = bk_braces | bk_parens | bk_refs | bk_vbar,
+      awk = extended | escape_in_lists,
+      grep = basic | newline_alt,
+      egrep = extended | newline_alt,
+      sed = basic,
+      perl = normal
+   }; 
+   `typedef` `unsigned` `int` flag_type;
+};
+```
+
+列挙型 `regbase::flag_type` は正規表現のコンパイルのための構文規則を決定する。
+それぞれのフラグは以下のような作用を持つ: 
+
+- `regbase::escape_in_lists`
+	- 文字集合の中で &amp;#34;\&amp;#34; を使うことを認める。
+		文字集合の中の文字、例えば [\]] は &amp;#34;]&amp;#34; のみを含む文字集合を表している。
+		もしこのフラグが設定されていなければ、&amp;#34;\&amp;#34; は文字集合の中では通常の文字として扱われる。
+- `regbase::char_classes`
+	- このビットが設定されているとき、文字クラス [:クラス名:] を文字集合宣言の中 で使うことを認める。
+		例えば [[:word:]] は文字クラス &amp;#34;word&amp;#34;に属する全ての文字の集合を表している。
+- `regbase::intervals`
+	- このビットが設定されているとき、
+		繰り返し回数の範囲指定を使うことを認める。
+		例えば &amp;#34;a{2,4}&amp;#34; は文字 a が2回以上4回以下繰り返されることを表している。
+- `regbase::limited_ops`
+	- このビットが設定されているとき、&amp;#34;+&amp;#34;、 &amp;#34;?&amp;#34; そして &amp;#34;|&amp;#34; はあらゆる状況で通常の文字として扱われる。
+- `regbase::newline_alt`
+	- このビットが設定されているとき、改行文字 &amp;#34;\n&amp;#34; は排他演算子 &amp;#34;|&amp;#34;と同じ作用を持つ。
+- `regbase::bk_plus_qm`
+	- このビットが設定されているとき、&amp;#34;\+&amp;#34; は1回以上の繰り返しを表す。
+		そして &amp;#34;\?&amp;#34; は0回か1回の繰り返しを表す。
+		このビットが設定されていないときは、代わりに &amp;#34;+&amp;#34; と &amp;#34;?&amp;#34; が使われる。
+- `regbase::bk_braces`
+	- このビットが設定されているとき、 &amp;#34;\{&amp;#34; と &amp;#34;\}&amp;#34; が繰り返しの回数指定に使われ、 &amp;#34;{&amp;#34; と &amp;#34;}&amp;#34; は通常の文字として扱われる。
+		これはデフォルトとは反対の動作である。
+- `regbase::bk_parens`
+	- このビットが設定されているとき、 &amp;#34;\(&amp;#34; と &amp;#34;\)&amp;#34; が子表現のグループ化に使われ、 &amp;#34;(&amp;#34; と &amp;#34;)&amp;#34; は通常の文字として扱われる。
+		これはデフォルトとは反対の動作である。
+- `regbase::bk_refs`
+	- このビットが設定されているとき、後方参照が許される。
+- `regbase::bk_vbar`
+	- このビットが設定されているとき、 &amp;#34;\|&amp;#34; が排他演算子を表し、 &amp;#34;|&amp;#34; は通常の文字として扱われる。
+		これはデフォルトとは反対の動作である。
+- `regbase::use_except`
+	- このビットが設定されているとき、 [`bad_expression`](#bad_expression) 例外がエラー時に発生する。
+		このフラグを使うことは賛成されない。
+		なぜなら `reg_expression` はエラーの際、常に例外を発生させるだろう。
+- `regbase::failbit`
+	- もし `regbase::use_except` が設定されていなければ、エラー時にこのビットが設定される。
+		使う前に、正規表現が妥当かどうかを見るためにこのビットをチェックすべきである。
+- `regbase::literal`
+	- 文字列中の全ての文字はリテラルとして扱われる。
+		特殊文字や、エスケープシーケンスは存在しない。
+- `regbase::icase`
+	- 文字列中の全ての文字は、大文字/小文字の区別なく一致する。
+- `regbase::nocollate`
+	- 文字集合宣言の中で、文字範囲を扱うときに、ロケールに特殊な一致は不可能になる。
+		例えば、このビットが設定されているとき、 [a-c] という表現は a, b そして c という文字にロケールにかかわらず一致する。
+		このビットが設定されていなければ、 [a-c] は a から c の並びにあるどんな文字にも一致する。
+- `regbase::basic`
+	- POSIX の基本正規表現構文との互換性をもつ:
+		つまり、`char_classes | intervals | limited_ops | bk_braces | bk_parens | bk_refs` のビットを設定する。
+- `Regbase::extended`
+	- POSIX の拡張正規表現構文との互換性をもつ:
+		つまり、 `char_classes | intervals | bk_refs` のビットを設定する。
+- `regbase::normal`
+	- これはデフォルトの設定である。
+		そして多くの人が、ライブラリがこのように動作することを期待している。
+		POSIX 拡張構文との互換性をもつが、ロケールに特殊な一致ない。
+		そして文字集合宣言の中でのエスケープ文字を使うことが出来る。
+		これは `regbase::escape_in_lists | regbase::char_classes | regbase::intervals | regbase::bk_refs | regbase::nocollate` のビットを設定する。
+- `regbase::emacs`
+	- emacs エディタとの互換性を与える。
+		`bk_braces | bk_parens | bk_refs | bk_vbar` と等価である。
+- `regbase::awk`
+	- Unix のユーティリティ Awk との互換性を与える。
+		POSIX 拡張正規表現と同じだが、文字集合の中にエスケープを許す。
+		`extended | escape_in_lists` と等価である。
+- `regbase::grep`
+	- Unix の grep ユーティリティとの互換性を与える。
+		POSIX 基本正規表現と同じだが、改行文字と排他演算子は等価である。
+		つまり、 `basic | newline_alt` と同じである。
+- `regbase::egrep`
+	- Unix の egrep ユーティリティとの互換性を与える。
+		POSIX 拡張正規表現と同じだが、改行文字と排他演算子は等価である。
+		つまり、 `extended | newline_alt` と同じである。
+- `regbase::sed`
+	- Unix の sed ユーティリティとの互換性を与える。
+		POSIX 基本正規表現と同じである。
+- `regbase::perl`
+	- プログラミング言語 perl との互換性を与える。
+		`regbase::normal` と同じである。
+
+---
+
+## &amp;lt;a name=&amp;#34;bad_expression&amp;#34;&amp;gt;Exception classes.&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/pat_except.hpp&amp;gt;
+```
+
+誤った正規表現が現れたときにいつでも、`bad_expression` のインスタンスが投げられる。
+
+```cpp
+namespace boost{
+
+class bad_pattern : public std::runtime_error
+{
+public:
+   explicit bad_pattern(const std::string&amp;amp; s) : std::runtime_error(s){};
+};
+
+class bad_expression : public bad_pattern
+{
+public:
+   bad_expression(const std::string&amp;amp; s) : bad_pattern(s) {}
+};
+
+
+} // namespace boost
+```
+
+補足: `bad_pattern` クラスは全てのパターンマッチングでの例外の基底クラスであり、 `bad_expression` はそのひとつである。
+`bad_pattern` の基底クラスとして `std::runtime_error ` を選択していることには議論の余地がある。
+ライブラリがどう使われるかよるが、例外は論理的エラー(プログラマが与えた正規表現)か、実行時エラー(ユーザが与えた正規表現)のいずれかだろう。
+
+---
+
+## &amp;lt;a name=&amp;#34;reg_expression&amp;#34;&amp;gt;Class `reg_expression`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex.hpp&amp;gt;
+```
+
+テンプレートクラス `reg_expression` は正規表現の解釈とコンパイルをカプセル化している。
+このクラスは [`regbase`](#regbase) を継承していて、3つのテンプレートパラメータを持つ。
+パラメータは:
+
+- `charT`:
+	- 文字型を決定する。
+		つまり、 `char` か `wchar_t` のどちらかである。
+- `traits`:
+	- 文字型の振る舞いを決定する。
+		例えば、大文字小文字を考慮して照合するか、文字クラス名を認識するか、などである。
+		デフォルトの `traits` クラスが与えられている: [`regex_traits&amp;lt;charT&amp;gt;`](#regex_char_traits) 。
+- `Allocator`:
+	- allocator クラスは、メモリ割り当てに使われるクラスである。
+
+簡単に使えるように、2つの標準的な `reg_expression` のインスタンスを定義した、2つの typedef がある。
+カスタムのアロケータクラスを使いたいのでなければ、これら以外のものを使う必要はないだろう。
+
+```cpp
+namespace boost{
+template &amp;lt;class charT, class traits = regex_traits&amp;lt;charT&amp;gt;, class Allocator = std::allocator&amp;lt;charT&amp;gt; &amp;gt;
+class reg_expression;
+typedef reg_expression&amp;lt;char&amp;gt; regex;
+typedef reg_expression&amp;lt;wchar_t&amp;gt; wregex;
+}
+```
+
+`reg_expression` の定義は次の通りである: 
+この定義は `basic_string` クラスに厳密に基づいていて、`charT` のコンテナとしての要求を満たしている。
+
+```cpp
+namespace boost{
+template &amp;lt;class charT, class traits = regex_traits&amp;lt;charT&amp;gt;, class Allocator = std::allocator&amp;lt;charT&amp;gt; &amp;gt;
+class reg_expression : public regbase
+{
+public: 
+   // typedefs:
+   typedef charT char_type; 
+   typedef traits traits_type; 
+   // locale_type 
+   // placeholder for actual locale type used by the 
+   // traits class to localise *this. 
+   typedef typename traits::locale_type locale_type; 
+   // value_type 
+   typedef charT value_type; 
+   // reference, const_reference 
+   typedef charT&amp;amp; reference; 
+   typedef const charT&amp;amp; const_reference; 
+   // iterator, const_iterator 
+   typedef const charT* const_iterator; 
+   typedef const_iterator iterator; 
+   // difference_type 
+   typedef typename Allocator::difference_type difference_type; 
+   // size_type 
+   typedef typename Allocator::size_type size_type; 
+   // allocator_type 
+   typedef Allocator allocator_type; 
+   typedef Allocator alloc_type; 
+   // flag_type 
+   typedef boost::int_fast32_t flag_type; 
+public: 
+   // constructors 
+   explicit reg_expression(const Allocator&amp;amp; a = Allocator()); 
+   explicit reg_expression(const charT* p, flag_type f = regbase::normal, const Allocator&amp;amp; a = Allocator()); 
+   reg_expression(const charT* p1, const charT* p2, flag_type f = regbase::normal, const Allocator&amp;amp; a = Allocator()); 
+   reg_expression(const charT* p, size_type len, flag_type f, const Allocator&amp;amp; a = Allocator()); 
+   reg_expression(const reg_expression&amp;amp;); 
+   template &amp;lt;class ST, class SA&amp;gt; 
+   explicit reg_expression(const std::basic_string&amp;lt;charT, ST, SA&amp;gt;&amp;amp; p, flag_type f = regbase::normal, const Allocator&amp;amp; a = Allocator()); 
+   template &amp;lt;class I&amp;gt; 
+   reg_expression(I first, I last, flag_type f = regbase::normal, const Allocator&amp;amp; a = Allocator()); 
+   ~reg_expression(); 
+   reg_expression&amp;amp; operator=(const reg_expression&amp;amp;); 
+   reg_expression&amp;amp; operator=(const charT* ptr); 
+   template &amp;lt;class ST, class SA&amp;gt; 
+   reg_expression&amp;amp; operator=(const std::basic_string&amp;lt;charT, ST, SA&amp;gt;&amp;amp; p); 
+   // 
+   // assign: 
+   reg_expression&amp;amp; assign(const reg_expression&amp;amp; that); 
+   reg_expression&amp;amp; assign(const charT* ptr, flag_type f = regbase::normal); 
+   reg_expression&amp;amp; assign(const charT* first, const charT* last, flag_type f = regbase::normal); 
+   template &amp;lt;class string_traits, class A&amp;gt; 
+   reg_expression&amp;amp; assign( 
+       const std::basic_string&amp;lt;charT, string_traits, A&amp;gt;&amp;amp; s, 
+       flag_type f = regbase::normal); 
+   template &amp;lt;class iterator&amp;gt; 
+   reg_expression&amp;amp; assign(iterator first, 
+                          iterator last, 
+                          flag_type f = regbase::normal); 
+   // 
+   // allocator access: 
+   Allocator get_allocator()const; 
+   // 
+   // locale: 
+   locale_type imbue(locale_type l); 
+   locale_type getloc()const; 
+   // 
+   // flags: 
+   flag_type getflags()const; 
+   // 
+   // str: 
+   std::basic_string&amp;lt;charT&amp;gt; str()const; 
+   // 
+   // begin, end: 
+   const_iterator begin()const; 
+   const_iterator end()const; 
+   // 
+   // swap: 
+   void swap(reg_expression&amp;amp;)throw(); 
+   // 
+   // size: 
+   size_type size()const; 
+   // 
+   // max_size: 
+   size_type max_size()const; 
+   // 
+   // empty: 
+   bool empty()const; 
+   unsigned mark_count()const; 
+   bool operator==(const reg_expression&amp;amp;)const; 
+   bool operator&amp;lt;(const reg_expression&amp;amp;)const; 
+};
+} // namespace boost 
+```
+
+`reg_expression` クラスは次のような公開メンバ関数を持っている:
+
+- `reg_expression(Allocator a = Allocator());`
+	- 何の表現ももっていない、`reg_expression` のデフォルトのインスタンスを構築する。
+- `reg_expression(charT* p, unsigned f = regbase::normal, Allocator a = Allocator());`
+	- 正規表現構文を決定するためのフラグ `f` を使って、ヌル終端文字列 `p` で表された表現から `reg_expression` のインスタンスを構築する。
+		利用可能なフラグの値に関しては[regbase](#regbase) を見よ。
+- `reg_expression(charT* p1, charT* p2, unsigned f = regbase::normal, Allocator a = Allocator());`
+	- 正規表現構文を決定するためのフラグ `f` を使って、入力イテレータ `p1` と `p2` で表された表現から `reg_expression` のインスタンスを構築する。
+		利用可能なフラグの値に関しては[regbase](#regbase) を見よ。
+- `reg_expression(charT* p, size_type len, unsigned f, Allocator a = Allocator());`
+	- 正規表現構文を決定するためのフラグ `f` を使って、長さ `len` の文字列 `p` によって表された表現から `reg_expression` のインスタンスを構築する。
+		利用可能なフラグの値に関しては [`regbase`](#regbase) を見よ。
+- `template &amp;lt;class ST, class SA&amp;gt; reg_expression(const std::basic_string&amp;lt;charT, ST, SA&amp;gt;&amp;amp; p, boost::int_fast32_t f = regbase::normal, const Allocator&amp;amp; a = Allocator());`
+	- 正規表現構文を決定するためのフラグ f を使って、文字列 p によって表された表現から `reg_expression` のインスタンスを構築する。
+		利用可能なフラグの値に関しては [`regbase`](#regbase) を見よ。
+		注意 - このメンバはコンパイラによっては利用できないかもしれない。
+- `template &amp;lt;class I&amp;gt; reg_expression(I first, I last, flag_type f = regbase::normal, const Allocator&amp;amp; a = Allocator());`
+	- 正規表現構文を決定するためのフラグ `f` を使って、入力イテレータ `p1` と `p2` で表された表現から `reg_expression` のインスタンスを構築する。
+		利用可能なフラグの値に関しては [`regbase`](#regbase) を見よ。
+- `reg_expression(const reg_expression&amp;amp;);`
+	- コピーコンストラクタ。
+		存在する正規表現をコピーする。
+- `reg_expression&amp;amp; operator=(const reg_expression&amp;amp;);`
+	- 存在する正規表現をコピーする。
+- `reg_expression&amp;amp; operator=(const charT* ptr);`
+	- assign(ptr) と等価。
+- `template &amp;lt;class ST, class SA&amp;gt; reg_expression&amp;amp; operator=(const std::basic_string&amp;lt;charT, ST, SA&amp;gt;&amp;amp; p);`
+	- assign(p) と等価。
+- `reg_expression&amp;amp; assign(const reg_expression&amp;amp; that);`
+	- `that` が持っている正規表現をコピーする。
+		もし `that` が有効な正規表現を持っていなければ、 [`bad_expression`](#bad_expression) が発生する。
+		`this` ポインタを返す。
+- `reg_expression&amp;amp; assign(const charT* p, flag_type f = regbase::normal);`
+	- 正規表現構文を決定するためのフラグ `f` を使って、ヌル終端文字列 `p` で表された表現から正規表現をコンパイルする。
+		利用可能なフラグの値に関しては [`regbase`](#regbase) を見よ。
+		もし `p` が有効な正規表現を持っていなければ [`bad_expression`](#bad_expression) が発生する。
+		`this` ポインタを返す。
+- `reg_expression&amp;amp; assign(const charT* first, const charT* last, flag_type f = regbase::normal);`
+	- 正規表現構文を決定するためのフラグ `f` を使って、入力イテレータ `first-last` で表された表現から正規表現をコンパイルする。
+		利用可能なフラグの値に関しては [`regbase`](#regbase) を見よ。
+		もし `p` が有効な正規表現を持っていなければ [`bad_expression`](#bad_expression) が発生する。
+		`this` ポインタを返す。
+- `template &amp;lt;class string_traits, class A&amp;gt; reg_expression&amp;amp; assign(const std::basic_string&amp;lt;charT, string_traits, A&amp;gt;&amp;amp; s, flag_type f = regbase::normal);`
+	- 正規表現構文を決定するためのフラグ `f` を使って、文字列 `s` で表された表現から正規表現をコンパイルする。
+		利用可能なフラグの値に関しては [`regbase`](#regbase) を見よ。
+		もし `p` が有効な正規表現を持っていなければ [`bad_expression`](#bad_expression) が発生する。
+		`this` ポインタを返す。
+- `template &amp;lt;class iterator&amp;gt;  reg_expression&amp;amp; assign(iterator first, iterator last, flag_type f = regbase::normal);`
+	- 正規表現構文を決定するためのフラグ `f` を使って、入力イテレータ `first-last` で表された表現から正規表現をコンパイルする。
+		利用可能なフラグの値に関しては [`regbase`](#regbase) を見よ。
+		もし `p` が有効な正規表現を持っていなければ [`bad_expression`](#bad_expression) が発生する。
+		`this` ポインタを返す。
+- `Allocator get_allocator()const;`
+	- 正規表現で使われるアロケータを返す。
+- `locale_type imbue(const locale_type&amp;amp; l);`
+	- 正規表現を特定のロケールに変更し、現在の表現を無効にする。
+		もし呼び出しの結果、実在しないメッセージカタログが開かれようとしたら、 `std::runtime_error` が発生するだろう。
+- `locale_type getloc()const;`
+	- 表現で使われているロケールを返す。
+- `flag_type getflags()const;`
+	- 現在の表現をコンパイルするのに使われているフラグを返す。
+- `std::basic_string&amp;lt;charT&amp;gt; str()const;`
+	- 現在の表現を文字列として返す。
+- `const_iterator begin()const;`
+	- 現在の表現の最初の文字へのポインタを返す。
+- `const_iterator end()const;`
+	- 現在の表現の最後の文字へのポインタを返す。
+- `size_type size()const;`
+	- 現在の表現の長さを返す。
+- `size_type max_size()const;`
+	- 正規表現文字列の最大長を返す。
+- `bool empty()const;`
+	- オブジェクトが有効な表現を持っていなければ `true` を返す。
+- `unsigned mark_count()const;`
+	- コンパイルされた正規表現の中の子表現の数を返す。
+		これは全体の一致(子表現がゼロ)も含み、常に1以上を返すことに注意せよ。
+
+---
+
+## &amp;lt;a name=&amp;#34;regex_char_traits&amp;#34;&amp;gt;Class `regex_traits`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex/regex_traits.hpp&amp;gt;
+```
+
+*これは正規表現特性クラスの予備的なバージョンであり、変更を必要とする。*
+
+特性クラスの目的は、 `reg_expression` クラスと、それに関連するマッチングアルゴリズムの振る舞いのカスタマイズをより簡単にすることである。
+カスタム特性クラスは特殊文字セットを扱うことが出来て、追加の文字クラスを定義する。
+例えば、全ての(ユニコード)漢字文字として [[:kanji:]] を定義することが出来る。
+このライブラリは3つの特性クラスと、使われているデフォルトのロケールモデルに依存してこの3つのうちのひとつを継承するラッパクラス `regex_traits` を提供している。
+`c_regex_traits` クラスは C のグローバルロケールをカプセル化している。
+`w32_regex_traits` クラスは Win32 グローバルロケールをカプセル化している(Win32 システム上だけで利用できる)。
+`cpp_regex_traits` は C++ のロケールをカプセル化している( `std::locale` がサポートされているときのみ提供される):
+
+```cpp
+template &amp;lt;class charT&amp;gt; class c_regex_traits;
+template&amp;lt;&amp;gt; class c_regex_traits&amp;lt;char&amp;gt; { /*details*/ };
+template&amp;lt;&amp;gt; class c_regex_traits&amp;lt;wchar_t&amp;gt; { /*details*/ };
+
+template &amp;lt;class charT&amp;gt; class w32_regex_traits;
+template&amp;lt;&amp;gt; class w32_regex_traits&amp;lt;char&amp;gt; { /*details*/ };
+template&amp;lt;&amp;gt; class w32_regex_traits&amp;lt;wchar_t&amp;gt; { /*details*/ };
+
+template &amp;lt;class charT&amp;gt; class cpp_regex_traits;
+template&amp;lt;&amp;gt; class cpp_regex_traits&amp;lt;char&amp;gt; { /*details*/ };
+template&amp;lt;&amp;gt; class cpp_regex_traits&amp;lt;wchar_t&amp;gt; { /*details*/ };
+
+template &amp;lt;class charT&amp;gt; class regex_traits : public base_type { /*detailts*/ };
+```
+
+`base_type` は Win32 システム上では、デフォルトで `w32_regex_traits` である。
+そうでなければ、 `c_regex_traits` がデフォルトである。
+デフォルトの振る舞いは `BOOST_REGEX_USE_C_LOCALE` (`c_regex_traits` をデフォルトで使うように強制する)、または `BOOST_REGEX_USE_CPP_LOCALE` (`cpp_regex_traits` をデフォルトで使うように強制する) を定義することによって変更できる。
+もう一つの選択肢として、特定の特性クラスを `reg_expression` テンプレートに渡すことも出来る。
+
+カスタムの制約クラスのための要求は [ここに記されている](traits_class_ref.md)。
+
+また、カスタムの制約クラスの例が [Christian Engstr](mailto:christian.engstrom@glindra.org) によって提供されている。
+*iso8859_1_regex_traits.cpp* 及び *iso8859_1_regex_traits.hpp* を見よ。
+より詳細は *readme file* を見よ。
+
+---
+
+## &amp;lt;a name=&amp;#34;reg_match&amp;#34;&amp;gt;Class `match_results`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex.hpp&amp;gt;
+```
+
+正規表現は、多くの単純なパターンマッチングのアルゴリズムとはことなる。
+なぜなら全体での一致を発見し、子表現の一致を作ることも出来るからである: 
+それぞれの子表現は、パターンの中で、丸括弧 (...) の組により区切られている。
+子表現の一致をユーザに報告するための方法もある:
+これは、 子表現の一致の集合の索引としての機能をもつ `match_results` クラスにより実現されている。
+それぞれの子表現の一致は `sub_match` 型のオブジェクトの中に格納されている。
+
+```cpp
+// 
+// class sub_match: 
+// denotes one sub-expression match. 
+//
+template &amp;lt;class iterator&amp;gt;
+struct sub_match
+{
+   typedef typename std::iterator_traits&amp;lt;iterator&amp;gt;::value_type       value_type;
+   typedef typename std::iterator_traits&amp;lt;iterator&amp;gt;::difference_type  difference_type;
+   typedef iterator                                                  iterator_type;
+
+   iterator first;
+   iterator second;
+   bool matched;
+
+   operator std::basic_string&amp;lt;value_type&amp;gt;()const;
+
+   bool operator==(const sub_match&amp;amp; that)const;
+   bool operator !=(const sub_match&amp;amp; that)const;
+   difference_type length()const;
+};
+
+// 
+// class match_results: 
+// contains an indexed collection of matched sub-expressions. 
+// 
+template &amp;lt;class iterator, class Allocator = std::allocator&amp;lt;typename std::iterator_traits&amp;lt;iterator&amp;gt;::value_type &amp;gt; &amp;gt; 
+class match_results 
+{ 
+public: 
+   typedef Allocator                                                 alloc_type; 
+   typedef typename Allocator::template Rebind&amp;lt;iterator&amp;gt;::size_type  size_type; 
+   typedef typename std::iterator_traits&amp;lt;iterator&amp;gt;::value_type       char_type; 
+   typedef sub_match&amp;lt;iterator&amp;gt;                                       value_type; 
+   typedef typename std::iterator_traits&amp;lt;iterator&amp;gt;::difference_type  difference_type; 
+   typedef iterator                                                  iterator_type; 
+   explicit match_results(const Allocator&amp;amp; a = Allocator()); 
+   match_results(const match_results&amp;amp; m); 
+   match_results&amp;amp; operator=(const match_results&amp;amp; m); 
+   ~match_results(); 
+   size_type size()const; 
+   const sub_match&amp;lt;iterator&amp;gt;&amp;amp; operator[](int n) const; 
+   Allocator allocator()const; 
+   difference_type length(int sub = 0)const; 
+   difference_type position(unsigned int sub = 0)const; 
+   unsigned int line()const; 
+   iterator line_start()const; 
+   std::basic_string&amp;lt;char_type&amp;gt; str(int sub = 0)const; 
+   void swap(match_results&amp;amp; that); 
+   bool operator==(const match_results&amp;amp; that)const; 
+   bool operator&amp;lt;(const match_results&amp;amp; that)const; 
+};
+typedef match_results&amp;lt;const char*&amp;gt; cmatch;
+typedef match_results&amp;lt;const wchar_t*&amp;gt; wcmatch; 
+typedef match_results&amp;lt;std::string::const_iterator&amp;gt; smatch;
+typedef match_results&amp;lt;std::wstring::const_iterator&amp;gt; wsmatch; 
+```
+
+`match_results` クラスは正規表現に一致したものを報告するのに使われる。
+これはマッチングアルゴリズム [`regex_match`](#query_match) と [`regex_search`](#reg_search) を渡されて、 [`regex_grep`](#reg_grep) によってコールバック関数(または関数オブジェクト) にに何が一致したのかを知らせる。
+一致判定の為に選ばれるデフォルトのアロケータパラメータは、 `reg_expresion` のデフォルトのアロケータパラメータであることに注意せよ。
+`match_results` には次の公開メンバ関数がある: 
+
+- `match_results(Allocator a = Allocator());`
+	- アロケータのインスタンス a を使って、 `match_results` のインスタンスを構築する。
+- `match_results(const match_results&amp;amp; m);`
+	- コピーコンストラクタ
+- `match_results&amp;amp; operator=(const match_results&amp;amp; m);`
+	- 代入演算子。
+- `const sub_match&amp;lt;iterator&amp;gt;&amp;amp; operator[](size_type n) const;`
+	- 一致したものを返す。
+		`n` が 0 なら文字列全体を、 `n` が 1 なら最初の子表現を表している。
+		(訳注: 以下、その数字に対応する子表現を表している)
+- `Allocator&amp;amp; allocator()const;`
+	- このクラスで使われているアロケータを返す。
+- `difference_type length(unsigned int sub = 0);`
+	- 一致した子表現の長さを返す。
+		デフォルトでは全体の一致の長さを返す。
+		要するにこれは、`operator [](sub).second - operator[](sub).first` と等価である。
+- `difference_type position(unsigned int sub = 0);`
+	- 一致した子表現の位置を返す。
+		デフォルトでは全体の一致の位置を返す。
+		戻り値は、文字列の先頭からの相対的な一致の位置である。
+- `unsigned int line()const;`
+	- 一致が起こった行番号を返す。
+		行番号の先頭は 0 でなく 1 である。
+		`operator[](0)` より前の改行文字の数に 1 を加えたものと等価である。
+- `iterator line_start()const;`
+	- 一致が起こった行の先頭を示すイテレータを返す。
+- `size_type size()const;`
+	- 一致の中に、子表現 0 (全体の一致) も含めて、いくつの子表現が存在するかを返す。
+		もし検索の操作で一致が見つからなかったとき、これは重要である。
+		一致が起こったかどうか決定するのに、 [`regex_search`](#reg_search) / [`regex_match`](#query_match) からの戻り値を使わなければならない。
+
+メンバ関数 `operator[]` は更に説明が必要である。
+これは `sub_match&amp;lt;iterator&amp;gt;` 型の構造体への const の参照を返す。
+`sub_match&amp;lt;iterator&amp;gt;` は次の公開メンバを持っている:
+
+- `typedef typename std::iterator_traits&amp;lt;iterator&amp;gt;::value_type value_type;`
+	- イテレータによって指されている型。
+- `typedef typename std::iterator_traits&amp;lt;iterator&amp;gt;::difference_type difference_type;`
+	- 二つのイテレータの違いを表す型。
+- `typedef iterator iterator_type;`
+	- イテレータの型。
+- `iterator first`
+	- 一致の先頭の位置を示すイテレータ。
+- `iterator second`
+	- 一致の終端の位置を示すイテレータ。
+- `bool matched`
+	- この子表現が一致したものの中にあるかを示す bool 値。
+- `difference_type length()const;`
+	- 子表現の一致の長さを返す。
+- `operator std::basic_string&amp;lt;value_type&amp;gt; ()const;`
+	- 子表現の一致を `std::basic_string&amp;lt;&amp;gt;` のインスタンスに変換する。
+		このメンバは存在しないか、コンパイラに依存して、より限られて存在するかのどちらかだろう、ということに注意せよ。
+
+`operator []` は情報を返す子表現を表す引数として整数値を取る。
+引数は次のような特殊な値を取りうる:
+
+- `-2`
+	- 一致の終端から、入力された文字列の終端までの全てを返す。
+		これは perl での `$&amp;#39;` と等価である。
+		もしこれが null 文字列なら: `first == second ` かつ `matched == false` である。
+- `-1`
+	- 入力された文字列の先頭から(または、もし grep の操作であれば最後の一致の終端から)この一致の先頭までの全てを返す。
+		perl での `$\`` と等価である。
+		もしこれが null 文字列なら: `first == second ` かつ `matched == false.` である。
+- `0`
+	- 一致したもの全体を返す。
+		perl での `$&amp;amp;` と等価である。
+		パラメータ `matched` は常に `true` である。
+- `0 &amp;lt; N &amp;lt; size()`
+	- 子表現 N に一致したものを返す。
+		もしこの子表現が何も一致していなかったら、 `matched == false ` そうでなければ `matched == true` である。
+- `N &amp;lt; -2 or N &amp;gt;= size()`
+	- 範囲外の存在しない子表現を表している。
+		「空の」一致を返す。
+		つまり、 `first == last ` かつ `matched == false.` である。
+
+アロケータのパラメータと同様に、 `match_results&amp;lt;&amp;gt;` もまたイテレータ型をもち、これはどんなイテレータの組み合わせも、それが双方向イテレータであるなら、与えられた正規表現で検索することが出来る、ということに注意せよ。
+
+---
+
+## &amp;lt;a name=&amp;#34;query_match&amp;#34;&amp;gt;Algorithm `regex_match`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex.hpp&amp;gt;
+```
+
+アルゴリズム `regex_match` は与えられた正規表現が、一組の双方向イテレータによって表されるシーケンスに一致するかを決定する。
+このアルゴリズムは以下のように定義されている。
+*入力シーケンス全体と一致したときのみ結果が `true` であることに注意せよ。*
+この関数の主要な使い道は、入力データの検証である:
+
+```cpp
+template &amp;lt;class iterator, class Allocator, class charT, class traits, class Allocator2&amp;gt;
+bool regex_match(iterator first, 
+                 iterator last, 
+                 match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m, 
+                 const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                 unsigned flags = match_default);
+```
+
+ライブラリは次の簡易版も定義している。
+これは `const charT*` 型か、或いは `const std::basic_string&amp;lt;&amp;gt;&amp;amp;` 型を一組のイテレータの代わりにとる。
+(コンパイラによってはこれらの簡易版は利用できないかもしれないこと、或いは限られた形でしか利用できないかもしれないことに注意せよ):
+
+```cpp
+template &amp;lt;class charT, class Allocator, class traits, class Allocator2&amp;gt;
+bool regex_match(const charT* str, 
+                 match_results&amp;lt;const charT*, Allocator&amp;gt;&amp;amp; m, 
+                 const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                 unsigned flags = match_default)
+
+template &amp;lt;class ST, class SA, class Allocator, class charT, class traits, class Allocator2&amp;gt;
+bool regex_match(const std::basic_string&amp;lt;charT, ST, SA&amp;gt;&amp;amp; s, 
+                 match_results&amp;lt;typename std::basic_string&amp;lt;charT, ST, SA&amp;gt;::const_iterator, Allocator&amp;gt;&amp;amp; m, 
+                 const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                 unsigned flags = match_default);
+```
+
+最後に、ただ true か false を返すだけで、何が一致したかに関与しない簡易版がある。
+
+```cpp
+template &amp;lt;class iterator, class Allocator, class charT, class traits, class Allocator2&amp;gt;
+bool regex_match(iterator first, 
+                 iterator last, 
+                 const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                 unsigned flags = match_default);
+
+template &amp;lt;class charT, class Allocator, class traits, class Allocator2&amp;gt;
+bool regex_match(const charT* str, 
+                 const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                 unsigned flags = match_default)
+
+template &amp;lt;class ST, class SA, class Allocator, class charT, class traits, class Allocator2&amp;gt;
+bool regex_match(const std::basic_string&amp;lt;charT, ST, SA&amp;gt;&amp;amp; s, 
+                 const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                 unsigned flags = match_default);
+```
+
+主要版(訳注:簡易版ではない定義)の関数のパラメータは次の通りである。
+
+- `iterator first`
+	- 一致させる範囲の先頭を示す。
+- `iterator last`
+	- 一致させる範囲の終端を示す。
+- `match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m`
+	- 何が一致したかを報告するための `match_results` のインスタンス。
+		関数を抜けるときに、もし一致が起こっていたら `m[0]` は一致した文字列の全体を表す。
+		`m[0].first` は `first` と等しく、 `m[0].second` は `last` より少ないか、等しい。
+		`m[1]` は最初の子表現、 `m[2]` は2番目の子表現を示し、以下それが続く。
+		もし一致が起こらなければ、 `m[0].first = m[0].second = last` である。
+	- `match_results` 構造体はイテレータのみを保持し、文字列を保持していないので、 `regex_match` に渡されるイテレータと文字列は、その結果が使われる限り有効でなければならないことに注意せよ。
+		このため、決して一時的文字列オブジェクトを `regex_match` に渡してはならない。
+- `const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e`
+	- 一致判定につかう正規表現を持つ。
+- `unsigned flags = match_default`
+	- 一致に使われるセマンティクスを決定する。
+		ひとつ以上の [`match_flags`](#match_type) 列挙子の組み合わせである。
+
+`regex_match` は一致が起こらなければ `false` を、起これば `true` を返す。
+一致は、 `first` で始まり、 `last` で終わるときにだけ起こる。
+例えば、次の例: *example* は FTP レスポンスの処理である。
+
+```cpp
+#include &amp;lt;stdlib.h&amp;gt; 
+#include &amp;lt;boost/regex.hpp&amp;gt; 
+#include &amp;lt;string&amp;gt; 
+#include &amp;lt;iostream&amp;gt; 
+
+using namespace boost; 
+
+regex expression(&amp;#34;([0-9]+)(\\-| |$)(.*)&amp;#34;); 
+
+// process_ftp: 
+// on success returns the ftp response code, and fills 
+// msg with the ftp response message. 
+int process_ftp(const char* response, std::string* msg) 
+{ 
+   cmatch what; 
+   if(regex_match(response, what, expression)) 
+   { 
+      // what[0] contains the whole string 
+      // what[1] contains the response code 
+      // what[2] contains the separator character 
+      // what[3] contains the text message. 
+      if(msg) 
+         msg-&amp;gt;assign(what[3].first, what[3].second); 
+      return std::atoi(what[1].first); 
+   } 
+   // failure did not match 
+   if(msg) 
+      msg-&amp;gt;erase(); 
+   return -1; 
+}
+```
+
+&amp;lt;a name=&amp;#34;match_type&amp;#34;&amp;gt;アルゴリズムに渡されるフラグパラメータの値は次の値のひとつ以上の組み合わせでなければならない。&amp;lt;/a&amp;gt;
+
+- `match_default`
+	- デフォルトの値である。
+		`first` は行の先頭、バッファの先頭、そして(可能なら)単語の先頭を表す。
+		`last` は行の最後、バッファの最後、そして(可能なら)単語の最後を表す。
+		子表現ドット &amp;#34;.&amp;#34; は改行文字とヌル文字の両方にも一致する。
+- `match_not_bol`
+	- このフラグが設定されているとき、 `first` は新しい行の先頭を表さない。
+- `match_not_eol`
+	- このフラグが設定されているとき、 `last` は行の最後を表さない。
+- `match_not_bob`
+	- このフラグが設定されているとき、 `first` はバッファの始まりを表さない。
+- `match_not_eob`
+	- このフラグが設定されているとき、 `last` はバッファの終わりを表さない。
+- `match_not_bow`
+	- このフラグが設定されているとき、 `first` は単語の先頭に一致することが出来ない。
+- `match_not_eow`
+	- このフラグが設定されているとき、 `last` は単語の終わりに一致することが出来ない。
+- `match_not_dot_newline`
+	- このフラグが設定されているとき、ドット表現 &amp;#34;.&amp;#34; は改行文字に一致しない
+- `match_not_dot_null`
+	- このフラグが設定されているとき、ドット表現 &amp;#34;.&amp;#34; はヌル文字に一致しない。
+- `match_prev_avail`
+	- このフラグが設定されているとき、 `*--first` は有効な表現であり、これらを検証するのに前の文字の値が使われるので `match_not_bol` と `match_not_bow` は作用しない。
+- `match_any`
+	- このフラグが設定されているとき、可能な限り長く一致するのではなく、一致した最初の文字列が返される。
+		このフラグは一致を発見するのにかかる時間を非常に削減するが、何が一致するかは未定義である。
+- `match_not_null`
+	- このフラグが設定されているとき、正規表現はヌル文字列には決して一致しない。
+- `match_continuous`
+	- このフラグが設定されているとき、grep 操作の間に、一連の一致はそれぞれ、以前の一致が終了した場所から始まる。
+- `match_partial`
+	- このフラグが設定されているとき、正規表現アルゴリズムは部分一致: [`partial matches`](#partial_matches) を報告する。
+		これは入力文字列の最後のひとつ以上の文字が、正規表現の接頭辞(訳注:入力文字列の最後の任意の部分と、正規表現の前からいくつかが一致するということ)に一致するということである。
+
+---
+
+## &amp;lt;a name=&amp;#34;reg_search&amp;#34;&amp;gt;Algorithm `regex_search`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex.hpp&amp;gt;
+```
+
+アルゴリズム `regex_search` は一組の双方向イテレータによって示される範囲を、与えられた正規表現で検索する。
+このアルゴリズムは、一致がその位置で始まる可能性があるときのみ、一致を検証することで、検索時間を削減するために様々な探索的方法を利用する。
+このアルゴリズムは次のように定義されている。
+
+```cpp
+template &amp;lt;class iterator, class Allocator, class charT, class traits, class Allocator2&amp;gt;
+bool regex_search(iterator first, 
+                iterator last, 
+                match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m, 
+                const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                unsigned flags = match_default);
+```
+
+ライブラリは次の簡易版も定義している。
+これは 一組のイテレータの代わりに、 `const charT*` 型か、或いは `const std::basic_string&amp;lt;&amp;gt;&amp;amp;` 型をとる。
+(コンパイラによってはこれらの簡易版は利用できないかもしれないこと、或いは限られた形でしか利用できないかもしれないことに注意せよ):
+
+```cpp
+template &amp;lt;class charT, class Allocator, class traits, class Allocator2&amp;gt;
+bool regex_search(const charT* str, 
+                match_results&amp;lt;const charT*, Allocator&amp;gt;&amp;amp; m, 
+                const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                unsigned flags = match_default);
+
+template &amp;lt;class ST, class SA, class Allocator, class charT, class traits, class Allocator2&amp;gt;
+bool regex_search(const std::basic_string&amp;lt;charT, ST, SA&amp;gt;&amp;amp; s, 
+                match_results&amp;lt;typename std::basic_string&amp;lt;charT, ST, SA&amp;gt;::const_iterator, Allocator&amp;gt;&amp;amp; m, 
+                const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e, 
+                unsigned flags = match_default);
+```
+
+主要版(訳注:簡易版ではない定義)の関数のパラメータは次の通りである。
+
+- `iterator first`
+	- 検索範囲の開始位置。
+- `iterator last`
+	- 検索範囲の終了位置。
+- `match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m`
+	- 何が一致したかを報告するための `match_results` のインスタンス。
+		関数を抜けるときに、もし一致が起こっていたら `m[0]` は一致した文字列の全体を表す。
+		`m[0].first` は `first` と等しく、 `m[0].second` は `last` より少ないか、等しい。
+		`m[1]` は最初の子表現、 `m[2]` は2番目の子表現を示し、以下それが続く。
+		もし一致が起こらなければ、 `m[0].first = m[0].second = last` である。
+	- `match_results` 構造体はイテレータのみを保持し、文字列を保持していないので、 `regex_search` に渡されるイテレータと文字列は、その結果が使われる限り有効でなければならないことに注意せよ。
+		このため、決して一時的文字列オブジェクトを `regex_search` に渡してはならない。
+- `const reg_expression&amp;lt;charT, traits, Allocator2&amp;gt;&amp;amp; e`
+	- 検索に使われる正規表現。
+- `unsigned flags = match_default`
+	- 何が一致するかを決定するフラグ。
+		[`match_flags`](#match_type) 列挙子のひとつ以上の組み合わせ。
+
+次の例: *example* は文字列の形でファイルの内容を受け取り、ファイルの中の全ての C++ クラス宣言を検索する。
+コードは `std::string` がどのように実装されていようが動く。
+例えば 不連続の保持(訳注: コンテナの要素がメモリ上で連続していないこと)を使っている SGI rope クラスでこれが動くように簡単に変更できる。
+
+```cpp
+#include &amp;lt;string&amp;gt; 
+#include &amp;lt;map&amp;gt; 
+#include &amp;lt;boost/regex.hpp&amp;gt; 
+
+// purpose: 
+// takes the contents of a file in the form of a string 
+// and searches for all the C++ class definitions, storing 
+// their locations in a map of strings/int&amp;#39;s 
+typedef std::map&amp;lt;std::string, int, std::less&amp;lt;std::string&amp;gt; &amp;gt; map_type; 
+
+boost::regex expression(&amp;#34;^(template[[:space:]]*&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?(class|struct)[[:space:]]*(\\&amp;lt;\\w+\\&amp;gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&amp;lt;\\w*\\&amp;gt;)[[:space:]]*(&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)&amp;#34;); 
+
+void IndexClasses(map_type&amp;amp; m, const std::string&amp;amp; file) 
+{ 
+   std::string::const_iterator start, end; 
+   start = file.begin(); 
+   end = file.end(); 
+      boost::match_results&amp;lt;std::string::const_iterator&amp;gt; what; 
+   unsigned int flags = boost::match_default; 
+   while(regex_search(start, end, what, expression, flags)) 
+   { 
+      // what[0] contains the whole string 
+      // what[5] contains the class name. 
+      // what[6] contains the template specialisation if any. 
+      // add class name and position to map: 
+      m[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
+                what[5].first - file.begin(); 
+      // update search position: 
+      start = what[0].second; 
+      // update flags: 
+      flags |= boost::match_prev_avail; 
+      flags |= boost::match_not_bob; 
+   } 
+}
+```
+
+---
+
+## &amp;lt;a name=&amp;#34;reg_grep&amp;#34;&amp;gt;Algorithm `regex_grep`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex.hpp&amp;gt;
+```
+
+`Regex_grep` は、双方向イテレータの範囲を最初から最後まで検索し、与えられた正規表現との全ての(重ならない)一致を発見する。
+この関数は次のように宣言されている:
+
+```cpp
+template &amp;lt;class Predicate, class iterator, class charT, class traits, class Allocator&amp;gt;
+unsigned int regex_grep(Predicate foo, 
+                        iterator first, 
+                        iterator last, 
+                        const reg_expression&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; e, 
+                        unsigned flags = match_default)
+```
+
+ライブラリは次の簡易版も定義している。
+これは 一組のイテレータの代わりに、 `const charT*` 型か、或いは `const std::basic_string&amp;lt;&amp;gt;&amp;amp;` 型をとる。
+(コンパイラによってはこれらの簡易版は利用できないかもしれないこと、或いは限られた形でしか利用できないかもしれないことに注意せよ):
+
+```cpp
+template &amp;lt;class Predicate, class charT, class Allocator, class traits&amp;gt;
+unsigned int regex_grep(Predicate foo, 
+              const charT* str, 
+              const reg_expression&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; e, 
+              unsigned flags = match_default);
+
+template &amp;lt;class Predicate, class ST, class SA, class Allocator, class charT, class traits&amp;gt;
+unsigned int regex_grep(Predicate foo, 
+              const std::basic_string&amp;lt;charT, ST, SA&amp;gt;&amp;amp; s, 
+              const reg_expression&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; e, 
+              unsigned flags = match_default);
+```
+
+主要版(訳注:簡易版ではない定義)の関数のパラメータは次の通りである。
+
+
+- `foo`
+	- 述語関数オブジェクトや関数ポインタ。
+		より詳しい情報は下を見よ。
+- `first`
+	- 検索範囲の先頭。
+- `last`
+	- 検索範囲の末端。
+- `e`
+	- 検索のための正規表現。
+- `flags`
+	- どのように一致が行われるかを決定するフラグ。
+		[`match_flags`](#match_type) 列挙子のひとつ。
+
+このアルゴリズムは、正規表現 e に対する、重ならない全ての一致を発見する。
+それぞれの一致で、 [`match_results&amp;lt;iterator, Allocator&amp;gt;`](#reg_match) 構造体に情報が入る。
+これは何が一致したかについての情報を保持し、述語関数 `foo` を呼び出し、ひとつの引数として `match_results&amp;lt;iterator,Allocator&amp;gt;` を渡す。
+もし述語関数が `true` を返せば grep 操作は引き続き行われる。
+そうでなければ grep 操作はそれ以降の一致を検索することなく終了する。
+この関数は、発見された一致の数を返す。
+
+述語関数の一般的な形式は以下の通りである: 
+
+```cpp
+struct grep_predicate
+{
+   bool operator()(const match_results&amp;lt;iterator_type, expression_type::alloc_type&amp;gt;&amp;amp; m);
+};
+```
+
+例えば、正規表現 `a*b` は文字列 `aaaaab` の中でひとつの一致を発見し、文字列 `aaabb` の中に二つの一致を発見する。
+
+このアルゴリズムは、grep の実装よりも多くのことに使うことが出来ることを覚えておくこと。
+述語関数があるので、やりたいことはそこで何でも出来る。
+grep ユーティリティは結果を画面に出力する。
+別のプログラムは正規表現に基づいてファイルを索引付けし、ブックマークの集合をリストに蓄えることが出来る。
+テキストファイル変換ユーティリティはファイルに出力する。
+再帰的な解析のために、ひとつの `regex_grep` の結果を別の `regex_grep` に連鎖することさえ可能である。
+
+*Example*: `regex_search` の例を、代わりに `regex_grep` を使って変換している:
+
+```cpp
+#include &amp;lt;string&amp;gt; 
+#include &amp;lt;map&amp;gt; 
+#include &amp;lt;boost/regex.hpp&amp;gt; 
+
+// IndexClasses: 
+// takes the contents of a file in the form of a string 
+// and searches for all the C++ class definitions, storing 
+// their locations in a map of strings/int&amp;#39;s 
+
+typedef std::map&amp;lt;std::string, int, std::less&amp;lt;std::string&amp;gt; &amp;gt; map_type; 
+
+boost::regex expression(&amp;#34;^(template[[:space:]]*&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?&amp;#34; 
+                 &amp;#34;(class|struct)[[:space:]]*(\\&amp;lt;\\w+\\&amp;gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&amp;lt;\\w*\\&amp;gt;)&amp;#34; 
+                 &amp;#34;[[:space:]]*(&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)&amp;#34;); 
+
+class IndexClassesPred 
+{ 
+   map_type&amp;amp; m; 
+   std::string::const_iterator base; 
+public: 
+   IndexClassesPred(map_type&amp;amp; a, std::string::const_iterator b) : m(a), base(b) {} 
+   bool operator()(const match_results&amp;lt;std::string::const_iterator, regex::alloc_type&amp;gt;&amp;amp; what) 
+   { 
+      // what[0] contains the whole string 
+      // what[5] contains the class name. 
+      // what[6] contains the template specialisation if any. 
+      // add class name and position to map: 
+      m[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
+                what[5].first - base; 
+      return true; 
+   } 
+}; 
+
+void IndexClasses(map_type&amp;amp; m, const std::string&amp;amp; file) 
+{ 
+   std::string::const_iterator start, end; 
+   start = file.begin(); 
+   end = file.end(); 
+   regex_grep(IndexClassesPred(m, start), start, end, expression); 
+}
+```
+
+*Example*: グローバルコールバック関数呼び出しに `regex_grep` を使っている:
+
+```cpp
+#include &amp;lt;string&amp;gt; 
+#include &amp;lt;map&amp;gt; 
+#include &amp;lt;boost/regex.hpp&amp;gt; 
+
+// purpose: 
+// takes the contents of a file in the form of a string 
+// and searches for all the C++ class definitions, storing 
+// their locations in a map of strings/int&amp;#39;s 
+
+typedef std::map&amp;lt;std::string, int, std::less&amp;lt;std::string&amp;gt; &amp;gt; map_type; 
+
+boost::regex expression(&amp;#34;^(template[[:space:]]*&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?(class|struct)[[:space:]]*(\\&amp;lt;\\w+\\&amp;gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&amp;lt;\\w*\\&amp;gt;)[[:space:]]*(&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)&amp;#34;); 
+
+map_type class_index; 
+std::string::const_iterator base;
+
+bool grep_callback(const boost::match_results&amp;lt;std::string::const_iterator, boost::regex::alloc_type&amp;gt;&amp;amp; what) 
+{ 
+   // what[0] contains the whole string 
+   // what[5] contains the class name. 
+   // what[6] contains the template specialisation if any. 
+   // add class name and position to map: 
+   class_index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
+                what[5].first - base; 
+   return true; 
+} 
+
+void IndexClasses(const std::string&amp;amp; file) 
+{ 
+   std::string::const_iterator start, end; 
+   start = file.begin(); 
+   end = file.end(); 
+   base = start; 
+   regex_grep(grep_callback, start, end, expression, match_default); 
+}
+
+```
+
+*Example*: `regex_grep` を使ってクラスメンバ関数を呼び出している。
+標準ライブラリアダプタ `std::mem_fun` と `std::bind1st` はメンバ関数を述語関数に変換するために使われている。
+
+```cpp
+#include &amp;lt;string&amp;gt; 
+#include &amp;lt;map&amp;gt; 
+#include &amp;lt;boost/regex.hpp&amp;gt; 
+#include &amp;lt;functional&amp;gt; 
+
+// purpose: 
+// takes the contents of a file in the form of a string 
+// and searches for all the C++ class definitions, storing 
+// their locations in a map of strings/int&amp;#39;s 
+
+typedef std::map&amp;lt;std::string, int, std::less&amp;lt;std::string&amp;gt; &amp;gt; map_type; 
+
+class class_index 
+{ 
+   boost::regex expression; 
+   map_type index; 
+   std::string::const_iterator base; 
+   bool grep_callback(boost::match_results&amp;lt;std::string::const_iterator, boost::regex::alloc_type&amp;gt; what); 
+public: 
+   void IndexClasses(const std::string&amp;amp; file); 
+   class_index() 
+      : index(), 
+        expression(&amp;#34;^(template[[:space:]]*&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?&amp;#34; 
+                   &amp;#34;(class|struct)[[:space:]]*(\\&amp;lt;\\w+\\&amp;gt;([[:blank:]]*\\([^)]*\\))?&amp;#34; 
+                   &amp;#34;[[:space:]]*)*(\\&amp;lt;\\w*\\&amp;gt;)[[:space:]]*(&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?&amp;#34; 
+                   &amp;#34;(\\{|:[^;\\{()]*\\{)&amp;#34; 
+                   ){} 
+}; 
+
+bool class_index::grep_callback(boost::match_results&amp;lt;std::string::const_iterator, boost::regex::alloc_type&amp;gt; what) 
+{ 
+   // what[0] contains the whole string 
+   // what[5] contains the class name. 
+   // what[6] contains the template specialisation if any. 
+   // add class name and position to map: 
+   index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
+               what[5].first - base; 
+   return true; 
+} 
+
+void class_index::IndexClasses(const std::string&amp;amp; file) 
+{ 
+   std::string::const_iterator start, end; 
+   start = file.begin(); 
+   end = file.end(); 
+   base = start; 
+   regex_grep(std::bind1st(std::mem_fun(&amp;amp;class_index::grep_callback), this), 
+              start, 
+              end, 
+              expression); 
+} 
+```
+
+*最後に*、 C++ Builder のユーザは C++ Builder のクロージャ型をコールバック引数として使うことが出来る。
+
+```cpp
+#include &amp;lt;string&amp;gt; 
+#include &amp;lt;map&amp;gt; 
+#include &amp;lt;boost/regex.hpp&amp;gt; 
+#include &amp;lt;functional&amp;gt; 
+
+// purpose: 
+// takes the contents of a file in the form of a string 
+// and searches for all the C++ class definitions, storing 
+// their locations in a map of strings/int&amp;#39;s 
+
+typedef std::map&amp;lt;std::string, int, std::less&amp;lt;std::string&amp;gt; &amp;gt; map_type; 
+class class_index 
+{ 
+   boost::regex expression; 
+   map_type index; 
+   std::string::const_iterator base; 
+   typedef boost::match_results&amp;lt;std::string::const_iterator, boost::regex::alloc_type&amp;gt; arg_type; 
+   bool grep_callback(const arg_type&amp;amp; what); 
+public: 
+   typedef bool (__closure* grep_callback_type)(const arg_type&amp;amp;); 
+   void IndexClasses(const std::string&amp;amp; file); 
+   class_index() 
+      : index(), 
+        expression(&amp;#34;^(template[[:space:]]*&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?&amp;#34; 
+                   &amp;#34;(class|struct)[[:space:]]*(\\&amp;lt;\\w+\\&amp;gt;([[:blank:]]*\\([^)]*\\))?&amp;#34; 
+                   &amp;#34;[[:space:]]*)*(\\&amp;lt;\\w*\\&amp;gt;)[[:space:]]*(&amp;lt;[^;:{]+&amp;gt;[[:space:]]*)?&amp;#34; 
+                   &amp;#34;(\\{|:[^;\\{()]*\\{)&amp;#34; 
+                   ){} 
+}; 
+
+bool class_index::grep_callback(const arg_type&amp;amp; what) 
+{ 
+   // what[0] contains the whole string    
+// what[5] contains the class name.    
+// what[6] contains the template specialisation if any.    
+// add class name and position to map:    
+index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
+               what[5].first - base; 
+   return true; 
+} 
+
+void class_index::IndexClasses(const std::string&amp;amp; file) 
+{ 
+   std::string::const_iterator start, end; 
+   start = file.begin(); 
+   end = file.end(); 
+   base = start; 
+   class_index::grep_callback_type cl = &amp;amp;(this-&amp;gt;grep_callback); 
+   regex_grep(cl, 
+            start, 
+            end, 
+            expression); 
+}
+```
+
+---
+
+## &amp;lt;a name=&amp;#34;reg_format&amp;#34;&amp;gt;Algorithm `regex_format`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex.hpp&amp;gt;
+```
+
+アルゴリズム `regex_format` は一致の結果を受け取り、 [書式指定子](format_string.md#format_string) に基づいて新しい文字列を作成する。
+`regex_format` は検索と置換の操作の為に使うことが出来る:
+
+```cpp
+template &amp;lt;class OutputIterator, class iterator, class Allocator, class charT&amp;gt;
+OutputIterator regex_format(OutputIterator out,
+                            const match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m,
+                            const charT* fmt,
+                            unsigned flags = 0);
+
+template &amp;lt;class OutputIterator, class iterator, class Allocator, class charT&amp;gt;
+OutputIterator regex_format(OutputIterator out,
+                            const match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m,
+                            const std::basic_string&amp;lt;charT&amp;gt;&amp;amp; fmt,
+                            unsigned flags = 0);&amp;lt;/pre&amp;gt;
+```
+
+ライブラリは次のような `regex_format` の簡易版も用意している。
+これは結果を、イテレータに出力するのではなく、文字列として直接返す。
+(注意: この簡易版はコンパイラによっては使えないか、使えても機能が限られているかもしれない。)
+
+```cpp
+template &amp;lt;class iterator, class Allocator, class charT&amp;gt;
+std::basic_string&amp;lt;charT&amp;gt; regex_format
+                                 (const match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m, 
+                                  const charT* fmt,
+                                  unsigned flags = 0);
+
+template &amp;lt;class iterator, class Allocator, class charT&amp;gt;
+std::basic_string&amp;lt;charT&amp;gt; regex_format
+                                 (const match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m, 
+                                  const std::basic_string&amp;lt;charT&amp;gt;&amp;amp; fmt,
+                                  unsigned flags = 0);
+```
+
+主要版の関数に渡されるパラメータは次の通りである。
+
+- `OutputIterator out`
+	- 出力イテレータ型。
+		出力文字列はこのイテレータに送られる。
+		通常は `std::ostream_iterator` である。
+- `const match_results&amp;lt;iterator, Allocator&amp;gt;&amp;amp; m`
+	- `match_result&amp;lt;&amp;gt;` のインスタンス。
+		これは上の一致判定アルゴリズムのうちのひとつから得られ、何が一致したを表す。
+- `const charT* fmt`
+	- 一致がどのように新しい文字列に変換されるかを決定する書式指定子。
+- `unsigned flags`
+	- 書式指定子がどのように解釈されるかを示す、オプションのフラグ。
+
+&amp;lt;a name=&amp;#34;format_flags&amp;#34;&amp;gt;書式のフラグは以下のように定義されている。&amp;lt;/a&amp;gt;
+
+- `format_all`
+	- すべての構文のオプションを可能にする。
+		(拡張正規表現構文に加え perl-like の構文も可能)。
+- `format_sed`
+	- sed-like の構文のみ許す。
+- `format_perl`
+	- perl-like の構文のみ許す。
+- `format_no_copy`
+	- [`regex_merge`](#reg_merge) 操作の間に、一致しなかった部分を出力文字列にコピーできなくする。
+- `format_first_only`
+	- このフラグが設定されているときは、最初の一致だけが置換される。
+		(`regex_merge` だけに適用される。)
+
+書式指定子の構文(そして利用可能なオプション)は [書式指定子](format_string.md#format_string) でより完全に書かれている。
+
+---
+
+## &amp;lt;a name=&amp;#34;reg_merge&amp;#34;&amp;gt;Algorithm `regex_merge`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex.hpp&amp;gt;
+```
+
+アルゴリズム `regex_merge` は [`regex_grep`](#reg_grep) と [`regex_format`](#reg_format) を組み合わせたものである。
+つまり、文字列の最初から最後まで、正規表現との全ての一致を発見し、その一致それぞれに対して、文字列を書式化するために [`regex_format`](#reg_format) を呼び出し、結果を出力イテレータに送る。
+一致しなかった部分のテキストはフラグパラメータ [`format_no_copy`](#format_flags) が設定されていなければ、変更されることなく出力される。
+[`format_first_only`](#format_flags) が設定されていれば、全ての一致ではなく、最初の一致だけが置換される。
+
+```cpp
+template &amp;lt;class OutputIterator, class iterator, class traits, class Allocator, class charT&amp;gt;
+OutputIterator regex_merge(OutputIterator out, 
+                          iterator first,
+                          iterator last,
+                          const reg_expression&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; e, 
+                          const charT* fmt, 
+                          unsigned int flags = match_default);
+
+template &amp;lt;class OutputIterator, class iterator, class traits, class Allocator, class charT&amp;gt;
+OutputIterator regex_merge(OutputIterator out, 
+                           iterator first,
+                           iterator last,
+                           const reg_expression&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; e, 
+                           std::basic_string&amp;lt;charT&amp;gt;&amp;amp; fmt, 
+                           unsigned int flags = match_default);
+```
+
+このライブラリは次のような `regex_merge` の簡易版も定義している。
+これは、イテレータに出力するのではなく、結果を文字列として直接返す。
+(注意：コンパイラによってはこの簡易版は利用できないか、利用できても限られた形でしか使えない。)
+
+```cpp
+template &amp;lt;class traits, class Allocator, class charT&amp;gt;
+std::basic_string&amp;lt;charT&amp;gt; regex_merge(const std::basic_string&amp;lt;charT&amp;gt;&amp;amp; text,
+                                     const reg_expression&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; e, 
+                                     const charT* fmt, 
+                                     unsigned int flags = match_default);
+
+template &amp;lt;class traits, class Allocator, class charT&amp;gt;
+std::basic_string&amp;lt;charT&amp;gt; regex_merge(const std::basic_string&amp;lt;charT&amp;gt;&amp;amp; text,
+                                     const reg_expression&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; e, 
+                                     const std::basic_string&amp;lt;charT&amp;gt;&amp;amp; fmt, 
+                                     unsigned int flags = match_default);
+```
+
+主要版の関数に渡されるパラメータは次の通りである:
+
+- `OutputIterator out`
+	- 出力イテレータ型。
+		通常は `std::ostream_iterator` である。
+- `iterator first`
+	- 検索するテキストの範囲の最初。
+		(双方向イテレータ)
+- `iterator last`
+	- 検索するテキストの範囲の最後。
+		(双方向イテレータ)
+- `const reg_expression&amp;lt;charT, traits, Allocator&amp;gt;&amp;amp; e`
+	- 検索のための正規表現
+- `const charT* fmt`
+	- 一致した部分のテキストに適用される書式指定子。
+- `unsigned int flags = match_default`
+	- 正規表現がどのように一致するかを決定するフラグ。
+		[`match_flags`](#match_type) を見よ。
+		また、書式指定子がどのように解釈されるかを決定するフラグ。
+        [`format_flags`](#format_flags) を見よ。
+
+次 *例* は C/C++ のソースコードをインプットとして受け取り、構文が強調された HTML コードを出力する。
+
+```cpp example
+#include &amp;lt;fstream&amp;gt;
+#include &amp;lt;sstream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;iterator&amp;gt;
+#include &amp;lt;boost/regex.hpp&amp;gt;
+#include &amp;lt;fstream&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+
+// purpose:
+// takes the contents of a file and transform to
+// syntax highlighted code in html format
+
+boost::regex e1, e2;
+extern const char* expression_text;
+extern const char* format_string;
+extern const char* pre_expression;
+extern const char* pre_format;
+extern const char* header_text;
+extern const char* footer_text;
+
+void load_file(std::string&amp;amp; s, std::istream&amp;amp; is)
+{
+   s.erase();
+   s.reserve(is.rdbuf()-&amp;gt;in_avail());
+   char c;
+   while(is.get(c))
+   {
+      if(s.capacity() == s.size())
+         s.reserve(s.capacity() * 3);
+      s.append(1, c);
+   }
+}
+
+int main(int argc, const char** argv)
+{
+   try{
+   e1.assign(expression_text);
+   e2.assign(pre_expression);
+   for(int i = 1; i &amp;lt; argc; ++i)
+   {
+      std::cout &amp;lt;&amp;lt; &amp;#34;Processing file &amp;#34; &amp;lt;&amp;lt; argv[i] &amp;lt;&amp;lt; std::endl;
+      std::ifstream fs(argv[i]);
+      std::string in;
+      load_file(in, fs);
+      std::string out_name(std::string(argv[i]) + std::string(&amp;#34;.htm&amp;#34;));
+      std::ofstream os(out_name.c_str());
+      os &amp;lt;&amp;lt; header_text;
+      // strip &amp;#39;&amp;lt;&amp;#39; and &amp;#39;&amp;gt;&amp;#39; first by outputting to a
+      // temporary string stream
+      std::ostringstream t(std::ios::out | std::ios::binary);
+      std::ostream_iterator&amp;lt;char, char&amp;gt; oi(t);
+      boost::regex_merge(oi, in.begin(), in.end(), e2, pre_format);
+      // then output to final output stream
+      // adding syntax highlighting:
+      std::string s(t.str());
+      std::ostream_iterator&amp;lt;char, char&amp;gt; out(os);
+      boost::regex_merge(out, s.begin(), s.end(), e1, format_string);
+      os &amp;lt;&amp;lt; footer_text;
+   }
+   }
+   catch(...)
+   { return -1; }
+   return 0;
+}
+
+extern const char* pre_expression = &amp;#34;(&amp;lt;)|(&amp;gt;)|\\r&amp;#34;;
+extern const char* pre_format = &amp;#34;(?1&amp;lt;)(?2&amp;gt;)&amp;#34;;
+
+
+const char* expression_text = // preprocessor directives: index 1
+                              &amp;#34;(^[[:blank:]]*#(?:[^\\\\\\n]|\\\\[^\\n[:punct:][:word:]]*[\\n[:punct:][:word:]])*)|&amp;#34;
+                              // comment: index 2
+                              &amp;#34;(//[^\\n]*|/\\*.*?\\*/)|&amp;#34;
+                              // literals: index 3
+                              &amp;#34;\\&amp;lt;([+-]?(?:(?:0x[[:xdigit:]]+)|(?:(?:[[:digit:]]*\\.)?[[:digit:]]+(?:[eE][+-]?[[:digit:]]+)?))u?(?:(?:int(?:8|16|32|64))|L)?)\\&amp;gt;|&amp;#34;
+                              // string literals: index 4
+                              &amp;#34;(&amp;#39;(?:[^\\\\&amp;#39;]|\\\\.)*&amp;#39;|\&amp;#34;(?:[^\\\\\&amp;#34;]|\\\\.)*\&amp;#34;)|&amp;#34;
+                              // keywords: index 5
+                              &amp;#34;\\&amp;lt;(__asm|__cdecl|__declspec|__export|__far16|__fastcall|__fortran|__import&amp;#34;
+                              &amp;#34;|__pascal|__rtti|__stdcall|_asm|_cdecl|__except|_export|_far16|_fastcall&amp;#34;
+                              &amp;#34;|__finally|_fortran|_import|_pascal|_stdcall|__thread|__try|asm|auto|bool&amp;#34;
+                              &amp;#34;|break|case|catch|cdecl|char|class|const|const_cast|continue|default|delete&amp;#34;
+                              &amp;#34;|do|double|dynamic_cast|else|enum|explicit|extern|false|float|for|friend|goto&amp;#34;
+                              &amp;#34;|if|inline|int|long|mutable|namespace|new|operator|pascal|private|protected&amp;#34;
+                              &amp;#34;|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_cast&amp;#34;
+                              &amp;#34;|struct|switch|template|this|throw|true|try|typedef|typeid|typename|union|unsigned&amp;#34;
+                              &amp;#34;|using|virtual|void|volatile|wchar_t|while)\\&amp;gt;&amp;#34;
+                              ;
+
+const char* format_string = &amp;#34;(?1&amp;lt;font color=\&amp;#34;#008040\&amp;#34;&amp;gt;$&amp;amp;&amp;lt;/font&amp;gt;)&amp;#34;
+                            &amp;#34;(?2&amp;lt;I&amp;gt;&amp;lt;font color=\&amp;#34;#000080\&amp;#34;&amp;gt;$&amp;amp;&amp;lt;/font&amp;gt;&amp;lt;/I&amp;gt;)&amp;#34;
+                            &amp;#34;(?3&amp;lt;font color=\&amp;#34;#0000A0\&amp;#34;&amp;gt;$&amp;amp;&amp;lt;/font&amp;gt;)&amp;#34;
+                            &amp;#34;(?4&amp;lt;font color=\&amp;#34;#0000FF\&amp;#34;&amp;gt;$&amp;amp;&amp;lt;/font&amp;gt;)&amp;#34;
+                            &amp;#34;(?5&amp;lt;B&amp;gt;$&amp;amp;&amp;lt;/B&amp;gt;)&amp;#34;
+
+const char* header_text = &amp;#34;&amp;lt;HTML&amp;gt;\n&amp;lt;HEAD&amp;gt;\n&amp;#34;
+                          &amp;#34;&amp;lt;TITLE&amp;gt;Auto-generated html formated source&amp;lt;/TITLE&amp;gt;\n&amp;#34;
+                          &amp;#34;&amp;lt;META HTTP-EQUIV=\&amp;#34;Content-Type\&amp;#34; CONTENT=\&amp;#34;text/html; charset=windows-1252\&amp;#34;&amp;gt;\n&amp;#34;
+                          &amp;#34;&amp;lt;/HEAD&amp;gt;\n&amp;#34;
+                          &amp;#34;&amp;lt;BODY LINK=\&amp;#34;#0000ff\&amp;#34; VLINK=\&amp;#34;#800080\&amp;#34; BGCOLOR=\&amp;#34;#ffffff\&amp;#34;&amp;gt;\n&amp;#34;
+                          &amp;#34;&amp;lt;P&amp;gt; &amp;lt;/P&amp;gt;\n&amp;lt;PRE&amp;gt;&amp;#34;;
+
+const char* footer_text = &amp;#34;&amp;lt;/PRE&amp;gt;\n&amp;lt;/BODY&amp;gt;\n\n&amp;#34;;
+```
+
+---
+
+## &amp;lt;a name=&amp;#34;regex_split&amp;#34;&amp;gt;Algorithm `regex_split`&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/regex.hpp&amp;gt;
+```
+
+アルゴリズム `regex_split` は perl の spilit 操作と似たようなことをおこなう。
+そして3種類のオーバロードの形で提供されている。
+
+```cpp
+template &amp;lt;class OutputIterator, class charT, class Traits1, class Alloc1, class Traits2, class Alloc2&amp;gt;
+std::size_t regex_split(OutputIterator out, 
+                        std::basic_string&amp;lt;charT, Traits1, Alloc1&amp;gt;&amp;amp; s, 
+                        const reg_expression&amp;lt;charT, Traits2, Alloc2&amp;gt;&amp;amp; e,
+                        unsigned flags,
+                        std::size_t max_split);
+
+template &amp;lt;class OutputIterator, class charT, class Traits1, class Alloc1, class Traits2, class Alloc2&amp;gt;
+std::size_t regex_split(OutputIterator out, 
+                        std::basic_string&amp;lt;charT, Traits1, Alloc1&amp;gt;&amp;amp; s, 
+                        const reg_expression&amp;lt;charT, Traits2, Alloc2&amp;gt;&amp;amp; e,
+                        unsigned flags = match_default);
+
+template &amp;lt;class OutputIterator, class charT, class Traits1, class Alloc1&amp;gt;
+std::size_t regex_split(OutputIterator out, 
+                        std::basic_string&amp;lt;charT, Traits1, Alloc1&amp;gt;&amp;amp; s);
+```
+
+それぞれの関数は出力のための出力イテレータ、入力文字列を受け取る。
+正規表現が、印付けされた子表現を含まないとき、アルゴリズムは正規表現と一致しないテキストのそれぞれの部分をひとつの文字列として、出力イテレータに書き込む。
+もし正規表現が印付けされた子表現を含んでいれば、一致が発見される度に、印付けされた子表現それぞれに対してひとつの文字列が、出力イテレータに書き込まれる。
+`max_split` 以上の文字列は出力イテレータに書き込まれない。
+関数を抜ける前に、処理された全ての入力は文字列 s から削除される(もし `max_split` まで到達しなければ、全ての `s` が削除される)。
+出力イテレータに書き込まれた文字列の数を返す。
+もしパラメータ `max_split` が特定されていなければ、デフォルトでは `UINT_MAX` が使われる。
+正規表現が特定されていなければ、デフォルトでは &amp;#34;\s+&amp;#34; が使われ、空白によって分割される。
+(訳注: この関数は、正規表現が子表現を持っているかどうかで、動作が大きく異なる。
+正規表現が子表現を持っていないとき、この関数はまさに、 perl の split と同様に動作する。
+正規表現が子表現を持っているとき、その一致した子表現が出力イテレータに書き込まれる。)
+
+*Example*: the following function will split the input string into a series of tokens, and remove each token from the string `s`:
+
+```cpp
+unsigned tokenise(std::list&amp;lt;std::string&amp;gt;&amp;amp; l, std::string&amp;amp; s)
+{
+   return boost::regex_split(std::back_inserter(l), s);
+}
+```
+
+*Example*: the following short program will extract all of the URL&amp;#39;s from a html file, and print them out to `cout`:
+
+```cpp
+#include &amp;lt;list&amp;gt;
+#include &amp;lt;fstream&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;boost/regex.hpp&amp;gt;
+
+boost::regex e(&amp;#34;&amp;lt;\\s*A\\s+[^&amp;gt;]*href\\s*=\\s*\&amp;#34;([^\&amp;#34;]*)\&amp;#34;&amp;#34;,
+               boost::regbase::normal | boost::regbase::icase);
+
+void load_file(std::string&amp;amp; s, std::istream&amp;amp; is)
+{
+   s.erase();
+   //
+   // attempt to grow string buffer to match file size,
+   // this doesn&amp;#39;t always work...
+   s.reserve(is.rdbuf()-&amp;amp;gtin_avail());
+   char c;
+   while(is.get(c))
+   {
+      // use logarithmic growth stategy, in case
+      // in_avail (above) returned zero:
+      if(s.capacity() == s.size())
+         s.reserve(s.capacity() * 3);
+      s.append(1, c);
+   }
+}
+
+
+int main(int argc, char** argv)
+{
+   std::string s;
+   std::list&amp;lt;std::string&amp;gt; l;
+
+   for(int i = 1; i &amp;lt; argc; ++i)
+   {
+      std::cout &amp;lt;&amp;lt; &amp;#34;Findings URL&amp;#39;s in &amp;#34; &amp;lt;&amp;lt; argv[i] &amp;lt;&amp;lt; &amp;#34;:&amp;#34; &amp;lt;&amp;lt; std::endl;
+      s.erase();
+      std::ifstream is(argv[i]);
+      load_file(s, is);
+      boost::regex_split(std::back_inserter(l), s, e);
+      while(l.size())
+      {
+         s = *(l.begin());
+         l.pop_front();
+         std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
+      }
+   }
+   return 0;
+}
+```
+
+---
+
+## &amp;lt;a name=&amp;#34;partial_matches&amp;#34;&amp;gt;Partial Matches&amp;lt;/a&amp;gt;
+
+一致フラグ `match_partial` は次のアルゴリズムに渡すことが出来る:
+[`regex_match`](#reg_match), [`regex_search`](#reg_search), そして [`regex_grep`](#reg_grep) 。
+これは、全体一致と同様に部分一致が発見されることを表す。
+部分一致は、入力テキストの終端に1文字以上の一致があるが、それが正規表現の全体と一致しているのではない、というものである(テキストが終了したかもしれないが、まだ続くかもしれない、というような時だ)。
+部分一致は通常、入力データの検証(キーボードが押される度にそれぞれの文字を検証する)、とか、メモリ(やメモリマップドファイルにさえ)に読み込むには長すぎるようなテキスト、または不確定な長さのテキスト(例えばテキストの元はソケットや、それに似たようなものかもしれない)を検索するときである。
+部分一致と全体一致は次の表に示されるように、区別されている(変数 `M` は `regex_match`, `regex_search`, `regex_grep` によって結果を書き込まれた `match_results&amp;lt;&amp;gt;` のインスタンスを表している)。
+
+| Result | `M[0].matched` | `M[0].first` | `M[0].second` |
+|---|---|---|---|
+| 一致無し | False | 未定義 | 未定義 | 未定義 |
+| 部分一致 | True | False | 部分一致の先頭 | 部分一致の終端(テキストの終端) |
+| 全体一致 | True | True | 全体一致の先頭 | 全体一致の終端 |
+
+*次の例* はユーザがキーを押す度に、テキストが有効なクレジットカードの番号かどうか検証する。
+入力された文字は積み上げられた文字列に付け加えられ、 `is_possible_card_number` に渡される。
+もしこれが true を返せばテキストは有効なカード番号であり、ユーザインタフェースの OK ボタンが有効になる。
+もし false を返せばこれはまだ有効なカードナンバーではないが、更に入力が可能で、ユーザインタフェースの OK ボタンは無効である。
+最後にこの手続きで、入力が決して有効な番号にはならないという例外が発生すれば、入力された文字は破棄され、ユーザに適したエラーを表示する。
+
+```cpp
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;boost/regex.hpp&amp;gt;
+
+boost::regex e(&amp;#34;(\\d{3,4})[- ]?(\\d{4})[- ]?(\\d{4})[- ]?(\\d{4})&amp;#34;);
+
+bool is_possible_card_number(const std::string&amp;amp; input)
+{
+   //
+   // return false for partial match, true for full match, or throw for
+   // impossible match based on what we have so far...
+   boost::match_results&amp;lt;std::string::const_iterator&amp;gt; what;
+   if(0 == boost::regex_match(input, what, e, boost::match_default | boost::match_partial))
+   {
+      // the input so far could not possibly be valid so reject it:
+      throw std::runtime_error(&amp;#34;Invalid data entered - this could not possibly be a valid card number&amp;#34;);
+   }
+   // OK so far so good, but have we finished?
+   if(what[0].matched)
+   {
+      // excellent, we have a result:
+      return true;
+   }
+   // what we have so far is only a partial match...
+   return false;
+}
+```
+
+*次の例* では、不定な長さのテキストを含むストリームから入力を受け取る。
+この例は単に、ストリームの中に現れる html タグの数を数えるだけである。
+テキストはバッファに読み込まれ、同時に一部を検索する。
+部分一致が現れれば、その部分一致は、次のひとまとまりのテキストの先頭として次回に検索される: 
+
+```cpp
+#include &amp;lt;iostream&amp;gt;
+#include &amp;lt;fstream&amp;gt;
+#include &amp;lt;sstream&amp;gt;
+#include &amp;lt;string&amp;gt;
+#include &amp;lt;boost/regex.hpp&amp;gt;
+
+// match some kind of html tag:
+boost::regex e(&amp;#34;&amp;lt;[^&amp;gt;]*&amp;gt;&amp;#34;);
+// count how many:
+unsigned int tags = 0;
+// saved position of partial match:
+char* next_pos = 0;
+
+bool grep_callback(const boost::match_results&amp;lt;char*&amp;gt;&amp;amp; m)
+{
+   if(m[0].matched == false)
+   {
+      // save position and return:
+      next_pos = m[0].first;
+   }
+   else
+      ++tags;
+   return true;
+}
+
+void search(std::istream&amp;amp; is)
+{
+   char buf[4096];
+   next_pos = buf + sizeof(buf);
+   bool have_more = true;
+   while(have_more)
+   {
+      // how much do we copy forward from last try:
+      unsigned leftover = (buf + sizeof(buf)) - next_pos;
+      // and how much is left to fill:
+      unsigned size = next_pos - buf;
+      // copy forward whatever we have left:
+      memcpy(buf, next_pos, leftover);
+      // fill the rest from the stream:
+      unsigned read = is.readsome(buf + leftover, size);
+      // check to see if we&amp;#39;ve run out of text:
+      have_more = read == size;
+      // reset next_pos:
+      next_pos = buf + sizeof(buf);
+      // and then grep:
+      boost::regex_grep(grep_callback,
+                        buf,
+                        buf + read + leftover,
+                        e,
+                        boost::match_default | boost::match_partial);
+   }
+}
+```
+
+---
+
+*Copyright* [*Dr John Maddock*](mailto:John_Maddock@compuserve.com) *1998-2001 all rights reserved.*
+
+---
+
+*Japanese Translation Copyright (C) 2003 [Kohske Takahashi](mailto:k_takahashi@cppll.jp)*
+
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Traits Class Reference. -- Boost.Regexの翻訳ドキュメントを移植(close #21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/traits_class_ref.html"/>
      <id>b2f311fe9f4f960861fa7a43663c708396346fab:archive/boost_docs/libs/regex/traits_class_ref.md</id>
      <updated>2020-06-01T18:56:40+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/traits_class_ref.md b/archive/boost_docs/libs/regex/traits_class_ref.md
new file mode 100644
index 0000000..ee91fed
--- /dev/null
+++ b/archive/boost_docs/libs/regex/traits_class_ref.md
@@ -0,0 +1,273 @@
+# Regex++, Traits Class Reference.
+
+*Copyright (c) 1998-2001*
+
+*Dr John Maddock*
+
+*Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
+Dr John Maddock makes no representations about the suitability of this software for any purpose.
+It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
+
+---
+
+この章では `reg_expression` テンプレートクラスの特性クラスの仕様について述べる。
+これらの仕様は多少複雑(申し訳ない)で、新しい特徴の要求にあたり変更が必要である。
+しかし私はしばらく、これらをこのままにしておこうと思う。
+そして理想的には、仕様は増えるよりも減らされるべきである。
+
+`reg_expression` 特性クラスは文字型の性質と、その文字型に関連するロケールの性質の両方をカプセル化する。
+関連するロケールは実行時に (`std::locale` によって) 定義されるかもしれないし、特性クラスに直接コーディングされて、コンパイル時に決定されているかもしれない。
+
+次のクラスの例は、 クラス `reg_expression` で使うための、 &amp;#34;典型的な&amp;#34; 特性クラスに求められるインタフェースを説明している:
+
+```cpp
+class mytraits
+{
+   typedef implementation_defined char_type;
+   typedef implementation_defined uchar_type;
+   typedef implementation_defined size_type;
+   typedef implementation_defined string_type;
+   typedef implementation_defined locale_type;
+   typedef implementation_defined uint32_t;
+   struct sentry
+   {
+      sentry(const mytraits&amp;amp;);
+      operator void*() { return this; }
+   };
+
+   enum char_syntax_type
+   {
+      syntax_char = 0,
+      syntax_open_bracket = 1,                  // (
+      syntax_close_bracket = 2,                 // )
+      syntax_dollar = 3,                        // $
+      syntax_caret = 4,                         // ^
+      syntax_dot = 5,                           // .
+      syntax_star = 6,                          // *
+      syntax_plus = 7,                          // +
+      syntax_question = 8,                      // ?
+      syntax_open_set = 9,                      // [
+      syntax_close_set = 10,                    // ]
+      syntax_or = 11,                           // |
+      syntax_slash = 12,                        //
+      syntax_hash = 13,                         // #
+      syntax_dash = 14,                         // -
+      syntax_open_brace = 15,                   // {
+      syntax_close_brace = 16,                  // }
+      syntax_digit = 17,                        // 0-9
+      syntax_b = 18,                            // for \b
+      syntax_B = 19,                            // for \B
+      syntax_left_word = 20,                    // for \&amp;amp;lt;
+      syntax_right_word = 21,                   // for \
+      syntax_w = 22,                            // for \w
+      syntax_W = 23,                            // for \W
+      syntax_start_buffer = 24,                 // for \`
+      syntax_end_buffer = 25,                   // for \&amp;#39;
+      syntax_newline = 26,                      // for newline alt
+      syntax_comma = 27,                        // for {x,y}
+
+      syntax_a = 28,                            // for \a
+      syntax_f = 29,                            // for \f
+      syntax_n = 30,                            // for \n
+      syntax_r = 31,                            // for \r
+      syntax_t = 32,                            // for \t
+      syntax_v = 33,                            // for \v
+      syntax_x = 34,                            // for \xdd
+      syntax_c = 35,                            // for \cx
+      syntax_colon = 36,                        // for [:...:]
+      syntax_equal = 37,                        // for [=...=]
+
+      // perl ops:
+      syntax_e = 38,                            // for \e
+      syntax_l = 39,                            // for \l
+      syntax_L = 40,                            // for \L
+      syntax_u = 41,                            // for \u
+      syntax_U = 42,                            // for \U
+      syntax_s = 43,                            // for \s
+      syntax_S = 44,                            // for \S
+      syntax_d = 45,                            // for \d
+      syntax_D = 46,                            // for \D
+      syntax_E = 47,                            // for \Q\E
+      syntax_Q = 48,                            // for \Q\E
+      syntax_X = 49,                            // for \X
+      syntax_C = 50,                            // for \C
+      syntax_Z = 51,                            // for \Z
+      syntax_G = 52,                            // for \G
+      syntax_bang = 53,                         // reserved for future use &amp;#39;!&amp;#39;
+      syntax_and = 54,                          // reserve for future use &amp;#39;&amp;amp;&amp;#39;
+   };
+
+   enum{
+      char_class_none = 0,
+      char_class_alpha,
+      char_class_cntrl,
+      char_class_digit,
+      char_class_lower,
+      char_class_punct,
+      char_class_space,
+      char_class_upper,
+      char_class_xdigit,
+      char_class_blank,
+      char_class_unicode,
+      char_class_alnum,
+      char_class_graph,
+      char_class_print,
+      char_class_word
+   };
+
+   static size_t length(const char_type* p);
+   unsigned int syntax_type(size_type c)const;
+   char_type translate(char_type c, bool icase)const;
+   void transform(string_type&amp;amp; out, const string_type&amp;amp; in)const;
+   void transform_primary(string_type&amp;amp; out, const string_type&amp;amp; in)const;
+   bool is_separator(char_type c)const;
+   bool is_combining(char_type)const;
+   bool is_class(char_type c, uint32_t f)const;
+   int toi(char_type c)const;
+   int toi(const char_type*&amp;amp; first, const char_type* last, int radix)const;
+   uint32_t lookup_classname(const char_type* first, const char_type* last)const;
+   bool lookup_collatename(string_type&amp;amp; buf, const char_type* first, const char_type* last)const;
+   locale_type imbue(locale_type l);
+   locale_type getloc()const;
+   std::string error_string(unsigned id)const;
+
+   mytraits();
+   ~mytraits();
+};
+```
+
+特性クラスに求められるメンバ型は次のように定義されている:
+
+| メンバ名      | 説明 |
+|---------------|------|
+| `char_type`   | この特性クラスがカプセル化する文字型。POD 型でなければならない。`uchar_type` に変換可能でなければならない。 |
+| `uchar_type`  | `char_type` に対応する unsigned 型。`size_type` に変換可能でなければならない。 |
+| `size_type`   | 符号なし整数型。`uchar_type` と同じ精度でなければならない。 |
+| `string_type` | `std::basic_string&amp;lt;char_type&amp;gt;` と同じ能力を提供する型。これは照合要素、文字列のソートのために使われる。もし `char_type` がロケール依存の照合を持っていなければ (&amp;#34;文字&amp;#34;ではない)、これは `std::basic_string` よりも単純なものでよい。 |
+| `locale_type` | 特性クラスで使われるロケールをカプセル化する型。おそらく `std::locale` だと思うが、プラットフォーム特有の型も可能である。または、もしインスタンス毎のロケールを特性クラスがサポートしないなら、ダミー型も可能である。 |
+| `uint32_t`    | 少なくとも 32ビットの精度を持つ 符号なし整数型。文字分類のためのビットマスク型として使われる。 |
+| `sentry`      | 特性クラスのインスタンスから構築可能で、 `void*` への変換可能なクラスもしくは構造体型。`sentry` 型のインスタンスはそれぞれの正規表現をコンパイルする前に構築される。これは、特性クラスの接頭辞/接尾辞操作を実行する機会を提供する。例えば、グローバルロケールをカプセル化した特性クラスは、(キャッシュされたデータを更新することで)グローバルロケールと同期する機会として、これを利用することが出来る。 |
+
+次のメンバ定数は、ロケール非依存な正規表現の構文をあらわすために使われる。
+メンバ関数 `syntax_type` はこれらの値のうちの一つを返し、ロケール依存の正規表現をロケール非依存なトークンのシーケンスに変換するために使われる。
+
+| メンバ定数             | 英語での表現         |
+|------------------------|----------------------|
+| `syntax_char`          | 全ての特殊でない文字 |
+| `syntax_open_bracket`  | (                    |
+| `syntax_close_bracket` | )                    |
+| `syntax_dollar`        | \$                   |
+| `syntax_caret`         | \^                   |
+| `syntax_dot`           | .                    |
+| `syntax_star`          | \*                   |
+| `syntax_plus`          | +                    |
+| `syntax_question`      | ?                    |
+| `syntax_open_set`      | [                    |
+| `syntax_close_set`     | ]                    |
+| `syntax_or`            | \|                   |
+| `syntax_slash`         | \\                   |
+| `syntax_hash`          | #                    |
+| `syntax_dash`          | -                    |
+| `syntax_open_brace`    | {                    |
+| `syntax_close_brace`   | }                    |
+| `syntax_digit`         | 0123456789           |
+| `syntax_b`             | b                    |
+| `syntax_B`             | B                    |
+| `syntax_left_word`     | &amp;lt;                    |
+| `syntax_right_word`    |                      |
+| `syntax_w`             | w                    |
+| `syntax_W`             | W                    |
+| `syntax_start_buffer`  | \`                   |
+| `syntax_end_buffer`    | &amp;#39;                    |
+| `syntax_newline`       | \\n                  |
+| `syntax_comma`         | ,                    |
+| `syntax_a`             | a                    |
+| `syntax_f`             | f                    |
+| `syntax_n`             | n                    |
+| `syntax_r`             | r                    |
+| `syntax_t`             | t                    |
+| `syntax_v`             | v                    |
+| `syntax_x`             | x                    |
+| `syntax_c`             | c                    |
+| `syntax_colon`         | :                    |
+| `syntax_equal`         | =                    |
+| `syntax_e`             | e                    |
+| `syntax_l`             | l                    |
+| `syntax_L`             | L                    |
+| `syntax_u`             | u                    |
+| `syntax_U`             | U                    |
+| `syntax_s`             | s                    |
+| `syntax_S`             | S                    |
+| `syntax_d`             | d                    |
+| `syntax_D`             | D                    |
+| `syntax_E`             | E                    |
+| `syntax_Q`             | Q                    |
+| `syntax_X`             | X                    |
+| `syntax_C`             | C                    |
+| `syntax_Z`             | Z                    |
+| `syntax_G`             | G                    |
+| `syntax_bang`          | !                    |
+| `syntax_and`           | &amp;amp;                    |
+
+次のメンバ定数は特別な文字分類を表すために使われる:
+
+| メンバ定数           | 説明                                                                                   |
+|----------------------|----------------------------------------------------------------------------------------|
+| `char_class_none`    | 分類なし。ゼロでなければならない。                                                     |
+| `char_class_alpha`   | 全てのアルファベット文字                                                               |
+| `char_class_cntrl`   | 全てのコントロール文字                                                                 |
+| `char_class_digit`   | 全ての10進数字                                                                         |
+| `char_class_lower`   | 全ての小文字                                                                           |
+| `char_class_punct`   | 全ての句読点                                                                           |
+| `char_class_space`   | 全ての空白文字                                                                         |
+| `char_class_upper`   | 全ての大文字                                                                           |
+| `char_class_xdigit`  | 全ての16進数字                                                                         |
+| `char_class_blank`   | 全てのブランク文字(スペースとタブ)                                                     |
+| `char_class_unicode` | 全ての拡張ユニコード文字。これらは単一のナロウキャラクタとしてあらわすことができない。 |
+| `char_class_alnum`   | 全ての文字と数字                                                                       |
+| `char_class_graph`   | 全ての絵文字                                                                           |
+| `char_class_print`   | 全ての印字可能文字                                                                     |
+| `char_class_word`    | 単語を形成する文字全て(文字、数字、アンダースコア)                                     |
+
+次のメンバ関数が全ての正規表現特性クラスに必要である。
+ここで *const* として宣言されているメンバは、もしクラスがインスタンスのデータを含まなければ代わりに *static* として宣言することが出来る。
+
+| メンバ関数 | 説明 |
+|------------|------|
+| `static size_t length(const char_type* p);` | null 終端文字列 p の長さを返す。|
+| `unsigned int syntax_type(size_type c)const;` | 入力文字列をロケール非依存なトークン (`syntax_xxx` メンバ定数のひとつ) に変換する。正規表現をロケール非依存な解析木に構文解析するときに呼ばれる。&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;例: 英語での正規表現では、全ての単語形成文字の文字クラスをあらわすために、&amp;#34;[[:word:]]&amp;#34; とこの略記 &amp;#34;\\w&amp;#34; を使うことが出来る。結果的に、 `syntax_type(&amp;#39;w&amp;#39;)` は `syntax_w` を返す。フランス語での正規表現では、 &amp;#34;[[:word:]]&amp;#34; の代わりに、&amp;#34;[[:mot:]]&amp;#34; を、&amp;#34;\\w&amp;#34; の代わりに &amp;#34;\\m&amp;#34; を使うことが出来る。このため、 `syntax_w` を返すのは、 `syntax_type(&amp;#39;m&amp;#39;)` である。 |
+| `char_type translate(char_type c, bool icase)const;` | 入力文字を、その文字が属する等価クラスをあらわす一意の識別子に変形する。もし `icase` が真なら、戻り値は大文字小文字を考慮しない。&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;[等価クラスは互いに等価であると扱われなければならない文字すべての集合である。] |
+| `void transform(string_type&amp;amp; out, const string_type&amp;amp; in)const;` | 文字列 `in` をロケール依存のソートキーに変形し、`out` に結果を格納する。 |
+| `void transform_primary(string_type&amp;amp; out, const string_type&amp;amp; in)const;` | 文字列 `in` をロケール依存の主ソートキーに変形し、結果を `out` に格納する。 |
+| `bool is_separator(char_type c)const;` | `c` が行の区切りなら `true` を返す。 |
+| `bool is_combining(char_type c)const;` | `c` がユニコード複合文字なら `true` を返す。 |
+| `bool is_class(char_type c, uint32_t f)const;` | `c` がビットマップ `f` であらわされる文字クラスの要素なら `true` を返す。 |
+| `int toi(char_type c)const;` | 文字 `c` を10進整数に変換する。 &amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;[事前条件: `is_class(c,char_class_digit)==true` ] |
+| `int toi(const char_type*&amp;amp; first, const char_type* last, int radix)const;` | 文字列 `[first-last)` を基数 `radix` の整数値に変換する。最初の非数字文字を発見したら停止し、 `first` がその文字をさすように設定する。&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;[事前条件: `is_class(*first,char_class_digit)==true` ] |
+| `uint32_t lookup_classname(const char_type* first, const char_type* last)const;` | 文字クラス `[first-last)` をあらわすビットマップを返す。もし `[first-last)` が文字クラス名として認識されたければ、 `char_class_none` を返す。 |
+| `bool lookup_collatename(string_type&amp;amp; buf, const char_type* first, const char_type* last)const;` | シーケンス `[first-last)` が既知の照合要素名であれば、その照合要素を `buf` に格納し、 `true` を返す。そうでなければ、 `false` を返す。 |
+| `locale_type imbue(locale_type l);` | クラスをロケール `l` にする。 |
+| `locale_type getloc()const;` | 特性クラスのロケールを返す。 |
+| `std::string error_string(unsigned id)const;` | エラー番号 `id` に対するロケール依存のエラー文字列を返す。引数 `id` は POSIX 標準で述べられ、 `&amp;lt;boost/cregex.hpp&amp;gt;` で定義されている `REG_XXX` エラーコードのひとつである。 |
+| `mytraits();` | コンストラクタ |
+| `~ mytraits();` | デストラクタ |
+
+カスタマイズされた特性クラスの例が
+[Christian Engstr・](mailto:christian.engstrom@glindra.org)
+によっても提供されている。
+[`iso8859_1_regex_traits.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/iso8859_1_regex_traits/iso8859_1_regex_traits.cpp) 及び [`iso8859_1_regex_traits.hpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/example/iso8859_1_regex_traits/iso8859_1_regex_traits.hpp) を見よ。
+この例は `c_regex_traits` を継承し、二つのロケール特有の関数についてのそれ自身の実装を提供している。
+これは (ひとつのロケールに結び付けられる限り) 全てのプラットフォームでそのクラスが安定した振る舞いを与えることを保証する。
+
+---
+
+*Copyright* [*Dr John Maddock*](mailto:John_Maddock@compuserve.com) *1998-2001 all rights reserved.*
+
+---
+
+*Japanese Translation Copyright (C) 2003 [Kohske Takahashi](mailto:k_takahashi@cppll.jp)*
+
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.73.0リリースノート -- 1.73.0リリースノート : Beastのパッチを記載</title>
      <link href="https://boostjp.github.io/document/version/1_73_0.html"/>
      <id>930bc9dde919b10990a6558589675d244756bf47:document/version/1_73_0.md</id>
      <updated>2020-05-03T18:38:38+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/document/version/1_73_0.md b/document/version/1_73_0.md
index b65d477..e7d5b8b 100644
--- a/document/version/1_73_0.md
+++ b/document/version/1_73_0.md
@@ -22,6 +22,18 @@
     - `status_code_domain`のアサーションを削除
         - [パッチ](https://www.boost.org/patches/1_73_0/0001-outcome-assert.patch)
         - [コミット](https://github.com/ned14/status-code/commit/9f414ea58264fe0a62172a06f4653adc7556c164)
+- Boost.Beast
+    - [パッチ](https://www.boost.org/patches/1_73_0/0002-beast-coroutines.patch)
+    - すべての非同期初期化関数を`use_awaitable`に修正
+        - [コミット](https://github.com/boostorg/beast/commit/d016ff52afe57e0eecbc939211c988213eb61309)
+    - `use_awaitable`での`async_detect_ssl`を修正
+        - [コミット](https://github.com/boostorg/beast/commit/24cc4a7aeec454af0b92be76af479fbb9400697e)
+    - `span_body`でのC++20非推奨化の警告を修正
+        - [コミット](https://github.com/boostorg/beast/commit/a4b5cd8473d65fc1cdb3b440f989c3a355d301d9)
+    - スタンドアロン版が`string_view`によってコンパイルエラーになる問題を修正
+        - [コミット](https://github.com/boostorg/beast/commit/fda558e034433fe96d27ca2604ad34bf1b1ef4d6)
+    - MSVCの`/std:c++latest`オプションでコンパイルエラーになる問題を修正
+        - [コミット](https://github.com/boostorg/beast/commit/638e2d1244a3655e90f343c45ef27ff562540b61)
 
 
 ## 新ライブラリ
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>