<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2016-08-25T00:43:46.087166</updated>
  <id>65d2d41b-ed3a-4e97-873a-7928bc1cee4f</id>

  
    <entry>
      <title>Random Number Generator Library Concepts -- Merge branch &#39;master&#39; of https://github.com/boostjp/site
</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/random/random-concepts.html"/>
      <id>322a5c6eb824413a3d2722b64085dab0b4e31bec:archive/boost_docs/libs/random/random-concepts.md</id>
      <updated>2016-08-25 00:43:28 +0900
</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Random Number Generator Library Concepts&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;乱数は、以下に示すような様々に異なる問題領域において要求される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;計算 (シミュレーション、モンテ・カルロ積分)&lt;/li&gt;
&lt;li&gt;ゲーム (ランダムな敵の動き)&lt;/li&gt;
&lt;li&gt;セキュリティ (鍵生成)&lt;/li&gt;
&lt;li&gt;テスト (無作為なホワイトボックステスト)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost Random Number Generator Library は、計算やセキュリティの領域を要求する場合においてもこの生成子が使われ得るように、よく吟味され決定された特徴を持つ乱数生成子のフレームワークを提供する。&lt;/p&gt;
&lt;p&gt;計算領域における乱数の一般的な概論は、以下を参照のこと。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&#34;Numerical Recipes in C: The art of scientific computing&#34;, William
H. Press, Saul A. Teukolsky, William A. Vetterling, Brian P. Flannery,
2nd ed., 1992, pp. 274-328&lt;br /&gt;
[訳注: 日本語版は、丹慶 勝市 他訳
「ニューメリカルレシピ・イン・シー 日本語版―C言語による数値計算のレシピ」
東京: 技術評論社、1993年 (ISBN: 4874085601)]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;問題領域の要求に応じて、乱数生成子の様々なバリエーションが利用できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非決定論的乱数生成子&lt;/li&gt;
&lt;li&gt;擬似乱数生成子&lt;/li&gt;
&lt;li&gt;準乱数生成子&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全てのバリエーションはいくつかの共通する特徴をもっている。
これらの（STLにおける）concept は、NumberGenerator や UniformRandomNumberGenerator と呼ばれる。
各 concept の定義は次節を参照のこと。&lt;/p&gt;
&lt;p&gt;このライブラリの最終目標は以下のとおりである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;サードパーティ製の乱数生成子との結合を容易にする。&lt;/li&gt;
&lt;li&gt;生成子の妥当性を検証するインターフェイスの定義。&lt;/li&gt;
&lt;li&gt;有名なディストリビューション[?]を模範とする簡便なフロントエンドクラスの提供。&lt;/li&gt;
&lt;li&gt;最大効率の提供。&lt;/li&gt;
&lt;li&gt;フロントエンド処理における量子化効果を操作可能にする。(まだできていない)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a name=&#34;number_generator&#34;&gt;Number Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;数生成子は、引数を取らない &lt;em&gt;関数オブジェクト&lt;/em&gt; (std:20.3 [lib.function.object]) であり、全て &lt;code&gt;operator()&lt;/code&gt; の呼出し毎に数値を返す。&lt;/p&gt;
&lt;p&gt;以下の表において、&lt;code&gt;X&lt;/code&gt; は、&lt;code&gt;T&lt;/code&gt; 型のオブジェクトを返す数生成子クラスである。
また、&lt;code&gt;u&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; の値である。&lt;/p&gt;
&lt;h3&gt;NumberGenerator の必須条件&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返値型&lt;/th&gt;
&lt;th&gt;事前/事後条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::result_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::numeric_limits&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; は真であり、&lt;code&gt;T&lt;/code&gt; は &lt;code&gt;LessThanComparable&lt;/code&gt; である。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;u.operator()()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; NumberGenerator の必須条件は、返される数値の特性にいかなる制約を課すのもではない。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;uniform-rng&#34;&gt;Uniform Random Number Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一定乱数生成子は、与えられた範囲で一様に生成される乱数列を提供する NumberGenerator である。
この範囲は、コンパイル時に固定されているか、もしくはオブジェクトの実行時構築の後(のみ)でも与えることができる。&lt;/p&gt;
&lt;p&gt;いくつかの(有限)集合 S の&lt;em&gt;下限値&lt;/em&gt;は、S の(唯一の)メンバ l であり、S における全ての v に関して、 l &amp;lt;= v が成り立つ。
同様に、いくつかの(有限)集合 S の&lt;em&gt;上限値&lt;/em&gt;は、S の(唯一の)メンバ u であり、S における全ての v に関して、 v &amp;lt;= u が成り立つ。&lt;/p&gt;
&lt;p&gt;以下の表において、&lt;code&gt;X&lt;/code&gt; は、&lt;code&gt;T&lt;/code&gt; 型のオブジェクトを返す数生成子クラスであり、 &lt;code&gt;v&lt;/code&gt; は、&lt;code&gt;X&lt;/code&gt; の定値である。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UniformRandomNumberGenerator&lt;/code&gt; の必須条件&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返値型&lt;/th&gt;
&lt;th&gt;事前/事後条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::has_fixed_range&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時定数。 &lt;code&gt;true&lt;/code&gt; であれば、乱数が一定に生成される範囲はコンパイル時に決定しており、 メンバ変数 &lt;code&gt;min_value&lt;/code&gt; と &lt;code&gt;max_value&lt;/code&gt; が存在する。 &lt;em&gt;注意:&lt;/em&gt; このフラグは、コンパイラの制限により &lt;code&gt;false&lt;/code&gt; になり得る。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::min_value&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時定数。 &lt;code&gt;min_value&lt;/code&gt; は &lt;code&gt;v.min()&lt;/code&gt; と同値である。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::max_value&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時定数。 &lt;code&gt;max_value&lt;/code&gt; は &lt;code&gt;v.max()&lt;/code&gt; と同値である。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v.min()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator()&lt;/code&gt; によって返される全ての値集合の下限を返す。 この関数の返値はオブジェクトの生存期間を通じて不変である。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v.max()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::numeric_limits&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; が真であれば、&lt;code&gt;operator()&lt;/code&gt; によって返される全ての値集合の上限、偽であれば、&lt;code&gt;operator()&lt;/code&gt; によって返される全ての値集合の上限より大きな、表現可能な最小の数を返す。いかなる場合においても、この関数の返値はオブジェクトの生存期間を通じて不変である。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;メンバ関数 &lt;code&gt;min&lt;/code&gt;、&lt;code&gt;max&lt;/code&gt;、および &lt;code&gt;operator()&lt;/code&gt; は、償却定数時間計算量を持つ。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; 整数生成子 (i.e. 整数 &lt;code&gt;T&lt;/code&gt;) においては、生成される値 &lt;code&gt;x&lt;/code&gt; は、 &lt;code&gt;min() &amp;lt;= x &amp;lt;= max()&lt;/code&gt; を満たす。
非整数生成子 (i.e. 非整数 &lt;code&gt;T&lt;/code&gt;)においては、 生成される値 &lt;code&gt;x&lt;/code&gt; は、&lt;code&gt;min() &amp;lt;= x &amp;lt; max()&lt;/code&gt; を満たす。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;論拠:&lt;/em&gt; &lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; による範囲の記述は2つの目的に役立つ。
一つは、[0..1) といったような正統な範囲に対する値のスケーリングを可能にする。
もう一つは、さらに進んだプロセスのために妥当であるかもしれない値の意味のあるビット(significant bit) を記述する。&lt;/p&gt;
&lt;p&gt;整数における範囲は、閉じられた間隔 [min, max] であるが、これは基礎となる型が半開の間隔 [min, max+1) を表現することができない可能性があるためである。
非整数における範囲は、これまでの版のどちらつかずの状態より実用的であるため、半開の間隔 [min, max)である。 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; UniformRandomNumberGenerator コンセプトは &lt;code&gt;operator()(long)&lt;/code&gt; を必須としていないため、 RandomNumberGenerator (std:25.2.11 [lib.alg.random.shuffle]) の必須事項を満足していない。
この要求を満足するためには &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-misc.html#random_number_generator&#34; target=&#34;_blank&#34;&gt;random_number_generator&lt;/a&gt;&lt;/code&gt; アダプタを使用すること。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;論拠:&lt;/em&gt; 整数範囲を持つ生成子による出力の異なる整数範囲へのマッピングは些細なことではないので、 &lt;code&gt;operator()(long)&lt;/code&gt; は供給されていない。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;nondet-rng&#34;&gt;Non-deterministic Uniform Random Number Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;非決定論的一様乱数生成子は、確率過程に基づく UniformRandomGenerator である。
それゆえ、この生成子は一連の真に無作為な数を提供する。
このような過程には、放射性核種崩壊、ツェーナー・ダイオードのノイズ、量子粒のトンネリング、サイコロを転がす、壺から引き当てる、コインを投げる、といった例を挙げることができる。
環境に依存するならば、ネットワーク・パケットの内部到達時間や、キーボードのイベントも確率過程の近似値になりえる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/nondet_random.html#random_device&#34; target=&#34;_blank&#34;&gt;random_device&lt;/a&gt;&lt;/code&gt; クラスは非決定論的乱数生成子のモデルである。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; このタイプの乱数生成子は、セキュリティ・アプリケーションに有用である。
外部からの攻撃者が数を予想し、暗号や認証鍵を入手されるのを防ぐ。
そこで、このコンセプトのモデルは、環境によって可能な範囲にかけて、いかなる情報も漏れないよう注意深くなければならない。
例えば、一時的な記憶域が必要でなくなったときにすぐに明示的に消去することは賢明である。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;pseudo-rng&#34;&gt;Pseudo-Random Number Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;擬似乱数生成子は、決定論的擬似乱数列を提供する UniformRandomNumberGenerator である。
この擬似乱数は、いくつかのアルゴリズムと内部状態に基づいている。
線形合同生成子と逆合同生成子[?]は、このような擬似乱数生成子の例である。
しばしば、これらの生成子はパラメータに非常に敏感である。
悪い実装が使われるのを避けるため、外部のテスト・スーツは生成された数列と提供された値の妥当性が実際に一致することを確かめるべきである。&lt;/p&gt;
&lt;p&gt;Donald E. Knuth は彼の著書 &#34;The Art of Computer Programming, Vol. 2, 3rd edition, Addison-Wesley, 1997&#34; の中で、擬似乱数生成に関して広範囲に及ぶ概観を示している。
特定の生成子に関する記述の中には補足の参考資料が含まれている。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; 擬似乱数生成子の状態は必然的に有限であるため、生成子によって返される数列はいずれはループすることになる。&lt;/p&gt;
&lt;p&gt;UniformRandomNumberGenerator の必須事項に加えて、擬似乱数生成子にはいくらか追加の必須事項がある。
下記の表において、&lt;code&gt;X&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; 型のオブジェクトを返す擬似乱数生成子クラスであり、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の値、&lt;code&gt;u&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; の値、そして &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;const&lt;/code&gt; な &lt;code&gt;X&lt;/code&gt; の値である。&lt;/p&gt;
&lt;h3&gt;PseudoRandomNumberGenerator 必須事項&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返値型&lt;/th&gt;
&lt;th&gt;事前/事後条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;実装定義の状態で生成子を作成する。 &lt;em&gt;注意:&lt;/em&gt; このように作成された生成子は、従属[?]しているか全く同一の乱数列を生成する可能性がある。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;explicit X(...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ユーザに提供された状態を用いて生成子を作成する。 実装はコンストラクタの仮引数を明示すること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;u.seed(...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;現在の状態を引数に従って設定する。 少なくともデフォルトではないコンストラクタと同様のシグネチャを持つ関数を提供すること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v.validation(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;あらかじめ計算されハードコーディングされた、生成子の乱数列における 10001 番目の要素と &lt;code&gt;x&lt;/code&gt; とを比較する。 妥当性の検証が有意味であるために、生成子はデフォルトコンストラクタによって構築されていなければならず、また &lt;code&gt;seed&lt;/code&gt; は呼ばれていてはならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The &lt;code&gt;seed&lt;/code&gt; member function is similar to the &lt;code&gt;assign&lt;/code&gt; member function in STL containers.
However, the naming did not seem appropriate.&lt;/p&gt;
&lt;p&gt;Classes which model a pseudo-random number generator shall also model EqualityComparable, i.e. implement &lt;code&gt;operator==&lt;/code&gt;.
Two pseudo-random number generators are defined to be &lt;em&gt;equivalent&lt;/em&gt; if they both return an identical sequence of numbers starting from a given state.&lt;/p&gt;
&lt;p&gt;Classes which model a pseudo-random number generator should also model the Streamable concept, i.e. implement &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;.
If so, &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; writes all current state of the pseudo-random number generator to the given &lt;code&gt;ostream&lt;/code&gt; so that &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; can restore the state at a later time.
The state shall be written in a platform-independent manner, but it is assumed that the &lt;code&gt;locale&lt;/code&gt;s used for writing and reading be the same.&lt;/p&gt;
&lt;p&gt;The pseudo-random number generator with the restored state and the original at the just-written state shall be equivalent.&lt;/p&gt;
&lt;p&gt;Classes which model a pseudo-random number generator may also model the CopyConstructible and Assignable concepts.
However, note that the sequences of the original and the copy are strongly correlated (in fact, they are identical), which may make them unsuitable for some problem domains.
Thus, copying pseudo-random number generators is discouraged; they should always be passed by (non-&lt;code&gt;const&lt;/code&gt;) reference.&lt;/p&gt;
&lt;p&gt;The classes &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#rand48&#34; target=&#34;_blank&#34;&gt;rand48&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#linear_congruential&#34; target=&#34;_blank&#34;&gt;minstd_rand&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#mersenne_twister&#34; target=&#34;_blank&#34;&gt;mt19937&lt;/a&gt;&lt;/code&gt; are models for a pseudo-random number generator.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This type of random-number generator is useful for numerics, games and testing.
The non-zero arguments constructor(s) and the &lt;code&gt;seed()&lt;/code&gt; member function(s) allow for a user-provided state to be installed in the generator.
This is useful for debugging Monte-Carlo algorithms and analyzing particular test scenarios.
The Streamable concept allows to save/restore the state of the generator, for example to re-run a test suite at a later time.&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;quasi-rng&#34;&gt;Quasi-Random Number Generators&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A quasi-random number generator is a Number Generator which provides a deterministic sequence of numbers, based on some algorithm and internal state.
The numbers do not have any statistical properties (such as uniform distribution or independence of successive values).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Quasi-random number generators are useful for Monte-Carlo integrations where specially crafted sequences of random numbers will make the approximation converge faster.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[Does anyone have a model?]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Jens Maurer, 2000-02-23&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon
</name>
        <email>melt@e-ml.jp
</email>
      </author>
    </entry>
  
    <entry>
      <title>Random Number Generator Library Concepts -- パースエラーを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/random/random-concepts.html"/>
      <id>7e51be86987c27989cfcbe13268ec50f747e7c45:archive/boost_docs/libs/random/random-concepts.md</id>
      <updated>2016-08-25 00:43:05 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Random Number Generator Library Concepts&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;乱数は、以下に示すような様々に異なる問題領域において要求される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;計算 (シミュレーション、モンテ・カルロ積分)&lt;/li&gt;
&lt;li&gt;ゲーム (ランダムな敵の動き)&lt;/li&gt;
&lt;li&gt;セキュリティ (鍵生成)&lt;/li&gt;
&lt;li&gt;テスト (無作為なホワイトボックステスト)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost Random Number Generator Library は、計算やセキュリティの領域を要求する場合においてもこの生成子が使われ得るように、よく吟味され決定された特徴を持つ乱数生成子のフレームワークを提供する。&lt;/p&gt;
&lt;p&gt;計算領域における乱数の一般的な概論は、以下を参照のこと。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&#34;Numerical Recipes in C: The art of scientific computing&#34;, William
H. Press, Saul A. Teukolsky, William A. Vetterling, Brian P. Flannery,
2nd ed., 1992, pp. 274-328&lt;br /&gt;
[訳注: 日本語版は、丹慶 勝市 他訳
「ニューメリカルレシピ・イン・シー 日本語版―C言語による数値計算のレシピ」
東京: 技術評論社、1993年 (ISBN: 4874085601)]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;問題領域の要求に応じて、乱数生成子の様々なバリエーションが利用できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非決定論的乱数生成子&lt;/li&gt;
&lt;li&gt;擬似乱数生成子&lt;/li&gt;
&lt;li&gt;準乱数生成子&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全てのバリエーションはいくつかの共通する特徴をもっている。
これらの（STLにおける）concept は、NumberGenerator や UniformRandomNumberGenerator と呼ばれる。
各 concept の定義は次節を参照のこと。&lt;/p&gt;
&lt;p&gt;このライブラリの最終目標は以下のとおりである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;サードパーティ製の乱数生成子との結合を容易にする。&lt;/li&gt;
&lt;li&gt;生成子の妥当性を検証するインターフェイスの定義。&lt;/li&gt;
&lt;li&gt;有名なディストリビューション[?]を模範とする簡便なフロントエンドクラスの提供。&lt;/li&gt;
&lt;li&gt;最大効率の提供。&lt;/li&gt;
&lt;li&gt;フロントエンド処理における量子化効果を操作可能にする。(まだできていない)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a name=&#34;number_generator&#34;&gt;Number Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;数生成子は、引数を取らない &lt;em&gt;関数オブジェクト&lt;/em&gt; (std:20.3 [lib.function.object]) であり、全て &lt;code&gt;operator()&lt;/code&gt; の呼出し毎に数値を返す。&lt;/p&gt;
&lt;p&gt;以下の表において、&lt;code&gt;X&lt;/code&gt; は、&lt;code&gt;T&lt;/code&gt; 型のオブジェクトを返す数生成子クラスである。
また、&lt;code&gt;u&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; の値である。&lt;/p&gt;
&lt;h3&gt;NumberGenerator の必須条件&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返値型&lt;/th&gt;
&lt;th&gt;事前/事後条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::result_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::numeric_limits&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; は真であり、&lt;code&gt;T&lt;/code&gt; は &lt;code&gt;LessThanComparable&lt;/code&gt; である。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;u.operator()()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; NumberGenerator の必須条件は、返される数値の特性にいかなる制約を課すのもではない。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;uniform-rng&#34;&gt;Uniform Random Number Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一定乱数生成子は、与えられた範囲で一様に生成される乱数列を提供する NumberGenerator である。
この範囲は、コンパイル時に固定されているか、もしくはオブジェクトの実行時構築の後(のみ)でも与えることができる。&lt;/p&gt;
&lt;p&gt;いくつかの(有限)集合 S の&lt;em&gt;下限値&lt;/em&gt;は、S の(唯一の)メンバ l であり、S における全ての v に関して、 l &amp;lt;= v が成り立つ。
同様に、いくつかの(有限)集合 S の&lt;em&gt;上限値&lt;/em&gt;は、S の(唯一の)メンバ u であり、S における全ての v に関して、 v &amp;lt;= u が成り立つ。&lt;/p&gt;
&lt;p&gt;以下の表において、&lt;code&gt;X&lt;/code&gt; は、&lt;code&gt;T&lt;/code&gt; 型のオブジェクトを返す数生成子クラスであり、 &lt;code&gt;v&lt;/code&gt; は、&lt;code&gt;X&lt;/code&gt; の定値である。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UniformRandomNumberGenerator&lt;/code&gt; の必須条件&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返値型&lt;/th&gt;
&lt;th&gt;事前/事後条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::has_fixed_range&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時定数。 &lt;code&gt;true&lt;/code&gt; であれば、乱数が一定に生成される範囲はコンパイル時に決定しており、 メンバ変数 &lt;code&gt;min_value&lt;/code&gt; と &lt;code&gt;max_value&lt;/code&gt; が存在する。 &lt;em&gt;注意:&lt;/em&gt; このフラグは、コンパイラの制限により &lt;code&gt;false&lt;/code&gt; になり得る。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::min_value&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時定数。 &lt;code&gt;min_value&lt;/code&gt; は &lt;code&gt;v.min()&lt;/code&gt; と同値である。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X::max_value&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時定数。 &lt;code&gt;max_value&lt;/code&gt; は &lt;code&gt;v.max()&lt;/code&gt; と同値である。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v.min()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator()&lt;/code&gt; によって返される全ての値集合の下限を返す。 この関数の返値はオブジェクトの生存期間を通じて不変である。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v.max()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::numeric_limits&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; が真であれば、&lt;code&gt;operator()&lt;/code&gt; によって返される全ての値集合の上限、偽であれば、&lt;code&gt;operator()&lt;/code&gt; によって返される全ての値集合の上限より大きな、表現可能な最小の数を返す。いかなる場合においても、この関数の返値はオブジェクトの生存期間を通じて不変である。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;メンバ関数 &lt;code&gt;min&lt;/code&gt;、&lt;code&gt;max&lt;/code&gt;、および &lt;code&gt;operator()&lt;/code&gt; は、償却定数時間計算量を持つ。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; 整数生成子 (i.e. 整数 &lt;code&gt;T&lt;/code&gt;) においては、生成される値 &lt;code&gt;x&lt;/code&gt; は、 &lt;code&gt;min() &amp;lt;= x &amp;lt;= max()&lt;/code&gt; を満たす。
非整数生成子 (i.e. 非整数 &lt;code&gt;T&lt;/code&gt;)においては、 生成される値 &lt;code&gt;x&lt;/code&gt; は、&lt;code&gt;min() &amp;lt;= x &amp;lt; max()&lt;/code&gt; を満たす。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;論拠:&lt;/em&gt; &lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; による範囲の記述は2つの目的に役立つ。
一つは、[0..1) といったような正統な範囲に対する値のスケーリングを可能にする。
もう一つは、さらに進んだプロセスのために妥当であるかもしれない値の意味のあるビット(significant bit) を記述する。&lt;/p&gt;
&lt;p&gt;整数における範囲は、閉じられた間隔 [min, max] であるが、これは基礎となる型が半開の間隔 [min, max+1) を表現することができない可能性があるためである。
非整数における範囲は、これまでの版のどちらつかずの状態より実用的であるため、半開の間隔 [min, max)である。 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; UniformRandomNumberGenerator コンセプトは &lt;code&gt;operator()(long)&lt;/code&gt; を必須としていないため、 RandomNumberGenerator (std:25.2.11 [lib.alg.random.shuffle]) の必須事項を満足していない。
この要求を満足するためには &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-misc.html#random_number_generator&#34; target=&#34;_blank&#34;&gt;random_number_generator&lt;/a&gt;&lt;/code&gt; アダプタを使用すること。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;論拠:&lt;/em&gt; 整数範囲を持つ生成子による出力の異なる整数範囲へのマッピングは些細なことではないので、 &lt;code&gt;operator()(long)&lt;/code&gt; は供給されていない。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;nondet-rng&#34;&gt;Non-deterministic Uniform Random Number Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;非決定論的一様乱数生成子は、確率過程に基づく UniformRandomGenerator である。
それゆえ、この生成子は一連の真に無作為な数を提供する。
このような過程には、放射性核種崩壊、ツェーナー・ダイオードのノイズ、量子粒のトンネリング、サイコロを転がす、壺から引き当てる、コインを投げる、といった例を挙げることができる。
環境に依存するならば、ネットワーク・パケットの内部到達時間や、キーボードのイベントも確率過程の近似値になりえる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/nondet_random.html#random_device&#34; target=&#34;_blank&#34;&gt;random_device&lt;/a&gt;&lt;/code&gt; クラスは非決定論的乱数生成子のモデルである。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; このタイプの乱数生成子は、セキュリティ・アプリケーションに有用である。
外部からの攻撃者が数を予想し、暗号や認証鍵を入手されるのを防ぐ。
そこで、このコンセプトのモデルは、環境によって可能な範囲にかけて、いかなる情報も漏れないよう注意深くなければならない。
例えば、一時的な記憶域が必要でなくなったときにすぐに明示的に消去することは賢明である。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;pseudo-rng&#34;&gt;Pseudo-Random Number Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;擬似乱数生成子は、決定論的擬似乱数列を提供する UniformRandomNumberGenerator である。
この擬似乱数は、いくつかのアルゴリズムと内部状態に基づいている。
線形合同生成子と逆合同生成子[?]は、このような擬似乱数生成子の例である。
しばしば、これらの生成子はパラメータに非常に敏感である。
悪い実装が使われるのを避けるため、外部のテスト・スーツは生成された数列と提供された値の妥当性が実際に一致することを確かめるべきである。&lt;/p&gt;
&lt;p&gt;Donald E. Knuth は彼の著書 &#34;The Art of Computer Programming, Vol. 2, 3rd edition, Addison-Wesley, 1997&#34; の中で、擬似乱数生成に関して広範囲に及ぶ概観を示している。
特定の生成子に関する記述の中には補足の参考資料が含まれている。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt; 擬似乱数生成子の状態は必然的に有限であるため、生成子によって返される数列はいずれはループすることになる。&lt;/p&gt;
&lt;p&gt;UniformRandomNumberGenerator の必須事項に加えて、擬似乱数生成子にはいくらか追加の必須事項がある。
下記の表において、&lt;code&gt;X&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; 型のオブジェクトを返す擬似乱数生成子クラスであり、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の値、&lt;code&gt;u&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; の値、そして &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;const&lt;/code&gt; な &lt;code&gt;X&lt;/code&gt; の値である。&lt;/p&gt;
&lt;h3&gt;PseudoRandomNumberGenerator 必須事項&lt;/h3&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返値型&lt;/th&gt;
&lt;th&gt;事前/事後条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;実装定義の状態で生成子を作成する。 &lt;em&gt;注意:&lt;/em&gt; このように作成された生成子は、従属[?]しているか全く同一の乱数列を生成する可能性がある。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;explicit X(...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;ユーザに提供された状態を用いて生成子を作成する。 実装はコンストラクタの仮引数を明示すること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;u.seed(...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;現在の状態を引数に従って設定する。 少なくともデフォルトではないコンストラクタと同様のシグネチャを持つ関数を提供すること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v.validation(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;あらかじめ計算されハードコーディングされた、生成子の乱数列における 10001 番目の要素と &lt;code&gt;x&lt;/code&gt; とを比較する。 妥当性の検証が有意味であるために、生成子はデフォルトコンストラクタによって構築されていなければならず、また &lt;code&gt;seed&lt;/code&gt; は呼ばれていてはならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The &lt;code&gt;seed&lt;/code&gt; member function is similar to the &lt;code&gt;assign&lt;/code&gt; member function in STL containers.
However, the naming did not seem appropriate.&lt;/p&gt;
&lt;p&gt;Classes which model a pseudo-random number generator shall also model EqualityComparable, i.e. implement &lt;code&gt;operator==&lt;/code&gt;.
Two pseudo-random number generators are defined to be &lt;em&gt;equivalent&lt;/em&gt; if they both return an identical sequence of numbers starting from a given state.&lt;/p&gt;
&lt;p&gt;Classes which model a pseudo-random number generator should also model the Streamable concept, i.e. implement &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;.
If so, &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; writes all current state of the pseudo-random number generator to the given &lt;code&gt;ostream&lt;/code&gt; so that &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; can restore the state at a later time.
The state shall be written in a platform-independent manner, but it is assumed that the &lt;code&gt;locale&lt;/code&gt;s used for writing and reading be the same.&lt;/p&gt;
&lt;p&gt;The pseudo-random number generator with the restored state and the original at the just-written state shall be equivalent.&lt;/p&gt;
&lt;p&gt;Classes which model a pseudo-random number generator may also model the CopyConstructible and Assignable concepts.
However, note that the sequences of the original and the copy are strongly correlated (in fact, they are identical), which may make them unsuitable for some problem domains.
Thus, copying pseudo-random number generators is discouraged; they should always be passed by (non-&lt;code&gt;const&lt;/code&gt;) reference.&lt;/p&gt;
&lt;p&gt;The classes &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#rand48&#34; target=&#34;_blank&#34;&gt;rand48&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#linear_congruential&#34; target=&#34;_blank&#34;&gt;minstd_rand&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#mersenne_twister&#34; target=&#34;_blank&#34;&gt;mt19937&lt;/a&gt;&lt;/code&gt; are models for a pseudo-random number generator.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This type of random-number generator is useful for numerics, games and testing.
The non-zero arguments constructor(s) and the &lt;code&gt;seed()&lt;/code&gt; member function(s) allow for a user-provided state to be installed in the generator.
This is useful for debugging Monte-Carlo algorithms and analyzing particular test scenarios.
The Streamable concept allows to save/restore the state of the generator, for example to re-run a test suite at a later time.&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;quasi-rng&#34;&gt;Quasi-Random Number Generators&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A quasi-random number generator is a Number Generator which provides a deterministic sequence of numbers, based on some algorithm and internal state.
The numbers do not have any statistical properties (such as uniform distribution or independence of successive values).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Quasi-random number generators are useful for Monte-Carlo integrations where specially crafted sequences of random numbers will make the approximation converge faster.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[Does anyone have a model?]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Jens Maurer, 2000-02-23&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Merge branch &#39;master&#39; of https://github.com/boostjp/site
</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>b12c90b7c78281c8b2af78e6d4d866d02d5cd5ca:archive/boost_docs/libs.md</id>
      <updated>2016-08-24 23:26:18 +0900
</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;各ライブラリの翻訳ドキュメント&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html&#34;&gt;function&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;遅延呼び出し及びコールバックのための関数オブジェクトラッパ。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional.html&#34;&gt;functional&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;機能強化された関数オブジェクトアダプタ。 Mark Rodgers 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph.html&#34;&gt;graph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;汎用グラフコンポーネント及びアルゴリズム。 Jeremy Siek and a University of Notre Dame team 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/io/ios_state.html&#34;&gt;io state savers&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;入出力の状態を保存して、データが化けるのを防ぐ。 Daryle Walker 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/multi_array.html&#34;&gt;muti_array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリ上で連続したデータの配列のための多次元コンテナとアダプタ。 Ron Garcia 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/random.html&#34;&gt;random&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;乱数生成のためのシステム一式。 Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/signals.html&#34;&gt;signals&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;管理されたシグナルとスロットのコールバックでの実装。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/smart_ptr.html&#34;&gt;smart_ptr&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;5つのスマートポインタクラステンプレート Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/type_traits.html&#34;&gt;type_traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型の基本的な特徴のためのテンプレート。 John Maddock, Steve Cleary, et al 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon
</name>
        <email>melt@e-ml.jp
</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost Random Number Library -- Merge branch &#39;master&#39; of https://github.com/boostjp/site
</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/random.html"/>
      <id>b12c90b7c78281c8b2af78e6d4d866d02d5cd5ca:archive/boost_docs/libs/random.md</id>
      <updated>2016-08-24 23:26:18 +0900
</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost Random Number Library&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;乱数は、様々な種類のアプリケーションで役立つ。
Boost Random Number Library (略してBoost.Random)は、例えば一様分布といったような、有用な特徴をもつ乱数を生成するための膨大で多様な生成子と分布を供給する。&lt;/p&gt;
&lt;p&gt;導入と基本的な概念の定義の理解のため、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/random/random-concepts.html&#34;&gt;concepts documentation[概要]&lt;/a&gt; を読むべきである。
早く始めたいのなら、&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random_demo.cpp&#34; target=&#34;_blank&#34;&gt;random_demo.cpp&lt;/a&gt; を一読すれば十分であろう。&lt;/p&gt;
&lt;h2&gt;Library Organization&lt;/h2&gt;
&lt;p&gt;ライブラリは全て &lt;code&gt;boost/random/&lt;/code&gt; ディレクトリ中に、複数のヘッダー・ファイルに分かれて存在している。
さらに、&lt;code&gt;boost/random/&lt;/code&gt; 中に存在する他の全てのヘッダー・ファイルをインクルードしている便利なヘッダー・ファイルが、 &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random.hpp&#34; target=&#34;_blank&#34;&gt;boost/random.hpp&lt;/a&gt;&lt;/code&gt; として利用可能である。&lt;/p&gt;
&lt;p&gt;各乱数生成子は、以下のヘッダー・ファイルで利用可能である。
生成子については &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-variate.html&#34; target=&#34;_blank&#34;&gt;documentation&lt;/a&gt; を読まれたい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/linear_congruential.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/linear_congruential.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/additive_combine.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/additive_combine.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/inversive_congruential.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/inversive_congruential.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/shuffle_output.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/shuffle_output.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/mersenne_twister.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/mersenne_twister.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/lagged_fibonacci.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/lagged_fibonacci.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に、各乱数分布は、以下のヘッダー・ファイルで利用可能である。
分布については &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-distributions.html&#34; target=&#34;_blank&#34;&gt;documentation&lt;/a&gt; を読まれたい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_smallint.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_smallint.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_int.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_int.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_01.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_01.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_real.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_real.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/triangle_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/triangle_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/bernoulli_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/bernoulli_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/cauchy_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/cauchy_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/exponential_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/exponential_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/geometric_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/geometric_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/normal_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/normal_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/lognormal_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/lognormal_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_on_sphere.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_on_sphere.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加えて、非決定論的乱数生成子が &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/nondet_random.hpp&#34; target=&#34;_blank&#34;&gt;&amp;lt;boost/nondet_random.hpp&amp;gt;&lt;/a&gt;&lt;/code&gt; ヘッダで利用可能である。
(&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/nondet_random.html&#34; target=&#34;_blank&#34;&gt;Documentation&lt;/a&gt;&lt;/code&gt; も同様)&lt;/p&gt;
&lt;p&gt;生成子と分布関数のインターフェースを他のコンセプトに配置するために、&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-misc.html&#34; target=&#34;_blank&#34;&gt;decorators[装飾子?]&lt;/a&gt;&lt;/code&gt; が利用可能である。&lt;/p&gt;
&lt;h2&gt;Tests&lt;/h2&gt;
&lt;p&gt;広範囲にわたる擬似乱数生成子と分布のためのテストスーツが &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random_test.cpp&#34; target=&#34;_blank&#34;&gt;random_test.cpp&lt;/a&gt; で利用可能である。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random_speed.cpp&#34; target=&#34;_blank&#34;&gt;random_speed.cpp&lt;/a&gt; を使用して得られた &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-performance.html&#34; target=&#34;_blank&#34;&gt;performance results[実行結果]&lt;/a&gt; も見ることができる。&lt;/p&gt;
&lt;h2&gt;Rationale&lt;/h2&gt;
&lt;p&gt;決定論的乱数と非決定論的乱数の生成及び算出手法は根本的に異なるものである。
おまけに、現代のコンピュータで本来的に使用されている決定論的[乱数生成]デザインのために、非決定論的乱数の生成手段を実装することは困難である。
そこで、この乱数ライブラリは、2つの異なる適用領域を反映して、複数のヘッダー・ファイルに分割されている。&lt;/p&gt;
&lt;h2&gt;History and Acknowledgements&lt;/h2&gt;
&lt;p&gt;1999年11月、Jeet Sakumaran は仮想関数に基づくフレームワークを提案、後にテンプレートに基づく方法の大筋を記した。
Ed Brey が、Microsoft Visual C++ がクラス内のメンバ初期化をサポートしていないことを指摘し、&lt;code&gt;enum&lt;/code&gt; による回避手段を提案。
Dave Abrahams が量子化の問題を強調した。&lt;/p&gt;
&lt;p&gt;この乱数ライブラリの最初の公のリリースは、2000年3月、boost メーリングリストでの広範囲にわたる議論の末に実現した。
Beman Dawes のオリジナルの &lt;code&gt;min_rand&lt;/code&gt; クラス、移植性の修正、文書の提案、そして全般的な指導に多大なる感謝を送る。
Harry Erwin は要求に対するさらなる識見をもたらすヘッダー・ファイルを送ってくれた。
Ed Brey と Beman Dawes はイテレータのようなインターフェースを欲していた。&lt;/p&gt;
&lt;p&gt;Beman Dawes は、Matthias Trayer と Csaba Szepesvari、そして Thomas Holenstein が詳細なコメントを記述している間に、正式な再検討を成し遂げた。
この再検討された版は、2000年6月17日に公式に boost の一部となった。&lt;/p&gt;
&lt;p&gt;Gary Powell は、コードのきれいさについての提案を貢献した。
Dave Abraham と Howard Hinnant は基本的な生成子テンプレートを &lt;code&gt;boost::detail&lt;/code&gt; 名前空間から &lt;code&gt;boost::random&lt;/code&gt; に移すよう提案した。&lt;/p&gt;
&lt;p&gt;Ed Brey は過度の警告を取り除くよう頼み、&lt;code&gt;uint64_t&lt;/code&gt; の取り扱い方について手助けをした。
Andreas Scherer は MSVC でのテストを行った。
Matthias Troyer は遅れのあるフィボナッチ(lagged_fibonacci)生成子を提供した。
Michael Stevens は normal_distribution のコピーセマンティックに潜んでいたバグを発見し、文書の改良を提案した。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jens_maurer.htm&#34; target=&#34;_blank&#34;&gt;Jens Maurer&lt;/a&gt;, 2001-08-31&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 KATOU Akira &amp;lt;turugina@blue.sakura.ne.jp&amp;gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の
複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」
に提供されており、いかなる明示的、暗黙的保証も行わない。また、
いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon
</name>
        <email>melt@e-ml.jp
</email>
      </author>
    </entry>
  
    <entry>
      <title>Random Number Generator Library Concepts -- Merge branch &#39;master&#39; of https://github.com/boostjp/site
</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/random/random-concepts.html"/>
      <id>b12c90b7c78281c8b2af78e6d4d866d02d5cd5ca:archive/boost_docs/libs/random/random-concepts.md</id>
      <updated>2016-08-24 23:26:18 +0900
</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/random/random-concepts.md b/archive/boost_docs/libs/random/random-concepts.md
new file mode 100644
index 0000000..5b201b7
--- /dev/null
+++ b/archive/boost_docs/libs/random/random-concepts.md
@@ -0,0 +1,166 @@
+#Random Number Generator Library Concepts
+
+##Introduction
+
+乱数は、以下に示すような様々に異なる問題領域において要求される。
+
+- 計算 (シミュレーション、モンテ・カルロ積分)
+- ゲーム (ランダムな敵の動き)
+- セキュリティ (鍵生成)
+- テスト (無作為なホワイトボックステスト)
+
+Boost Random Number Generator Library は、計算やセキュリティの領域を要求する場合においてもこの生成子が使われ得るように、よく吟味され決定された特徴を持つ乱数生成子のフレームワークを提供する。
+
+計算領域における乱数の一般的な概論は、以下を参照のこと。
+
+&amp;gt; &amp;#34;Numerical Recipes in C: The art of scientific computing&amp;#34;, William
+&amp;gt; H. Press, Saul A. Teukolsky, William A. Vetterling, Brian P. Flannery,
+&amp;gt; 2nd ed., 1992, pp. 274-328&amp;lt;br&amp;gt;
+&amp;gt; [訳注: 日本語版は、丹慶 勝市 他訳
+&amp;gt; 「ニューメリカルレシピ・イン・シー 日本語版―C言語による数値計算のレシピ」
+&amp;gt; 東京: 技術評論社、1993年 (ISBN: 4874085601)]
+
+問題領域の要求に応じて、乱数生成子の様々なバリエーションが利用できる。
+
+- 非決定論的乱数生成子
+- 擬似乱数生成子
+- 準乱数生成子
+
+全てのバリエーションはいくつかの共通する特徴をもっている。
+これらの（STLにおける）concept は、NumberGenerator や UniformRandomNumberGenerator と呼ばれる。
+各 concept の定義は次節を参照のこと。
+
+このライブラリの最終目標は以下のとおりである。
+
+- サードパーティ製の乱数生成子との結合を容易にする。
+- 生成子の妥当性を検証するインターフェイスの定義。
+- 有名なディストリビューション[?]を模範とする簡便なフロントエンドクラスの提供。
+- 最大効率の提供。
+- フロントエンド処理における量子化効果を操作可能にする。(まだできていない)
+
+##&amp;lt;a name=&amp;#34;number_generator&amp;#34;&amp;gt;Number Generator&amp;lt;/a&amp;gt;
+
+数生成子は、引数を取らない *関数オブジェクト* (std:20.3 [lib.function.object]) であり、全て `operator()` の呼出し毎に数値を返す。
+
+以下の表において、`X` は、`T` 型のオブジェクトを返す数生成子クラスである。
+また、`u` は `X` の値である。
+
+###NumberGenerator の必須条件
+
+| 式 | 返値型 | 事前/事後条件 |
+|----|--------|---------------|
+| `X::result_type` | `T` | `std::numeric_limits&amp;lt;T&amp;gt;::is_specialized` は真であり、`T` は `LessThanComparable` である。 |
+| `u.operator()()` | `T` | - |
+
+*注意:* NumberGenerator の必須条件は、返される数値の特性にいかなる制約を課すのもではない。
+
+##&amp;lt;a name=&amp;#34;uniform-rng&amp;#34;&amp;gt;Uniform Random Number Generator&amp;lt;/a&amp;gt;
+
+一定乱数生成子は、与えられた範囲で一様に生成される乱数列を提供する NumberGenerator である。
+この範囲は、コンパイル時に固定されているか、もしくはオブジェクトの実行時構築の後(のみ)でも与えることができる。
+
+いくつかの(有限)集合 S の*下限値*は、S の(唯一の)メンバ l であり、S における全ての v に関して、 l &amp;amp;lt;= v が成り立つ。
+同様に、いくつかの(有限)集合 S の*上限値*は、S の(唯一の)メンバ u であり、S における全ての v に関して、 v &amp;amp;lt;= u が成り立つ。
+
+以下の表において、`X` は、`T` 型のオブジェクトを返す数生成子クラスであり、 `v` は、`X` の定値である。
+
+`UniformRandomNumberGenerator` の必須条件
+
+| 式 | 返値型 | 事前/事後条件 |
+|----|--------|---------------|
+| `X::has_fixed_range` | `bool` | コンパイル時定数。 `true` であれば、乱数が一定に生成される範囲はコンパイル時に決定しており、 メンバ変数 `min_value` と `max_value` が存在する。 *注意:* このフラグは、コンパイラの制限により `false` になり得る。 |
+| `X::min_value` | `T` | コンパイル時定数。 `min_value` は `v.min()` と同値である。 |
+| `X::max_value` | `T` | コンパイル時定数。 `max_value` は `v.max()` と同値である。 |
+| `v.min()` | `T` | `operator()` によって返される全ての値集合の下限を返す。 この関数の返値はオブジェクトの生存期間を通じて不変である。 |
+| `v.max()` | `T` |`std::numeric_limits&amp;lt;T&amp;gt;::is_integer` が真であれば、`operator()` によって返される全ての値集合の上限、偽であれば、`operator()` によって返される全ての値集合の上限より大きな、表現可能な最小の数を返す。いかなる場合においても、この関数の返値はオブジェクトの生存期間を通じて不変である。 |
+
+メンバ関数 `min`、`max`、および `operator()` は、償却定数時間計算量を持つ。
+
+*注意:* 整数生成子 (i.e. 整数 `T`) においては、生成される値 `x` は、 `min() &amp;lt;= x &amp;lt;= max()` を満たす。
+非整数生成子 (i.e. 非整数 `T`)においては、 生成される値 `x` は、`min() &amp;lt;= x &amp;lt; max()` を満たす。
+
+*論拠:* `min` と `max` による範囲の記述は2つの目的に役立つ。
+一つは、[0..1) といったような正統な範囲に対する値のスケーリングを可能にする。
+もう一つは、さらに進んだプロセスのために妥当であるかもしれない値の意味のあるビット(significant bit) を記述する。
+
+整数における範囲は、閉じられた間隔 [min, max] であるが、これは基礎となる型が半開の間隔 [min, max+1) を表現することができない可能性があるためである。
+非整数における範囲は、これまでの版のどちらつかずの状態より実用的であるため、半開の間隔 [min, max)である。 
+
+*注意:* UniformRandomNumberGenerator コンセプトは `operator()(long)` を必須としていないため、 RandomNumberGenerator (std:25.2.11 [lib.alg.random.shuffle]) の必須事項を満足していない。
+この要求を満足するためには [`random_number_generator`](http://www.boost.org/doc/libs/1_31_0/libs/random/random-misc.html#random_number_generator) アダプタを使用すること。
+
+*論拠:* 整数範囲を持つ生成子による出力の異なる整数範囲へのマッピングは些細なことではないので、 `operator()(long)` は供給されていない。
+
+##&amp;lt;a name=&amp;#34;nondet-rng&amp;#34;&amp;gt;Non-deterministic Uniform Random Number Generator&amp;lt;/a&amp;gt;
+
+非決定論的一様乱数生成子は、確率過程に基づく UniformRandomGenerator である。
+それゆえ、この生成子は一連の真に無作為な数を提供する。
+このような過程には、放射性核種崩壊、ツェーナー・ダイオードのノイズ、量子粒のトンネリング、サイコロを転がす、壺から引き当てる、コインを投げる、といった例を挙げることができる。
+環境に依存するならば、ネットワーク・パケットの内部到達時間や、キーボードのイベントも確率過程の近似値になりえる。
+
+[`random_device`](http://www.boost.org/doc/libs/1_31_0/libs/random/nondet_random.html#random_device) クラスは非決定論的乱数生成子のモデルである。
+
+*注意:* このタイプの乱数生成子は、セキュリティ・アプリケーションに有用である。
+外部からの攻撃者が数を予想し、暗号や認証鍵を入手されるのを防ぐ。
+そこで、このコンセプトのモデルは、環境によって可能な範囲にかけて、いかなる情報も漏れないよう注意深くなければならない。
+例えば、一時的な記憶域が必要でなくなったときにすぐに明示的に消去することは賢明である。
+
+##&amp;lt;a name=&amp;#34;pseudo-rng&amp;#34;&amp;gt;Pseudo-Random Number Generator&amp;lt;/a&amp;gt;
+
+擬似乱数生成子は、決定論的擬似乱数列を提供する UniformRandomNumberGenerator である。
+この擬似乱数は、いくつかのアルゴリズムと内部状態に基づいている。
+線形合同生成子と逆合同生成子[?]は、このような擬似乱数生成子の例である。
+しばしば、これらの生成子はパラメータに非常に敏感である。
+悪い実装が使われるのを避けるため、外部のテスト・スーツは生成された数列と提供された値の妥当性が実際に一致することを確かめるべきである。
+
+Donald E. Knuth は彼の著書 &amp;#34;The Art of Computer Programming, Vol. 2, 3rd edition, Addison-Wesley, 1997&amp;#34; の中で、擬似乱数生成に関して広範囲に及ぶ概観を示している。
+特定の生成子に関する記述の中には補足の参考資料が含まれている。
+
+*注意:* 擬似乱数生成子の状態は必然的に有限であるため、生成子によって返される数列はいずれはループすることになる。
+
+UniformRandomNumberGenerator の必須事項に加えて、擬似乱数生成子にはいくらか追加の必須事項がある。
+下記の表において、`X` は `T` 型のオブジェクトを返す擬似乱数生成子クラスであり、 `x` は `T` の値、`u` は `X` の値、そして `v` は `const` な `X` の値である。
+
+###PseudoRandomNumberGenerator 必須事項
+
+| 式 | 返値型 | 事前/事後条件 |
+|----|--------|---------------|
+| `X()` | - | 実装定義の状態で生成子を作成する。 *注意:* このように作成された生成子は、従属[?]しているか全く同一の乱数列を生成する可能性がある。 |
+| `explicit X(...)` | - | ユーザに提供された状態を用いて生成子を作成する。 実装はコンストラクタの仮引数を明示すること。 |
+| `u.seed(...)` | `void` | 現在の状態を引数に従って設定する。 少なくともデフォルトではないコンストラクタと同様のシグネチャを持つ関数を提供すること。 |
+| `v.validation(x)` | `bool` | あらかじめ計算されハードコーディングされた、生成子の乱数列における 10001 番目の要素と `x` とを比較する。 妥当性の検証が有意味であるために、生成子はデフォルトコンストラクタによって構築されていなければならず、また `seed` は呼ばれていてはならない。 |
+
+*Note:* The `seed` member function is similar to the `assign` member function in STL containers.
+However, the naming did not seem appropriate.
+
+Classes which model a pseudo-random number generator shall also model EqualityComparable, i.e. implement `operator==`.
+Two pseudo-random number generators are defined to be *equivalent* if they both return an identical sequence of numbers starting from a given state.
+
+Classes which model a pseudo-random number generator should also model the Streamable concept, i.e. implement `operator&amp;lt;&amp;lt;` and `operator&amp;gt;&amp;gt;`.
+If so, `operator&amp;lt;&amp;lt;` writes all current state of the pseudo-random number generator to the given `ostream` so that `operator&amp;gt;&amp;gt;` can restore the state at a later time.
+The state shall be written in a platform-independent manner, but it is assumed that the `locale`s used for writing and reading be the same.
+
+The pseudo-random number generator with the restored state and the original at the just-written state shall be equivalent.
+
+Classes which model a pseudo-random number generator may also model the CopyConstructible and Assignable concepts.
+However, note that the sequences of the original and the copy are strongly correlated (in fact, they are identical), which may make them unsuitable for some problem domains.
+Thus, copying pseudo-random number generators is discouraged; they should always be passed by (non-`const`) reference.
+
+The classes [`rand48`](http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#rand48), [`minstd_rand`](http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#linear_congruential), and [`mt19937`](http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#mersenne_twister) are models for a pseudo-random number generator.
+
+*Note:* This type of random-number generator is useful for numerics, games and testing.
+The non-zero arguments constructor(s) and the `seed()` member function(s) allow for a user-provided state to be installed in the generator.
+This is useful for debugging Monte-Carlo algorithms and analyzing particular test scenarios.
+The Streamable concept allows to save/restore the state of the generator, for example to re-run a test suite at a later time.
+
+##&amp;lt;a name=&amp;#34;quasi-rng&amp;#34;&amp;gt;Quasi-Random Number Generators&amp;lt;/a&amp;gt;
+
+A quasi-random number generator is a Number Generator which provides a deterministic sequence of numbers, based on some algorithm and internal state.
+The numbers do not have any statistical properties (such as uniform distribution or independence of successive values).
+
+*Note:* Quasi-random number generators are useful for Monte-Carlo integrations where specially crafted sequences of random numbers will make the approximation converge faster.
+
+*[Does anyone have a model?]*
+
+Jens Maurer, 2000-02-23
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>melpon
</name>
        <email>melt@e-ml.jp
</email>
      </author>
    </entry>
  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Boost.Random の翻訳ドキュメントを移植</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>e6d4d951e961b511cf594dbc95869efa83c85715:archive/boost_docs/libs.md</id>
      <updated>2016-08-24 23:25:41 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;各ライブラリの翻訳ドキュメント&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html&#34;&gt;function&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;遅延呼び出し及びコールバックのための関数オブジェクトラッパ。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional.html&#34;&gt;functional&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;機能強化された関数オブジェクトアダプタ。 Mark Rodgers 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph.html&#34;&gt;graph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;汎用グラフコンポーネント及びアルゴリズム。 Jeremy Siek and a University of Notre Dame team 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/io/ios_state.html&#34;&gt;io state savers&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;入出力の状態を保存して、データが化けるのを防ぐ。 Daryle Walker 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/multi_array.html&#34;&gt;muti_array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリ上で連続したデータの配列のための多次元コンテナとアダプタ。 Ron Garcia 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/random.html&#34;&gt;random&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;乱数生成のためのシステム一式。 Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/signals.html&#34;&gt;signals&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;管理されたシグナルとスロットのコールバックでの実装。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/smart_ptr.html&#34;&gt;smart_ptr&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;5つのスマートポインタクラステンプレート Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/type_traits.html&#34;&gt;type_traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型の基本的な特徴のためのテンプレート。 John Maddock, Steve Cleary, et al 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost Random Number Library -- Boost.Random の翻訳ドキュメントを移植</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/random.html"/>
      <id>e6d4d951e961b511cf594dbc95869efa83c85715:archive/boost_docs/libs/random.md</id>
      <updated>2016-08-24 23:25:41 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost Random Number Library&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;乱数は、様々な種類のアプリケーションで役立つ。
Boost Random Number Library (略してBoost.Random)は、例えば一様分布といったような、有用な特徴をもつ乱数を生成するための膨大で多様な生成子と分布を供給する。&lt;/p&gt;
&lt;p&gt;導入と基本的な概念の定義の理解のため、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/random/random-concepts.html&#34;&gt;concepts documentation[概要]&lt;/a&gt; を読むべきである。
早く始めたいのなら、&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random_demo.cpp&#34; target=&#34;_blank&#34;&gt;random_demo.cpp&lt;/a&gt; を一読すれば十分であろう。&lt;/p&gt;
&lt;h2&gt;Library Organization&lt;/h2&gt;
&lt;p&gt;ライブラリは全て &lt;code&gt;boost/random/&lt;/code&gt; ディレクトリ中に、複数のヘッダー・ファイルに分かれて存在している。
さらに、&lt;code&gt;boost/random/&lt;/code&gt; 中に存在する他の全てのヘッダー・ファイルをインクルードしている便利なヘッダー・ファイルが、 &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random.hpp&#34; target=&#34;_blank&#34;&gt;boost/random.hpp&lt;/a&gt;&lt;/code&gt; として利用可能である。&lt;/p&gt;
&lt;p&gt;各乱数生成子は、以下のヘッダー・ファイルで利用可能である。
生成子については &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-variate.html&#34; target=&#34;_blank&#34;&gt;documentation&lt;/a&gt; を読まれたい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/linear_congruential.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/linear_congruential.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/additive_combine.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/additive_combine.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/inversive_congruential.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/inversive_congruential.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/shuffle_output.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/shuffle_output.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/mersenne_twister.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/mersenne_twister.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/lagged_fibonacci.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/lagged_fibonacci.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に、各乱数分布は、以下のヘッダー・ファイルで利用可能である。
分布については &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-distributions.html&#34; target=&#34;_blank&#34;&gt;documentation&lt;/a&gt; を読まれたい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_smallint.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_smallint.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_int.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_int.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_01.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_01.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_real.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_real.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/triangle_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/triangle_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/bernoulli_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/bernoulli_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/cauchy_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/cauchy_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/exponential_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/exponential_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/geometric_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/geometric_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/normal_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/normal_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/lognormal_distribution.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/lognormal_distribution.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/random/uniform_on_sphere.hpp&#34; target=&#34;_blank&#34;&gt;boost/random/uniform_on_sphere.hpp&lt;/a&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加えて、非決定論的乱数生成子が &lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/boost/nondet_random.hpp&#34; target=&#34;_blank&#34;&gt;&amp;lt;boost/nondet_random.hpp&amp;gt;&lt;/a&gt;&lt;/code&gt; ヘッダで利用可能である。
(&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/nondet_random.html&#34; target=&#34;_blank&#34;&gt;Documentation&lt;/a&gt;&lt;/code&gt; も同様)&lt;/p&gt;
&lt;p&gt;生成子と分布関数のインターフェースを他のコンセプトに配置するために、&lt;code&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-misc.html&#34; target=&#34;_blank&#34;&gt;decorators[装飾子?]&lt;/a&gt;&lt;/code&gt; が利用可能である。&lt;/p&gt;
&lt;h2&gt;Tests&lt;/h2&gt;
&lt;p&gt;広範囲にわたる擬似乱数生成子と分布のためのテストスーツが &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random_test.cpp&#34; target=&#34;_blank&#34;&gt;random_test.cpp&lt;/a&gt; で利用可能である。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random_speed.cpp&#34; target=&#34;_blank&#34;&gt;random_speed.cpp&lt;/a&gt; を使用して得られた &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/random/random-performance.html&#34; target=&#34;_blank&#34;&gt;performance results[実行結果]&lt;/a&gt; も見ることができる。&lt;/p&gt;
&lt;h2&gt;Rationale&lt;/h2&gt;
&lt;p&gt;決定論的乱数と非決定論的乱数の生成及び算出手法は根本的に異なるものである。
おまけに、現代のコンピュータで本来的に使用されている決定論的[乱数生成]デザインのために、非決定論的乱数の生成手段を実装することは困難である。
そこで、この乱数ライブラリは、2つの異なる適用領域を反映して、複数のヘッダー・ファイルに分割されている。&lt;/p&gt;
&lt;h2&gt;History and Acknowledgements&lt;/h2&gt;
&lt;p&gt;1999年11月、Jeet Sakumaran は仮想関数に基づくフレームワークを提案、後にテンプレートに基づく方法の大筋を記した。
Ed Brey が、Microsoft Visual C++ がクラス内のメンバ初期化をサポートしていないことを指摘し、&lt;code&gt;enum&lt;/code&gt; による回避手段を提案。
Dave Abrahams が量子化の問題を強調した。&lt;/p&gt;
&lt;p&gt;この乱数ライブラリの最初の公のリリースは、2000年3月、boost メーリングリストでの広範囲にわたる議論の末に実現した。
Beman Dawes のオリジナルの &lt;code&gt;min_rand&lt;/code&gt; クラス、移植性の修正、文書の提案、そして全般的な指導に多大なる感謝を送る。
Harry Erwin は要求に対するさらなる識見をもたらすヘッダー・ファイルを送ってくれた。
Ed Brey と Beman Dawes はイテレータのようなインターフェースを欲していた。&lt;/p&gt;
&lt;p&gt;Beman Dawes は、Matthias Trayer と Csaba Szepesvari、そして Thomas Holenstein が詳細なコメントを記述している間に、正式な再検討を成し遂げた。
この再検討された版は、2000年6月17日に公式に boost の一部となった。&lt;/p&gt;
&lt;p&gt;Gary Powell は、コードのきれいさについての提案を貢献した。
Dave Abraham と Howard Hinnant は基本的な生成子テンプレートを &lt;code&gt;boost::detail&lt;/code&gt; 名前空間から &lt;code&gt;boost::random&lt;/code&gt; に移すよう提案した。&lt;/p&gt;
&lt;p&gt;Ed Brey は過度の警告を取り除くよう頼み、&lt;code&gt;uint64_t&lt;/code&gt; の取り扱い方について手助けをした。
Andreas Scherer は MSVC でのテストを行った。
Matthias Troyer は遅れのあるフィボナッチ(lagged_fibonacci)生成子を提供した。
Michael Stevens は normal_distribution のコピーセマンティックに潜んでいたバグを発見し、文書の改良を提案した。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jens_maurer.htm&#34; target=&#34;_blank&#34;&gt;Jens Maurer&lt;/a&gt;, 2001-08-31&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 KATOU Akira &amp;lt;turugina@blue.sakura.ne.jp&amp;gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の
複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」
に提供されており、いかなる明示的、暗黙的保証も行わない。また、
いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Random Number Generator Library Concepts -- Boost.Random の翻訳ドキュメントを移植</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/random/random-concepts.html"/>
      <id>e6d4d951e961b511cf594dbc95869efa83c85715:archive/boost_docs/libs/random/random-concepts.md</id>
      <updated>2016-08-24 23:25:41 +0900</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/random/random-concepts.md b/archive/boost_docs/libs/random/random-concepts.md
new file mode 100644
index 0000000..5b201b7
--- /dev/null
+++ b/archive/boost_docs/libs/random/random-concepts.md
@@ -0,0 +1,166 @@
+#Random Number Generator Library Concepts
+
+##Introduction
+
+乱数は、以下に示すような様々に異なる問題領域において要求される。
+
+- 計算 (シミュレーション、モンテ・カルロ積分)
+- ゲーム (ランダムな敵の動き)
+- セキュリティ (鍵生成)
+- テスト (無作為なホワイトボックステスト)
+
+Boost Random Number Generator Library は、計算やセキュリティの領域を要求する場合においてもこの生成子が使われ得るように、よく吟味され決定された特徴を持つ乱数生成子のフレームワークを提供する。
+
+計算領域における乱数の一般的な概論は、以下を参照のこと。
+
+&amp;gt; &amp;#34;Numerical Recipes in C: The art of scientific computing&amp;#34;, William
+&amp;gt; H. Press, Saul A. Teukolsky, William A. Vetterling, Brian P. Flannery,
+&amp;gt; 2nd ed., 1992, pp. 274-328&amp;lt;br&amp;gt;
+&amp;gt; [訳注: 日本語版は、丹慶 勝市 他訳
+&amp;gt; 「ニューメリカルレシピ・イン・シー 日本語版―C言語による数値計算のレシピ」
+&amp;gt; 東京: 技術評論社、1993年 (ISBN: 4874085601)]
+
+問題領域の要求に応じて、乱数生成子の様々なバリエーションが利用できる。
+
+- 非決定論的乱数生成子
+- 擬似乱数生成子
+- 準乱数生成子
+
+全てのバリエーションはいくつかの共通する特徴をもっている。
+これらの（STLにおける）concept は、NumberGenerator や UniformRandomNumberGenerator と呼ばれる。
+各 concept の定義は次節を参照のこと。
+
+このライブラリの最終目標は以下のとおりである。
+
+- サードパーティ製の乱数生成子との結合を容易にする。
+- 生成子の妥当性を検証するインターフェイスの定義。
+- 有名なディストリビューション[?]を模範とする簡便なフロントエンドクラスの提供。
+- 最大効率の提供。
+- フロントエンド処理における量子化効果を操作可能にする。(まだできていない)
+
+##&amp;lt;a name=&amp;#34;number_generator&amp;#34;&amp;gt;Number Generator&amp;lt;/a&amp;gt;
+
+数生成子は、引数を取らない *関数オブジェクト* (std:20.3 [lib.function.object]) であり、全て `operator()` の呼出し毎に数値を返す。
+
+以下の表において、`X` は、`T` 型のオブジェクトを返す数生成子クラスである。
+また、`u` は `X` の値である。
+
+###NumberGenerator の必須条件
+
+| 式 | 返値型 | 事前/事後条件 |
+|----|--------|---------------|
+| `X::result_type` | `T` | `std::numeric_limits&amp;lt;T&amp;gt;::is_specialized` は真であり、`T` は `LessThanComparable` である。 |
+| `u.operator()()` | `T` | - |
+
+*注意:* NumberGenerator の必須条件は、返される数値の特性にいかなる制約を課すのもではない。
+
+##&amp;lt;a name=&amp;#34;uniform-rng&amp;#34;&amp;gt;Uniform Random Number Generator&amp;lt;/a&amp;gt;
+
+一定乱数生成子は、与えられた範囲で一様に生成される乱数列を提供する NumberGenerator である。
+この範囲は、コンパイル時に固定されているか、もしくはオブジェクトの実行時構築の後(のみ)でも与えることができる。
+
+いくつかの(有限)集合 S の*下限値*は、S の(唯一の)メンバ l であり、S における全ての v に関して、 l &amp;amp;lt;= v が成り立つ。
+同様に、いくつかの(有限)集合 S の*上限値*は、S の(唯一の)メンバ u であり、S における全ての v に関して、 v &amp;amp;lt;= u が成り立つ。
+
+以下の表において、`X` は、`T` 型のオブジェクトを返す数生成子クラスであり、 `v` は、`X` の定値である。
+
+`UniformRandomNumberGenerator` の必須条件
+
+| 式 | 返値型 | 事前/事後条件 |
+|----|--------|---------------|
+| `X::has_fixed_range` | `bool` | コンパイル時定数。 `true` であれば、乱数が一定に生成される範囲はコンパイル時に決定しており、 メンバ変数 `min_value` と `max_value` が存在する。 *注意:* このフラグは、コンパイラの制限により `false` になり得る。 |
+| `X::min_value` | `T` | コンパイル時定数。 `min_value` は `v.min()` と同値である。 |
+| `X::max_value` | `T` | コンパイル時定数。 `max_value` は `v.max()` と同値である。 |
+| `v.min()` | `T` | `operator()` によって返される全ての値集合の下限を返す。 この関数の返値はオブジェクトの生存期間を通じて不変である。 |
+| `v.max()` | `T` |`std::numeric_limits&amp;lt;T&amp;gt;::is_integer` が真であれば、`operator()` によって返される全ての値集合の上限、偽であれば、`operator()` によって返される全ての値集合の上限より大きな、表現可能な最小の数を返す。いかなる場合においても、この関数の返値はオブジェクトの生存期間を通じて不変である。 |
+
+メンバ関数 `min`、`max`、および `operator()` は、償却定数時間計算量を持つ。
+
+*注意:* 整数生成子 (i.e. 整数 `T`) においては、生成される値 `x` は、 `min() &amp;lt;= x &amp;lt;= max()` を満たす。
+非整数生成子 (i.e. 非整数 `T`)においては、 生成される値 `x` は、`min() &amp;lt;= x &amp;lt; max()` を満たす。
+
+*論拠:* `min` と `max` による範囲の記述は2つの目的に役立つ。
+一つは、[0..1) といったような正統な範囲に対する値のスケーリングを可能にする。
+もう一つは、さらに進んだプロセスのために妥当であるかもしれない値の意味のあるビット(significant bit) を記述する。
+
+整数における範囲は、閉じられた間隔 [min, max] であるが、これは基礎となる型が半開の間隔 [min, max+1) を表現することができない可能性があるためである。
+非整数における範囲は、これまでの版のどちらつかずの状態より実用的であるため、半開の間隔 [min, max)である。 
+
+*注意:* UniformRandomNumberGenerator コンセプトは `operator()(long)` を必須としていないため、 RandomNumberGenerator (std:25.2.11 [lib.alg.random.shuffle]) の必須事項を満足していない。
+この要求を満足するためには [`random_number_generator`](http://www.boost.org/doc/libs/1_31_0/libs/random/random-misc.html#random_number_generator) アダプタを使用すること。
+
+*論拠:* 整数範囲を持つ生成子による出力の異なる整数範囲へのマッピングは些細なことではないので、 `operator()(long)` は供給されていない。
+
+##&amp;lt;a name=&amp;#34;nondet-rng&amp;#34;&amp;gt;Non-deterministic Uniform Random Number Generator&amp;lt;/a&amp;gt;
+
+非決定論的一様乱数生成子は、確率過程に基づく UniformRandomGenerator である。
+それゆえ、この生成子は一連の真に無作為な数を提供する。
+このような過程には、放射性核種崩壊、ツェーナー・ダイオードのノイズ、量子粒のトンネリング、サイコロを転がす、壺から引き当てる、コインを投げる、といった例を挙げることができる。
+環境に依存するならば、ネットワーク・パケットの内部到達時間や、キーボードのイベントも確率過程の近似値になりえる。
+
+[`random_device`](http://www.boost.org/doc/libs/1_31_0/libs/random/nondet_random.html#random_device) クラスは非決定論的乱数生成子のモデルである。
+
+*注意:* このタイプの乱数生成子は、セキュリティ・アプリケーションに有用である。
+外部からの攻撃者が数を予想し、暗号や認証鍵を入手されるのを防ぐ。
+そこで、このコンセプトのモデルは、環境によって可能な範囲にかけて、いかなる情報も漏れないよう注意深くなければならない。
+例えば、一時的な記憶域が必要でなくなったときにすぐに明示的に消去することは賢明である。
+
+##&amp;lt;a name=&amp;#34;pseudo-rng&amp;#34;&amp;gt;Pseudo-Random Number Generator&amp;lt;/a&amp;gt;
+
+擬似乱数生成子は、決定論的擬似乱数列を提供する UniformRandomNumberGenerator である。
+この擬似乱数は、いくつかのアルゴリズムと内部状態に基づいている。
+線形合同生成子と逆合同生成子[?]は、このような擬似乱数生成子の例である。
+しばしば、これらの生成子はパラメータに非常に敏感である。
+悪い実装が使われるのを避けるため、外部のテスト・スーツは生成された数列と提供された値の妥当性が実際に一致することを確かめるべきである。
+
+Donald E. Knuth は彼の著書 &amp;#34;The Art of Computer Programming, Vol. 2, 3rd edition, Addison-Wesley, 1997&amp;#34; の中で、擬似乱数生成に関して広範囲に及ぶ概観を示している。
+特定の生成子に関する記述の中には補足の参考資料が含まれている。
+
+*注意:* 擬似乱数生成子の状態は必然的に有限であるため、生成子によって返される数列はいずれはループすることになる。
+
+UniformRandomNumberGenerator の必須事項に加えて、擬似乱数生成子にはいくらか追加の必須事項がある。
+下記の表において、`X` は `T` 型のオブジェクトを返す擬似乱数生成子クラスであり、 `x` は `T` の値、`u` は `X` の値、そして `v` は `const` な `X` の値である。
+
+###PseudoRandomNumberGenerator 必須事項
+
+| 式 | 返値型 | 事前/事後条件 |
+|----|--------|---------------|
+| `X()` | - | 実装定義の状態で生成子を作成する。 *注意:* このように作成された生成子は、従属[?]しているか全く同一の乱数列を生成する可能性がある。 |
+| `explicit X(...)` | - | ユーザに提供された状態を用いて生成子を作成する。 実装はコンストラクタの仮引数を明示すること。 |
+| `u.seed(...)` | `void` | 現在の状態を引数に従って設定する。 少なくともデフォルトではないコンストラクタと同様のシグネチャを持つ関数を提供すること。 |
+| `v.validation(x)` | `bool` | あらかじめ計算されハードコーディングされた、生成子の乱数列における 10001 番目の要素と `x` とを比較する。 妥当性の検証が有意味であるために、生成子はデフォルトコンストラクタによって構築されていなければならず、また `seed` は呼ばれていてはならない。 |
+
+*Note:* The `seed` member function is similar to the `assign` member function in STL containers.
+However, the naming did not seem appropriate.
+
+Classes which model a pseudo-random number generator shall also model EqualityComparable, i.e. implement `operator==`.
+Two pseudo-random number generators are defined to be *equivalent* if they both return an identical sequence of numbers starting from a given state.
+
+Classes which model a pseudo-random number generator should also model the Streamable concept, i.e. implement `operator&amp;lt;&amp;lt;` and `operator&amp;gt;&amp;gt;`.
+If so, `operator&amp;lt;&amp;lt;` writes all current state of the pseudo-random number generator to the given `ostream` so that `operator&amp;gt;&amp;gt;` can restore the state at a later time.
+The state shall be written in a platform-independent manner, but it is assumed that the `locale`s used for writing and reading be the same.
+
+The pseudo-random number generator with the restored state and the original at the just-written state shall be equivalent.
+
+Classes which model a pseudo-random number generator may also model the CopyConstructible and Assignable concepts.
+However, note that the sequences of the original and the copy are strongly correlated (in fact, they are identical), which may make them unsuitable for some problem domains.
+Thus, copying pseudo-random number generators is discouraged; they should always be passed by (non-`const`) reference.
+
+The classes [`rand48`](http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#rand48), [`minstd_rand`](http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#linear_congruential), and [`mt19937`](http://www.boost.org/doc/libs/1_31_0/libs/random/random-generators.html#mersenne_twister) are models for a pseudo-random number generator.
+
+*Note:* This type of random-number generator is useful for numerics, games and testing.
+The non-zero arguments constructor(s) and the `seed()` member function(s) allow for a user-provided state to be installed in the generator.
+This is useful for debugging Monte-Carlo algorithms and analyzing particular test scenarios.
+The Streamable concept allows to save/restore the state of the generator, for example to re-run a test suite at a later time.
+
+##&amp;lt;a name=&amp;#34;quasi-rng&amp;#34;&amp;gt;Quasi-Random Number Generators&amp;lt;/a&amp;gt;
+
+A quasi-random number generator is a Number Generator which provides a deterministic sequence of numbers, based on some algorithm and internal state.
+The numbers do not have any statistical properties (such as uniform distribution or independence of successive values).
+
+*Note:* Quasi-random number generators are useful for Monte-Carlo integrations where specially crafted sequences of random numbers will make the approximation converge faster.
+
+*[Does anyone have a model?]*
+
+Jens Maurer, 2000-02-23
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.62.0リリースノート -- Merge branch &#39;master&#39; of https://github.com/boostjp/site
</title>
      <link href="http://boostjp.github.io/document/version/1_62_0.html"/>
      <id>c6ca9263f6096e7c15632ce38d71a519a333ee65:document/version/1_62_0.md</id>
      <updated>2016-08-24 13:47:11 +0900
</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost 1.62.0リリースノート&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/website/blob/master/feed/history/boost_1_62_0.qbk&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/website/blob/master/feed/history/boost_1_62_0.qbk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_62_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_62_0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリからのビルド方法は、egtraさんのブログを参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「&lt;a href=&#34;http://dev.activebasic.com/egtra/2013/12/03/620/&#34; target=&#34;_blank&#34;&gt;Modularized Boost（GitHubへ移行したリポジトリ）を使用する&lt;/a&gt;」&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fiber&#34; target=&#34;_blank&#34;&gt;Fiber&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ユーザースレッド／ファイバーのフレームワーク&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/qvm&#34; target=&#34;_blank&#34;&gt;QVM&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフィック処理、ビデオゲーム、シミュレーションアプリケーションなどで必要となる、2、3、4次元の静的なサイズを持つクォータニオン、ベクトル、行列を操作するためのジェネリックライブラリ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#chrono&#34;&gt;Chrono&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#circular-buffer&#34;&gt;Circular Buffer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#context&#34;&gt;Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#coroutine2&#34;&gt;Coroutine2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#functional-forward&#34;&gt;Functional/Forward&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#chrono&#34; name=&#34;chrono&#34;&gt;Chrono&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11330&#34; target=&#34;_blank&#34;&gt;#11330&lt;/a&gt; &lt;code&gt;duration&lt;/code&gt;をゼロ初期化するのは、C++98モードもしくは&lt;code&gt;BOOST_CHRONO_DURATION_DEFAULTS_TO_ZERO&lt;/code&gt;がdefineされたときのみとし、それ以外は未初期化とした&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11618&#34; target=&#34;_blank&#34;&gt;#11618&lt;/a&gt; Chrono IO V2のドキュメントで「ios_state.hpp」というヘッダが記載されていたが、正しくは「ios_base_state.hpp」&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11631&#34; target=&#34;_blank&#34;&gt;#11631&lt;/a&gt; Chrono IO V2で&lt;code&gt;clock_string&lt;/code&gt;をカスタマイズできなくなっていた問題を修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#circular-buffer&#34; name=&#34;circular-buffer&#34;&gt;Circular Buffer&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/6277&#34; target=&#34;_blank&#34;&gt;#6277&lt;/a&gt; デバッグ実装がデバッグモードで使用されなくなる。デバッグ実装には、通常の実装と同じレベルのスレッド安全性の保証がない。この変更により&lt;code&gt;BOOST_CB_DISABLE_DEBUG&lt;/code&gt;マクロは使用されなくなり、代わりに&lt;code&gt;BOOST_CB_ENABLE_DEBUG&lt;/code&gt;マクロを定義することでデバッグ実装が有効になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#context&#34; name=&#34;context&#34;&gt;Context&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/12215&#34; target=&#34;_blank&#34;&gt;#12215&lt;/a&gt; 一部のフィールドがゼロ初期化されていなかったために、Windows環境でクラッシュする問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/12242&#34; target=&#34;_blank&#34;&gt;#12242&lt;/a&gt; MacOS上のIntel C++ Compilerでのビルドエラーを修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;execution_context_v1&lt;/code&gt;のスタック巻き戻しを修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#coroutine2&#34; name=&#34;coroutine2&#34;&gt;Coroutine2&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/12221&#34; target=&#34;_blank&#34;&gt;#12221&lt;/a&gt; &lt;code&gt;coroutine&amp;lt;&amp;gt;::push_type&lt;/code&gt;のコンストラクタがコルーチン関数を実行しないようにした。Coroutine2の前メジャーバージョンであるCoroutineライブラリでは元々実行しないようになっていた。この問題のために、コンストラクタ時点でコルーチン関数が最後まで到達して実行が終了し、関数呼び出し演算子で改めてコルーチン関数を実行する際に、終了済みの関数実行を再開してしまうという動作になっていた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;coroutine&amp;lt;&amp;gt;::push_type&lt;/code&gt;の構築時に発生した例外を飲み込まないようにした&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_62_0.html#functional-forward&#34; name=&#34;functional-forward&#34;&gt;Functional/Forward&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11でのコンパイルエラーを修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要なテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加して含まれるテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;GCC, C++11:&lt;/li&gt;
&lt;li&gt;GCC, C++14:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;Intel, C++11:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++11:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++14:&lt;/li&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;Clang, C++11:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/faithandbrave&#34; target=&#34;_blank&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon
</name>
        <email>melt@e-ml.jp
</email>
      </author>
    </entry>
  
</feed>