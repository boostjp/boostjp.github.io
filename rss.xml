<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="https://boostjp.github.io" />
  <updated>2018-07-02T05:39:58.402412</updated>
  <id>ddb8c3eb-65ea-4e8e-a2c4-03e146573356</id>

  
    <entry>
      <title>Boost 1.68.0リリースノート -- 1.68.0リリースノート : Program Optionsを追加 (close #261)</title>
      <link href="https://boostjp.github.io/document/version/1_68_0.html"/>
      <id>45f2401e6b4c701ac38ffe9b9ad99cbf0b190d7a:document/version/1_68_0.md</id>
      <updated>2018-07-02T14:35:44+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Boost 1.68.0リリースノート&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/website/blob/master/feed/history/boost_1_68_0.qbk&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/website/blob/master/feed/history/boost_1_68_0.qbk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_68_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_68_0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリからのビルド方法は、egtraさんのブログを参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「&lt;a href=&#34;http://dev.activebasic.com/egtra/2013/12/03/620/&#34; target=&#34;_blank&#34;&gt;Modularized Boost（GitHubへ移行したリポジトリ）を使用する&lt;/a&gt;」&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#newone&#34;&gt;NewOne&lt;/a&gt; # example&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#program-options&#34;&gt;Program Options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#graph&#34; id=&#34;graph&#34;&gt;Graph&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/89&#34; target=&#34;_blank&#34;&gt;GitHub #89&lt;/a&gt; 標準C++で非推奨・削除された機能を、以下のように置き換えた：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::bind1st&lt;/code&gt; → &lt;code&gt;std::bind&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt; → &lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::random_shuffle&lt;/code&gt; → &lt;code&gt;std::shuffle&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/84&#34; target=&#34;_blank&#34;&gt;GitHub #84&lt;/a&gt; VS2015のリリースビルドでコンパイルエラーになる問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/87&#34; target=&#34;_blank&#34;&gt;GitHub #87&lt;/a&gt; Stanford GraphBaseの例を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/103&#34; target=&#34;_blank&#34;&gt;GitHub #103&lt;/a&gt; &lt;code&gt;iterator_core_access&lt;/code&gt;のfriend宣言を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/104&#34; target=&#34;_blank&#34;&gt;GitHub #104&lt;/a&gt; 不足していた&lt;code&gt;&amp;lt;boost/iterator.hpp&amp;gt;&lt;/code&gt;のインクルードを追加&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/90&#34; target=&#34;_blank&#34;&gt;GitHub #90&lt;/a&gt; 未使用変数の警告を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/88&#34; target=&#34;_blank&#34;&gt;GitHub #88&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/graph/pull/98&#34; target=&#34;_blank&#34;&gt;GitHub #98&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/graph/pull/104&#34; target=&#34;_blank&#34;&gt;GitHub #104&lt;/a&gt; いくつかのドキュメント上のtypoを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/85&#34; target=&#34;_blank&#34;&gt;GitHub #85&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/graph/pull/105&#34; target=&#34;_blank&#34;&gt;GitHub #105&lt;/a&gt; テストとサンプルコードのいくつかの問題を修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#program-options&#34; id=&#34;program-options&#34;&gt;Program Options&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/program_options/pull/53&#34; target=&#34;_blank&#34;&gt;GitHub #53&lt;/a&gt; オプションごとの複数のロング名 (long name) をサポート。Eyal Rozenberg氏に感謝&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要なテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加して含まれるテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;GCC, C++11:&lt;/li&gt;
&lt;li&gt;GCC, C++14:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;Intel, C++11:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++11:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++14:&lt;/li&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;Clang, C++11:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/faithandbrave&#34; target=&#34;_blank&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.68.0リリースノート -- 1.68.0リリースノート : Graphを追加 (close #260)</title>
      <link href="https://boostjp.github.io/document/version/1_68_0.html"/>
      <id>4ff47383e29c50854690003e29b30eb0a471fe44:document/version/1_68_0.md</id>
      <updated>2018-06-29T13:27:58+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Boost 1.68.0リリースノート&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/website/blob/master/feed/history/boost_1_68_0.qbk&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/website/blob/master/feed/history/boost_1_68_0.qbk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_68_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_68_0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリからのビルド方法は、egtraさんのブログを参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「&lt;a href=&#34;http://dev.activebasic.com/egtra/2013/12/03/620/&#34; target=&#34;_blank&#34;&gt;Modularized Boost（GitHubへ移行したリポジトリ）を使用する&lt;/a&gt;」&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#newone&#34;&gt;NewOne&lt;/a&gt; # example&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#graph&#34; id=&#34;graph&#34;&gt;Graph&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/89&#34; target=&#34;_blank&#34;&gt;GitHub #89&lt;/a&gt; 標準C++で非推奨・削除された機能を、以下のように置き換えた：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::bind1st&lt;/code&gt; → &lt;code&gt;std::bind&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt; → &lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::random_shuffle&lt;/code&gt; → &lt;code&gt;std::shuffle&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/84&#34; target=&#34;_blank&#34;&gt;GitHub #84&lt;/a&gt; VS2015のリリースビルドでコンパイルエラーになる問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/87&#34; target=&#34;_blank&#34;&gt;GitHub #87&lt;/a&gt; Stanford GraphBaseの例を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/103&#34; target=&#34;_blank&#34;&gt;GitHub #103&lt;/a&gt; &lt;code&gt;iterator_core_access&lt;/code&gt;のfriend宣言を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/104&#34; target=&#34;_blank&#34;&gt;GitHub #104&lt;/a&gt; 不足していた&lt;code&gt;&amp;lt;boost/iterator.hpp&amp;gt;&lt;/code&gt;のインクルードを追加&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/90&#34; target=&#34;_blank&#34;&gt;GitHub #90&lt;/a&gt; 未使用変数の警告を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/88&#34; target=&#34;_blank&#34;&gt;GitHub #88&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/graph/pull/98&#34; target=&#34;_blank&#34;&gt;GitHub #98&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/graph/pull/104&#34; target=&#34;_blank&#34;&gt;GitHub #104&lt;/a&gt; いくつかのドキュメント上のtypoを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/graph/pull/85&#34; target=&#34;_blank&#34;&gt;GitHub #85&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/graph/pull/105&#34; target=&#34;_blank&#34;&gt;GitHub #105&lt;/a&gt; テストとサンプルコードのいくつかの問題を修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要なテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加して含まれるテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;GCC, C++11:&lt;/li&gt;
&lt;li&gt;GCC, C++14:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;Intel, C++11:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++11:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++14:&lt;/li&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;Clang, C++11:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/faithandbrave&#34; target=&#34;_blank&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>リリースノート -- 1.68.0のリリースノートページを作成 (close #259)</title>
      <link href="https://boostjp.github.io/document/version.html"/>
      <id>75605efc768295b7b2118b5733cf6f73760c7c20:document/version.md</id>
      <updated>2018-06-28T15:59:31+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;リリースノート&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;以下は、Boostの各バージョンのリリースノートを翻訳、情報補完したドキュメントです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/template.html&#34;&gt;雛形ページ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html&#34;&gt;1.68.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_67_0.html&#34;&gt;1.67.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_66_0.html&#34;&gt;1.66.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_65_1.html&#34;&gt;1.65.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_65_0.html&#34;&gt;1.65.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_64_0.html&#34;&gt;1.64.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_63_0.html&#34;&gt;1.63.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_62_0.html&#34;&gt;1.62.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_61_0.html&#34;&gt;1.61.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_60_0.html&#34;&gt;1.60.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_59_0.html&#34;&gt;1.59.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_58_0.html&#34;&gt;1.58.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_57_0.html&#34;&gt;1.57.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_56_0.html&#34;&gt;1.56.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_55_0.html&#34;&gt;1.55.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_54_0.html&#34;&gt;1.54.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_53_0.html&#34;&gt;1.53.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_52_0.html&#34;&gt;1.52.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_51_0.html&#34;&gt;1.51.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_50_0.html&#34;&gt;1.50.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_49_0.html&#34;&gt;1.49.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_48_0.html&#34;&gt;1.48.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_47_0.html&#34;&gt;1.47.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_46_1.html&#34;&gt;1.46.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_46_0.html&#34;&gt;1.46.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_45_0.html&#34;&gt;1.45.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.68.0リリースノート -- 1.68.0のリリースノートページを作成 (close #259)</title>
      <link href="https://boostjp.github.io/document/version/1_68_0.html"/>
      <id>75605efc768295b7b2118b5733cf6f73760c7c20:document/version/1_68_0.md</id>
      <updated>2018-06-28T15:59:31+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Boost 1.68.0リリースノート&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/website/blob/master/feed/history/boost_1_68_0.qbk&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/website/blob/master/feed/history/boost_1_68_0.qbk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_68_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_68_0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリからのビルド方法は、egtraさんのブログを参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「&lt;a href=&#34;http://dev.activebasic.com/egtra/2013/12/03/620/&#34; target=&#34;_blank&#34;&gt;Modularized Boost（GitHubへ移行したリポジトリ）を使用する&lt;/a&gt;」&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#newone&#34;&gt;NewOne&lt;/a&gt; # example&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#one&#34;&gt;One&lt;/a&gt; # example&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#two&#34;&gt;Two&lt;/a&gt; # example&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#three&#34;&gt;Three&lt;/a&gt; # example&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#one&#34; id=&#34;One&#34;&gt;One&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;blahblahblah&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#two&#34; id=&#34;Two&#34;&gt;Two&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;改善&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;something&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解決したチケット&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/xxxx&#34; target=&#34;_blank&#34;&gt;#xxxx&lt;/a&gt; ticket&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/XXX/pull/XX&#34; target=&#34;_blank&#34;&gt;pull request XX&lt;/a&gt; GitHub PR&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/document/version/1_68_0.html#three&#34; id=&#34;Three&#34;&gt;Three&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Feature: &lt;code&gt;boost::xxx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trailing &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/xxxx&#34; target=&#34;_blank&#34;&gt;#xxxx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要なテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加して含まれるテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;GCC, C++11:&lt;/li&gt;
&lt;li&gt;GCC, C++14:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;Intel, C++11:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++11:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++14:&lt;/li&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;Clang, C++11:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;Someone&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Boost.Tupleの翻訳ドキュメントを移植(close #25)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>1038805d6f62f81ccd73b3c0a9601995d2e40bef:archive/boost_docs/libs.md</id>
      <updated>2018-06-15T21:04:52+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;各ライブラリの翻訳ドキュメント&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/function.html&#34;&gt;function&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;遅延呼び出し及びコールバックのための関数オブジェクトラッパ。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/functional.html&#34;&gt;functional&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;機能強化された関数オブジェクトアダプタ。 Mark Rodgers 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/graph.html&#34;&gt;graph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;汎用グラフコンポーネント及びアルゴリズム。 Jeremy Siek and a University of Notre Dame team 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/io/ios_state.html&#34;&gt;io state savers&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;入出力の状態を保存して、データが化けるのを防ぐ。 Daryle Walker 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda.html&#34;&gt;lambda&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;実際の呼び出し時の、小さな無名関数オブジェクトの定義。, from Jaakko Jävi and Gary Powell.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/math.html&#34;&gt;math&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学の領域での多くの貢献。様々な作者による。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/multi_array.html&#34;&gt;muti_array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリ上で連続したデータの配列のための多次元コンテナとアダプタ。 Ron Garcia 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/preprocessor.html&#34;&gt;preprocessor&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;繰り返しと再帰を含むプリプロセッサメタプログラミングツール群。 Vesa Karvonen 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/pool.html&#34;&gt;pool&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリプールの管理。Steve Cleary 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/random.html&#34;&gt;random&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;乱数生成のためのシステム一式。 Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/signals.html&#34;&gt;signals&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;管理されたシグナルとスロットのコールバックでの実装。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/static_assert.html&#34;&gt;static_assert&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;静的アサート(コンパイル時アサート)。 John Maddock 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/smart_ptr.html&#34;&gt;smart_ptr&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;5つのスマートポインタクラステンプレート Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html&#34;&gt;tuple&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数の値を返す関数の簡単な定義など。 Jaakko Javi 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/type_traits.html&#34;&gt;type_traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型の基本的な特徴のためのテンプレート。 John Maddock, Steve Cleary, et al 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>The Boost Tuple Library -- Boost.Tupleの翻訳ドキュメントを移植(close #25)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/tuple.html"/>
      <id>1038805d6f62f81ccd73b3c0a9601995d2e40bef:archive/boost_docs/libs/tuple.md</id>
      <updated>2018-06-15T21:04:52+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;The Boost Tuple Library&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;タプル(または &lt;em&gt;n&lt;/em&gt; -タプル)は決まった個数の要素からなるコレクションである。
2つ組(pair)、3つ組、4つ組などがタプルである。
プログラミング言語においては、タプルは他のオブジェクトを要素として持つデータオブジェクトである。
要素となるオブジェクトは異なる型でありうる。&lt;/p&gt;
&lt;p&gt;タプルはいろいろな状況で役に立つ。
例えば、2個以上の値を返す関数を定義するのが楽になる。&lt;/p&gt;
&lt;p&gt;ML、PythonまたはHaskellなど、いくつかのプログラミング言語は、タプルの構造が組み込まれているが、不運にもC++はそうではない。
この&#34;不足&#34;を補うため、Boost Tuple Libraryは、タプル構造をテンプレートで実装する。&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#using_library&#34;&gt;ライブラリを使う&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#tuple_types&#34;&gt;タプル型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#constructing_tuples&#34;&gt;タプルを構築する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#accessing_elements&#34;&gt;タプル要素にアクセスする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#construction_and_assignment&#34;&gt;コピーコンストラクションとタプルの代入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#relational_operators&#34;&gt;関係演算子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#tiers&#34;&gt;結束子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#streaming&#34;&gt;ストリーム化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#performance&#34;&gt;パフォーマンス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#portability&#34;&gt;移植性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#thanks&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#references&#34;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;もっと詳しく&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple/tuple_advanced_interface.html&#34;&gt;上位の機能&lt;/a&gt; (いくつかのメタ関数などを紹介する)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple/design_decisions_rationale.html&#34;&gt;一部の設計/実装上の決定に関する隠れた理論的根拠&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;using_library&#34;&gt;ライブラリを使う&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ライブラリを使うには:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;cp&#34;&gt;#include &#34;boost/tuple/tuple.hpp&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;比較演算子を使うには:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;cp&#34;&gt;#include &#34;boost/tuple/tuple_comparison.hpp&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;タプルの入出力演算子を使うには、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;cp&#34;&gt;#include &#34;boost/tuple/tuple_io.hpp&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tuple_io.hpp&lt;/code&gt; と &lt;code&gt;tuple_comparison.hpp&lt;/code&gt; はどちらも &lt;code&gt;tuple.hpp&lt;/code&gt; をインクルードする。
全ての定義は名前空間 &lt;code&gt;::boost::tuples&lt;/code&gt; にあるが、最もよく使われるいくつかの名前は、using宣言を使って、名前空間 &lt;code&gt;::boost&lt;/code&gt; に持ち上げられている: &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;make_tuple&lt;/code&gt;, &lt;code&gt;tie&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; である。
さらに、&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;cref&lt;/code&gt; が &lt;code&gt;::boost&lt;/code&gt; の直下に定義されている。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;tuple_types&#34;&gt;タプル型&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;タプル型は &lt;code&gt;tuple&lt;/code&gt; テンプレートのインスタンスである。
テンプレートパラメータはタプルの要素の型を指定する。
現在のバージョンは、0-10個の要素を使うことができる。
もし必要なら、要素数の上限は、まあ数十個ぐらいまでなら増やせるだろう。
データ要素はC++の型であればなんでもいい。
&lt;code&gt;void&lt;/code&gt; と通常の関数型は、その型のオブジェクトは存在できないものの、正当なC++の型であることに注意してほしい。
あるタプル型が要素としてそれらを含んでいると、タプル型は存在できるが、その型のオブジェクトはできない。
コピーできない、あるいはデフォルト コンストラクトできない要素型には、その性質よりおのずと生じる制限がある。
後の&#39;タプルを構築する&#39;を参照されたい。&lt;/p&gt;
&lt;p&gt;例えば、次の定義はそれぞれ正当なタプルのインスタンス化である(&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; は何かしらのユーザ定義型と思っていただきたい):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;constructing_tuples&#34;&gt;タプルを構築する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;タプルのコンストラクタはタプルの要素を引数としてとる。
ある &lt;em&gt;n&lt;/em&gt; -要素タプルのコンストラクタは、&lt;code&gt;0 &amp;lt; k &amp;lt;= n&lt;/code&gt; である &lt;code&gt;k&lt;/code&gt; 個の引数をもって召喚することができる。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;3.14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;要素に初期値が与えられなかったならば、それはデフォルト値で初期化される(というわけでデフォルトの初期化が可能でなければならぬ)。
例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;nl&#34;&gt;public:&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;                                              &lt;span class=&#34;c1&#34;&gt;// error: no default constructor for X&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;Jaba&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;Daba&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;Duu&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;特に参照型はデフォルトの初期化ができない:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// error: reference must be&lt;/span&gt;
                                &lt;span class=&#34;c1&#34;&gt;// initialized explicitly&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;               &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;3.14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// error: cannot initialize&lt;/span&gt;
                                &lt;span class=&#34;c1&#34;&gt;// non-const reference with a temporary&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;3.14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// ok, but dangerous:&lt;/span&gt;
                                &lt;span class=&#34;c1&#34;&gt;// the element becomes a dangling reference&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コピーできない要素に初期値を与えると、コンパイル時にエラーになる:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Y&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;nl&#34;&gt;public:&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// error, neither arrays nor Y can be copied&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;だが次の例は全くokである:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;構築できないタプル型ができてしまうこともある。
これは、初期化できない要素が、初期化を必要とする要素より前にあった場合に起こる。
例えば: &lt;code&gt;tuple&amp;lt;char[10], int&amp;amp;&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;おおざっばに言って、タプルの構築は、文脈的に、それぞれの要素の構築の集まりにすぎない。&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;make_tuple&#34;&gt;&lt;code&gt;make_tuple&lt;/code&gt; 関数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;タプルはまた、&lt;code&gt;make_tuple&lt;/code&gt; (cf. &lt;code&gt;std::make_pair&lt;/code&gt;)ヘルパ関数によっても構築することができる。
これを使うと要素型を明示的に記述しなくてもよくなるので、構築はより簡単になる:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add_multiply_divide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;デフォルトでは、要素型は、型推論によって通常の非参照型とされる。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make_tuple&lt;/code&gt; の結果は、タプル型 &lt;code&gt;tuple&amp;lt;A, B&amp;gt;&lt;/code&gt; になる。&lt;/p&gt;
&lt;p&gt;例えば、コピーできない型の要素があるなど、通常の非参照型が望ましくない場合もある。
そんな時は、型推論を抑制し、代わりにconstへの参照または非constへの参照型を用いるよう明示することができる。
それには二つのヘルパ テンプレート関数、&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;cref&lt;/code&gt; を使う。
望みの型を得るために、どの引数でもこれらの関数でラップしてよい。
constオブジェクトを &lt;code&gt;ref&lt;/code&gt; しても、結果のタプルにはconstへの参照が入るので、このメカニズムでconstが勝手に剥ぎ取られるようなことはない(次の5行のコードを見ていただきたい)。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ca&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// creates tuple&amp;lt;const A&amp;amp;, B&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// creates tuple&amp;lt;A&amp;amp;, B&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// creates tuple&amp;lt;A&amp;amp;, const B&amp;amp;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ca&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// creates tuple&amp;lt;const A&amp;amp;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ca&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// creates tuple&amp;lt;const A&amp;amp;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;配列が &lt;code&gt;make_tuple&lt;/code&gt; 関数の引数に与えられたとき、デフォルトでは型推論によりconstへの参照とされる。
&lt;code&gt;cref&lt;/code&gt; でラップする必要はない。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;Donald&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;Daisy&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このコードは &lt;code&gt;tuple&amp;lt;const char (&amp;amp;)[5], const char (&amp;amp;)[6]&amp;gt;&lt;/code&gt; 型のオブジェクトを生成する(文字列リテラルは &lt;code&gt;const char&lt;/code&gt; の配列であり、&lt;code&gt;const char*&lt;/code&gt; ではない)。
しかし、&lt;code&gt;make_tuple&lt;/code&gt; で、非const配列の要素を持つタプルを生成したいときには、&lt;code&gt;ref&lt;/code&gt; を使わなければならない.&lt;/p&gt;
&lt;p&gt;関数ポインタは型推論により通常の非参照型とされ、つまり、通常の関数ポインタになる。
タプルには関数への参照も入れることができる。
しかしこのようなタプルは &lt;code&gt;make_tuple&lt;/code&gt; で構築することができない(結果的にconst修飾された関数型となり、文法違反になるためである):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// tuple&amp;lt;void (*)(int)&amp;gt;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                    &lt;span class=&#34;c1&#34;&gt;// not ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;accessing_elements&#34;&gt;タプル要素にアクセスする&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;タプル要素には次の式でアクセスすることができる:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;または&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;t&lt;/code&gt; はタプルオブジェクトであり、&lt;code&gt;N&lt;/code&gt; はアクセスされる要素のインデックスを特定する汎整数定数式である。
&lt;code&gt;t&lt;/code&gt; がconstか否かによって、&lt;code&gt;get&lt;/code&gt; が、&lt;code&gt;N&lt;/code&gt; 番目の要素を、constへの参照として返すか、非constへの参照として返すかが決まる。&lt;/p&gt;
&lt;p&gt;最初の要素のインデックスは0であり、したがって &lt;code&gt;N&lt;/code&gt; は0から &lt;code&gt;k-1&lt;/code&gt; ( &lt;code&gt;k&lt;/code&gt; はタプルの要素の数)でなければならない。
さもなくばコンパイル時にエラーになる。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;2.7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ct&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                       &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                            &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                           &lt;span class=&#34;c1&#34;&gt;// error, can&#39;t assign to const&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;3.14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// error, can&#39;t assign to const&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aa&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// error: index out of bounds&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// ok, can be used as any variable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;注意!
メンバ関数の &lt;code&gt;get&lt;/code&gt; はMS Visual C++ compilerではサポートされていない。
そのうえこのコンパイラは、明示的に名前空間を指定しないと、非メンバ関数のgetを使うときにもトラブルが起こる。
そのため、MSVC++ 6.0.でコンパイルされるであろうコードを書くときは、全ての &lt;code&gt;get&lt;/code&gt; 呼び出しに、このように指定をした方がよい: &lt;code&gt;tuples::get&amp;lt;N&amp;gt;(a_tuple)&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;construction_and_assignment&#34;&gt;コピーコンストラクションとタプルの代入&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;タプルは、要素ごとのコピーコンストラクトができるなら、他のタプルからコピーコンストラクトすることができる。
同様に、要素ごとの代入ができるなら、他のタプルに代入することができる。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;D&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                     &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;どちらの場合でも、変換は次のように行われる: &lt;code&gt;char -&amp;gt; int&lt;/code&gt;, &lt;code&gt;B* -&amp;gt; A*&lt;/code&gt; (派生クラスへのポインタから基本クラスのポインタへ),  &lt;code&gt;B -&amp;gt; C&lt;/code&gt; (ユーザ定義の変換), &lt;code&gt;D -&amp;gt; C&lt;/code&gt; (ユーザ定義の変換)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::pair&lt;/code&gt; からの代入も定義されている:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_pair&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;relational_operators&#34;&gt;関係演算子&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;タプルは &lt;code&gt;==, !=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=&lt;/code&gt; 演算子を、対応する、要素ごとの演算子に還元する。
これは、いずれかの演算子が、二つのタプルの全ての要素に対して定義されていれば、その演算子が、タプルについても定義されることを意味する。&lt;/p&gt;
&lt;p&gt;二つのタプル &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; に対する等価演算子は、このように定義される:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a == b&lt;/code&gt; iff for each &lt;code&gt;i&lt;/code&gt;: &lt;code&gt;ai == bi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a != b&lt;/code&gt; iff exists &lt;code&gt;i&lt;/code&gt;: &lt;code&gt;ai != bi&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=&lt;/code&gt; 演算子は、辞書式順序を実装する。&lt;/p&gt;
&lt;p&gt;要素数の異なる二つのタプルを比較しようとする試みは、コンパイル時エラーになる。
また、比較演算子は &lt;em&gt;&#34;短絡的&#34;&lt;/em&gt; である: 要素ごとの比較は最初の要素から順に始められるが、結果が明らかになるまでしか行われない。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;same?&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;same?&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;different&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;All the same to me...&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// true&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// false, does not print &#34;All the...&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;tiers&#34;&gt;結束子&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;結束子&lt;/em&gt; はタプルの一種で、全ての要素が非constへの参照型のものである。
これらは &lt;code&gt;tie&lt;/code&gt; 関数テンプレート(cf. &lt;code&gt;make_tuple&lt;/code&gt;)を召喚することによって構築される:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;上の &lt;code&gt;tie&lt;/code&gt; 関数は、&lt;code&gt;tuple&amp;lt;int&amp;amp;, char&amp;amp;, double&amp;amp;&amp;gt;&lt;/code&gt; 型のタプルを生成する。
&lt;code&gt;make_tuple(ref(i), ref(c), ref(a))&lt;/code&gt; によっても同じ結果が得られる。&lt;/p&gt;
&lt;p&gt;要素として非constへの参照を持つタプルは、別のタプルをいくつかの変数に&#39;荷解き&#39;するために利用することができる。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;5.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34; &#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34; &#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このコードは標準出力ストリームに &lt;code&gt;1 a 5.5&lt;/code&gt; とプリントする。&lt;/p&gt;
&lt;p&gt;このようなタプル荷解き操作は、MLとPythonの例に見ることができる。
タプルを返す関数を呼ぶときに役立つ。&lt;/p&gt;
&lt;p&gt;tieのメカニズムは &lt;code&gt;std::pair&lt;/code&gt; テンプレートに対しても同様に働く:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_pair&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;ignore&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ignore&lt;/code&gt; は、タプルから代入された要素を無視することを可能にするオブジェクトである。
タプルを返す関数の、返却値の一部にしか興味が無いときに使う。
例えば(&lt;code&gt;ignore&lt;/code&gt; は入れ子の名前空間 &lt;code&gt;tuples&lt;/code&gt; にある):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ignore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_pair&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;streaming&#34;&gt;ストリーム化&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;グローバルの &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; は、タプルを &lt;code&gt;std::ostream&lt;/code&gt; に出力するとき、それぞれの要素について再帰的に &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; を呼び出すよう、オーバーロードされている。&lt;/p&gt;
&lt;p&gt;同様に、グローバルの &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; も、タプルを &lt;code&gt;std::istream&lt;/code&gt; から抽出するとき、それぞれの要素について再帰的に &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; を呼び出すよう、オーバーロードされている。&lt;/p&gt;
&lt;p&gt;デフォルトの区切り文字は空白で、タプルの前後は括弧でくくられる。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.0f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;Howdy folks!&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このコードはタプルをこのように出力する: &lt;code&gt;(1.0 2 Howdy folks!)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ライブラリは、デフォルトの挙動を変えるために、3つのマニピュレータを定義している:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set_open(char)&lt;/code&gt; は、最初の要素の前に出力される文字を定義する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set_close(char)&lt;/code&gt; は、最後の要素の後に出力される文字を定義する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set_delimiter(char)&lt;/code&gt; は、要素間の区切り文字を定義する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらのマニピュレータは、入れ子の名前空間 &lt;code&gt;tuples&lt;/code&gt; に定義されている。
例えば:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39;[&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39;]&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_delimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39;,&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このコードは同じタプルをこのように出力する: &lt;code&gt;[1.0,2,Howdy folks!]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同じマニピュレータは &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; と &lt;code&gt;istream&lt;/code&gt; にも同じように働く。
&lt;code&gt;cin&lt;/code&gt; ストリームに次のようなデータがあるとしよう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次のコード:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;cin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39;[&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39;]&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tules&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_delimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39;:&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;はタプル &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;j&lt;/code&gt; にデータを読み込む。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::string&lt;/code&gt; やCスタイルの文字列を含むタプルを抽出するのは、一般的にはうまくいかない。
ストリーム化されたタプルの表現は、あいまいでない構文解析ができるとは限らないからである。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;performance&#34;&gt;パフォーマンス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;タプルの全てのアクセス関数や構築関数は、小さなインライン化された一行関数である。
したがって、 標準的な処理系なら、タプルを使うことで、手書きのタプルに似たクラスよりかかる余分なコストを除去できるだろう。
具体的には、そういう処理系なら、このコードと:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;hand_made_tuple&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;nl&#34;&gt;public:&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;hand_made_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;hand_made_tuple&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;hmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このコードに:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;パフォーマンスの差は無い。&lt;/p&gt;
&lt;p&gt;広く使われている処理系でも、タプルのこの種の用途について最適化をしくじるものが存在する(例えば bcc 5.5.1)ことに注意されたい。&lt;/p&gt;
&lt;p&gt;処理系の最適化能力に依存するが、tieのメカニズムは、関数が複数の値を返すために非const参照引数を使うのに比べて、小さなペナルティしかもたらさないだろう。
例えば、次の関数 &lt;code&gt;f1&lt;/code&gt; と &lt;code&gt;f2&lt;/code&gt; が、等価な機能を持っているとしよう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この場合、次のコードの関数呼び出し &lt;code&gt;#1&lt;/code&gt; は、&lt;code&gt;#2&lt;/code&gt; よりわずかに早いだろう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// #1&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// #2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;より突っ込んだ議論は、 [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#publ_1&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#publ_2&#34;&gt;2&lt;/a&gt;] を参照されたい。&lt;/p&gt;
&lt;h4&gt;コンパイル時間に与える影響&lt;/h4&gt;
&lt;p&gt;タプルをコンパイルする時、テンプレートのインスタンス化を大量に行う必要があるので、遅くなることがある。
処理系やタプルの要素数に依存するが、タプルの構築は、前に出てきた &lt;code&gt;hand_made_tuple&lt;/code&gt; のような、明示的に書かれた等価なクラスをコンパイルするのに比べ、10倍以上遅くなるだろう。
しかし、現実的には、プログラムは、タプルの定義以外にも多量のコードを含んでいるであろうから、その差はたぶん、気になるほどではないだろう。
非常に頻繁にタプルを使用した、複数のプログラムで計測した結果、コンパイル時間は5から10パーセント増大した。
同じテストプログラムで、コンパイル時のメモリ消費量は22から27パーセント増大した。
詳しくは [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#publ_1&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#publ_2&#34;&gt;2&lt;/a&gt;] を参照されたい。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;portability&#34;&gt;移植性&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ライブラリのコードは標準C++である(?)ので、標準規格に合致した処理系で使うことができる。
以下に、処理系の一覧と、それぞれの処理系についての既知の問題を掲げる:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;処理系&lt;/th&gt;
&lt;th&gt;問題&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;gcc 2.95&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;edg 2.44&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Borland 5.5&lt;/td&gt;
&lt;td&gt;関数ポインタとメンバ ポインタをタプルの要素にできない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Metrowerks 6.2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;cref&lt;/code&gt; ラッパが使えない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MS Visual C++&lt;/td&gt;
&lt;td&gt;参照を要素にできない(でも &lt;code&gt;tie&lt;/code&gt; は動作する)。&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;cref&lt;/code&gt; ラッパが使えない&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a id=&#34;thanks&#34;&gt;謝辞&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Gary Powell has been an indispensable helping hand.
In particular, stream manipulators for tuples were his idea.
Doug Gregor came up with a working version for MSVC.
Thanks to Jeremy Siek, William Kempf and Jens Maurer for their help and suggestions.
The comments by Vesa Karvonen, John Max Skaller, Ed Brey, Beman Dawes, David Abrahams and Hartmut Kaiser helped to improve the library.
The idea for the tie mechanism came from an old usenet article by Ian McCulloch, where he proposed something similar for std::pairs.&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;references&#34;&gt;参考文献&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a id=&#34;publ_1&#34;&gt;[1]&lt;/a&gt;
Jarvi J.: &lt;em&gt;Tuples and multiple return values in C++&lt;/em&gt;, TUCS Technical Report No 249, 1999 (&lt;a href=&#34;http://www.tucs.fi/publications&#34; target=&#34;_blank&#34;&gt;http://www.tucs.fi/publications&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;publ_2&#34;&gt;[2]&lt;/a&gt;
Jarvi J.: &lt;em&gt;ML-Style Tuple Assignment in Standard C++ - Extending the Multiple Return Value Formalism&lt;/em&gt;, TUCS Technical Report No 267, 1999 (&lt;a href=&#34;http://www.tucs.fi/publications&#34; target=&#34;_blank&#34;&gt;http://www.tucs.fi/publications&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;[3] Jarvi J.:&lt;em&gt;Tuple Types and Multiple Return Values&lt;/em&gt;, C/C++ Users Journal, August 2001.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified 2001-09-13&lt;/p&gt;
&lt;p&gt;(c) Copyright  Jaakko Jarvi 2001.&lt;/p&gt;
&lt;p&gt;Permission to copy, use, modify, sell and distribute this software and its documentation is granted provided this copyright notice appears in all copies.
This software and its documentation is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 Yoshinori Tagawa.
オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。
このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。
また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Tuple Library : design decisions rationale -- Boost.Tupleの翻訳ドキュメントを移植(close #25)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/tuple/design_decisions_rationale.html"/>
      <id>1038805d6f62f81ccd73b3c0a9601995d2e40bef:archive/boost_docs/libs/tuple/design_decisions_rationale.md</id>
      <updated>2018-06-15T21:04:52+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Tuple Library : design decisions rationale&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;名前空間について&lt;/h2&gt;
&lt;p&gt;その昔、タプルは独立した名前空間にあるべきか、直接 &lt;code&gt;boost&lt;/code&gt; 名前空間にあるべきかについて、議論がなされた。
一般的な原則として、専門的なライブラリ(&lt;em&gt;graph&lt;/em&gt; や &lt;em&gt;python&lt;/em&gt; のような)は独立した入れ子の名前空間に入るべきである一方、ユーティリティ的なライブラリは直接 &lt;code&gt;boost&lt;/code&gt; 名前空間に入るべきであった。&lt;/p&gt;
&lt;p&gt;タプルはそのどちらとも決めがたい。
tupleテンプレートは明らかに汎用的なユーティリティであるが、ライブラリは他にとても多くの名前を、ただtupleテンプレートのために導入する。&lt;/p&gt;
&lt;p&gt;タプルは最初は入れ子の名前空間のもとにあった。
議論の結果、タプルの定義は &lt;code&gt;boost&lt;/code&gt; の直下に移された。
さらに継続した議論の結果、入れ子の名前空間が再び導入された。
最終的な(真剣にそう願う)解答は、今や、全ての定義を名前空間 &lt;code&gt;::boost::tuples&lt;/code&gt; に置き、最もよく使われる名前を、&lt;code&gt;::boost&lt;/code&gt; 名前空間にも同様に置こうというものである。&lt;/p&gt;
&lt;p&gt;これはusing宣言によって実現された(Dave Abrahamsの提案による):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 全てのライブラリ コード&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;make_tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この配置によって、コンストラクタによる、または &lt;code&gt;make_tuple&lt;/code&gt; あるいは &lt;code&gt;tie&lt;/code&gt; 関数によるタプル生成には、名前空間限定子が不要になる。
さらに、タプルを操作する全ての関数はKoenig-lookupで検出される。
唯一の例外は、常に明示的なテンプレート引数とともに呼び出されるため、Koenig-lookupが適用されない &lt;code&gt;get&amp;lt;N&amp;gt;&lt;/code&gt; 関数である。
そこで、getはusing宣言によって &lt;code&gt;::boost&lt;/code&gt; 名前空間に持ち上げられた。
こうして、アプリケーション プログラマのためのインタフェイスだけが、実際に名前空間 &lt;code&gt;::boost&lt;/code&gt; のもとにあることになった。&lt;/p&gt;
&lt;p&gt;その他の名前、ライブラリ作者のためのインタフェイス(consリスト、consリストを操作するメタ関数、...)は入れ子の名前空間 &lt;code&gt;::boost::tuples&lt;/code&gt; に残された。
名前&lt;code&gt;ignore&lt;/code&gt;、&lt;code&gt;set_open&lt;/code&gt;、&lt;code&gt;set_close&lt;/code&gt; および &lt;code&gt;set_delimiter&lt;/code&gt; はアプリケーション プログラマのインタフェイスに含まれるものと考えられるが、&lt;code&gt;boost&lt;/code&gt; 名前空間には入っていないことに注意されたい。
その理由は、ありがちな命名なので名前が衝突する危険があるためである。
それに、たぶん、これらはそう頻繁には使われないだろう。&lt;/p&gt;
&lt;h4&gt;名前空間に魅せられた者たちへ&lt;/h4&gt;
&lt;p&gt;入れ子の名前空間名 &lt;em&gt;tuples&lt;/em&gt; は多少の議論を惹き起こした。
最も自然な命名である&#39;tuple&#39;を使わなかった理論的根拠は、tupleテンプレートと同一の名前を持つことを避けたからである。
しかし、boost librariesでは、名前空間名は一般に複数形ではない。
最初は、名前空間とクラスに同じ名前を使っても、深刻なトラブルは報告されなかったので、&#39;tuples&#39;を&#39;tuple&#39;に変えようかとも考えた。
しかし結局トラブルが見つかった。
gccとedgコンパイラが、名前空間名とクラス名が同一の場合、using宣言を拒絶したのである:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tie&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// error&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;とはいえ、グローバル名前空間では同様のusing宣言はokらしい:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;consリストの終端マーク(nil, null_type, ...)&lt;/h2&gt;
&lt;p&gt;タプルは内部的には &lt;code&gt;cons&lt;/code&gt; リストとして表現されている:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;は&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;cons&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cons&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;を継承している。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;null_type&lt;/code&gt; はリストの終端を示すマークである。
最初の案では &lt;code&gt;nil&lt;/code&gt; であったが、この名前はMacOSで使われており、問題を起こすことが予想されたので、代わりに &lt;code&gt;null_type&lt;/code&gt; が選ばれた。
他には &lt;em&gt;null_t&lt;/em&gt; および &lt;em&gt;unit&lt;/em&gt; (SMLにおける空タプル型)も考慮の対象となった。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;null_type&lt;/code&gt; は空タプルの内部表現である: &lt;code&gt;tuple&amp;lt;&amp;gt;&lt;/code&gt; は &lt;code&gt;null_type&lt;/code&gt; から派生している。&lt;/p&gt;
&lt;h2&gt;要素のインデックス&lt;/h2&gt;
&lt;p&gt;要素のインデックスを0から始めるか1からにするかは、徹底的のさらに上をゆく議論がなされ、次の所見が得られた:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-ベースのインデックスは&#39;C++らしい&#39;。
    配列などで前例がある。&lt;/li&gt;
&lt;li&gt;1-ベースの&#39;name like&#39;インデックスもまた前例がある。
    例えば &lt;code&gt;bind1st&lt;/code&gt;, &lt;code&gt;bind2nd&lt;/code&gt;, &lt;code&gt;pair::first&lt;/code&gt; など。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;get&amp;lt;N&amp;gt;(a)&lt;/code&gt; または &lt;code&gt;a.get&amp;lt;N&amp;gt;()&lt;/code&gt; ( &lt;code&gt;a&lt;/code&gt; はタプルで、&lt;code&gt;N&lt;/code&gt; はインデックスである)のシンタックスでタプル要素にアクセスするのは、前者の種類に属すると考えられる。
そこで、最初の要素のインデックスは0とされた。&lt;/p&gt;
&lt;p&gt;1-ベースの&#39;name like&#39;インデックスを、&lt;code&gt;_1st&lt;/code&gt;, &lt;code&gt;_2nd&lt;/code&gt;, &lt;code&gt;_3rd&lt;/code&gt;, ...のような定数を使って提供しようという提案もなされた。
定数に適切な型を選べば、こんな代替構文も可能になるだろう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1st&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1st&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1st&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;だが、0-ベース以外のインデックスを提供するのはやめることにした。
次の理由による:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-ベースのインデックスは、全員を満足させないだろうが、一度決定されれば、2種類のインデックスを持った場合より混乱は少ないだろう(配列のためにこのような定数を望むものがいるだろうか?)。&lt;/li&gt;
&lt;li&gt;他の種類のインデックスを追加しても、ライブラリの利用者に、本当に新しい何か(新機能とか)を提供することにはならない。&lt;/li&gt;
&lt;li&gt;C++の変数と定数の命名規則では、短くて適切なインデックス用の定数(&lt;code&gt;_1st&lt;/code&gt;, ...のような)を定義する余地は少ない。
    それらは、bindingやlambdaライブラリに譲り、より良い用途に使ってもらおう。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a[_1st]&lt;/code&gt; (または &lt;code&gt;a(_1st)&lt;/code&gt; )構文は魅力的で、もう少しで我々にインデックス用の定数を追加させるところだった。
    しかし、0-ペースの添字はC++に深く深く根ざしている。
    我々は混乱を恐れた。&lt;/li&gt;
&lt;li&gt;こんな定数、追加しようと思えばいつでもできる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;タプルの比較&lt;/h2&gt;
&lt;p&gt;比較演算子は辞書的順序を実装する。
他の順序付け、主にdominance (&lt;em&gt;a &amp;lt; b iff for each i a(i) &amp;lt; b(i)&lt;/em&gt;)も考慮された。
我々は、辞書的順序は、最も自然な数学的順序付けではないが、日々のプログラミングで最も頻繁に必要とされると信じている。&lt;/p&gt;
&lt;h2&gt;ストリーム化&lt;/h2&gt;
&lt;p&gt;タプルのストリーム マニピュレータに設定された文字は、&lt;code&gt;ios_base::xalloc&lt;/code&gt; によって確保された &lt;code&gt;long&lt;/code&gt; 型のオブジェクト用の記憶域に格納される。
&lt;code&gt;long&lt;/code&gt;とストリームの文字型との間の変換には &lt;code&gt;static_cast&lt;/code&gt; が使われる。
従って、longと相互に変換できない文字型を持つストリームでは、コンパイルに失敗する。&lt;/p&gt;
&lt;p&gt;この問題はいつか再考されよう。
可能な解決が二つある:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常の &lt;code&gt;char&lt;/code&gt; 型のみをタプルの区切り文字として認め、ストリームの文字型との間の変換に &lt;code&gt;widen&lt;/code&gt; と &lt;code&gt;narrow&lt;/code&gt; を使う。
    これは常にコンパイルされるだろうが、一部のマニピュレータ呼び出しで、(数個のデフォルトの文字が)期待したのと違う字になるかもしれない。&lt;/li&gt;
&lt;li&gt;ストリームの文字型を格納するのに十分な領域を確保する。
    この意味するところは、区切り文字を保持するメモリを別に確保して、それへのポインタを &lt;code&gt;ios_base::xalloc&lt;/code&gt; で確保した空間に入れるということである。
    誰かやってくんない?&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;(c) Copyright Jaakko Jarvi 2001.&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 Yoshinori Tagawa.
オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。
このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。
また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Tuple library advanced features -- Boost.Tupleの翻訳ドキュメントを移植(close #25)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/tuple/tuple_advanced_interface.html"/>
      <id>1038805d6f62f81ccd73b3c0a9601995d2e40bef:archive/boost_docs/libs/tuple/tuple_advanced_interface.md</id>
      <updated>2018-06-15T21:04:52+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Tuple library advanced features&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;この文書で解説されている上位の機能はすべて、名前空間 &lt;code&gt;::boost::tuples&lt;/code&gt; にある。&lt;/p&gt;
&lt;h2&gt;タプル型のためのメタ関数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;T&lt;/code&gt; はタプル型であり、&lt;code&gt;N&lt;/code&gt; は汎整数定数式であるとする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これはタプル型 &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;N&lt;/code&gt; 番目の要素の型となる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これはタプル型 &lt;code&gt;T&lt;/code&gt; の要素数となる。&lt;/p&gt;
&lt;h2&gt;consリスト&lt;/h2&gt;
&lt;p&gt;タプルは内部的には &lt;em&gt;consリスト&lt;/em&gt; として表現されている。
例えば、タプル&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;tuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;は、型&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;cons&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cons&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cons&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cons&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;を継承している。
タプル テンプレートは、consリストにアクセスするため、typedef名 &lt;code&gt;inherited&lt;/code&gt; を提供している。
例えば: &lt;code&gt;tuple&amp;lt;A&amp;gt;::inherited&lt;/code&gt; は型 &lt;code&gt;cons&amp;lt;A, null_type&amp;gt;&lt;/code&gt; である。&lt;/p&gt;
&lt;h4&gt;空タプル&lt;/h4&gt;
&lt;p&gt;空タプル &lt;code&gt;tuple&amp;lt;&amp;gt;&lt;/code&gt; の内部表現は &lt;code&gt;null_type&lt;/code&gt; である。&lt;/p&gt;
&lt;h4&gt;headとtail&lt;/h4&gt;
&lt;p&gt;タプル テンプレートとconsテンプレートのどちらも、typedef名 &lt;code&gt;head_type&lt;/code&gt; と &lt;code&gt;tail_type&lt;/code&gt; を提供している。
&lt;code&gt;head_type&lt;/code&gt; は、タプル(またはconsリスト)の最初の要素の型となる。
&lt;code&gt;tail_type&lt;/code&gt; は、最初の要素を除いたconsリストの残りの部分となる。
最初の要素は、メンバ変数 &lt;code&gt;head&lt;/code&gt; に格納されており、tailリストはメンバ変数 &lt;code&gt;tail&lt;/code&gt; にある。
consリストは、そのheadへの参照を得るためにメンバ関数 &lt;code&gt;get_head()&lt;/code&gt; を、またtailへの参照を得るためにメンバ関数 &lt;code&gt;get_tail()&lt;/code&gt; を提供している。
どちらの関数にも、constおよび非constのバージョンがある。&lt;/p&gt;
&lt;p&gt;1要素のタプルにおいては、&lt;code&gt;tail_type&lt;/code&gt; は &lt;code&gt;null_type&lt;/code&gt; と等しく、&lt;code&gt;get_tail()&lt;/code&gt; 関数は &lt;code&gt;null_type&lt;/code&gt; のオブジェクトを返す。&lt;/p&gt;
&lt;p&gt;空タプル(&lt;code&gt;null_type&lt;/code&gt;)にはheadもtailも無い。
だから &lt;code&gt;get_head&lt;/code&gt; および &lt;code&gt;get_tail&lt;/code&gt; 関数は提供されない。&lt;/p&gt;
&lt;p&gt;タプルをconsリストとして扱うと、タプルを操作するためのジェネリックな関数を定義するのが楽になる。
例えば、次の二つの関数テンプレートは、タプルのそれぞれの要素に0を代入する(もちろん、要素型にとって代入は正当な操作でなければならない):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kr&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;set_to_zero&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;kr&#34;&gt;inline&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set_to_zero&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cons&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set_to_zero&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;consリストを構築する&lt;/h4&gt;
&lt;p&gt;consリストは、もし全ての要素がデフォルト コンストラクト可能であれば、デフォルト コンストラクト可能である。&lt;/p&gt;
&lt;p&gt;consリストは、headおよびtailから構築可能である。コンストラクタのプロトタイプは:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;cons&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;access_traits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parameter_type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
     &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;headパラメータの特性テンプレートは、任意の要素型に対して、適切なパラメータ型を選択する(参照型の要素では、パラメータ型は要素型と同じ、非参照型では、パラメータ型はconst非volatileへの参照となる)。&lt;/p&gt;
&lt;p&gt;1要素のconsリストでは、tail引数(&lt;code&gt;null_type&lt;/code&gt;)は省略してよい。&lt;/p&gt;
&lt;h2&gt;タプル要素型の特性クラス&lt;/h2&gt;
&lt;h4&gt;&lt;code&gt;access_traits&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;テンプレート &lt;code&gt;access_traits&lt;/code&gt; は3つの型関数を定義する。
&lt;code&gt;T&lt;/code&gt; があるタプルの要素型であるとしよう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;access_traits&amp;lt;T&amp;gt;::type&lt;/code&gt; は、非constのアクセス関数(非メンバおよびメンバの &lt;code&gt;get&lt;/code&gt; 関数、&lt;code&gt;get_head&lt;/code&gt; 関数)の返却値型になる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;access_traits&amp;lt;T&amp;gt;::const_type&lt;/code&gt; は、constのアクセス関数の返却値型になる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;access_traits&amp;lt;T&amp;gt;::parameter_type&lt;/code&gt; は、タプルのコンストラクタのパラメータ型になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;make_tuple_traits&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;make_tuple&lt;/code&gt; 関数によって生成されるタプルの要素型は、型関数 &lt;code&gt;make_tuple_traits&lt;/code&gt; により求められる。
型関数呼び出し &lt;code&gt;make_tuple_traits&amp;lt;T&amp;gt;::type&lt;/code&gt; は、次のように型を対応付ける:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参照型 -&amp;gt; &lt;em&gt;コンパイル時エラー&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;配列型&lt;/em&gt; -&amp;gt; &lt;em&gt;配列型へのconst参照&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; -&amp;gt; &lt;code&gt;T&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; -&amp;gt; &lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型 &lt;code&gt;reference_wrapper&lt;/code&gt; のオブジェクトは、&lt;code&gt;ref&lt;/code&gt; または &lt;code&gt;cref&lt;/code&gt; 関数によって生成されるものである(&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html#make_tuple&#34;&gt;&lt;code&gt;make_tuple&lt;/code&gt; 関数&lt;/a&gt;を参照されたい)。&lt;/p&gt;
&lt;p&gt;参照ラッパはそもそもはtuple libraryの一部であったが、今やboostの汎用的なユーティリティとなった。
&lt;code&gt;reference_wrapper&lt;/code&gt; テンプレートと &lt;code&gt;ref&lt;/code&gt; および &lt;code&gt;cref&lt;/code&gt; 関数は、主boostインクルードディレクトリにある別のファイル &lt;code&gt;ref.hpp&lt;/code&gt; において、直接 &lt;code&gt;boost&lt;/code&gt; 名前空間に定義されている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;(c) Copyright Jaakko Jarvi 2001.&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 Yoshinori Tagawa.
オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。
このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。
また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;各ライブラリの翻訳ドキュメント&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/function.html&#34;&gt;function&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;遅延呼び出し及びコールバックのための関数オブジェクトラッパ。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/functional.html&#34;&gt;functional&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;機能強化された関数オブジェクトアダプタ。 Mark Rodgers 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/graph.html&#34;&gt;graph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;汎用グラフコンポーネント及びアルゴリズム。 Jeremy Siek and a University of Notre Dame team 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/io/ios_state.html&#34;&gt;io state savers&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;入出力の状態を保存して、データが化けるのを防ぐ。 Daryle Walker 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda.html&#34;&gt;lambda&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;実際の呼び出し時の、小さな無名関数オブジェクトの定義。, from Jaakko Jävi and Gary Powell.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/math.html&#34;&gt;math&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学の領域での多くの貢献。様々な作者による。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/multi_array.html&#34;&gt;muti_array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリ上で連続したデータの配列のための多次元コンテナとアダプタ。 Ron Garcia 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/preprocessor.html&#34;&gt;preprocessor&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;繰り返しと再帰を含むプリプロセッサメタプログラミングツール群。 Vesa Karvonen 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/pool.html&#34;&gt;pool&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリプールの管理。Steve Cleary 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/random.html&#34;&gt;random&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;乱数生成のためのシステム一式。 Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/signals.html&#34;&gt;signals&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;管理されたシグナルとスロットのコールバックでの実装。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/static_assert.html&#34;&gt;static_assert&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;静的アサート(コンパイル時アサート)。 John Maddock 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/smart_ptr.html&#34;&gt;smart_ptr&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;5つのスマートポインタクラステンプレート Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/type_traits.html&#34;&gt;type_traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型の基本的な特徴のためのテンプレート。 John Maddock, Steve Cleary, et al 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>The Boost Lambda Library -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;The Boost Lambda Library&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;Copyright (c) 1999-2004 Jaakko Järvi, Gary Powell&lt;/p&gt;
&lt;p&gt;The Boost Lambda Library is free software; Permission to copy, use, modify and distribute this software and its documentation is granted, provided this copyright notice appears in all copies.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda.html#introduction&#34;&gt;In a nutshell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s02.html&#34;&gt;Getting Started&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;2.1. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s02.html#id2790109&#34;&gt;Installing the library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.2. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s02.html#id2741935&#34;&gt;Conventions used in this document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s03.html&#34;&gt;Introduction&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;3. 1. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s03.html#id2741989&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3. 2. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s03.html#id2742784&#34;&gt;Introduction to lambda expressions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html&#34;&gt;Using the library&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;4.1. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html#sect_introductory_examples&#34;&gt;Introductory Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.2. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html#sect_parameter_and_return_types&#34;&gt;Parameter and return types of lambda functors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.3. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html#sect_actual_arguments_to_lambda_functors&#34;&gt;About actual arguments to lambda functors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.4. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html#sect_storing_bound_arguments&#34;&gt;Storing bound arguments in lambda functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html&#34;&gt;Lambda expressions in details&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;5.1. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_placeholders&#34;&gt;Placeholders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.2. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_operator_expressions&#34;&gt;Operator expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.3. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_bind_expressions&#34;&gt;Bind expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.4. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_overriding_deduced_return_type&#34;&gt;Overriding the deduced return type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.5. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_delaying_constants_and_variables&#34;&gt;Delaying constants and variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.6. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_lambda_expressions_for_control_structures&#34;&gt;Lambda expressions for control structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.7. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_exceptions&#34;&gt;Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.8. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_construction_and_destruction&#34;&gt;Construction and destruction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.9. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#id2805476&#34;&gt;Special lambda expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.10. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#id2806049&#34;&gt;Casts, sizeof and typeid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.11. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_nested_stl_algorithms&#34;&gt;Nesting STL algorithm invocations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;6. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s06.html&#34;&gt;Extending return type deduction system&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s07.html&#34;&gt;Practical considerations&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;7.1. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s07.html#id2807564&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7.2. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s07.html#id2808056&#34;&gt;About compiling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7.3. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s07.html#id2808118&#34;&gt;Portability&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;8. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s08.html&#34;&gt;Relation to other Boost libraries&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;8.1. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s08.html#id2808509&#34;&gt;Boost Function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;8.2. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s08.html#id2808613&#34;&gt;Boost Bind&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;9. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s09.html&#34;&gt;Contributors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/apa.html&#34;&gt;Rationale for some of the design decisions&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;1. &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/apa.html#sect_why_weak_arity&#34;&gt;Lambda functor arity&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html&#34;&gt;Bibliography&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id=&#34;introduction&#34;&gt;1. In a nutshell&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost Lambda Library(以降BLL)はC++においての &lt;em&gt;λ抽象&lt;/em&gt; の型を実装したC++のテンプレートライブラリである。
この言葉はλ抽象によって無名の関数を定義する関数型言語やλ計算に由来する。
BLLの主な動機はSTLのアルゴリズムのための無名の関数オブジェクトを定義する柔軟で簡便な方法を提供することである。
このライブラリについて説明するにあたって、簡単なコードを見るほうが理解しやすい。
次の一行はあるSTLコンテナ &lt;code&gt;a&lt;/code&gt; の要素を空白で区切って出力する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39; &#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::cout &amp;lt;&amp;lt; _1 &amp;lt;&amp;lt; &#39; &#39;&lt;/code&gt; は単項関数オブジェクトを定義している。
変数 &lt;code&gt;_1&lt;/code&gt; はこの関数の仮引数であり、実引数のためのプレースホルダーである。
&lt;code&gt;for_each&lt;/code&gt; の繰り返しのたびに、この関数は &lt;code&gt;a&lt;/code&gt; の一つの要素を実引数として呼出される。
この実引数はプレースホルダーとして抽象化され、この関数の&#34;本体&#34;が評価される。&lt;/p&gt;
&lt;p&gt;BLLの本質は上にあげたような小さな無名の関数オブジェクトを、STLアルゴリズムを呼出す位置で直接定義することを可能にすることである。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>A. Rationale for some of the design decisions -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/apa.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/apa.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;A. Rationale for some of the design decisions&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;&lt;a id=&#34;sect_why_weak_arity&#34;&gt;1. Lambda functor arity&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;λ式におけるプレースホルダの最大のインデックスによって、結果の関数オブジェクトの引数の数が決定される。
しかし、これは単なる最少の引数の数であって、関数オブジェクトは任意の数の引数を取ることが可能である。
(これらは不要なものであり、無視される。)
二つの bind 式と次の呼出しを考えてみる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最初の行では、引数のうち &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; を無視して、次のような呼出しとなる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;一方、二行目では、引数の &lt;code&gt;y&lt;/code&gt; と &lt;code&gt;z&lt;/code&gt; が無視され、次のような呼出しとなる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;初期のライブラリでは、後者の結果はコンパイル時エラーとなった。
これは基本的に安全性と柔軟性のトレードオフであり、この問題はライブラリの Boost のレビューの時期に大規模に話し合われた。
&lt;em&gt;厳密な引数の数&lt;/em&gt; チェックの主な利点は、プログラムのエラーを初期の段階で発見できるかもしれないということと、次のように明示的に引数を無視するλ式は簡単に記述できるからである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このλ式は三つの引数を取る。
カンマ演算子の左側の引数は何もしなく、カンマ演算子は右側の引数の評価結果を返す。
引数の数を厳密にチェックしたとしても、結局は &lt;code&gt;g(x, x, x)&lt;/code&gt; の呼出しになる。&lt;/p&gt;
&lt;p&gt;厳密な引数の数のチェックに反対することの主な利点は、引数を無視することが必要となるのは普通であるので、簡単に記述できるべきであるということと、実際には厳密に引数をチェックしても、対象的なλ式の場合には特に、実際上あまり安全性を得ることができないということである。
例えば、プログラマが &lt;code&gt;_1 + _2&lt;/code&gt; という式を記述したかったが誤って &lt;code&gt;_1 + 2&lt;/code&gt; と記述した場合に、厳密に引数の数をチェックすれば、コンパイラはエラーを発見する。
しかし、間違った式が &lt;code&gt;1 + _2&lt;/code&gt; であった場合には、エラーは発見されない。
さらに、引数を緩和してチェックすれば、実装が少し単純になる。
Boost のレビューの推薦に従って、厳密な引数のチェックは却下された。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>2. Getting Started -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s02.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/ar01s02.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;2. Getting Started&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;2.1. Installing the library&lt;/h2&gt;
&lt;p&gt;ライブラリはインクルードファイルのみで構成されているため、ライブラリを利用するための特別な手続きはない。
ただし、&lt;code&gt;boost&lt;/code&gt; のインクルードディレクトリがインクルードパスに含まれている必要がある。
以下のように異った機能を提供する数々のインクルードファイルが存在する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lambda/lambda.hpp&lt;/code&gt; は様々な C++ の演算子のためのλ式を定義している。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_operator_expressions&#34;&gt;Section 5.2&lt;/a&gt;を見よ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambda/bind.hpp&lt;/code&gt; は9個までの引数のための &lt;code&gt;boost::bind&lt;/code&gt; 関数を定義している。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_bind_expressions&#34;&gt;Section 5.3&lt;/a&gt;を見よ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambda/if.hpp&lt;/code&gt; は if 文や条件演算子と等価なλ関数を定義している。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_lambda_expressions_for_control_structures&#34;&gt;Section 5.6&lt;/a&gt;を見よ。
    (&lt;code&gt;lambda.hpp&lt;/code&gt; も見ることを薦める)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambda/loops.hpp&lt;/code&gt; は繰り返し構造と等価なλ関数を定義している。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_lambda_expressions_for_control_structures&#34;&gt;Section 5.6&lt;/a&gt;を見よ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambda/switch.hpp&lt;/code&gt; は switc 文と等価なλ関数を定義している。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_lambda_expressions_for_control_structures&#34;&gt;Section 5.6&lt;/a&gt;を見よ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambda/construct.hpp&lt;/code&gt; はコンストラクタ、デストラクタ、new や delete を呼出すλ式を記述するツールを提供している。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_construction_and_destruction&#34;&gt;Section 5.8&lt;/a&gt;を見よ。
    (&lt;code&gt;lambda.hpp&lt;/code&gt;も見ることを薦める)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambda/casts.hpp&lt;/code&gt; はλ関数のための、キャストや &lt;code&gt;sizeof&lt;/code&gt;、&lt;code&gt;typeid&lt;/code&gt; を定義している。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_cast_expressions&#34;&gt;Section 5.10.1&lt;/a&gt;を見よ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambda/exceptions.hpp&lt;/code&gt; はλ関数内での例外を送出したり、補足する手段を提供する。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_exceptions&#34;&gt;Section 5.7&lt;/a&gt;を見よ。
    (&lt;code&gt;lambda.hpp&lt;/code&gt;を含む)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambda/algorithm.hpp&lt;/code&gt; と &lt;code&gt;lambda/numeric.hpp&lt;/code&gt; (標準ライブラリの &lt;code&gt;algortihm&lt;/code&gt; と &lt;code&gt;numeric&lt;/code&gt; ヘッダを参照 ) はネストした STL アルゴリズムの呼び出しを可能にする。
    詳しくは&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_nested_stl_algorithms&#34;&gt;Section 5.11&lt;/a&gt;を見よ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上に挙げた以外のパッケージ内のヘッダファイルは内部的に使用しているものである。
更に、lambda ライブラリは &lt;code&gt;Tuple&lt;/code&gt; [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__tuple&#34;&gt;tuple&lt;/a&gt;] と &lt;code&gt;type_traits&lt;/code&gt; [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__type_traits&#34;&gt;type_traits&lt;/a&gt;] の二つの Boost ライブラリに依存している。
そして、&lt;code&gt;boost/ref.hpp&lt;/code&gt; ヘッダファイルにも依存する。&lt;/p&gt;
&lt;p&gt;全ての定義は &lt;code&gt;boost::lambda&lt;/code&gt; ネームスペースとそのサブネームスペースに属する。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;id2741935&#34;&gt;2.2. Conventions used in this document&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;多くのコード例では、&lt;code&gt;std&lt;/code&gt; と &lt;code&gt;boost::lambda&lt;/code&gt; の名前空間の名前の接頭辞を省略している。
そのため事実上暗黙的に、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;という定義があると仮定している。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>3. Introduction -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s03.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/ar01s03.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;3. Introduction&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;&lt;a id=&#34;id2741989&#34;&gt;3.1. Motivation&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;現在では C++ 標準ライブラリ[&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_c++_98&#34;&gt;C++98&lt;/a&gt;]の一部となっている標準テンプレートライブラリ (STL)[&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_stepanov_94&#34;&gt;STL94&lt;/a&gt;] は汎用のコンテナとアルゴリズムのライブラリである。
一般的には STL アルゴリズムはコンテナの要素を &lt;em&gt;関数オブジェクト&lt;/em&gt; を介して操作する。
これらの関数オブジェクトはアルゴリズムに引数として渡される。&lt;/p&gt;
&lt;p&gt;関数呼び出しの文法に従って呼出されるいかなる C++ の構造も関数オブジェクトである。
STL にはいくつかの共通の用途のための関数オブジェクトがあらかじめ定義されている。
(&lt;code&gt;plus&lt;/code&gt;、&lt;code&gt;less&lt;/code&gt;、&lt;code&gt;not1&lt;/code&gt; などがある。)
例えば、&lt;code&gt;plus&lt;/code&gt; の標準的な実装の一つは次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;binary_function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;基底クラスの &lt;code&gt;binary_function&amp;lt;T, T, T&amp;gt;&lt;/code&gt; には、関数オブジェクトの引数と返り値の型のための typedef が存在する。
それらの typedef は関数オブジェクトを &lt;em&gt;適合&lt;/em&gt; させるのに必要である。&lt;/p&gt;
&lt;p&gt;上に挙げたような基本的な関数オブジェクトに加えて、適合二項関数の引数の一つを定数に定めて単項関数を作るための &lt;code&gt;binder&lt;/code&gt; テンプレートも存在する。
例えば、次のような関数オブジェクトを明示的に記述しなくとも &lt;code&gt;plus&lt;/code&gt; テンプレートとbinderテンプレートの一つ &lt;code&gt;bind1st&lt;/code&gt; を使用して等価な機能を実現できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;plus_1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;nl&#34;&gt;public:&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;plus_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;以下の二つの式は同一の関数オブジェクトを生成する。
つまり、呼出されたとき双方とも関数オブジェクトの引数に &lt;code&gt;1&lt;/code&gt; を加えた結果を返す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;plus_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind1st&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;後の式の部分式 &lt;code&gt;plus&amp;lt;int&amp;gt;()&lt;/code&gt; は二つの整数の合計を計算する二項関数オブジェクトである。
そして、&lt;code&gt;bind1st&lt;/code&gt; は 第一引数を部分的に 1 に束縛して、この関数オブジェクトを呼出す。
上記の関数オブジェクトの使用例を以下に提示する。
以下のコードはあるコンテナ &lt;code&gt;a&lt;/code&gt; の要素に 1 を加えて、その結果を標準出力ストリーム &lt;code&gt;cout&lt;/code&gt; へ出力する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ostream_iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
          &lt;span class=&#34;n&#34;&gt;bind1st&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;binder テンプレートをより一般的に適用できるようにするために、STL は関数へのポインタや参照、メンバ関数へのポインタを適合可能にする &lt;code&gt;adaptors&lt;/code&gt; を提供している。
&lt;strong&gt;さらに、標準 [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_sgi_02&#34;&gt;SGI02&lt;/a&gt;] の拡張として、関数の合成操作を含む STL の実装もある。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;これらすべての手段の目標は一つである。
STL アルゴリズムの呼出しの中で &lt;em&gt;無名関数&lt;/em&gt; を指定できるようにすることである。
言い換えると、コードの一部を関数への引数として渡すことである。&lt;/p&gt;
&lt;p&gt;しかし、この目標は部分的にしか実現できない。
上の単純な例を見ても分かる通り、標準の手段を用いた無名関数の定義は扱いにくい。&lt;/p&gt;
&lt;p&gt;ファンクタや、アダプタ、バインダや関数合成操作を含む複雑な式は理解しにくくなってしまう。&lt;/p&gt;
&lt;p&gt;それに加え、標準の手段を適用するのに重要な制限がある。
標準のバインダでは、二項関数の引数のうちの一つしか束縛することができない。
3 引数、4 引数といった 3 つ以上引数をとる関数のためのバインダが存在しないのである。&lt;/p&gt;
&lt;p&gt;Boost Lambda Library は上記のような問題を解決する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直観的な文法によって簡単に無名関数を作成できる。
    上記の例は次のように記述できる。
    &lt;code&gt;transform(a.begin(), a.end(), ostream_iterator&amp;lt;int&amp;gt;(cout), 1 + _1);&lt;/code&gt;
    または、より直観的に
    &lt;code&gt;for_each(a.begin(), a.end(), cout &amp;lt;&amp;lt; (1 + _1));&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;引数の束縛に関するほとんどの制限はなくなり、実際的には C++ のいかなる関数でも任意の引数を束縛することができる。&lt;/li&gt;
&lt;li&gt;関数合成は暗黙的にサポートされてるので個々の関数合成操作は不要である。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id=&#34;id2742784&#34;&gt;3.2. Introduction to lambda expressions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;λ式は関数型言語においては一般的なものである。
その文法は言語によって様々である。
(λ計算の形式によっても異なる)
しかし、λ式の基本的な形は次のようである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;λ式は無名関数を定義し、次のように構成される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数の仮引数 : &lt;code&gt;x1 ... xn&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;仮引数から関数の値を計算する式 e &lt;code&gt;x1 ... xn&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;λ式の簡単な例を挙げると、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;λ関数を適用するとは、形式的な引数を実際の引数で置き換えることである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;C++ におけるλ式では、&lt;code&gt;lambda x1 ... xn&lt;/code&gt; という部分がなく、形式的な引数は予め決められた名前を持っている。
現在のライブラリのバージョンでは、&lt;em&gt;プレースホルダ&lt;/em&gt; と呼ばれるこのような予め決められた形式的な引数が三つある。
&lt;code&gt;_1&lt;/code&gt; と &lt;code&gt;_2&lt;/code&gt; と &lt;code&gt;_3&lt;/code&gt; である。&lt;/p&gt;
&lt;p&gt;それぞれλ式で関数定義された関数の第一、第二、第三引数を示す。&lt;/p&gt;
&lt;p&gt;例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;の C++ における定義は&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;となる。&lt;/p&gt;
&lt;p&gt;よって、C++のλ式には文法的なキーワードは存在しない。
オペランドとしてプレースホルダーの使することは、この演算子の呼出しはλ式であることを意味する。
しかし、これは演算子の呼出しに関してのみ正しい。
関数呼出しや、操作構造、キャストなどが含まれたλ式は、特別な文法的構造が必要となる。
さらに重要なことには、関数呼出しは内部では、関数 &lt;code&gt;boost::bind&lt;/code&gt; でラップされる必要がある。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例えば、 &lt;code&gt;foo(_1, _2)&lt;/code&gt; ではなく、&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;というλ式を考えてみる。
この式に対応する C++ の式は、&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;となる。&lt;/strong&gt;
この種のλ式を &lt;em&gt;bind expressions&lt;/em&gt; と呼ぶことにする。&lt;/p&gt;
&lt;p&gt;λ式は C++ の関数オブジェクトを定義する。
よって、関数適用の文法は他の関数オブジェクトの呼出しと同様である。
すなわち、&lt;code&gt;(_1 + _2)(i, j)&lt;/code&gt; ような形である。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_partial_function_application&#34;&gt;3.2.1. Partial function application&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;関数 boost::bind は実質上 &lt;em&gt;部分関数適用&lt;/em&gt;である。
部分関数適用では、関数の引数のいくつかを定数へ束縛する。
適用の結果は別な関数である。
そして、その関数の引数はおそらく元の関数よりも少ない。
束縛されていない引数をともなって呼出されたとき、この新しい関数は束縛された引数とそうでない引数とをまとめて元の関数を呼出す。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_terminology&#34;&gt;3.2.2. Terminology&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;λ式は関数を定義する。
C++ のλ式は評価されるときに、完全に関数オブジェクト(&lt;em&gt;ファンクタ&lt;/em&gt;)を構築する。
このような関数オブジェクトを指すのに、&lt;em&gt;λファンクタ&lt;/em&gt; という言葉を用いる。
よって、この語法に従えば、λ式の評価結果はλファンクタである。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>4. Using the library -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/ar01s04.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;4. Using the library&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このセクションの目的はλライブラリの基本的な機能を紹介することである。
例外事項や特別な場合も非常にたくさんあるが、それらの議論は後のセクションにまわすことにする。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_introductory_examples&#34;&gt;4.1. Introductory Examples&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このセクションでは、STL アルゴリズムの呼出しにおける、BLL のλ式の基本的な例を示す。
いくつかの単純な式から始めて、徐々に発展させていく。
まず、コンテナ( 例えば &lt;code&gt;list&lt;/code&gt; ) の要素を &lt;code&gt;1&lt;/code&gt; に初期化してみる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_1 = 1&lt;/code&gt; という式は、&lt;code&gt;v&lt;/code&gt; の全ての要素に対して 1 を割当てるλファンクタを生成する。
[&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html#ftn.id2739587&#34;&gt;1&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;次に、ポインタのコンテナを作成し、そのポインタを &lt;strong&gt;最初の&lt;/strong&gt; コンテナ &lt;code&gt;v&lt;/code&gt; の要素を指すようにする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;_1&lt;/code&gt;という式は、&lt;code&gt;v&lt;/code&gt; のそれぞれの要素のアドレスを取得する関数オブジェクトを生成する。
そして、そのアドレスは対応する &lt;code&gt;vp&lt;/code&gt; の要素に割当てられる。&lt;/p&gt;
&lt;p&gt;次のコードは &lt;code&gt;v&lt;/code&gt; の要素の値を変化させる。
それぞれの要素に対して、関数 &lt;code&gt;foo&lt;/code&gt; が呼ばれる。
&lt;code&gt;foo&lt;/code&gt; には、各要素の値が引数として渡され、その結果は引数として渡された要素に割当てられる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次では、&lt;code&gt;vp&lt;/code&gt; の要素のソートを行う。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この &lt;code&gt;sort&lt;/code&gt; の呼出しでは、要素をポインタの指す内容の降順でソートする。&lt;/p&gt;
&lt;p&gt;最後に、次の &lt;code&gt;for_each&lt;/code&gt; の呼出しでは、ソートされた &lt;code&gt;vp&lt;/code&gt; の要素の指す内容を改行区切りで出力する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;λ式の部分式で通常の式( λ式でない )ものは即座に評価されることに注意しなければならない。
そうしないと、予期しない結果を導いてしまう。
例えば、先の例は次のように書換えてみると、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;\n&#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;部分式 &lt;code&gt;cout &amp;lt;&amp;lt; &amp;lt;&amp;lt; &#39;\n&#39;&lt;/code&gt; は即座に評価されてしまう。
その結果、一つの改行とそれに続いて &lt;code&gt;vp&lt;/code&gt; の要素が出力されてしまう。
BLL では関数 &lt;code&gt;constant&lt;/code&gt; と関数 &lt;code&gt;var&lt;/code&gt; が提供されており、それぞれ定数と変数をλ式へと変換する。
これらの関数を使用することにより、部分式が即座に評価されてしまうことを防止できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これらの関数は &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_delaying_constants_and_variables&#34;&gt;Section 5.5&lt;/a&gt; でより詳しく記述する。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_parameter_and_return_types&#34;&gt;4.2. Parameter and return types of lambda functors&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;λファンクタの呼出しの間は、実引数はプレースホルダーとして抽象化されている。
プレースホルダーは実引数の型には影響を与えない。
基本的には、抽象化されたλ式が C++ の有効な式であるかぎり、λ関数はいかなる型の引数をともなっても呼ぶことができる。
例えば、 &lt;code&gt;_1 + _2&lt;/code&gt; は、二項λファンクタを生成する。
このファンクタはいかなる型 &lt;code&gt;A&lt;/code&gt; と 型 &lt;code&gt;B&lt;/code&gt; の二つのオブジェクトと共に呼出すことができる。
これらの型には &lt;code&gt;operator+(A,B)&lt;/code&gt; が定義されていればよい。
(そして、BLL がその演算子の返り値を識別できればよい。
 詳しくは以下を見よ。)&lt;/p&gt;
&lt;p&gt;C++ には式の型を問合せるメカニズムが存在しない。
しかし、この正確な機能は C++ のλ式の実装には極めて重大である。
よって、BLL はちょっとした複雑な型推論システムを内包している。
そこでは、λ関数の返り値の型を推論するために、特性クラスの集合を使用している。
その推論システムは組み込み型や、標準ライブラリの型がオペランドである多くの式がオペランドである式を扱う。
多くのユーザ定義型も、返り値の型の決定における通常の慣例に従ってユーザが演算子を定義している限りは、うまく対応できている。&lt;/p&gt;
&lt;p&gt;しかしながら、返り値の型を推論できない場合が存在する。
例えば、次のように定義をしたとすると、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次のλファンクタの呼出しは、返り値の型を推論できないために失敗する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これを解決するには二つの代替案がある。
一つ目は、BLL の型推論システムを独自の型に対応するために拡張することである。
(詳しくは &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s06.html#sect_extending_return_type_system&#34;&gt;Section 6&lt;/a&gt; を見よ)
二つ目の方法は次のように特別なλ式 &lt;code&gt;ret&lt;/code&gt; を使用することである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このλ式は型推論システムに代わって、返り値の型を決定する。
(詳しくは &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_overriding_deduced_return_type&#34;&gt;Section 5.4&lt;/a&gt; を見よ)&lt;/p&gt;
&lt;p&gt;bind 式に関しては、返り値の型はテンプレート引数として次のように指定することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_actual_arguments_to_lambda_functors&#34;&gt;4.3. About actual arguments to lambda functors&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般的な実引数の制限は、実引数は constでない右辺値ではないということである。
例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// error (!)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;である。
この制限はそれほど悪いものではない。
λファンクタはたいていの場合、STL のアルゴリズム中で呼出されるため、引数は参照外しのイテレータであり、参照外しの操作が右辺値を返すことはほとんどないからである。
そして、右辺値を返すような場合には、&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_rvalues_as_actual_arguments&#34;&gt;Section 5.9.2&lt;/a&gt;で述べるような代替案がある。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_storing_bound_arguments&#34;&gt;4.4. Storing bound arguments in lambda functions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;デフォルトの動作では、束縛された引数の const な一時的なコピーは、λファンクタ中に格納される。
つまり、束縛された引数の値は、λ関数の生成時に固定され、かつ、λ関数オブジェクトのライフタイムの間は定数であり続けるということである。
例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最後の行の式の値は 4 ではなく、3 である。
言い換えると、λ式 &lt;code&gt;_1 + i&lt;/code&gt; は &lt;code&gt;lambda x.x+i&lt;/code&gt; ではなく、&lt;code&gt;lambda x.x+1&lt;/code&gt; というλ関数を生成する。&lt;/p&gt;
&lt;p&gt;先に述べたように、これはあくまでデフォルトの動作であって、例外もある。
正確な規則は次のようになる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;プログラマは &lt;code&gt;ref&lt;/code&gt; や &lt;code&gt;cref&lt;/code&gt; のラッパ[&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__ref&#34;&gt;ref&lt;/a&gt;]を使用することにより、格納のメカニズムを操作することができる。
    引数を &lt;code&gt;ref&lt;/code&gt; や &lt;code&gt;cref&lt;/code&gt;でラップすることにより、引数をそれぞれ参照として、const への参照として格納するように指定することができる。
    例えば、先の例の変数 &lt;code&gt;i&lt;/code&gt; を &lt;code&gt;ref&lt;/code&gt; でラップして書き直せば、&lt;code&gt;lambda x.x+i&lt;/code&gt;というλ式を作成し、最後の行の式の値は 4 となる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;cref&lt;/code&gt; は &lt;code&gt;var&lt;/code&gt; や &lt;code&gt;constant&lt;/code&gt; とは異ることに注意しなさい。
後者は、λファンクタを生成するのに対し、前者はそうではない。
例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// not ok, ref(i) is not a lambda functor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;となる。
関数 &lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;cref&lt;/code&gt; はほとんど歴史的な理由からのみ存在している。
そして、&lt;code&gt;ref&lt;/code&gt; は &lt;code&gt;var&lt;/code&gt; で &lt;code&gt;cref&lt;/code&gt; は &lt;code&gt;constant_ref&lt;/code&gt;で置き換えることができる。
詳しくは &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_delaying_constants_and_variables&#34;&gt;Section 5.5&lt;/a&gt; を見よ。
&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;cref&lt;/code&gt; は Boost の基本的な目的のユーティリティー関数であるので、&lt;code&gt;boost&lt;/code&gt; ネームスペースに直接定義されている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配列型はコピーすることはできず、デフォルトの動作では、const な参照として格納される。&lt;/li&gt;
&lt;li&gt;いくつかの式については、参照として引数を格納するほうが納得がいく。
    例えば、λ式&lt;code&gt;i += _1&lt;/code&gt;の意図は明らかに、λファンクタの呼出しにより、一時的なコピーではなく、変数 &lt;code&gt;i&lt;/code&gt; そのものの値に影響を与えることである。
    別な例を挙げると、ストリームの演算子は const でない参照として最左の引数をとる。
    正確な規則は次のようになる。&lt;ul&gt;
&lt;li&gt;複合代入演算子(&lt;code&gt;+=&lt;/code&gt; や &lt;code&gt;*=&lt;/code&gt; のようなもの)の左側の引数は、const でない参照として格納される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; の左の引数が &lt;code&gt;basic_ostream&lt;/code&gt; の &lt;strong&gt;インスタンス化&lt;/strong&gt; から派生していた場合や、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; の左の引数が &lt;code&gt;basic_istream&lt;/code&gt; の &lt;strong&gt;インスタンス化&lt;/strong&gt; から派生した場合には、その引数は constでない参照として格納される。
    その他の型に関しては、引数はコピーとして格納される。&lt;/li&gt;
&lt;li&gt;ポインタの算術式においては、const でない配列型は、constでない参照として格納される。
    これは、ポインタの算術計算によって、const でない配列が const になるのを防ぐためである。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;[&lt;a id=&#34;ftn.id2739587&#34;&gt;1&lt;/a&gt;]
厳密には、C++ 標準規格では、&lt;code&gt;for_each&lt;/code&gt; は &lt;em&gt;変更のない連続操作&lt;/em&gt; であり、&lt;code&gt;for_each&lt;/code&gt; へ渡す関数オブジェクトはその引数をを変更すべきでないと定義されている。
この引数に対する要求は不必要に厳しすぎる。
なぜなら、イテレータが &lt;strong&gt;mutable&lt;/strong&gt; である限り、&lt;code&gt;for_each&lt;/code&gt; は引数への副作用のある関数オブジュクトも処理できるからである。
&lt;strong&gt;それでもやはり、&lt;code&gt;std::for_each&lt;/code&gt; の機能を持つが、引数に関する一層きめの細かい要求の関数テンプレートを提供することは簡単である。&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>5. Lambda expressions in details -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/ar01s05.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;5. Lambda expressions in details&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このセクションでは様々な形のλ式を詳しく説明する。
個々のサブセクションではそれぞれ有効なλ式の形式について説明している。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_placeholders&#34;&gt;5.1. Placeholders&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;BLL では、&lt;code&gt;placeholder1_type&lt;/code&gt;、&lt;code&gt;placeholder2_type&lt;/code&gt;、&lt;code&gt;placeholder3_type&lt;/code&gt; という 3 つのプレースホルダー型を定義されている。
また、BLL ではそれぞれのプレースホルダー型の変数、&lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;_2&lt;/code&gt; and &lt;code&gt;_3&lt;/code&gt; があらかじめ定義されている。
しかし、ユーザはこれらのプレースホルダーを使用しなくともよい。
別な名前のプレースホルダーは簡単に定義できる。
プレースホルダー型の新しい変数を定義すればよい。
例えば、次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;placeholder1_type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;placeholder2_type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;placeholder3_type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これらの変数を定義すれば、&lt;code&gt;X += Y * Z&lt;/code&gt; は &lt;code&gt;_1 += _2 * _3&lt;/code&gt; と等価である。&lt;/p&gt;
&lt;p&gt;λ式でのプレースホルダーの使用法によって、そのλ式が表現する関数が、無引数か、一引数か、二引数か、三引数かが決まる。
最も大きいインデックスのプレースホルダーが決定する。
例えば、次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;              &lt;span class=&#34;c1&#34;&gt;// unary&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// unary&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;             &lt;span class=&#34;c1&#34;&gt;// binary&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 3-ary&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;             &lt;span class=&#34;c1&#34;&gt;// 3-ary&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;注意が必要なのは、最後の行のλ式は三引数の関数を生成することである。
その関数は、第一、第二引数を無視し、&lt;em&gt;第三引数&lt;/em&gt; に 10 を加える。
さらに、λファンクタは最低限の引数しかもたない。
しかし、より多くの引数を(サポートされているプレースホルダーの数までであれば)与えることが可能である。
このことは実際に必要となる。
余剰な引数は単に無視されるだけである。
例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// returns i, discards j and k&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// returns j+j, discards i and k&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;となる。
この機能の背景にある設計理由にについては、&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/apa.html#sect_why_weak_arity&#34;&gt;Section 1&lt;/a&gt; を見よ。&lt;/p&gt;
&lt;p&gt;これら三つのプレースホルダー型に加えて、四つ目のプレースホルダー型 &lt;code&gt;placeholderE_type&lt;/code&gt; もある。
このプレースホルダーの使い方は、λ式内での例外処理を説明する &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_exceptions&#34;&gt;Section 5.7&lt;/a&gt; で定義している。&lt;/p&gt;
&lt;p&gt;実引数がプレースホルダーに渡されたとき、パラメタはいつも参照によって渡される。
これは、プレースホルダーに対するいかなる副作用も実引数に反映させるためである。
例えば、次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// i is now 3&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// i is now 4, outputs 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_operator_expressions&#34;&gt;5.2. Operator expressions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;基本的な規則では、少なくとも一つのλ式を引数とするすべての C++ の演算子の呼出しは、それ自身がλ式である。
オーバーロード可能な演算子のほとんどはサポートしている。
例えば、以下のものは有効なλ式である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかし、いくつかの制限もある。
それらは、C++ の演算子のオーバーロードの規則に基づくものと、特別な場合のものとある。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;id2740636&#34;&gt;5.2.1. Operators that cannot be overloaded&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いくつかの演算子は完全にオーバーロードすることができない。
(例えば、&lt;code&gt;::&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;.*&lt;/code&gt;)
また、いくつかの演算子に関しては、返り値の型の認識が必要なために、λ式を生成するためのオーバーロードをすることができない。
&lt;code&gt;-&amp;gt;.&lt;/code&gt;, &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new[]&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;delete[]&lt;/code&gt; and &lt;code&gt;?:&lt;/code&gt; (条件演算子)がそういった演算子である。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_assignment_and_subscript&#34;&gt;5.2.2. Assignment and subscript operators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;こういった演算子はクラスのメンバ関数として実装しなければならない。
よって、演算子の左側の引数はλ式でなければならない。
例えば次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// not ok. i is not a lambda expression&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この制限に関する単純な解決策を &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_delaying_constants_and_variables&#34;&gt;Section 5.5&lt;/a&gt; において説明する。
簡潔にいうと、左側のオペランドを 次のように特別な関数 &lt;code&gt;var&lt;/code&gt; でラップして明示的にλファンクタとすればよい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_logical_operators&#34;&gt;5.2.3. Logical operators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;論理演算子は短絡評価の規則に従う。
例えば、次のコードでは、&lt;code&gt;i&lt;/code&gt; は決してインクリメントされることはない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_comma_operator&#34;&gt;5.2.4. Comma operator&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;コンマ演算子はλ式中の文の区切りである。
コンマは関数呼出しの引数の区切りでもあるため、余分な括弧が必要になることがある。
例えば、次のようなときである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;++_1, cout &amp;lt;&amp;lt; _1&lt;/code&gt; を囲う余分な括弧がないと、このコードは &lt;code&gt;for_each&lt;/code&gt; を 4 つの引数で呼出そうとしていると解釈されてしまう。&lt;/p&gt;
&lt;p&gt;コンマ演算子を用いて作成されたλファンクタは、左のオペランドを評価してから、右のオペランドを評価するという C++ の規則と同じように評価する。
上に挙げた例では、&lt;code&gt;a&lt;/code&gt; の要素それぞれに対して、まずインクリメントされ、その後でストリームへ書き出される。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_function_call_operator&#34;&gt;5.2.5. Function call operator&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;関数呼出し演算子にはλファンクタを評価する効果がある。
少ない引数での呼出しはコンパイル時エラーとして検出される。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_member_pointer_operator&#34;&gt;5.2.6. Member pointer operator&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;メンバポインタ演算子 &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; は自由にオーバーロード可能である。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;よって、ユーザ定義型に関してはメンバポインタ演算子の特別な場合はない。
しかし、組み込み型においてはもう少し複雑な場合がある。
組み込みのメンバポインタ演算子は、左の引数があるクラス &lt;code&gt;A&lt;/code&gt; のオブジェクトを指すポインタであり、右側の引数が &lt;code&gt;A&lt;/code&gt; のメンバへのポインタであるか、&lt;code&gt;A&lt;/code&gt; から派生したクラスのメンバへのポインタであった場合に適用される。
さらに、次の二つの場合は分けて考えなければならない。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;まず、右側の引数がメンバ変数へのポインタであるときである。
    この場合は、λファンクタは単純に実引数の代入を行い、引数のポインタが指しているメンバ変数の参照を返す組み込みのメンバポインタ演算子が呼ばれる。
    例えば、次のようになる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// returns a reference to a-&amp;gt;d&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// likewise&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;次に、右側の引数がメンバ関数へのポインタであるときである。
    このような組み込みの演算子の呼出しは、一種のメンバ関数の遅延呼出しのような結果となる。
    このような式の後には、メンバ関数の遅延呼出しのための引数リストが続かなくてはならない。
    例えば、次のようになる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// returns a delayed call to b-&amp;gt;foo&lt;/span&gt;
                        &lt;span class=&#34;c1&#34;&gt;// a function argument list must follow&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// ok, calls b-&amp;gt;foo(1)&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// returns a delayed call to b-&amp;gt;foo,&lt;/span&gt;
                        &lt;span class=&#34;c1&#34;&gt;// no effect as such&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// calls b-&amp;gt;foo(1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_bind_expressions&#34;&gt;5.3. Bind expressions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;bind 式には次の二つの形がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;member&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;bind 式は関数の呼出しを遅延させる。
もし、&lt;em&gt;target-function&lt;/em&gt; が &lt;em&gt;n&lt;/em&gt; 引数の関数であれば、&lt;code&gt;bind-argument-list&lt;/code&gt; も同様に &lt;em&gt;n&lt;/em&gt; 個の引数を含んでいなければならない。
現在のバージョンの BLL では、引数の数 n には、&lt;code&gt;0 &amp;lt;= n &amp;lt;= 9&lt;/code&gt; という制限がある。
メンバ関数に適用する場合には、対象のオブジェクトが引数として渡されるため、引数の数は最大 8 個に抑えなければならない。
基本的には、引数がプレースホルダーである、またより一般的に言えば、λ式であることを除けば、&lt;code&gt;bind-argument-list&lt;/code&gt; は目的の関数への有効な引数のリストでなければならない。
また、目的の関数はλ式であってもよい。
bind 式の結果は、無引数、一引数、二引数、または、三引数の関数オブジェクトである。
この引数の数は、&lt;code&gt;bind-argument-list&lt;/code&gt; 内のプレースホルダーの使い方によって決定される。
(詳しくは &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_placeholders&#34;&gt;Section 5.1&lt;/a&gt; を見よ)&lt;/p&gt;
&lt;p&gt;次の例で示すように、bind 式で作成されたλファンクタの返り値は、テンプレート引数として明示的に指定される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RET&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この明示的な指定は、目的の関数の返り値の型を推論できなかった場合のみ必要となる。&lt;/p&gt;
&lt;p&gt;以下のサブセクションでは、様々な bind 式の形について説明している。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_function_pointers_as_targets&#34;&gt;5.3.1. Function pointers or references as targets&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;目的の関数は、関数のポインタであっても参照であってもよく、また、その関数が束縛されても、束縛されてなくともよい。
例えば、次の例の bind 式は全て有効である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;返り値の型の推論はこれらの bind 式では全て解決できる。&lt;/p&gt;
&lt;p&gt;C++ ではオーバーロードされた関数のアドレスは、直接アドレスが指定されるか、 &lt;strong&gt;曖昧さを解決する型を持つ変数の初期化として使用されるか、&lt;/strong&gt; 明示的なキャストが使用された場合のみ取得することができる。
つまり、オーバーロードされた関数は、次に示すように直接 bind 式で使用することはできない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                            &lt;span class=&#34;c1&#34;&gt;// error&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pf1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pf1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                             &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;static_cast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;member_functions_as_targets&#34;&gt;5.3.2. Member functions as targets&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;bind 式においてメンバ関数へのポインタを使用するための文法は次の通りである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;member&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;オブジェクトは、参照でもポインタでもよい。
BLL は両方の場合を同一のインターフェースでサポートしている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;find_if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;find_if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;同様に、オブジェクトが束縛されていなければ、bind 式の結果のλファンクタは実際に渡された引数がポインタか参照かによってどちらも呼ぶことができる。
次にその例を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pointers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;find_if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;refs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;find_if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pointers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pointers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;インターフェースは同じであっても、オブジェクトがポインタであるか、参照であるかには、重要な意味的な違いがある。
この違いは、関数 &lt;code&gt;bind&lt;/code&gt; の引数の取り方と、束縛された引数をλファンクタ内に格納する方法によるものである。
オブジェクトは他の bind の引数と同様に渡され、格納される。(&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html#sect_storing_bound_arguments&#34;&gt;Section 4.4&lt;/a&gt; 参照);
つまり、const な参照として渡され、const なコピーとしてλファンクタに格納される。
これにより、λファンクタと元々のメンバ関数や、見た目には同じλファンクタの間に非対称性が生じてしまう。
例えば、次のような場合である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;mutable&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;nl&#34;&gt;public:&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ii&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;jj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ii&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;set_i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set_j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ポインタとして使用された場合には、次の動作は恐らくプログラマが期待したものである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// a.i == 1&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// a.j == 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;オブジェクトの const なコピーが格納されていたとしても、元のオブジェクト &lt;code&gt;a&lt;/code&gt; も変更されている。
これは、オブジェクトがポインタとして渡されたためであり、ポインタが指すオブジェクトがコピーされたのではなく、ポインタ自身がコピーされたためである。
参照として使用された場合には、異った動作となる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// error; a const copy of a is stored.&lt;/span&gt;
                           &lt;span class=&#34;c1&#34;&gt;// Cannot call a non-const function set_i&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// a.j == 0, as a copy of a is modified&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コピーの発生を防ぐためには、次のように &lt;code&gt;ref&lt;/code&gt; や &lt;code&gt;cref&lt;/code&gt; のラッパを使用すればよい。
(&lt;code&gt;var&lt;/code&gt; や &lt;code&gt;constant_ref&lt;/code&gt; も同様である )&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// a.j == 1&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// a.j == 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここまでの事項の内容は束縛された引数にのみ関係する。
オブジェクトが束縛されていない場合には、引数は常に参照として渡される。
よって、次の二つのλファンクタでは、引数 &lt;code&gt;a&lt;/code&gt; はコピーされない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// a.i == 1&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// a.j == 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_members_variables_as_targets&#34;&gt;5.3.3. Member variables as targets&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;メンバ変数へのポインタは実際には関数ではない。
しかし、それにも関らず、関数 &lt;code&gt;bind&lt;/code&gt; は第一引数にメンバ変数へのポインタを取ることが可能である。
このような bind を呼出すと、そのメンバ変数の参照が返される。
例えば、次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// a.data == 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;参照されるメンバ変数を持つオブジェクトの const/volatile の修飾子は尊重される。
例えば、次の例では const な位置へ書き込もうとしている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ca&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ca&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_function_objects_as_targets&#34;&gt;5.3.4. Function objects as targets&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;関数オブジェクトも目的の関数として使用できる。
関数オブジェクトとは、関数呼出し演算子が定義されたクラスオブジェクトのことである。
一般的には、BLL は任意の関数オブジェクトの返り値の型を推論することはできない。
しかし、この機能を特定の関数オブジェクトのクラスに提供する方法がある。&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;id2803238&#34;&gt;The sig template&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;BLL が関数オブジェクトの返り値の型を認識するためには、 &lt;code&gt;type&lt;/code&gt; という返り値の型を指定する typedef を持った &lt;code&gt;sig&amp;lt;Args&amp;gt;&lt;/code&gt; メンバテンプレート構造体を提供する必要がある。
これが簡単な例である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sig&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;テンプレート引数 &lt;code&gt;Args&lt;/code&gt; は &lt;code&gt;tuple&lt;/code&gt;(より正確に言えば、&lt;code&gt;cons&lt;/code&gt;リスト) 型 [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__tuple&#34;&gt;tuple&lt;/a&gt;] である。
そして、最初の要素は関数オブジェクト自身であり、残りの要素は関数オブジェクトが呼ばれるときの引数の型である。
これは、&lt;code&gt;return_type&lt;/code&gt; typedef で指定する標準ライブラリの関数オブジェクトの返り値の型の定義の仕様と比較すると、必要以上に複雑に見えるかもしれない。
しかし、返り値の型を単純な typedef で示すためには、二つの重要な制限が必要となる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数オブジェクトが複数の関数呼出し演算子を定義していた場合、それらに対し異なる返り値の型を指定する方法がない。&lt;/li&gt;
&lt;li&gt;関数呼出し演算子がテンプレートであった場合、返り値の型はそのテンプレート引数に依存するかもしれない。
    よって、typedef もテンプレートであるはずである。
    しかし、C++ はこれをサポートしていない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下のコードは、返り値の型が引数の一つの型に依存する例であり、 &lt;code&gt;sig&lt;/code&gt; テンプレートによって、どのように依存関係を表現できるかを示している。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// the return type equals the third argument type:&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;T3&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;sig&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// get the third argument type (4th element)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tuples&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;element&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;T3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;nl&#34;&gt;public:&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;remove_cv&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Args&lt;/code&gt; タプルの要素は常に参照でない型である。
さらに、要素の型は、const や volatile または、その両方によって修飾されることがある。
これにより、引数の const/volatile 修飾子によって、返り値の型へ影響を与えることが可能となる。
また、潜在的に const/volatile によって修飾子された関数オブジェクトの型自身が &lt;code&gt;Args&lt;/code&gt; タプルに含まれていることにより、関数オブジェクトクラスは、const と 非 const (または、volatile や const volatile )の関数呼出し演算子を両方含むことができ、かつ、それぞれの異なる返り値の型とすることが可能となる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sig&lt;/code&gt; テンプレートは引数の型のタプルから、その型の引数をともなって呼ばれた場合の返り値の型への &lt;em&gt;メタ関数&lt;/em&gt; と見ることができる。
上で示した例のように、テンプレートは結局何かと複雑になってしまうことがある。
典型的な場合に実行されるのは、const/volatile 修飾子を取り除くなどして、タプルから関係のある型を取り出すことである。
これらのことの助けとなる手段については、Boost の type_traits [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__type_traits&#34;&gt;type_traits&lt;/a&gt;] と Tuple [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__type_traits&#34;&gt;type_traits&lt;/a&gt;] のライブラリを見よ。
&lt;code&gt;sig&lt;/code&gt; テンプレートは最初に FC++ ライブラリ [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_fc++&#34;&gt;fc++&lt;/a&gt;] で導入された同様な仕組を洗練したものである。&lt;/p&gt;
&lt;p&gt;初期のバージョンのライブラリでは、標準ライブラリの仕様をデフォルトでサポートしており、&lt;code&gt;sig&lt;/code&gt; テンプレートを認識させるためには特別な操作が必要であった。
現在の BLL では、これが逆になっている。
標準ライブラリの仕様に従ったファンクタを bind 式で使用する必要があるときのために、 &lt;code&gt;std_functor&lt;/code&gt; ラッパ が提供されている。
このラッパにより、&lt;code&gt;result_type&lt;/code&gt; typedef に基づいて、&lt;code&gt;sig&lt;/code&gt; テンプレートが用意される。
例えば、次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;              &lt;span class=&#34;c1&#34;&gt;// error, no sig template&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std_functor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_overriding_deduced_return_type&#34;&gt;5.4. Overriding the deduced return type&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;返り値の型推論システムは一部のユーザ定義の演算子とクラスオブジェクトを含んだ bind 式の返り値の型を解決できないかもしれない。
返り値の型を明示し、型推論システムをオーバーライドするために、特別なλ式の型が提供されている。
λ式 &lt;code&gt;e&lt;/code&gt; で定義されるλファンクタの返り値が &lt;code&gt;T&lt;/code&gt; であると示すには、次のように記述すればよい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これにより、λ式 &lt;code&gt;e&lt;/code&gt; には返り値の型推論が一切行われない。
そのかわりに、&lt;code&gt;T&lt;/code&gt; が返り値として使用される。
明かに、&lt;code&gt;T&lt;/code&gt; には任意の型が指定できるわけではない。
真のλファンクタの型は暗黙的に &lt;code&gt;T&lt;/code&gt; に変換可能でなければならない。
例えば、次のようなことである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// error (C cannot be converted to D)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok (int can be converted to float)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// error, return type cannot be deduced&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;bind 式に関しては、&lt;code&gt;ret&lt;/code&gt; の代わりに使用できる簡便な表記がある。
先の例の最後の行は、次のように記述することが可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この機能は Boost Bind library [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__bind&#34;&gt;bind&lt;/a&gt;] に倣ったものである。&lt;/p&gt;
&lt;p&gt;ネストしたλ式中においては、 &lt;code&gt;ret&lt;/code&gt; はそれなしでは返り値の型推論に失敗するそれぞれの部分式について使用しなければならない。
例えば次のようなことである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;D&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// error&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もし、&lt;code&gt;ret&lt;/code&gt; を同一の型に何度も使用しているのであれば、返り値の型推論を拡張する価値がある。
(詳しくは &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s06.html#sect_extending_return_type_system&#34;&gt;Section 6&lt;/a&gt; を見よ)&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_nullary_functors_and_ret&#34;&gt;5.4.1. Nullary lambda functors and ret&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;ここまでで示したように、&lt;code&gt;ret&lt;/code&gt; により返り値の型推論を実行することを防ぐことができる。
しかし、例外もある。
&lt;strong&gt;C++ のテンプレートのインスタンス化の働きのために、コンパイラは 0 引数のλファンクタに関しては、常に返り値の型が解決されたテンプレートのインスタンス化を強制する。&lt;/strong&gt;
これにより、&lt;code&gt;ret&lt;/code&gt; にちょっとした問題が発生する。
次の例がそれをよく表わしている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;F&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// fails, cannot deduce the return type&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// fails, cannot deduce the return type&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// fails as well!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;BLL は &lt;code&gt;F&lt;/code&gt; は &lt;code&gt;result_type&lt;/code&gt; typedef を定義していないため、上のような bind の呼出しの返り値の型を推論することはできない。
&lt;code&gt;ret&lt;/code&gt; がこれを解決してくれるだろうと期待するかもしれないが、(上の例の最後の行のような) bind 式の結果である引数なしのλファンクタに関しては、うまく機能しないのである。
&lt;strong&gt;たとえ不必要であったとしても、返り値の型が解決されたテンプレートがインスタンス化される。
その結果としてコンパイル時エラーとなる。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;この問題の解決法は関数 &lt;code&gt;ret&lt;/code&gt; を使用することではなく、次のように &lt;code&gt;bind&lt;/code&gt; の呼出しにおいて、テンプレート引数で明示的に返り値の型を指定することである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ret&amp;lt;T&amp;gt;(bind(arg-list))&lt;/code&gt; から生成されたλファンクタと、&lt;code&gt;bind&amp;lt;T&amp;gt;(arg-list)&lt;/code&gt; から生成されたλファンクタは全く同一の機能を持つ。
異なるのは前者は一部の無引数のλファンクタにおいてうまく動作しないのに対し、後者はその場合にも動作するということである。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_delaying_constants_and_variables&#34;&gt;5.5. Delaying constants and variables&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;単項関数 &lt;code&gt;constant&lt;/code&gt; と &lt;code&gt;constant_ref&lt;/code&gt; と &lt;code&gt;var&lt;/code&gt; は引数を &lt;strong&gt;同一のマッピングを実装する&lt;/strong&gt; λファンクタへと変化させる。
前の二つは定数に用い、最後のものは変数に用いる。
これらの &lt;em&gt;評価を遅延させた&lt;/em&gt; 定数や変数は、明示的なλ式の文法がないために必要となる。
例を挙げると、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39; &#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39; &#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最初の行では、&lt;code&gt;a&lt;/code&gt; の要素を空白で区切って出力するが、二行目では、一つ空白を出力しそのあとに区切なしで、&lt;code&gt;a&lt;/code&gt; の要素を出力する。
これは、&lt;code&gt;cout &amp;lt;&amp;lt; &#39; &#39;&lt;/code&gt; のオペランドのいずれもλ式でないためである。
よって、&lt;code&gt;cout &amp;lt;&amp;lt; &#39; &#39;&lt;/code&gt; が即座に評価されてしまうのである。
&lt;code&gt;cout &amp;lt;&amp;lt; &#39; &#39;&lt;/code&gt; の評価を遅延させるためには、オペランドの一つをλ式であると明示的に示さなくてはならない。
これは、関数 &lt;code&gt;constant&lt;/code&gt; によって行なえる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39; &#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constant(&#39; &#39;)&lt;/code&gt; の呼出しにより、無引数のλファンクタが生成される。
このファンクタは、定数文字 &lt;code&gt;&#39; &#39;&lt;/code&gt; を格納し、呼出されたときにこの文字への参照を返す。
関数 &lt;code&gt;constant_ref&lt;/code&gt; も、引数の定数への参照を格納するという点を除いて、同様である。
&lt;code&gt;constant&lt;/code&gt; と &lt;code&gt;constant_ref&lt;/code&gt; は上記の例のように、演算子の呼出しに副作用があるときにのみ必要となる。&lt;/p&gt;
&lt;p&gt;時々変数の評価を遅延させる必要がある。
コンテンナの要素を番号付けしたリストとして出力したいとする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;:&#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;:&#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&#39;\n&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最初の行の &lt;code&gt;for_each&lt;/code&gt; の呼出しは期待通りには動作しない。
&lt;code&gt;index&lt;/code&gt; は一度だけインクリメントされ、その値が一度だけ出力ストリームに書き出される。
&lt;code&gt;var&lt;/code&gt; を使用して、&lt;code&gt;index&lt;/code&gt; をλ式とすることにより、望む効果が得られる。&lt;/p&gt;
&lt;p&gt;まとめると、&lt;code&gt;var(x)&lt;/code&gt; は変数 &lt;code&gt;x&lt;/code&gt;への参照を格納した無引数のλファンクタを生成する。
このλファンクタが呼出されると、&lt;code&gt;x&lt;/code&gt; への参照が返される。&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;id2804084&#34;&gt;Naming delayed constants and variables&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;λ式の外側で遅延評価する変数や定数を前もって定義し、名前付けすることも可能である。
テンプレート &lt;code&gt;var_type&lt;/code&gt; や &lt;code&gt;constant_type&lt;/code&gt; や &lt;code&gt;constant_ref_type&lt;/code&gt; はこの目的のために提供されている。
これらは次のように使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;var_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delayed_i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;constant_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delayed_c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最初の行では、型 &lt;code&gt;T&lt;/code&gt; の変数 &lt;code&gt;i&lt;/code&gt; の遅延評価用の変数 &lt;code&gt;delayed_i&lt;/code&gt; を定義している。
同様に、二行目では、定数 &lt;code&gt;c&lt;/code&gt; の遅延評価用の定数として &lt;code&gt;delayed_c&lt;/code&gt;を定義している。
例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;は次のものと等価である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;遅延評価する定数の名前付けの例を挙げると、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;constant_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&#39; &#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;id2804207&#34;&gt;About assignment and subscript operators&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_assignment_and_subscript&#34;&gt;Section 5.2.2&lt;/a&gt; で示したように、代入と添字の演算子は常にメンバ関数として定義される。
このため、 &lt;code&gt;x = y&lt;/code&gt; や &lt;code&gt;x[y]&lt;/code&gt; の形の式がλ式と解釈されるためには、左側のオペランドはλ式でなければならない。
結果として、&lt;code&gt;var&lt;/code&gt;をこの目的のために使用しなければならない場合がある。
次に、&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_assignment_and_subscript&#34;&gt;Section 5.2.2&lt;/a&gt; の例を再び示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// error&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+=&lt;/code&gt; や &lt;code&gt;-=&lt;/code&gt; といった複合代入演算子は非メンバ関数として定義することが可能である。
そのため、たとえ右側のオペランドのみがλ式であったとしても、これらの式はλ式として解釈される。
しかしながら、左側のオペランドを明示的に遅延評価させても全く問題ない。
例えば、&lt;code&gt;i += _1&lt;/code&gt; と &lt;code&gt;var(i) += _1&lt;/code&gt; は等価である。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_lambda_expressions_for_control_structures&#34;&gt;5.6. Lambda expressions for control structures&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;BLL は制御構造を表現するλファンクタを生成するいくつかの関数を定義している。
それらは、引数としてλファンクを取り、返り値は &lt;code&gt;void&lt;/code&gt; である。
まず、例を提示する。
以下のコードはあるコンテナ &lt;code&gt;a&lt;/code&gt; の偶数の要素をすべて出力する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;if_then&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;BLL は制御構造のために以下の関数テンプレートをサポートする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;if_then&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;then_part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;if_then_else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;then_part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;else_part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;if_then_else_return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;then_part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;else_part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;while_loop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;while_loop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// no body case&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;do_while_loop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;do_while_loop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// no body case&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_loop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;increment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_loop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;increment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// no body case&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;switch_statement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;すべての制御構造のλファンクタの返り値は &lt;code&gt;void&lt;/code&gt; である。
例外は、次の条件演算子の呼出しをラップする &lt;code&gt;if_then_else_return&lt;/code&gt; だけである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;then_part&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;else_part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この演算子の返り値の型の規則は少々複雑である。
基本的には、両方の分岐の結果の型が同一であれば、その型が返り値の型である。
分岐の型の結果が異なるのであれば、片方の分岐の結果、例えば &lt;code&gt;A&lt;/code&gt; はもう一つの分岐の結果、例えば &lt;code&gt;B&lt;/code&gt; に変換可能でなければならない。
このような状況では、返り値の型は &lt;code&gt;B&lt;/code&gt; である。
さらに、共通の型が左辺値であれば、返り値も左辺値になるであろう。&lt;/p&gt;
&lt;p&gt;遅延評価される変数は、制御構造のλ式によく現れる。
例えば、ここでは、&lt;code&gt;for_loop&lt;/code&gt; の引数をλ式に変換するために &lt;code&gt;var&lt;/code&gt; を使用している。
次のコードは二次元配列の各要素に 1 を加えるものである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;for_loop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
           &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;BLL は Joel de Guzmann が提案した、別な制御式の文法もサポートしている。
&lt;code&gt;operator[]&lt;/code&gt; をオーバーロードすることにより、組み込みの制御構造と非常によく似たものを実現できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;if_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;then_part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;if_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;then_part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;else_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;else_part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;while_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;do_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;while_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;increment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;例えば、この文法を使用すると 上記の &lt;code&gt;if_then&lt;/code&gt; の例は次のように記述することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;経験を積むと、これらのいくつかを結局は非難するかもしれない。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_switch_statement&#34;&gt;5.6.1. Switch statement&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;数多くの場合があるため、&lt;code&gt;switch&lt;/code&gt; 文の制御構造のλ式はもう少し複雑である。
一般的な switch 文のλ式の形は次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;switch_statement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;case_statement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;label&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;case_statement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;label&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;default_statement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;condition&lt;/code&gt; 引数は全体の返り値の型をともなったλファンクタを生成するλ式でなければならない。
関数 &lt;code&gt;case_statement&lt;/code&gt; によって各 case 文が生成され、関数 &lt;code&gt;default_statement&lt;/code&gt; によってオプションである default 文が生成される。
case 文のラベルは関数 &lt;code&gt;case_statement&lt;/code&gt; へのテンプレート引数によって明示的に指定され、&lt;code&gt;break&lt;/code&gt; 文は暗黙的に各 case 文に含まれている。
例えば、&lt;code&gt;a&lt;/code&gt; があるλファンクタであるとして、&lt;code&gt;case_statement&amp;lt;1&amp;gt;(a)&lt;/code&gt; は次のようなコードを生成する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;:
 &lt;span class=&#34;n&#34;&gt;evaluate&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;functor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;関数 &lt;code&gt;switch_statement&lt;/code&gt; は 9 つまでの case 文に特化されている。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;switch 文の完全な例を示す。
次のコードでは、あるコンテナ &lt;code&gt;v&lt;/code&gt; に関して反復しながら、0 の要素ごとに &#34;zero&#34; を、 1 の要素ごとに &#34;one&#34; を、その他の数 &lt;code&gt;n&lt;/code&gt; に対しては、&#34;other: n&#34; という文字列を出力する。
各要素の後に改行を出力するために、&lt;code&gt;switch_statement&lt;/code&gt; の後に別なλ式が続いている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;switch_statement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_statement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;:&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;zero&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_statement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;:&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;one&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;default_statement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;other: &#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_exceptions&#34;&gt;5.7. Exceptions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;BLL は 例外を送出したり、補足するλファンクタを提供している。
例外を送出するλファンクタは単項関数 &lt;code&gt;throw_exception&lt;/code&gt; によって生成される。
この関数の引数は送出する例外か、送出する例外を生成するλファンクタである。
例外を再送出するλファンクタは、無項関数 &lt;code&gt;rethrow&lt;/code&gt; によって生成される。&lt;/p&gt;
&lt;p&gt;例外を扱うλ式はもう少し複雑である。
try-catch ブロックの一般的なλ式の形は次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;try_catch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;catch_exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;catch_exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;catch_all&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expression&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最初のλ式が try ブロックである。
各 &lt;code&gt;catch_exception&lt;/code&gt; は補足する例外の型をテンプレート引数として明示的に指定して catch ブロックを定義する。
&lt;code&gt;catch_exception&lt;/code&gt; 内のλ式では、例外を補足した際の動作を定義する。
参照として補足する例外ハンドラ、すなわち、&lt;code&gt;catch_exception&amp;lt;T&amp;gt;(...)&lt;/code&gt; というλ式は次のような catch ブロックとなる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最後の catch ブロックは、&lt;code&gt;catch_exception&amp;lt;type&amp;gt;&lt;/code&gt; または、&lt;code&gt;catch(...)&lt;/code&gt; と等価のλ式 &lt;code&gt;catch_all&lt;/code&gt; の呼出しとなる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#ex_exceptions&#34;&gt;Example 1&lt;/a&gt; では BLL の例外操作の機能の使い方の実例を示している。
最初の例外ハンドラは &lt;code&gt;foo_exception&lt;/code&gt; 型の例外を補足する。
プレースホルダ &lt;code&gt;_1&lt;/code&gt; をハンドラの内部で使用している。&lt;/p&gt;
&lt;p&gt;二つ目の例外ハンドラでは、例外の送出の方法と、 &lt;em&gt;例外プレースホルダ&lt;/em&gt; &lt;code&gt;_e&lt;/code&gt; の実例を示している。
この特別なプレースホルダは、補足した例外オブジェクトをハンドラの内部から参照している。
ここでは、例外の原因を説明する文字列が付随している &lt;code&gt;std::exception&lt;/code&gt; 型の例外を扱っている。
この説明は無引数のメンバ関数 &lt;code&gt;what&lt;/code&gt; により取り出すことができる。
&lt;code&gt;bind(&amp;amp;std::exception::what, _e)&lt;/code&gt; という式はこの関数を呼出すλファンクタを生成する。
&lt;code&gt;_e&lt;/code&gt; は例外ハンドラを示すλ式の外側では使用できない。
二番目の例外ハンドラの最後の行では、新たな例外オブジェクトを構築し、 &lt;strong&gt;関数 &lt;code&gt;throw_exception&lt;/code&gt; を使用して&lt;/strong&gt;、その例外オブジェクトを送出する。
λ式中における、オブジェクトの構築と破棄に関しては、 &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_construction_and_destruction&#34;&gt;Section 5.8&lt;/a&gt; において説明する。&lt;/p&gt;
&lt;p&gt;そして、三番目の例外ハンドラ(&lt;code&gt;catch_all&lt;/code&gt;)では、例外の再送出の実例を示す。&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;ex_exceptions&#34;&gt;Example 1. Throwing and handling exceptions in lambda expressions.&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;try_catch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// foo may throw&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;catch_exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo_exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;Caught foo_exception: &#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
           &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&#34;foo was called with argument = &#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;catch_exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;Caught std::exception: &#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
           &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;what&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;throw_exception&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constructor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar_exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;catch_all&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;constant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&#34;Unknown&#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rethrow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_construction_and_destruction&#34;&gt;5.8. Construction and destruction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;演算子 &lt;code&gt;new&lt;/code&gt; と &lt;code&gt;delete&lt;/code&gt; はオーバーロード可能であるが、それらの返り値は共通である。
&lt;strong&gt;特に、返り値はλファンクタとなることはない。
そのため、λ式のためにオーバーロードされることが防げる。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;コンストラクタのアドレスを取得することはできない。
よって、コンストラクタは bind 式の対象として使用することはできない。
このことは、デストラクタに関しても同じである。
このような制限を回避するために、BLL は コンストラクタやデストラクタと同様に &lt;code&gt;new&lt;/code&gt; と &lt;code&gt;delete&lt;/code&gt; の呼出しを行なうためのラッパのクラスを定義している。
これらのクラスのインスタンスは関数オブジェクトであり、bind 式の対象として使用することが可能である。
次に例を挙げる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delete_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;new_ptr&amp;lt;int&amp;gt;()&lt;/code&gt; という式は、呼出されたときに、&lt;code&gt;new int()&lt;/code&gt;を呼出す関数オブジェクトを生成する。
そして、&lt;code&gt;bind&lt;/code&gt; 中においてその呼出しをラップすることにより、λファンクタとしている。&lt;/strong&gt;
同様に、&lt;code&gt;delete_ptr()&lt;/code&gt; という式は引数に対して、&lt;code&gt;delete&lt;/code&gt; を呼出す関数オブジェクトを生成する。
&lt;code&gt;new_ptr&amp;lt;T&amp;gt;()&lt;/code&gt; も同様に引数を取ることができる。
その引数は直接コンストラクタの呼出しに渡される。
そして、そのことにより引数をとるコンストラクタの呼出しが可能になる。&lt;/p&gt;
&lt;p&gt;λ式によるコンストラクタの例を示す。
以下のコードでは、二つのコンテナ &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; から整数を取り出し、それらの pair を構築し、三つ目のコンテナへ挿入する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;back_inserter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
          &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;constructor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#table_constructor_destructor_fos&#34;&gt;Table 1&lt;/a&gt; にオブジェクトの構築と破棄に関するすべての関数オブジェクトをまとめた。
この表は、関数オブジェクトの生成と呼出しの式とこの式の評価の効果を示している。&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;table_constructor_destructor_fos&#34;&gt;Table 1. Construction and destruction related function objects.&lt;/a&gt;&lt;/h4&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Function object call&lt;/th&gt;
&lt;th&gt;Wrapped expression&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;constructor&amp;lt;T&amp;gt;()(arg_list)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T(arg_list)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;destructor()(a)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a.~A()&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;destructor()(pa)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pa.-&amp;gt;A()&lt;/code&gt;, where &lt;code&gt;pa&lt;/code&gt; is of type &lt;code&gt;A*&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;new_ptr&amp;lt;T&amp;gt;()(arg_list)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;new T(arg_list)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;new_array&amp;lt;T&amp;gt;()(sz)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;new T[sz]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;delete_ptr()(p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;delete p&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;delete_array()(p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;delete p[]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a id=&#34;id2805476&#34;&gt;5.9. Special lambda expressions&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&#34;id2805483&#34;&gt;5.9.1. Preventing argument substitution&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;λファンクタが呼出されたとき、デフォルトの動作では、すべての部分式において実引数をプレースホルダと置き換える。
このサブセクションでは、置き換えと部分式の表を防ぐ方法を示し、この機能が必要な場合に関して説明する。&lt;/p&gt;
&lt;p&gt;bind 式の引数には任意のλ式がなることがありえる。
例えば、次のように別な bind 式が引数となることも可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最後の行では、&lt;code&gt;foo(bar(i));&lt;/code&gt; が呼出される。
bind 式の最初の引数は、つまり対象の関数は、&lt;strong&gt;例外がなく&lt;/strong&gt;、 bind 式もこの引数となりうる。
一番内側のλファンクタは、別なλファンクタ、関数ポインタ、メンバ関数へのポインタといった、対象の関数として使用されるものを単に返せばよい。
例えば次のコードでは、一番内側のλファンクタは二つの関数の選択をし、そのうちの一つへのポインタを返す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mul&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;add_or_mul&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;add&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mul&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;add_or_mul&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;sect_unlambda&#34;&gt;5.9.1.1. Unlambda&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;対象の関数がテンプレート引数に依存する型が可変である場合には、いつのまにか bind 式がネストしてしまうことがある。
一般的に対象の関数は関数テンプレートの形式的引数となりうる。
このような場合には、プログラマは対象の関数がλファンクタかどうか知らないかもしれない。&lt;/p&gt;
&lt;p&gt;次の関数テンプレートを考えてみる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nested&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数内では、形式的引数 &lt;code&gt;f&lt;/code&gt; は bind 式の対象の関数として利用されている。
この &lt;code&gt;bind&lt;/code&gt; の呼出しが有効であるためには、 &lt;code&gt;f&lt;/code&gt; は単項関数でなければならない。
以下の二つの &lt;code&gt;nested&lt;/code&gt; の呼出しを考えてみる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;nested&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;nested&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;両方とも単項の関数または関数オブジェクトであり、適切な引数と返り値をもつ。
しかし、後者はコンパイルできない。
後者の呼出しにおいては、&lt;code&gt;nested&lt;/code&gt; の内部の bind 式は次のようになってしまう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これが、引数 &lt;code&gt;x&lt;/code&gt; をとって呼出されたとき、置換され、結局は次のように呼出すこととなる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、エラーとなる。
&lt;code&gt;bar&lt;/code&gt; の呼出しの返り値は int であり、単項の関数や関数オブジェクトではない。&lt;/p&gt;
&lt;p&gt;上記の例では、&lt;code&gt;nested&lt;/code&gt; 中の bind 式の意図は &lt;code&gt;f&lt;/code&gt; をλファンクタではなく、通常の関数オブジェクトとして扱うことである。
BLL は関数テンプレート &lt;code&gt;unlambda&lt;/code&gt; を提供している。
この関数テンプレートにより、 &lt;code&gt;unlambda&lt;/code&gt; の内部にラップされたλファンクタはもはやλファンクタではなく、引数の代入のプロセスには関係しない。
ということを表現する。
λファンクタ以外の型の引数に対しては、&lt;code&gt;unlambda&lt;/code&gt; は &lt;strong&gt;const なオブジェクトを非 const に変更することを除いて、 恒等演算&lt;/strong&gt; である。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unlambda&lt;/code&gt; を利用して、関数 &lt;code&gt;nested&lt;/code&gt; は次のように書くことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nested&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlambda&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;id2805742&#34;&gt;5.9.1.2. Protect&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;関数 &lt;code&gt;protect&lt;/code&gt; は unlambda と関係がある。
この関数も引数の代入を防ぐために利用される。
しかし、&lt;code&gt;unlambda&lt;/code&gt; はλファンクタを永続的に通常の関数オブジェクトに変換するのに対して、&lt;code&gt;protected&lt;/code&gt; はこの操作を一回の評価だけに一時的に行う。
次に例を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;protect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最初の呼出しでは、&lt;code&gt;x&lt;/code&gt; を最左の &lt;code&gt;_1&lt;/code&gt; に代入され、その結果は別なλファンクタ &lt;code&gt;x + (_1 + 2)&lt;/code&gt; となる。
そのλファンクタが &lt;code&gt;y&lt;/code&gt; とともに呼出されると、&lt;code&gt;x + (y + 2)&lt;/code&gt; となり、最終的には 13 となる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt; をライブラリに含めた主要な動機はネストした STL アルゴリズムの呼出しを可能にすることであった。
(&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_nested_stl_algorithms&#34;&gt;Section 5.11&lt;/a&gt;)&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;sect_rvalues_as_actual_arguments&#34;&gt;5.9.2. Rvalues as actual arguments to lambda functors&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;非 const な右辺値がλファンクタの実引数となることはできない。
これは意図して決定された設計のためである。
この制限がなければ、実引数に対する副作用を与えることができなくなる。
この制限を回避する方法がある。
サブセクション &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s04.html#sect_actual_arguments_to_lambda_functors&#34;&gt;Section 4.3&lt;/a&gt; の例を再び使用して、いくつかの解決策を並べる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// error (!)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;もし、右辺値がクラス型であれば、右辺値を作成する関数の返り値の型は const として定義されるべきである。
    不幸にも言語仕様の制限により、この方法は組み込みの型に対してはうまくいかない。
    組み込みの型の右辺値は、const 修飾することができないためである。&lt;/li&gt;
&lt;li&gt;λ関数の呼出しの部分を変更できるのであれば、
    関数 &lt;code&gt;make_const&lt;/code&gt; を利用して右辺値を &lt;em&gt;const 修飾&lt;/em&gt; することができる。
    次に例を示す。
    &lt;code&gt;(_1 + _2)(make_const(1), make_const(2)); // ok&lt;/code&gt;
    一般的にλ関数の呼出しは標準アルゴリズムのテンプレート関数の内部で行われるため、この解決策を仕様することは難しい。&lt;/li&gt;
&lt;li&gt;上記のいずれもが不可能であれば、λ式を 関数 &lt;code&gt;const_parameters&lt;/code&gt; でラップすることができる。
    この関数は引数を const 参照としてとる別の型のλファンクタを生成する。
    以下に例を示す。
    &lt;code&gt;const_parameters(_1 + _2)(1, 2); // ok&lt;/code&gt;
    &lt;code&gt;const_parameters&lt;/code&gt; は全ての引数を const な型にする。
    そのため、引数に非 const な右辺値があったり、非 const 参照として渡したい引数があった場合にはこの方法は使用できない。&lt;/li&gt;
&lt;li&gt;以上のいづれも不可能である場合にも、残念ながら &lt;strong&gt;const 性&lt;/strong&gt; を破ることも可能となってしまうが、一つの解決策が存在する。
    この解決法はさらに別なλファンクタのラッパを使用することである。
    このラッパには &lt;code&gt;break_const&lt;/code&gt; と名付けて、ユーザにこの関数の潜在的な危険に注意を促している。
    関数 &lt;code&gt;break_const&lt;/code&gt; は const として引数を受け取り、ラップされたλファンクタを呼出す前に const を捨て去るλファンクタを生成する。
    次に例を示す。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// error, 2 is a non-const rvalue&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;const_parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// error, i becomes const&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;break_const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// ok, but dangerous&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;break_const&lt;/code&gt; や &lt;code&gt;const_parameters&lt;/code&gt; の結果はλファンクタではない。
そのため、例えば次のように、λ式の部分式として使用することはできない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;break_const&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fails.&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;const_parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// fails.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかし、部分的なλファンクタは BLL の内部で呼出され、非 const な右辺値の問題の影響を受けないため、この種のコードは決して必要とされない。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;id2806049&#34;&gt;5.10. Casts, sizeof and typeid&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a id=&#34;sect_cast_expressions&#34;&gt;5.10.1.  Cast expressions&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;BLL は &lt;code&gt;static_cast&lt;/code&gt;、&lt;code&gt;dynamic_casy&lt;/code&gt;、 &lt;code&gt;const_cast&lt;/code&gt;、&lt;code&gt;reinterpret_cast&lt;/code&gt; の四つのキャストと同等なものを定義している。
BLL のキャストには、&lt;code&gt;ll_&lt;/code&gt; という接頭辞が付いている。
キャスト先の型はテンプレート引数として明示的に指定し、唯一の引数はキャストを行なう式である。
引数がλファンクタであれば、λファンクタがまず評価される。
例えば、以下のコードでは、&lt;code&gt;ll_dynamic_cast&lt;/code&gt; を使用して、コンテナ &lt;code&gt;a&lt;/code&gt; 内の &lt;code&gt;derived&lt;/code&gt; 型のインスタンスの数を数える。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;derived&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;if_then&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ll_dynamic_cast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;derived&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;id2806150&#34;&gt;5.10.2. Sizeof and typeid&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;BLL の sizeof と typeid と同等なものは、 &lt;code&gt;ll_sizeof&lt;/code&gt; と &lt;code&gt;ll_typeid&lt;/code&gt; と名付けらている。
双方とも一つの引数をとる。
その引数はλ式でもよい。
これらにより作られたλファンクタは、&lt;code&gt;sizeof&lt;/code&gt; や &lt;code&gt;typeid&lt;/code&gt; の呼出しをラップする。
そして、λファンクタが呼出されたときに、ラップされた操作が実行される。
以下に例を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type_info&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ll_typeid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ll_typeid&lt;/code&gt; は各要素に対して、&lt;code&gt;typeid&lt;/code&gt; を呼出すλファンクタを生成する。
&lt;code&gt;typeid&lt;/code&gt; の呼出しの結果は &lt;code&gt;type_info&lt;/code&gt; 型のインスタンスであり、bind 式はそのメンバ関数 &lt;code&gt;name&lt;/code&gt; を呼ぶλファンクタを生成する。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;sect_nested_stl_algorithms&#34;&gt;5.11. Nesting STL algorithm invocations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;BLL は共通の STL アルゴリズムを関数オブジェクトクラスとして定義しており、そのインスタンスは bind 式の対象の関数として使用できる。
例えば、以下のコードでは、二次元配列の要素を反復して、その和を計算する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
          &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ll&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;protect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;BLL の STL アルゴリズムはクラスである。
そのクラスでは、関数呼出し演算子(時にはオーバーロードして) を定義し、 &lt;code&gt;std&lt;/code&gt; 名前空間の対応すう関数テンプレートを呼出すようにしている。
これらすべての構造体は部分名前空間 &lt;code&gt;boost::lambda::ll&lt;/code&gt; に存在する。&lt;/p&gt;
&lt;p&gt;λ式におけるオーバーロードされたメンバ関数の呼出しを表現する簡単な方法はない。
このことにより、ネストした STL アルゴリズムの有効性を制限されてしまう。
例えば、テンプレートコンテナにおいて、関数 &lt;code&gt;begin&lt;/code&gt; はオーバーロードされた定義が一つ以上ある。
一般的には、以下の擬似コードと類似したものを書くことはできない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
          &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ll&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;protect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかし、共通の特殊な場合には対応策が提供されている。
BLL は &lt;code&gt;call_begin&lt;/code&gt; と &lt;code&gt;call_end&lt;/code&gt; という二つのヘルパ関数オブジェクトクラスを定義している。
それらのクラスはそれぞれコンテナの関数 &lt;code&gt;begin&lt;/code&gt; と関数 &lt;code&gt;end&lt;/code&gt; の呼出しをラップし、コンテナの &lt;code&gt;const_iterator&lt;/code&gt; 型を返す。
これらのヘルパテンプレートを用いると、上記のコードは次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
          &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ll&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;for_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
                   &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;call_begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;call_end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;protect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>6. Extending return type deduction system -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s06.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/ar01s06.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;6. Extending return type deduction system&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このセクションでは、ユーザ定義の演算子を扱うために、返り値の型推論システムの拡張する方法を解説する。
BLL はデフォルトの演算子の返り値の型を定義しているため、多くの場合にはこれは必要ない。
例えば、すべての比較演算子のデフォルトの返り値は &lt;code&gt;bool&lt;/code&gt; であり、ユーザが比較演算子の返り値の型を &lt;code&gt;bool&lt;/code&gt; として定義している限り返り値の型推論クラスの新しい特殊化を書く必要はない。
しかし、これが不可避である場合もある。&lt;/p&gt;
&lt;p&gt;オーバーロード可能なユーザ定義の演算子は、単項または二項演算子である。
その引数の数ごとに、異る演算子の返り値の型を定義する二つの特性テンプレートがある。
よって、このテンプレートを使い特殊化することにより、返り値の型推論システムを拡張することができる。
単項関数のためのテンプレートは、
&lt;code&gt;plain_return_type_1&amp;lt;Action, A&amp;gt;&lt;/code&gt; と &lt;code&gt;return_type_1&amp;lt;Action, A&amp;gt;&lt;/code&gt; であり、二項関数のためのものは、 &lt;code&gt;plain_return_type_2&amp;lt;Action, A, B&amp;gt;&lt;/code&gt; と &lt;code&gt;return_type_2&amp;lt;Action, A, B&amp;gt;&lt;/code&gt; である。&lt;/p&gt;
&lt;p&gt;これら全てのテンプレートに対する第一引数(&lt;code&gt;Action&lt;/code&gt;) は、演算子を指定している &lt;em&gt;アクション&lt;/em&gt; クラスである。
同じ返り値の型の規則を持った演算子は、 &lt;em&gt;アクショングループ&lt;/em&gt; にまとめられ、アクションクラスとアクショングループのみが演算子の曖昧さを解決する。
例を挙げると、&lt;code&gt;operator+&lt;/code&gt;を示すアクション型 &lt;code&gt;arithmetic_action&amp;lt;plus_action&amp;gt;&lt;/code&gt; がある。
他のアクション型の完全なリストを &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s06.html#table_actions&#34;&gt;Table 2&lt;/a&gt; に示す。&lt;/p&gt;
&lt;p&gt;単項関数の場合の &lt;code&gt;A&lt;/code&gt; や二項関数の場合の &lt;code&gt;A&lt;/code&gt; や &lt;code&gt;B&lt;/code&gt; の残りのテンプレート引数は、演算子呼出しの引数の型を示している。
二つのテンプレート群 &lt;code&gt;plain_return_type_n&lt;/code&gt; と &lt;code&gt;return_type_n&lt;/code&gt; は、(&lt;code&gt;n&lt;/code&gt; は１または２) 引数の型の提示の仕方において異なる。
前者のテンプレートでは、引数の型は常に参照型でなく、また、const や volatile といった修飾子もついていない。
これにより、一般的に各ユーザ定義の演算子や演算子群ごとに一つの特殊化を行うだけで十分となるため、特殊化が簡単になる。
一方、特定の演算子を同じ型の引数に異なった const/volatile の修飾子をつけたり、オーバーロードした演算子の返り値の型が異なる場合には、より細かい操作が必要となる。
よって、後者のテンプレートでは、引数の型は const/volatile の修飾子も変更せず、非参照型もそのままにする。
欠点は上記のようなオーバーロードした演算子のために、最悪の場合十六個の &lt;code&gt;return_type_2&lt;/code&gt; の特殊化が必要となるかもしれないことである。&lt;/p&gt;
&lt;p&gt;ユーザ定義の型 &lt;code&gt;X&lt;/code&gt;、&lt;code&gt;Y&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt; に対して演算子をオーバーロードしたとする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;そして以下では、左側の引数の型が &lt;code&gt;X&lt;/code&gt;であり、右側の引数の型が &lt;code&gt;Y&lt;/code&gt; であれば、そのような二項演算の結果の型は &lt;code&gt;Z&lt;/code&gt; であるという特殊化の記述を追加している。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Act&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plain_return_type_2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arithmetic_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Act&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この特殊化を定義することにより、BLL は正しく上記の二つの演算子の返り値の型を推論することができる。
特殊化は主要なテンプレートとともに、名前空間 &lt;code&gt;::boost::lambda&lt;/code&gt;に存在しなければならない。
簡単のために、以下の例ではこの名前空間の定義は省略する。&lt;/p&gt;
&lt;p&gt;演算子グループの特殊化に加えて、個々の演算子ごとに特殊化を行うことも可能である。
例えば、新しく引数の型が、&lt;code&gt;X&lt;/code&gt; と &lt;code&gt;Y&lt;/code&gt; である算術演算子を追加したとする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;全ての算術演算子に対する最初の規則では、返り値の型は &lt;code&gt;Z&lt;/code&gt; と指定している。
これは、この場合には明らか間違っている。
よって、剰余演算子に対して次のように新しい規則を提供する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;plain_return_type_2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arithmetic_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;multiply_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;特殊化により、引数の型から返り値の型への任意のマッピングを定義することができる。
次のように、要素の型をテンプレートとした数学的なベクトルがあったとする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;my_vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;要素の型の間に加法演算子が定義されている限り、いかなる二つの &lt;code&gt;my_vector&lt;/code&gt; のインタンスの間にも加法演算子が定義されるとする。
さらに、その結果の &lt;code&gt;my_vector&lt;/code&gt; の要素の型は、二つの &lt;code&gt;my_vector&lt;/code&gt; の要素の加法の結果の型と同じであるとする。
例えば、&lt;code&gt;my_vector&amp;lt;int&amp;gt;&lt;/code&gt; と &lt;code&gt;my_vector&amp;lt;double&amp;gt;&lt;/code&gt; の加法の結果は &lt;code&gt;my_vector&amp;lt;double&amp;gt;&lt;/code&gt; となる。
BLL は整数、浮動小数、複素数の間の &lt;strong&gt;暗黙的な組込みの標準的な&lt;/strong&gt; 型変換を実現する特性クラスを持っている。
BLL の機能を利用すれば、上記の加法演算子は次のように定義できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;my_vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;return_type_2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arithmetic_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plus_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;operator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;my_vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;my_vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;return_type_2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arithmetic_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plus_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;my_vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;my_vector&lt;/code&gt; の加算の型推論を正確に行うために、次のように定義できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;plain_return_type_2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arithmetic_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plus_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                           &lt;span class=&#34;n&#34;&gt;my_vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;my_vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;typename&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;return_type_2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arithmetic_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plus_action&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;nl&#34;&gt;public:&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;my_vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res_type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;BLL のテンプレート &lt;code&gt;return_type_2&lt;/code&gt; の実在する特殊化を再利用している。
そのためには、引数の型が参照型であることが必要である。&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;table_actions&#34;&gt;Table 2. Action types&lt;/a&gt;&lt;/h4&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_action&amp;lt;plus_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_action&amp;lt;minus_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_action&amp;lt;multiply_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_action&amp;lt;divide_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_action&amp;lt;remainder_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_arithmetic_action&amp;lt;plus_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_arithmetic_action&amp;lt;minus_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_action&amp;lt;and_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_action&amp;lt;or_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_action&amp;lt;not_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_action&amp;lt;xor_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_action&amp;lt;leftshift_action_no_stream&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_action&amp;lt;rightshift_action_no_stream&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;logical_action&amp;lt;and_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\|\|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;logical_action&amp;lt;or_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;logical_action&amp;lt;not_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;relational_action&amp;lt;less_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;relational_action&amp;lt;greater_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;relational_action&amp;lt;lessorequal_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;relational_action&amp;lt;greaterorequal_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;relational_action&amp;lt;equal_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;relational_action&amp;lt;notequal_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_assignment_action&amp;lt;plus_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_assignment_action&amp;lt;minus_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_assignment_action&amp;lt;multiply_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_assignment_action&amp;lt;divide_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;arithmetic_assignment_action&amp;lt;remainder_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_assignment_action&amp;lt;and_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;=\|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_assignment_action&amp;lt;or_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_assignment_action&amp;lt;xor_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_assignment_action&amp;lt;leftshift_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bitwise_assignment_action&amp;lt;rightshift_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;++&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pre_increment_decrement_action&amp;lt;increment_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pre_increment_decrement_action&amp;lt;decrement_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;++&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;post_increment_decrement_action&amp;lt;increment_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;post_increment_decrement_action&amp;lt;decrement_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;other_action&amp;lt;address_of_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;other_action&amp;lt;contents_of_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;,&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;other_action&amp;lt;comma_action&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>7. Practical considerations -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s07.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/ar01s07.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;7. Practical considerations&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;&lt;a id=&#34;id2807564&#34;&gt;7.1. Performance&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準 STL の関数オブジェクトやバインダのオーバーヘッドと同様に理論的には STL アルゴリズム や λファンクタの使用による手書のループと比較した全てのオーバーヘッドは最適化により解消される。
コンパイラに依存しているものの、これは実際に正しい。
GCC 3.0.4 を使用して、Intel Pentium 4 の 1.5 GHz のマシン上で二つのテストを行なった。
最適化フラグは -O3 とした。&lt;/p&gt;
&lt;p&gt;最初のテストでは、λファンクタと明示的に書いた関数オブジェクトを比較した。
繰り返し自分自身の値をかける単項関数を両方の形で定義した。
恒等関数から始めて、&lt;code&gt;x^5&lt;/code&gt; まで行なった。
この式は &lt;code&gt;std::transform&lt;/code&gt; のループの内部で呼出され、ある &lt;code&gt;std::vector&amp;lt;int&amp;gt;&lt;/code&gt; から引数を読み出し、結果を別な &lt;code&gt;std::vector&amp;lt;int&amp;gt;&lt;/code&gt; に格納した。
vector の要素数は 100 とした。
実行時間は、 &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s07.html#table_increasing_arithmetic_test&#34;&gt;Table 3&lt;/a&gt; に示してある。
二つの方法に大きな差はないことが分かる。&lt;/p&gt;
&lt;p&gt;二つ目のテストでは、100個の要素の vector の各要素に対して操作を行うため、再び &lt;code&gt;std::transform&lt;/code&gt; を使用した。
今回は、vector の要素の型は &lt;code&gt;double&lt;/code&gt; であり、非常に簡単な算術式から始めて、少しずつ複雑なものへとしていった。
実行時間を &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s07.html#table_ll_vs_stl_test&#34;&gt;Table 4&lt;/a&gt; に示す。&lt;/p&gt;
&lt;p&gt;ここでは、従来の STL スタイルの無名関数もテストに加えている。
これらの式はより複雑になるため提示しない。
例えば、 &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s07.html#table_ll_vs_stl_test&#34;&gt;Table 4&lt;/a&gt; の最後の式は、従来の STL の方法で記述すると、七回の &lt;code&gt;compose2&lt;/code&gt; の呼出しと、八回の &lt;code&gt;bind1st&lt;/code&gt; の呼出し、 &lt;code&gt;multiplies&lt;/code&gt;、&lt;code&gt;minus&lt;/code&gt;、&lt;code&gt;plus&lt;/code&gt; のオブジェクトの構築に合計十四回のコンストラクタの呼出しを含むことになる。
このテストにおいては、対応する手書きの関数オブジェクトと比較して、BLL の式は少し遅い。
(大まかに言って平均で 10%、最大で 14% ほど) 従来の STL の式ではパフォーマンスの低下はもう少し大きい。
一番単純な式では 27% ほどになっている。&lt;/p&gt;
&lt;p&gt;これらのテストから、BLL は STL の関数オブジェクトと比較してパフォーマンスの低下を招いてはいない。
適当な最適化コンパイラを使用すれば、パフォーマンスの特性は、従来の STL を使ったものに匹敵すると思われる。
さらに、単純な式であれば、明示的に記述した関数オブジェクトの場合のパフォーマンスに近いと考えられる。
しかし、λファンクタの評価は、インライン宣言された小さな関数の呼出しの連続であるため、コンパイラがそれらのインライン展開に失敗すると、パフォーマンスは低下するだろう。
こうなった場合、実行時間は二倍以上になるかもしれない。
上記のテストはこのようなことが発生する式を含んでいないが、一見すると単純な式で、このようなことになったこともある。&lt;/p&gt;
&lt;h4&gt;&lt;a id=&#34;table_increasing_arithmetic_test&#34;&gt;Table 3.&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Test 1. λ式で記述した整数の乗算と従来の手書きの関数オブジェクトクラスで記述した整数の乗算のCPU 時間の比較。
&lt;strong&gt;実行時間は任意の単位で表現している。&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;expression&lt;/th&gt;
&lt;th&gt;lambda expression&lt;/th&gt;
&lt;th&gt;hand-coded function object&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;240&lt;/td&gt;
&lt;td&gt;230&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x*x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;340&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x*x*x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;770&lt;/td&gt;
&lt;td&gt;760&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x*x*x*x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1180&lt;/td&gt;
&lt;td&gt;1210&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x*x*x*x*x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1950&lt;/td&gt;
&lt;td&gt;1910&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;a id=&#34;table_ll_vs_stl_test&#34;&gt;Table 4.&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Test 2. λ式で記述した算術式と、 &lt;code&gt;compose2&lt;/code&gt; や &lt;code&gt;bind1st&lt;/code&gt; などを使用した従来の STL の無名関数で記述した算術式と、従来の手書きの関数オブジェクトクラスで記述した算術式のCPU 時間の比較。
BLL の言葉を使用すれば、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は式の束縛変数であり、&lt;code&gt;x&lt;/code&gt; は自由変数である。
全ての変数は &lt;code&gt;double&lt;/code&gt; 型である。
&lt;strong&gt;実行時間は任意の単位で表現している。&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;expression&lt;/th&gt;
&lt;th&gt;lambda expression&lt;/th&gt;
&lt;th&gt;classic STL expression&lt;/th&gt;
&lt;th&gt;hand-coded function object&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ax&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;330&lt;/td&gt;
&lt;td&gt;370&lt;/td&gt;
&lt;td&gt;290&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-ax&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;td&gt;370&lt;/td&gt;
&lt;td&gt;310&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ax-(a+x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;470&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;420&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(ax-(a+x))(a+x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;620&lt;/td&gt;
&lt;td&gt;670&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;((ax) - (a+x))(bx - (b+x))(ax - (b+x))(bx - (a+x))&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1660&lt;/td&gt;
&lt;td&gt;1660&lt;/td&gt;
&lt;td&gt;1460&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;初期のライブラリを使用した更なるパフォーマンスのテストは、 [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_jarvi_00&#34;&gt;Jar00&lt;/a&gt;] に記述してある。&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;id2808056&#34;&gt;7.2. About compiling&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;BLL は同じテンプレートの数多くの再帰的なインスタンス化を行うため、テンプレートを非常に大量に使用している。
このことは(少なくとも)次の三つのことを意味している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非常に複雑なλ式を書くことができても、恐らくそれはいい考えではない。
    そのようなλ式のコンパイルにはたくさんのメモリを必要とし、コンパイルが遅くなってしまうかもしれない。&lt;/li&gt;
&lt;li&gt;例え単純なλ式から生成されたとしても、λファンクタの型は不可解である。
    通常プログラマはλファンクタそのものの型を扱う必要は全くない。
    しかし、λ式中でエラーが発生した場合は、通常コンパイラは関係するλファンクタの型を出力する。
    特に、コンパイラが一連のテンプレートのインスタンス化の全てを出力すると、エラーメッセージは非常に長くなり、意味を理解することが難しくなる。&lt;/li&gt;
&lt;li&gt;C++ 標準では、無限再帰の検出のために、テンプレートのネストは 17 階層までと提案されている。
    複雑なλテンプレートは簡単にこの制限を越えてしまう。
    多くのコンパイラはより深いテンプレートのネストを許しているが、一般的には、明示的に制限を上げるコマンドライン引数を必要とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id=&#34;id2808118&#34;&gt;7.3. Portability&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;BLL は以下のコンパイラで動作する。
つまり、これらのコンパイラは BLL を含んだテストケースをコンパイルすることができる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 3.0.4&lt;/li&gt;
&lt;li&gt;KCC 4.0f with EDG 2.43.1&lt;/li&gt;
&lt;li&gt;GCC 2.96 (&lt;code&gt;exception_test.cpp&lt;/code&gt; のみコンパイラの内部エラーにより失敗する)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id=&#34;id2808157&#34;&gt;7.3.1. Test coverage&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以下のリストは含まれているテストファイルと、それぞれのファイルが対象とする特性を示している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bind_tests_simple.cpp&lt;/code&gt; : 異なる引数の数と、対象の関数の異なる形態(関数ポインタ、関数オブジェクト、メンバ関数)に対する bind 式。
    bind 式による関数の合成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind_tests_simple_function_references.cpp&lt;/code&gt; : &lt;strong&gt;対象の関数を関数ポインタの代りに、関数への参照を使用して&lt;/strong&gt; &lt;code&gt;bind_tests_simple.cpp&lt;/code&gt; の全てのテストを繰り返す。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind_tests_advanced.cpp&lt;/code&gt; : ネストした bind 式、&lt;code&gt;unlambda&lt;/code&gt;、&lt;code&gt;protect&lt;/code&gt;、 &lt;code&gt;const_parameters&lt;/code&gt;、&lt;code&gt;break_const&lt;/code&gt; のテストを含む。
    λファンクタを実引数として他のλファンクタに渡し、カリー化し、関数オブジェクトの返り値の型を指定するために、テンプレート &lt;code&gt;sig&lt;/code&gt; を使用するテスト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator_tests_simple.cpp&lt;/code&gt; : 単項、二項の算術演算、ビット演算、比較、論理演算、インクリメント、デクリメント、合成、代入、 &lt;strong&gt;subscrict&lt;/strong&gt; アドレス演算、参照はがし、コンマ演算子というλ式のためにオーバーロードされるすべての演算子を使うテスト。
    &lt;strong&gt;加算演算子、や減算演算子を使ったポインタの算術演算と同様にシフト演算子の本質を流す。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;member_pointer_test.cpp&lt;/code&gt; : メンバの演算子へのポインタは非常に複雑なので、テストファイルを別にした。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;control_structures.cpp&lt;/code&gt; : ループと if 文の構造のテスト。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;switch_construct.cpp&lt;/code&gt; : 全てのサポートする switch 文 の引数の数と default の場合があるかどうかのテストを含む。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exception_test.cpp&lt;/code&gt; : catch ブロックの数を変化させながら、try/catch のための例外を送出するテストを含む。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constructor_tests.cpp&lt;/code&gt; : &lt;code&gt;constructor&lt;/code&gt;、&lt;code&gt;destructor&lt;/code&gt;、&lt;code&gt;new_ptr&lt;/code&gt;、 &lt;code&gt;delete_ptr&lt;/code&gt;、&lt;code&gt;new_array&lt;/code&gt;、&lt;code&gt;delete_array&lt;/code&gt; に対するテストを含む。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cast_test.cpp&lt;/code&gt; : 四つのキャスト式のテスト。
    &lt;code&gt;typeid&lt;/code&gt; と &lt;code&gt;sizeof&lt;/code&gt; のテストも含む。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extending_return_type_traits.cpp&lt;/code&gt; : ユーザ定義型のための返り値の型推論システムの拡張のテスト。
    いくつかのユーザ定義の演算子と、それに対応する特殊化のための返り値の型推論テンプレートを含む。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_instance_of_test.cpp&lt;/code&gt; : 内部的に使用される特性テンプレートのためのテストを含む。
    この特性テンプレートは、与えられた型があるテンプレートのインスタンスかどうかを検出する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bll_and_function.cpp&lt;/code&gt; : λファンクタと &lt;code&gt;boost::function&lt;/code&gt; を一緒にしようするテストを含む。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>8. Relation to other Boost libraries -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s08.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/ar01s08.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;8. Relation to other Boost libraries&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;&lt;a id=&#34;id2808509&#34;&gt;8.1. Boost Function&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;λファンクタを変数に格納すると都合のいい場合がある。
しかし、最も単純なλファンクタの型であっても、長く、現実的でない。
そして、一般的にはλファンクタの型の変数を宣言することは実現不可能である。
&lt;em&gt;Boost Function ライブラリ&lt;/em&gt; [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__function&#34;&gt;function&lt;/a&gt;] は、例えばλファンクタのような任意の関数オブジェクトのラッパを定義する。
これらのラッパは記述しやすい型となっている。
以下に例を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// returns 3&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// sets i to = 11;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;たとえ、一般的な引数を持っているλファンクタであっても&lt;/strong&gt;、ラップする関数オブジェクトの返り値と引数の型は、ラッパテンプレート &lt;code&gt;boost::function&lt;/code&gt; のテンプレート引数として明示的に記述されなければならない。
&lt;code&gt;boost::function&lt;/code&gt; で関数オブジェクトをラップすると、実際には仮想関数を使用していないが、仮想関数の処理と同等なパフォーマンスのコストが生じてしまう。
&lt;code&gt;boost::function&lt;/code&gt; 中にλファンクタを格納することは危険の原因となりうる。
ある種のλファンクタは、λ式の引数のコピーをとる代わりに、束縛変数への参照を格納しているかもしれない。
STL アルゴリズムの呼出しが完了した直後にλファンクタは破棄されるため、STL アルゴリズムの呼出しで、一時的なλファンクタのオブジェクトが使用されている場合は常に安全である。
しかし、&lt;code&gt;boost::function&lt;/code&gt; の内部にラップされたλファンクタは、さらに生存し続け、無効な参照を持つ可能性を作ってしまう。
以下に、例を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ok, *sum = 5;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// error, *sum does not exist anymore&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a id=&#34;id2808613&#34;&gt;8.2. Boost Bind&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Boost Bind&lt;/em&gt; [&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html#cit_boost__bind&#34;&gt;bind&lt;/a&gt;] ライブラリは部分的に BLL の機能と重複する。
基本的には、Boost Bind ライブラリ(以降 BB)では、BLL の一部の bind 式を実装しているといえる。
しかし、いくつか意味的に異なる部分もある。&lt;/p&gt;
&lt;p&gt;BLL と BB は別々に発展し、異った実装となっている。
そのため、BB の bind 式は BLL の bind 式、他の形のλ式には使用することはできない。
BB において、BLL の bind 式を使用するのにも、同じ制限がある。
しかし、BB ライブラリの名前は、名前空間 &lt;code&gt;boost&lt;/code&gt; に存在するのに対し、BLL の名前は、名前空間 &lt;code&gt;boost::lambda&lt;/code&gt; に存在するため、これらの二つのライブラリは共存できる。&lt;/p&gt;
&lt;p&gt;BLL はある程度 C++ 標準に順応なコンパイラが必要であるのに対し、BB ライブラリはよりポータブルなコンパイラで十分であり、より多くのコンパイラで機能する。&lt;/p&gt;
&lt;p&gt;以降の二つのサブセクションでは、BB と BLL における bind 式の意味的な相違について説明する。&lt;/p&gt;
&lt;h3&gt;&lt;a id=&#34;id2808678&#34;&gt;8.2.1. First argument of bind expression&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;BB においては、対象の関数である bind 式の第一引数の扱い方は、他の引数の扱い方とは異なる。
この引数に関しては、引数の代入が行なわれないのである。
BLL においては、この点においては第一引数は特別扱いはされない。
以下に例を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;k&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;nested&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; の内部の bind 式は次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;BLL においては、これは次のように解釈される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;一方、BB においては次のようになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;BLL ではこの機能を実現するため、&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s05.html#sect_unlambda&#34;&gt;Section 5.9.1.1&lt;/a&gt; で説明したように、関数 &lt;code&gt;foo&lt;/code&gt; の内部の bind 式は次のように書くことが可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlambda&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;BLL では三つのプレースホルダしか定義されていないのに対し、BB ライブラリは九つまでのプレースホルダをサポートしている。
これ以上のプレースホルダを提供しない根拠は、いかなる STL アルゴリズムで受理できる関数オブジェクトの最多の引数の数は二つであることである。
BB ライブラリにおいてプレースホルダの数は簡単に増加させることができる。
BLL でも可能であるが、しかしより多くの労力を必要とする。
現在 BLL は実引数を内部的にλファンクタにそのまま渡しており、タプルにラップしたりはしない。
これは、広く使用されているいくつかのコンパイラが最適化において中間のタプルを取り去ることができないためである。
中間のタプルの生成はパフォーマンスに重大な影響を与えてしまう。
特に、単純な(そして最も一般な)λファンクタの場合には重要である。
そして、より多くのプレースホルダも可能であるが、単純なλファンクタのパフォーマンスに関して妥協しない折衷案を選択した。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>9. Contributors -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/ar01s09.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/ar01s09.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;9. Contributors&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ライブラリの主要な部分は Jaakko と Jarvi と Gary Powell によって記述された。
Jeremy Siek、Peter Higley、Peter Dimov、Valentin Bonnard、William Kempf から &lt;strong&gt;概観の助言&lt;/strong&gt;、提案、アイデアをもらった。
Joel de Guzmann とBLL に非常に影響を与えた Phoenix との彼の仕事については特に言及したい。
それにより、新たな特性を付けてライブラリを拡張することが大幅に簡単になった。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Bibliography -- Boost.Lambdaの翻訳ドキュメントを移植(close #13)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/lambda/bi01.html"/>
      <id>c881cabffeee74d879bb3701689d03e913cc5e27:archive/boost_docs/libs/lambda/bi01.md</id>
      <updated>2018-06-13T22:12:21+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Bibliography&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a id=&#34;cit_stepanov_94&#34;&gt;[STL94]&lt;/a&gt;
A. A. Stepanov and M. Lee.  &lt;em&gt;The Standard Template Library&lt;/em&gt;.  Hewlett-Packard Laboratories.  1994.
&lt;a href=&#34;http://www.hpl.hp.com/techreports&#34; target=&#34;_blank&#34;&gt;www.hpl.hp.com/techreports&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_sgi_02&#34;&gt;[SGI02]&lt;/a&gt;
&lt;em&gt;The SGI Standard Template Library&lt;/em&gt;. 2002.
&lt;a href=&#34;http://www.sgi.com/tech/stl/&#34; target=&#34;_blank&#34;&gt;www.sgi.com/tech/stl/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_c++_98&#34;&gt;[C++98]&lt;/a&gt;
&lt;em&gt;International Standard, Programming Languages – C++&lt;/em&gt;. ISO/IEC:14882. 1998.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_jarvi_99&#34;&gt;[Jar99]&lt;/a&gt;
Jaakko Jarvi.  &lt;em&gt;C++ Function Object Binders Made Easy&lt;/em&gt;. . &lt;em&gt;Lecture Notes in Computer Science&lt;/em&gt;. 1977. Springer. 2000.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_jarvi_00&#34;&gt;[Jar00]&lt;/a&gt;
Jaakko Jarvi. Gary Powell. &lt;em&gt;The Lambda Library : Lambda Abstraction in C++&lt;/em&gt;. Turku Centre for Computer Science. Technical Report . 378. 2000.
&lt;a href=&#34;http://www.tucs.fi/Publications/techreports/TR378.php&#34; target=&#34;_blank&#34;&gt;www.tucs.fi/publications&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_jarvi_01&#34;&gt;[Jar01]&lt;/a&gt;
Jaakko Jarvi. Gary Powell. &lt;em&gt;The Lambda Library : Lambda Abstraction in C++&lt;/em&gt;. Second  Workshop on C++ Template Programming. Tampa Bay, OOPSLA&#39;01. . 2001.
&lt;a href=&#34;http://www.oonumerics.org/tmpw01/&#34; target=&#34;_blank&#34;&gt;www.oonumerics.org/tmpw01/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_boost__tuple&#34;&gt;[tuple]&lt;/a&gt;
&lt;em&gt;The Boost Tuple Library&lt;/em&gt;.
&lt;a href=&#34;http://www.boost.org/libs/tuple/doc/tuple_users_guide.html&#34; target=&#34;_blank&#34;&gt;www.boost.org/libs/tuple/doc/tuple_users_guide.html&lt;/a&gt;. 2002.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_boost__type_traits&#34;&gt;[type_traits]&lt;/a&gt;
&lt;em&gt;The Boost type_traits&lt;/em&gt;.
&lt;a href=&#34;http://www.boost.org/libs/type_traits/index.htm&#34; target=&#34;_blank&#34;&gt;www.boost.org/libs/type_traits/&lt;/a&gt;. 2002.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_boost__ref&#34;&gt;[ref]&lt;/a&gt;
&lt;em&gt;Boost ref&lt;/em&gt;.
&lt;a href=&#34;http://www.boost.org/libs/bind/ref.html&#34; target=&#34;_blank&#34;&gt;www.boost.org/libs/bind/ref.html&lt;/a&gt;. 2002.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_boost__bind&#34;&gt;[bind]&lt;/a&gt;
&lt;em&gt;Boost Bind Library&lt;/em&gt;.
&lt;a href=&#34;http://www.boost.org/libs/bind/bind.html&#34; target=&#34;_blank&#34;&gt;www.boost.org/libs/bind/bind.html&lt;/a&gt;. 2002.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_boost__function&#34;&gt;[function]&lt;/a&gt;
&lt;em&gt;Boost Function Library&lt;/em&gt;.
&lt;a href=&#34;http://www.boost.org/libs/function/&#34; target=&#34;_blank&#34;&gt;www.boost.org/libs/function/&lt;/a&gt;. 2002.&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;cit_fc++&#34;&gt;[fc++]&lt;/a&gt;
&lt;em&gt;The FC++ library: Functional Programming in C++&lt;/em&gt;. Yannis Smaragdakis. Brian McNamara.
&lt;a href=&#34;http://www.cc.gatech.edu/~yannis/fc++/&#34; target=&#34;_blank&#34;&gt;www.cc.gatech.edu/~yannis/fc++/&lt;/a&gt;. 2002.&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
</feed>