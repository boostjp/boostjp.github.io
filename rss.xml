<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="https://boostjp.github.io" />
  <updated>2017-07-03T23:03:38.775925</updated>
  <id>71c0c6de-8937-4a04-8216-76a8358f24f5</id>

  
    <entry>
      <title>C++Now! -- 「C++Now! 2017」作成</title>
      <link href="https://boostjp.github.io/cppnow.html"/>
      <id>7d9319baa01b0cf62d746b87ca22179d54522526:cppnow.md</id>
      <updated>2017-06-12T05:51:06+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now!&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;2012年から、BoostConという名前で開催されていたカンファレンスがC++Now!という名前に変わりました。ここでは、C++Now!のセッション概要の翻訳、およびセッション資料のまとめを記載していきます。&lt;/p&gt;
&lt;p&gt;BoostConは以下のページを参照してください：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/boostcon.html&#34;&gt;BoostCon - boostjp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;各年のセッション概要翻訳&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html&#34;&gt;C++Now! 2012&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html&#34;&gt;C++Now! 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html&#34;&gt;C++Now! 2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2015.html&#34;&gt;C++Now! 2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2016.html&#34;&gt;C++Now! 2016&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2017.html&#34;&gt;C++Now! 2017&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2017 -- 「C++Now! 2017」作成</title>
      <link href="https://boostjp.github.io/cppnow/2017.html"/>
      <id>7d9319baa01b0cf62d746b87ca22179d54522526:cppnow/2017.md</id>
      <updated>2017-06-12T05:51:06+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2017&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://cppnow2017.sched.com&#34; target=&#34;_blank&#34;&gt;https://cppnow2017.sched.com&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Rust: Hack Without Fear!&lt;/li&gt;
&lt;li&gt;C++17 Features&lt;/li&gt;
&lt;li&gt;Expression Templates Everywhere with C++14 and Yap&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt; ALL the things!&lt;/li&gt;
&lt;li&gt;Rethinking Strings&lt;/li&gt;
&lt;li&gt;Networking TS Workshop (part 1 of 2)&lt;/li&gt;
&lt;li&gt;Networking TS Workshop (part 2 of 2)&lt;/li&gt;
&lt;li&gt;C++11’s Quiet Little Gem: &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Local (&#34;Arena&#34;) Memory Allocators&lt;/li&gt;
&lt;li&gt;Containers &amp;amp; Strings: Why the Implementation Matters&lt;/li&gt;
&lt;li&gt;Haskell taketh away: limiting side effects for parallel programming&lt;/li&gt;
&lt;li&gt;(Ab)using C++17&lt;/li&gt;
&lt;li&gt;Good FIFOs Make Good Thread Neighbors&lt;/li&gt;
&lt;li&gt;Postmodern Immutable Data Structures&lt;/li&gt;
&lt;li&gt;Type Based Template Metaprogramming is Not Dead&lt;/li&gt;
&lt;li&gt;A vision for C++20 and &lt;code&gt;std2&lt;/code&gt; (part 1 of 3)&lt;/li&gt;
&lt;li&gt;Fun with Boost.Hana&lt;/li&gt;
&lt;li&gt;Composite Arithmetic Types Are &amp;gt; the + of Their Parts&lt;/li&gt;
&lt;li&gt;An easy to use RPC framework implemented in C++11/14&lt;/li&gt;
&lt;li&gt;Mocking C++ (full-length version)&lt;/li&gt;
&lt;li&gt;The Mathematical Underpinnings of Promises in C++&lt;/li&gt;
&lt;li&gt;Multithreading Using Lockless Lists and RCU&lt;/li&gt;
&lt;li&gt;Call: A Library that Will Change the Way You Think about Function Invocations (part 1 of 2)&lt;/li&gt;
&lt;li&gt;Call: A Library that Will Change the Way You Think about Function Invocations (part 2 of 2)&lt;/li&gt;
&lt;li&gt;Postmodern C++&lt;/li&gt;
&lt;li&gt;Promises in C++: The Universal Glue for Asynchronous Programs&lt;/li&gt;
&lt;li&gt;A look at C++ through the glasses of a language tool&lt;/li&gt;
&lt;li&gt;Boost vs Qt: What Could They Learn From Each Other?&lt;/li&gt;
&lt;li&gt;A vision for C++20 and &lt;code&gt;std2&lt;/code&gt; (part 2 of 3)&lt;/li&gt;
&lt;li&gt;Practical (?) Applications of Reflection&lt;/li&gt;
&lt;li&gt;Towards Painless Testing&lt;/li&gt;
&lt;li&gt;Sorting in less than O(n log n): Generalizing and optimizing radix sort&lt;/li&gt;
&lt;li&gt;Parallel Programming with RaftLib: streaming/data-flow concurrency via concise C++ iostream-like operators&lt;/li&gt;
&lt;li&gt;Implementing &lt;code&gt;variant&lt;/code&gt; visitation using lambdas&lt;/li&gt;
&lt;li&gt;Testing the Limits of Allocator Awareness&lt;/li&gt;
&lt;li&gt;Competitive Advantage with D&lt;/li&gt;
&lt;li&gt;Effective CMake&lt;/li&gt;
&lt;li&gt;The &#39;Detection Idiom:&#39; A Better Way to SFINAE&lt;/li&gt;
&lt;li&gt;C++ Core Guidelines - Modernize your C++ Code Base&lt;/li&gt;
&lt;li&gt;Restoring Your Sanity: An Approach to Dealing with Reference Types in the Generic Programming Paradigm&lt;/li&gt;
&lt;li&gt;Locally Atomic Capabilities and How to Count Them&lt;/li&gt;
&lt;li&gt;The Holy Grail - A Hash Array Mapped Trie for C++&lt;/li&gt;
&lt;li&gt;A vision for C++20 and &lt;code&gt;std2&lt;/code&gt; (part 3 of 3)&lt;/li&gt;
&lt;li&gt;No raw &lt;code&gt;std::thread&lt;/code&gt;! - Live Tweet Analysis in C++&lt;/li&gt;
&lt;li&gt;Customization Points That Suck Less&lt;/li&gt;
&lt;li&gt;clang-useful: Building useful tools with LLVM and clang for fun and profit&lt;/li&gt;
&lt;li&gt;Performance analysis and optimization of C++ standard libraries&lt;/li&gt;
&lt;li&gt;Type-safe Programming&lt;/li&gt;
&lt;li&gt;The Lesser-Known Multicore Synchronization Primitives&lt;/li&gt;
&lt;li&gt;CHAP: A memory analyzer for un-instrumented cores&lt;/li&gt;
&lt;li&gt;Nbdl: Generic Library for Managing State Seamlessly Across Network&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2017&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2017&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2016 -- C++Now 2016 のセッションリストを修正</title>
      <link href="https://boostjp.github.io/cppnow/2016.html"/>
      <id>ac1cadd4d4cb8cfc63aaeaeb12858706efd39421:cppnow/2016.md</id>
      <updated>2017-06-12T05:46:48+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2016&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://cppnow2016.sched.com&#34; target=&#34;_blank&#34;&gt;https://cppnow2016.sched.com&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Better Code&lt;/li&gt;
&lt;li&gt;Typegrind: Type Preserving Heap Profiler for C++&lt;/li&gt;
&lt;li&gt;C++14 Dependency Injection&lt;/li&gt;
&lt;li&gt;Proper Inheritance (Part 1)&lt;/li&gt;
&lt;li&gt;CopperSpice: The Next Generation of Signals&lt;/li&gt;
&lt;li&gt;Proper Inheritance (Part 2)&lt;/li&gt;
&lt;li&gt;Practical Performance Practices&lt;/li&gt;
&lt;li&gt;Metaprogramming for Dummies&lt;/li&gt;
&lt;li&gt;Monoids, Monads and Applicative Functors: Repeated Software Patterns&lt;/li&gt;
&lt;li&gt;C++14 Version of Boost.MSM-eUML&lt;/li&gt;
&lt;li&gt;Diet for your Templates: Reducing Code Bloat in your Templated Library&lt;/li&gt;
&lt;li&gt;Variants: Past, Present, and Future&lt;/li&gt;
&lt;li&gt;Come Stream With Me: Build Performant, Simple, Parallel Applications in C++ Using RaftLib&lt;/li&gt;
&lt;li&gt;Documenting C++ Using the Right Tools&lt;/li&gt;
&lt;li&gt;array_ref: Multidimensional Array References for the C++ Standard Library&lt;/li&gt;
&lt;li&gt;Implementing a Lock-Free atomic_shared_ptr&lt;/li&gt;
&lt;li&gt;Friendship in Service of Testing&lt;/li&gt;
&lt;li&gt;Pulling Visitors&lt;/li&gt;
&lt;li&gt;Thread-safe Observer Pattern: You&#39;re Doing It Wrong&lt;/li&gt;
&lt;li&gt;Metaprogramming for the Brave&lt;/li&gt;
&lt;li&gt;Implementation of a Multithreaded Compile-Time ECS in C++14&lt;/li&gt;
&lt;li&gt;Design Patterns in the 21st Century&lt;/li&gt;
&lt;li&gt;Let&#39;s Make a Web Match-3 Game in C++14&lt;/li&gt;
&lt;li&gt;Multithreading is the Answer. What was the Question? (Part 1)&lt;/li&gt;
&lt;li&gt;Variadic Expansion in Examples&lt;/li&gt;
&lt;li&gt;IoC++: An IoC Framework for C++&lt;/li&gt;
&lt;li&gt;Multithreading is the Answer. What was the Question? (Part 2)&lt;/li&gt;
&lt;li&gt;Preprocessor-Aware Automated Refactoring&lt;/li&gt;
&lt;li&gt;Extending C++ with Co-Array Semantics&lt;/li&gt;
&lt;li&gt;Progress on Contract Support for C++17&lt;/li&gt;
&lt;li&gt;Implementing Static Control Flow in C++14&lt;/li&gt;
&lt;li&gt;The Effective Structured Data Marshalling/Demarshalling Through Boost.Fusion Introspection in a High Performance Web Service&lt;/li&gt;
&lt;li&gt;Why And How To Add Scripting&lt;/li&gt;
&lt;li&gt;The Design of a New C++ Build Toolchain&lt;/li&gt;
&lt;li&gt;C++ Performance in Practice: Align, Vectorise, Cache, Jump!&lt;/li&gt;
&lt;li&gt;Goodbye Metaprogramming, and Hello Functional: Living in a Post-Metaprogramming Era in C++&lt;/li&gt;
&lt;li&gt;Understanding Boost.Build&lt;/li&gt;
&lt;li&gt;Simple Hand Written Parsers&lt;/li&gt;
&lt;li&gt;An Interesting Lock-free Queue: Part 2 of N&lt;/li&gt;
&lt;li&gt;HPX and GPU Parallelized STL&lt;/li&gt;
&lt;li&gt;The Fiber Library&lt;/li&gt;
&lt;li&gt;What is the Basic Interface?&lt;/li&gt;
&lt;li&gt;The CPU Cache: Instruction Re-Ordering Made Obvious&lt;/li&gt;
&lt;li&gt;No Sane Compiler would Optimize Atomics&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2016&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2016 -- C++Now 2016 のセッションリストを修正</title>
      <link href="https://boostjp.github.io/cppnow/2016.html"/>
      <id>f27f1709b46db6bdd94e7efb059d82828040e962:cppnow/2016.md</id>
      <updated>2017-06-12T05:28:51+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2016&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://cppnow2016.sched.com&#34; target=&#34;_blank&#34;&gt;https://cppnow2016.sched.com&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Rust: Hack Without Fear!&lt;/li&gt;
&lt;li&gt;C++17 Features&lt;/li&gt;
&lt;li&gt;Expression Templates Everywhere with C++14 and Yap&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt; ALL the things!&lt;/li&gt;
&lt;li&gt;Rethinking Strings&lt;/li&gt;
&lt;li&gt;Networking TS Workshop (part 1 of 2)&lt;/li&gt;
&lt;li&gt;Networking TS Workshop (part 2 of 2)&lt;/li&gt;
&lt;li&gt;C++11’s Quiet Little Gem: &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Local (&#34;Arena&#34;) Memory Allocators&lt;/li&gt;
&lt;li&gt;Containers &amp;amp; Strings: Why the Implementation Matters&lt;/li&gt;
&lt;li&gt;Haskell taketh away: limiting side effects for parallel programming&lt;/li&gt;
&lt;li&gt;(Ab)using C++17&lt;/li&gt;
&lt;li&gt;Good FIFOs Make Good Thread Neighbors&lt;/li&gt;
&lt;li&gt;Postmodern Immutable Data Structures&lt;/li&gt;
&lt;li&gt;Type Based Template Metaprogramming is Not Dead&lt;/li&gt;
&lt;li&gt;A vision for C++20 and &lt;code&gt;std2&lt;/code&gt; (part 1 of 3)&lt;/li&gt;
&lt;li&gt;Fun with Boost.Hana&lt;/li&gt;
&lt;li&gt;Composite Arithmetic Types Are &amp;gt; the + of Their Parts&lt;/li&gt;
&lt;li&gt;An easy to use RPC framework implemented in C++11/14&lt;/li&gt;
&lt;li&gt;Mocking C++ (full-length version)&lt;/li&gt;
&lt;li&gt;The Mathematical Underpinnings of Promises in C++&lt;/li&gt;
&lt;li&gt;Multithreading Using Lockless Lists and RCU&lt;/li&gt;
&lt;li&gt;Call: A Library that Will Change the Way You Think about Function Invocations (part 1 of 2)&lt;/li&gt;
&lt;li&gt;Call: A Library that Will Change the Way You Think about Function Invocations (part 2 of 2)&lt;/li&gt;
&lt;li&gt;Postmodern C++&lt;/li&gt;
&lt;li&gt;Promises in C++: The Universal Glue for Asynchronous Programs&lt;/li&gt;
&lt;li&gt;A look at C++ through the glasses of a language tool&lt;/li&gt;
&lt;li&gt;Boost vs Qt: What Could They Learn From Each Other?&lt;/li&gt;
&lt;li&gt;A vision for C++20 and &lt;code&gt;std2&lt;/code&gt; (part 2 of 3)&lt;/li&gt;
&lt;li&gt;Practical (?) Applications of Reflection&lt;/li&gt;
&lt;li&gt;Towards Painless Testing&lt;/li&gt;
&lt;li&gt;Sorting in less than O(n log n): Generalizing and optimizing radix sort&lt;/li&gt;
&lt;li&gt;Parallel Programming with RaftLib: streaming/data-flow concurrency via concise C++ iostream-like operators&lt;/li&gt;
&lt;li&gt;Implementing &lt;code&gt;variant&lt;/code&gt; visitation using lambdas&lt;/li&gt;
&lt;li&gt;Testing the Limits of Allocator Awareness&lt;/li&gt;
&lt;li&gt;Competitive Advantage with D&lt;/li&gt;
&lt;li&gt;Effective CMake&lt;/li&gt;
&lt;li&gt;The &#39;Detection Idiom:&#39; A Better Way to SFINAE&lt;/li&gt;
&lt;li&gt;C++ Core Guidelines - Modernize your C++ Code Base&lt;/li&gt;
&lt;li&gt;Restoring Your Sanity: An Approach to Dealing with Reference Types in the Generic Programming Paradigm&lt;/li&gt;
&lt;li&gt;Locally Atomic Capabilities and How to Count Them&lt;/li&gt;
&lt;li&gt;The Holy Grail - A Hash Array Mapped Trie for C++&lt;/li&gt;
&lt;li&gt;A vision for C++20 and &lt;code&gt;std2&lt;/code&gt; (part 3 of 3)&lt;/li&gt;
&lt;li&gt;No raw &lt;code&gt;std::thread&lt;/code&gt;! - Live Tweet Analysis in C++&lt;/li&gt;
&lt;li&gt;Customization Points That Suck Less&lt;/li&gt;
&lt;li&gt;clang-useful: Building useful tools with LLVM and clang for fun and profit&lt;/li&gt;
&lt;li&gt;Performance analysis and optimization of C++ standard libraries&lt;/li&gt;
&lt;li&gt;Type-safe Programming&lt;/li&gt;
&lt;li&gt;The Lesser-Known Multicore Synchronization Primitives&lt;/li&gt;
&lt;li&gt;CHAP: A memory analyzer for un-instrumented cores&lt;/li&gt;
&lt;li&gt;Nbdl: Generic Library for Managing State Seamlessly Across Network&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2016&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2015 -- C++ Now のリンクを修正</title>
      <link href="https://boostjp.github.io/cppnow/2015.html"/>
      <id>5752e50ac864b2cd1ec94f00db9b140e3619d23c:cppnow/2015.md</id>
      <updated>2017-06-12T05:12:58+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2015&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://cppnow2015.sched.com&#34; target=&#34;_blank&#34;&gt;https://cppnow2015.sched.com&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Library in a Week: C++ Application Configuration&lt;/li&gt;
&lt;li&gt;Conference Keynote: Generic Programming with Concepts&lt;/li&gt;
&lt;li&gt;Parallel Computing: Strategies and Implications&lt;/li&gt;
&lt;li&gt;Testing Battle.net (before deploying to millions of players)&lt;/li&gt;
&lt;li&gt;Your CPU Is Binary&lt;/li&gt;
&lt;li&gt;Functional Geometry: Producing Pure Spaces&lt;/li&gt;
&lt;li&gt;Lessons Learned&lt;/li&gt;
&lt;li&gt;Type Deduction in C++14&lt;/li&gt;
&lt;li&gt;Yomm11: Open Multi-Methods for C++11&lt;/li&gt;
&lt;li&gt;constexpr: C++ At Compile Time&lt;/li&gt;
&lt;li&gt;Biicode, a C/C++ dependency manager with a hosting service&lt;/li&gt;
&lt;li&gt;Boost 2.0&lt;/li&gt;
&lt;li&gt;Conference Keynote: Numerical Weather Prediction: Facing the Future with C++&lt;/li&gt;
&lt;li&gt;On the design and Boost-based implementation of two new C++ libraries for atmospheric research&lt;/li&gt;
&lt;li&gt;Thinking Portable: Why and how to make your C++ cross platform&lt;/li&gt;
&lt;li&gt;Why in heaven there is no dependency management for C++?&lt;/li&gt;
&lt;li&gt;Boost.Compute: A library for GPU/parallel-computing&lt;/li&gt;
&lt;li&gt;Developing EDSL&#39;s for Boost.Spirit&lt;/li&gt;
&lt;li&gt;Back to the Future&lt;/li&gt;
&lt;li&gt;Large-Scale C++: Advanced Levelization Techniques, Parts I &amp;amp; II&lt;/li&gt;
&lt;li&gt;switchAny - A Practical Exercise in Template Metaprogramming&lt;/li&gt;
&lt;li&gt;New Build System for New C++&lt;/li&gt;
&lt;li&gt;The Price of Shared Pointers or Why Passing them by-reference can be Useful&lt;/li&gt;
&lt;li&gt;Conference Keynote: Ranges for the Standard Library&lt;/li&gt;
&lt;li&gt;A review of C++ 11/14 only Boost libraries - Fiber, AFIO, DI and APIBind&lt;/li&gt;
&lt;li&gt;Type-safe configuration library&lt;/li&gt;
&lt;li&gt;How we reason about procedural programs&lt;/li&gt;
&lt;li&gt;Modern generic programming using the Tick and Fit libraries&lt;/li&gt;
&lt;li&gt;Functions Want To Be Free&lt;/li&gt;
&lt;li&gt;Boostache Exposed - the internals of Boost&#39;s template engine&lt;/li&gt;
&lt;li&gt;Lock-free by Example: Towards an Interesting Lock-free MPMC Queue&lt;/li&gt;
&lt;li&gt;Big Projects, and CMake, and Git, Oh My!&lt;/li&gt;
&lt;li&gt;Debugging using an exact recording of a program&#39;s execution.&lt;/li&gt;
&lt;li&gt;Details Matter&lt;/li&gt;
&lt;li&gt;The Rule of Seven (Plus or Minus Two): Modern C++ Boilerplate&lt;/li&gt;
&lt;li&gt;Parallelizing the Standard Template Library(STL)&lt;/li&gt;
&lt;li&gt;C++ metaprogramming: a paradigm shift&lt;/li&gt;
&lt;li&gt;Fun with C11 generic selection expression&lt;/li&gt;
&lt;li&gt;IIFE In C++ For Performance and Safety&lt;/li&gt;
&lt;li&gt;Better Code: Concurrency&lt;/li&gt;
&lt;li&gt;Using Spirit X3&lt;/li&gt;
&lt;li&gt;An Overview on Encryption in C++&lt;/li&gt;
&lt;li&gt;C++17 coroutines for app and library developers&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2015&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2015&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2012 -- C++ Now のリンクを修正</title>
      <link href="https://boostjp.github.io/cppnow/2012.html"/>
      <id>b1f0565297261a631dd64647d980ac086ff40284:cppnow/2012.md</id>
      <updated>2017-06-12T04:51:27+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2012&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2012&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://boostjp.github.io/archive/cpp_online_reading.html&#34;&gt;C++オンライン読書会&lt;/a&gt; にて有志が一部の資料を読んでいるので、そちらも資料を読むお供にどうぞ。&lt;/p&gt;
&lt;h2&gt;ビデオ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.youtube.com/user/BoostCon&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/user/BoostCon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参加レポート&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/redboltz/20120519/1337385881&#34; target=&#34;_blank&#34;&gt;C++Now2012体験記 - redboltzの日記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/faith_and_brave/20120522/1337650107&#34; target=&#34;_blank&#34;&gt;C++Now! 2012に参加してきました - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zakkas783.tumblr.com/post/25007975614/c-now-boostcon-c-now-boost-konferenz-im&#34; target=&#34;_blank&#34;&gt;C++Now! - BoostCon新装開店 (C++Now! – Boost-Konferenz im neuen Gewand) - 雑貨’s tumblr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#50-boost-libs&#34;&gt;180分でめぐるBoost Library 50個の旅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#more-useful-computations&#34;&gt;おなじ環境でより効果的な計算を： C++で組み込みリアルタイムコード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#whirlwind-overview-cpp11&#34;&gt;駆け足でC++11の概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#odeint&#34;&gt;odeint - C++で常微分方程式を解く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#fresh-paint&#34;&gt;新仕様できたてほやほや!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#openmp-for-better-high&#34;&gt;ハイパフォーマンスを求めるためだけではなく、高次の並列化のためのOpenMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#hpx&#34;&gt;HPX: C++11並列実行システム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#lambda-functions&#34;&gt;ラムダ関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#future-cpp1x-proposals&#34;&gt;来るC++1xへの提案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#variadic-tmp&#34;&gt;モナドを使って可変長テンプレートメタプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#ustring&#34;&gt;Ustring - 現代的な&lt;code&gt;std::string&lt;/code&gt;の代替&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#high-level-threading&#34;&gt;C++11: 高次のスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#grill-the-committee&#34;&gt;標準委員を質問攻めにしよう!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#moving-forward&#34;&gt;キーノート：C++11で前進せよ!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#metaparse&#34;&gt;Metaparse – テンプレートメタプログラミングによるコンパイル時構文解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#ladon&#34;&gt;Ladon - 分散状態マシンフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#low-level-threading&#34;&gt;黒魔術につき取扱注意 - C++11で低レヴェルスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#exception-safety&#34;&gt;C++で例外安全なコーディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#moving-boost-to-git&#34;&gt;BoostをGitに移行しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#learned-developing-std-lib&#34;&gt;C++11標準ライブラリの策定を通じて学んだこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#utilizing-modern-programming&#34;&gt;科学的ソフトウェア開発における今日的プログラミングテクニックとBoostライブラリの適用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#vs-ide&#34;&gt;C++開発者むけVisual Studio IDEの最新情報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#modules&#34;&gt;キーノート： C++におけるモジュール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#generic-programming-real-world&#34;&gt;C++でのジェネリックプログラミング： 実例を交えて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#lowest-variational-methods&#34;&gt;Boost.Protoを用いた最低次変分法のドメイン特化固有言語の実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#cpp11-containers&#34;&gt;C++11コンテナの最新情報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#concept-clang&#34;&gt;ConceptClang： C++ Conceptの実装モデル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#modern-cpp-techniques&#34;&gt;現代的C++テクニック入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#smart-pointers-algorithm&#34;&gt;C++11のスマートポインタとアルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#voronoi&#34;&gt;Boost.Polygon.Voronoiライブラリを例に、堅牢かつ効率的多倍精度アルゴリズムの設計について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#tool-for-class-and-library-authors&#34;&gt;C++11: クラスやライブラリ実装者のための新しいツール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#cmake-modularization&#34;&gt;CMake、モジュール化と Ryppl 開発者向けプレヴュー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#now-what&#34;&gt;キーノート： さて、これからどうしよう？ 3つの視点から&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#compile-time-reparsing&#34;&gt;コンパイル時 再パース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#type-string-conversions&#34;&gt;型から文字列への変換と、その逆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34;&gt;C++11にある珠玉の品々&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#linear-programming-proto&#34;&gt;Boost Protoで線型計画法を簡単に&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#solidfire&#34;&gt;SolidFireではC++11への移行をいかにして成しとげたか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#refactoring-clang&#34;&gt;ClangでC++のリファクタリング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#state-machine-coroutine&#34;&gt;Boost.Coroutineを用いてステートマシンを解決する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#metaprogramming-cpp11&#34;&gt;C++11でのメタプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#numerical-problems-metaprogramming&#34;&gt;メタプログラミングの数学的問題への適用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#tr2-boost&#34;&gt;TR2に向けたBoostライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#how-i-code-and-why&#34;&gt;どうしてそう書くの？なんで？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#preparation-cppnow-2013&#34;&gt;C++Now! 2013に向けた準備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#winrt&#34;&gt;WinRTにむけたC++コンポーネント拡張&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#value-semantics&#34;&gt;値のセマンティクスとConceptベースの多態&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#future-of-boost&#34;&gt;Boostの将来&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#50-boost-libs&#34; name=&#34;50-boost-libs&#34;&gt;180分でめぐるBoost Library 50個の旅&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;50 Boost Libraries in 180 minutes&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/boris-schaeling/&#34; target=&#34;_blank&#34;&gt;Boris Schäling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/50_boost_libraries.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/50_boost_libraries.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションでは、50個のBoost Libraryを180分かけて紹介する。多くのBoost Libraryについて、幅広く俯瞰する。あまりboostに詳しくない方、または、いくつかのライブラリしか知らない方は、今後、boostが提供すべきすぐれたアイデアを得ることができるだろう。このセッションは、後程どのライブラリについて学びたいか、いまのプロジェクトで使えるか、さらには貢献できそうか判断する指針となるだろう。 このセッションは、プレゼンターの著書である「The Boost C++ Libraries」(英語版 2011/6刊行)と「Die Boost C++ Bibliotheken」(ドイツ語版 2012/1刊行)に基づいている。これらの書籍ではすぐに習得できる一般的なライブラリを紹介している。このセッションでは、これらの本から例を引用するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#more-useful-computations&#34; name=&#34;more-useful-computations&#34;&gt;おなじ時間でより効果的な計算を： C++で組み込みリアルタイムコード&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;More Useful Computations in the Same Duration: Optimizing Embedded Hard Real-Time Code in C++
スピーカー：&lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/schurr_more_useful_computations.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/schurr_more_useful_computations.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=mJjYgpeo5ws&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=mJjYgpeo5ws&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は非常に広い問題領域に適用可能なマルチパラダイム言語である。このセッションでは限られたメモリリソース、かつ、200KHz(5マイクロ秒)サーボインタラプト割合のリアルタイム組み込みシステムにC++を利用した際の最適化と拡張について紹介する。二年以上かけて、このシステムのデータ処理帯域幅は、ハードウェアの強化をすることなく大きく改善した。この改善を達成するために、様々なアプローチとテクニックについて議論した。その結果、ほとんどのよく知られているC++イディオムは組み込みのリアルタイムシステム環境にはよく合わないことが分かった。しかし、C++はCよりもメンテナンスの面でもコード実行速度の面でも優位な性能を見せた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、組み込み向け、汎用機向けという区分なく、特定のC++コードの実行速度の高速化に興味がある方には有意だろう。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションで、特定の組み込み環境について、何が正しく動き、何が正しく動かないのか、そしてその理由はなにかについて説明する。主なテーマはパフォーマンスモニタリング、特定領域のコードデザイン、コンパイラに高速なコードを生成させる方法、スレッドセーフオプションである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#whirlwind-overview-cpp11&#34; name=&#34;whirlwind-overview-cpp11&#34;&gt;駆け足でC++11の概要&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Whirlwind Overview of C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/leor-zolman/&#34; target=&#34;_blank&#34;&gt;Leor Zolman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/cpp_overview_handout.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/cpp_overview_handout.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=jrCrWdrH17g&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=jrCrWdrH17g&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このC++11の簡潔なイントロダクションでは、プレゼンターであるLeor Zolmanが言語への主要な機能追加について調査する。また以下の項目についても述べる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コード可読性の向上について(ラムダ, 統一初期化, &lt;code&gt;auto&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;パフォーマンスの向上について(右辺値参照とムーブコンストラクタ)&lt;/li&gt;
&lt;li&gt;マルチスレッドについて(並行性とアトミック型)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、他の多岐に渡る便利な機能や、標準ライブラリのコンポーネント(スマートポインタと新しいSTLコンテナ)についても触れる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションはC++11の簡潔な概要を知りたい方向けである。そのため、詳細をカヴァーしきれない言語機能、ライブラリが多々あることをご了承いただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#odeint&#34; name=&#34;odeint&#34;&gt;odeint - C++で常微分方程式を解く&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;odeint – Solving ordinary differential equations in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/karsten-ahnert/&#34; target=&#34;_blank&#34;&gt;Karsten Ahnert&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mario-mulansky/&#34; target=&#34;_blank&#34;&gt;Mario Mulansky&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/odeint.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/odeint.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=jv2oDfT-jds&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=jv2oDfT-jds&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常微分方程式(ODE: Ordinary differential equation)は自然科学、応用分野の諸領域で重要な役割を果たしている。&lt;br /&gt;
例示すると、古典的ニュートン物理学、化学反応式、量子系から神経系にわたる、個体群動態における反応速度式などである。&lt;br /&gt;
さらに、常微分方程式は偏微分方程式(PDE: partial differential equation)の離散化をする際頻出する。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、odeint(&lt;a href=&#34;http://odeint.com&#34; target=&#34;_blank&#34;&gt;odeint.com&lt;/a&gt;) -常微分方程式の数値解法を探索するためだけのC++ライブラリ- を紹介する。このライブラリはBoost入りを目指している。&lt;/p&gt;
&lt;p&gt;odeintは非常にジェネリックに実装されており、高速に相互運用することができる。&lt;/p&gt;
&lt;p&gt;odeintはODEソルバのためのC++コンセプトを導入しており、標準的なメソッドを数多く実装している。例えば、古典的Runge-Kuttaスキーム、ステップサイズコントロールと稠密出力のメソッド、非明示なメソッドとシンプレティック解法などである。； odeintはコンテナ非依存であることを強調しておきたい。つまり、使用者はstd::vectorのような特定の型を使うことを強いられない。 それゆえ、ネットワーク、ラティス上のODEを解くこともできる。 さらに、多倍精度か区間演算を利用できる。 ジェネリックな設計を取っているので、odeintは容易に並列化してCUDA GPUで実行できる。 それにもかかわず、odeintはわかりやすいインターフェースを備えているので、簡単に、容易に使うことができる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではodeintの主要な機能ならびにそのソフトウェアデザインについて述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#fresh-paint&#34; name=&#34;fresh-paint&#34;&gt;新仕様できたてほやほや!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Fresh Paint&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/fresh_paint.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/fresh_paint.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=ourmFvidEpk&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=ourmFvidEpk&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11では様々な方法で言語を拡張する興味深い新機能が導入された。&lt;/p&gt;
&lt;p&gt;このセッションではそれらを完全に無視して、別のテーマに焦点を当てる。すなわち、C++11でよりシンプルに、クリーンに、エレガントに記述する方法について述べる。このセッションはソフトウェアデザインの最先端についてあまりよく知らないけれど、クリーンかつシンプルかつ効率的なコードを書くことに関心がある方に最適である。話のなかでデザインについて知見が得られれば幸いである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#openmp-for-better-high&#34; name=&#34;openmp-for-better-high&#34;&gt;ハイパフォーマンスを求めるためだけではなく、高次の並列化のためのOpenMP&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OpenMP for better high-level parallelism, not just for High Performance Computing&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/47981ddb3630f7fc1651ae0ecb608b0344d19b5f/mon/cppnow_openmp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/47981ddb3630f7fc1651ae0ecb608b0344d19b5f/mon/cppnow_openmp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=iGrk2mbKTS0&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=iGrk2mbKTS0&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OpenMPは高次の言語を用いたインクリメンタル並列化をサポートする、C,C++,FORTRAN向けの分散メモリ並列化の仕様である。&lt;/p&gt;
&lt;p&gt;OpenMPはハイパフォーマンスコンピューティング、スーパーコンピューティングのためのもの、と思っている方がいるかもしれないが、実際は他にほぼ類をみない分散メモリ並列化 - これは3つの汎用言語で実装されている - に適しており、それ自体高次言語である。OpenMPはグラフィクスや可視化の分野や、組み込みやリアルタイムアプリケーション分野、コミュニケーションとネットワーク分野、自動化とロボディクス分野、財務や通商分野、医療と生命工学分野、石油・ガス業界、シミュレーション、データベースとミドルウェア、音声・オーディオ処理、汎用データ解析などの分野でも有効であることが知られている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#hpx&#34; name=&#34;hpx&#34;&gt;HPX: C++11並列実行システム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HPX: A C++11 parallel runtime system&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/bryce-adelstein-lelbach/&#34; target=&#34;_blank&#34;&gt;Bryce Adelstein-Lelbach&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/hartmut-kaiser/&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/matthew-anderson/&#34; target=&#34;_blank&#34;&gt;Matthew Anderson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/thu/hpx_a_cxx11_parallel_distributed_system.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/thu/hpx_a_cxx11_parallel_distributed_system.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;計算科学のアプリケーションは、しばしば基になる実行モデルから受けついだ選択の影響を受ける。並列計算アプリケーションにおいては、MPIが注目をあつめている。しかし、電源や、プロセッサコアの複雑性、マルチコアソケット、GPUの異種混在という問題が深刻になってきたため、並列アプリケーションはスケーリング不全の危機に陥っている。&lt;/p&gt;
&lt;p&gt;HPX実行時システムはモジュラーであり、完全実装であり、SMPノードとコモディティ・クラスターのような従来型の並列計算アーキテクチャを対象としたParalleX実行モデルのパフォーマンス指向の表現である。MPIの代替として、HPXは軽量ユーザースレッドを管理するためのルーチンに加えて、アクティヴグローバルアドレス空間(AGAS: Active Global Address Space)を提供している。HPXはC++11で実装され、20のBoostライブラリ/Boostライブラリ候補を利用している。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、実行時システムアーキテクチャに焦点を当てるとともに、HPXでどのようにBoost C++ライブラリやC++11機能を利用しているかについて議論する。HPXの概要についてプレゼンテーションし、さらに、競合するランタイムシステムおよび科学計算コミュニティ向けアプリケーションとの比較とベンチマークを紹介する。HPXに興味、関心をもたれて、実際に試用していただければ幸いである。ダウンロードはこちらから： &lt;a href=&#34;http://stellar.cct.lsu.edu/&#34; target=&#34;_blank&#34;&gt;http://stellar.cct.lsu.edu/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#lambda-functions&#34; name=&#34;lambda-functions&#34;&gt;ラムダ関数&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lambda Functions&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/lambda.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/lambda.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=tLp6ZBHwvj4&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=tLp6ZBHwvj4&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;無名関数は多くの言語で有用なツールとして成功を収めている。その局所性と明瞭な構文により、高い表現力と、バグの少ないコードを記述できる。Boost.LambdaやBoost.Phoenix、そしてFC++といったライブラリによって、C++にラムダ式がもたらされたが、今日、C++11には言語機能としてラムダ関数がある。ラムダ関数は無名関数オブジェクトとよく似ている。というのは、ラムダのスコープ外でキャプチャ/識別子の状態の変更が可能だからだ。&lt;/p&gt;
&lt;p&gt;この90分のチュートリアルセッションで、この新しい言語機能の構文と利用方法を概観する。上達を図るために練習問題や例を多数用意している。ラムダが利用可能なコンパイラを持参し、ぜひラムダ関数を使うとコードがどれほどよくなるか体験していただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#future-cpp1x-proposals&#34; name=&#34;future-cpp1x-proposals&#34;&gt;来るC++1xへの提案&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Future C++1x proposals&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/cppnow_future.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/cppnow_future.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=NdWHVyZBazo&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=NdWHVyZBazo&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11が公開された今、C++1xに搭載される次の機能は何だろうか？ このプレゼンテーションでは2月のコナ会議で提案されたものを紹介していく。Evolution Working Groupでレヴュー済みのペーパーと、ConcurrencyおよびLibrary Working Groupの活動についても焦点を当てる。 おまけ： 主要なコンパイラについて、最新のC++11実装状態についてもお伝えしたい。&lt;/p&gt;
&lt;p&gt;2012年2月のコナ会議を経て、標準委員会は次のC++標準を暫定的に2017年に、その次を2022年に、おおよそ五年毎に公開するように決定した。また、いくつか主要なものを例にあげると、モジュールや高度な並列抽象化、リフレクションといった次の標準にむけての提案についても精査した。このプレゼンテーションではこれらの機能について焦点をあて、C++11にどのような影響を与えるかについて議論する。&lt;/p&gt;
&lt;p&gt;カナダ、IBMのC++標準委員会代表や、BoostConでトランザクショナル・メモリからC++11の並行について多様なトピックを長きにわたってプレゼンターを務めた者として、標準委員会でC++の将来搭載されるべき機能についての議論にはできるだけ参加するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#variadic-tmp&#34; name=&#34;variadic-tmp&#34;&gt;モナドを使って可変長テンプレートメタプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Variadic Template Metaprogramming using Monads&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bartosz-milewski/&#34; target=&#34;_blank&#34;&gt;Bartosz Milewski&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/eric-niebler/&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/compile_time_runtime_cpp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/compile_time_runtime_cpp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11 の新機能である可変引数テンプレートは，パワフルだが気の触れた制限がついている．なんと template parameter pack が一級市民ではないので，一部のよくある(メタ)プログラミングの定石で使いにくいのだ．うれしいことに偶然，関数型プログラミング，正確に言うと Haskell では，おもしろい方法でこの問題を解決している．というわけで我々は，可変個継続，継続モナド，カリー化，その他C++メタプログラミングで使うためのエキゾチックな構成を使った方法について話す．&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#ustring&#34; name=&#34;ustring&#34;&gt;Ustring - 現代的なstd::stringの代替&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ustring – A Modern Alternative to &lt;code&gt;std::string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alan-talbot/&#34; target=&#34;_blank&#34;&gt;Alan Talbot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/ustring.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/ustring.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=nAm1Tbk068U&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=nAm1Tbk068U&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++プログラミングで推奨される文字列表現はstd::stringである。しかし、実際には、あるプログラムには三つ以上の文字列型(例えば、&lt;code&gt;std::string&lt;/code&gt;、MFCの&lt;code&gt;CString&lt;/code&gt;、&lt;code&gt;char*&lt;/code&gt;)が混在していることがほとんどである。われらが&lt;code&gt;std::&lt;/code&gt;stringは長年よくやってくれているが、いろいろな制限やときどき見せる奇行に悩まされることもままある。そして、他の文字列クラスが備えている便利な機能、特に言うならUnicodeサポートが欠けている。C++11が公開されたことと、&lt;code&gt;std::string&lt;/code&gt;が実装されてから数十年来の知見を集めて、よりよいツールを創ってみた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションの前半は、将来、強力かつ競争力のあるツールとなるよう、&lt;code&gt;std::string&lt;/code&gt;の制限や問題を解決することをめざした新しいクラスの設計について述べる。多くの知見を集積して、C++11にふさわしい、簡便で、表現力豊かで、強力な文字列処理を創りだすことが目標である。そのために、後半は理論や秘話、懸案事項やアイデアなどをいただきたく、聴講されている皆様とブレインストーミングするセッションにするつもりである。このライブラリは開発の初期段階にあるので、変更の余地はあるし、どんなアイデアでも歓迎する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#high-level-threading&#34; name=&#34;high-level-threading&#34;&gt;C++11: 高次のスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11: High-Level Threading&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/concurrency.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/concurrency.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=9GILH2U94Ls&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=9GILH2U94Ls&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11は並行処理の新しい機構を備えている。慎重に設計されたシステムのプログラミング言語であるならば当然のことだが、言語機能は厳格な理論的基礎(メモリモデル)に基いて構築され、低レヴェルプリミティヴ(atomic)へのアクセスを提供している。幸運にも、C++11ではスレッドを効果的に使う際に、こうした難解な詳細について理解する必要はない。(もし低レヴェルの事柄について詳細を知りたければ、Tony Van Eerdのプレゼンテーションを見るべし)&lt;/p&gt;
&lt;p&gt;その基礎の上に、プログラマが日々のコンカレントなコードを記述する際、実際に使うべきAPIが用意されている。すなわち、大量のロックやミューテクスや条件変数、そして、より高いレヴェルの&lt;code&gt;future&lt;/code&gt;, &lt;code&gt;promise&lt;/code&gt;, &lt;code&gt;packaged_task&lt;/code&gt;などだ。また、スレッドセーフなプログラミングの中核的問題についても述べ、これら問題を解決するためのコンポーネントの使いかたについても述べる。&lt;/p&gt;
&lt;p&gt;メモ： このプレゼンテーションに興味を持たれたかたは、&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34;&gt;&#34;Other C++11 Gems&#34;&lt;/a&gt;のプレゼンテーションにも食指が動くかもしれない。そちらのプレゼンテーションでは、時刻や時間、タイムアウトでのロック、スリープといった優れたデザインの新機能について取りあげるそうだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#grill-the-committee&#34; name=&#34;grill-the-committee&#34;&gt;標準委員を質問攻めにしよう!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Grill the Committee&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準のなれそめについて知りたくないか？ このパネルディスカッションではC++標準委員会のメンバーに登壇いただき、聴衆の皆様に気になっていることを質問していただく趣旨である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#moving-forward&#34; name=&#34;moving-forward&#34;&gt;キーノート： C++11で前進せよ!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Moving Forward with C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料&lt;ul&gt;
&lt;li&gt;前編：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part1.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part1.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;後編：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part2.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part2.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;前編・後編一括：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;右辺値参照はC++に二つの新しい相乗的に機能するプログラミングイディオムをもたらす。すなわちムーブセマンティクスと完全転送である。このプレゼンテーションでは右辺値参照とは何か、ムーブセマンティクスとは何か、完全転送とは何か、といった基礎からはいる。また、このプレゼンテーションではこれらが導入された動機や利用法、コンパイラがこれらを自動生成する条件についても述べる。さらに、クラスを設計した後でも、条件に合致すれば自動的に、ムーブセマンティクスが最適化の役目を果たすことができるけれども、ムーブセマンティクスの知識は直接的にクラス設計に影響を与えることを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#metaparse&#34; name=&#34;metaparse&#34;&gt;Metaparse – テンプレートメタプログラミングによるコンパイル時構文解析&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaparse – Complie-time parsing with template metaprogramming&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/abel-sinkovics/&#34; target=&#34;_blank&#34;&gt;Ábel Sinkovics&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/zoltan-porkolab/&#34; target=&#34;_blank&#34;&gt;Zoltan Porkolab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/2b6b26f9fcc28fa7b2c777819111012217116ff5/tue/metaparse.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/tue/metaparse.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=v3XoWi0XbZk&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=v3XoWi0XbZk&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Metaparseは、C++のコンパイル時文字列を解析する、パーサー生成のためのC++テンプレートメタプログラミングライブラリである。Boostはすでに2つのパーサージェネレータライブラリを持っている：Boost.SpiritとBoost.Proto。MetaparseとBoost.Spiritの主な違いは、Metaparseによって生成されたパーサーはコンパイル時に実行され、Boost.Spiritによって生成されたパーサーは実行時に実行されるということである。Boost.ProtoパーサーはC++の有効な式をコンパイル時に処理し、Metaparseは自由形式の文字列を入力としてパーサーを構築する。&lt;/p&gt;
&lt;p&gt;コンパイル時の任意なテキストを解析することは、多くの状況で有用である。我々はより複雑なユースケースを比較的に簡単にする方法を提供する。一般的な構文は、以下の正規表現のコンパイル時検証を有効にすることでBoost.Xpressiveのラッパーを作成できる。より複雑な例として、printfの書式指定文字列を解析し、コンパイル時に引数の型を検査する。コンパイル時パーサーの別な手段は、組み込みDSLスクリプトをC++のネイティブな関数への変換をコンパイル時に行い、実行時にそれを実行することである。最も複雑な例では、テンプレートメタ関数を定義するために、組み込みDSLをどのようにして実装するかを示す。Metaparseはパーサー生成のDSLをメタ関数に変換する能力を持つ。&lt;/p&gt;
&lt;p&gt;Metaparseの内部構造と、それをどのようにして拡張するかを説明する。ライブラリの正確なエラー報告の機能を紹介する。モナドの概念の入門と、それを使用することでパーサーの構築を容易にすることを示す。新たなC++標準の&lt;code&gt;constexpr&lt;/code&gt;は、コンパイル時にアルゴリズムを実行するための構造を提供する。メタプログラミングと&lt;code&gt;constexpr&lt;/code&gt;の間を繋ぎ、パーサーによって処理される入力の構文的なオーバーヘッドを最小限にしてそれを利用する方法を提供する。&lt;/p&gt;
&lt;p&gt;Metaparseと、その元となるライブラリは、以下から利用可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://abel.web.elte.hu/mpllibs&#34; target=&#34;_blank&#34;&gt;http://abel.web.elte.hu/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sabel83/mpllibs&#34; target=&#34;_blank&#34;&gt;https://github.com/sabel83/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これはユーザーと開発者にとって高度な話である。Boost.MPLに精通していることを前提とする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#ladon&#34; name=&#34;ladon&#34;&gt;Ladon - 分散状態マシンフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ladon - A Distributed State-Machine Framework&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/ladon.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/ladon.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=KExYq1bepT0&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=KExYq1bepT0&amp;amp;feature=plcp&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;階層的な状態マシンは、多くのドメインにエレガントな解決策を提供する。それらの厳格な要件は、高い信頼性のシステムのための規律を一段階強化する。状態マシンはシステムの反応的な振る舞い(reactive behavior)について記述するのに役立つ。ポート束縛、メッセージ配信、およびプロトコル変換を提供する一方で、コミュニケーションポートや包含コンセプト(containment concepts)のようないくつかの(ROOMのような)構造的コンポーネントを加える。そうすれば、分散状態マシンフレームワークが生まれる。よく定義されたインタフェースを持ったより小さな分散マシンに分割することは、大きな反応的システムのための強力なツールである。&lt;/p&gt;
&lt;p&gt;このセッションでは、Ladon分散状態マシンフレームワーク(C++Now 2012でデビューするciere consultingのオープンソースプロジェクト)を導入する。Ladonは、反応的なシステムのためのリッチな分散ソリューションを作成するために、Boost.MSM、Boost.AsioおよびBoost.Spiritを融合させる。フレームワークの設計と基本的な使用法についての議論に加え、我々はあなたのシステムで使用できるおもしろいパターンと解決策のいくつかを紹介する。我々が言及するライブラリは、以下のものを含む：MSM、Spirit、Asio、Fusion、Signals2、そしてPhoenix。&lt;/p&gt;
&lt;p&gt;この90分間のセッションは、初心者と中級レベルの出席者に、いくつかのBoostライブラリと現代的なC++手法の概観を提供する。&lt;/p&gt;
&lt;p&gt;語源 - Ladon(Λάδων)は、ヘスペリデスの庭のトマトを守護する、ギリシャの100の頭を持つヘビのようなドラゴンである。頭がそれぞれ異なる言語を話したという噂がある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#low-level-threading&#34; name=&#34;low-level-threading&#34;&gt;黒魔術につき取扱注意 - C++11で低レヴェルスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Don’t Try This at Work – Low Level Threading with C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/low_level_threading_with_cpp11.pps?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/low_level_threading_with_cpp11.pps?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のC++は&#34;メモリモデル&#34;がある。しかしこれはどんな意味で、どうして導入されたのか、また、以前のC++に必要なかったのは何故か？ これを使って何ができるか？ そしてこれらの新しい原子操作にはなにやら相関があるようだ… むむむ…&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#exception-safety&#34; name=&#34;exception-safety&#34;&gt;C++で例外安全なコーディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Exception-Safe Coding in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/exception_safe_coding.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/exception_safe_coding.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;皆様のコードは100%例外安全を達成していると言えるだろうか？&lt;/p&gt;
&lt;p&gt;例外を安全に利用するのはなまはんかな問題ではない。この業界では20年来この問題に奮闘してきた。もし皆様が恐怖や不透明感、例外安全に疑いをもっていたり、純粋にC++で例外のベストプラクティスを知りたいと思っているならば、ぜひこのプレゼンテーションを聞いていただきたい。まず始めに、&#34;何を解決しようとしているか&#34;から入り、代案について議論し、例外の利用に関する問題を確認し、例外安全について曲解されやすい試みについて述べる。また、安全な例外の利用法についての基本的なガイドラインと過去の例外安全ではないコードベースから移行するための鉄板の実装テクについても述べる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションの目的は、皆様に、簡単に記述できて、理解しやすく、高速に動作し、例外が発生しても100%の堅牢性を誇るコードをどうやったら書けるようになるかお伝えすることである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#moving-boost-to-git&#34; name=&#34;moving-boost-to-git&#34;&gt;BoostをGitに移行しよう&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Moving Boost to Git&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/moving_to_git.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/moving_to_git.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=rqKGX2LJOmU&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=rqKGX2LJOmU&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gitヴァージョン管理システムはSubversionに比べてBoostの開発者、利用者双方に利益がある。このセッションではBoostからみたGitについて紹介し、徐々に高度な議題について述べていく：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;なぜGitなのか？ - 成層圏から俯瞰してみよう&lt;/li&gt;
&lt;li&gt;皆様にGitの基礎を知っていただくために、駆け足のGitのチュートリアル&lt;/li&gt;
&lt;li&gt;Subversionに対するGitの優位性 - Boost開発者の視点から&lt;/li&gt;
&lt;li&gt;Subversionに対するGitの優位性 - Boost利用者の視点から&lt;/li&gt;
&lt;li&gt;Boostのモジュール化への試み - 課題、アプローチ、トレードオフについて&lt;/li&gt;
&lt;li&gt;Boost開発者にあわせたワークフロー構築の試み&lt;/li&gt;
&lt;li&gt;BoostをGitに移行してみるワークショップ - 実行計画の開発&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この&#34;BoostをGitに移行しよう の前準備&#34;と題したドキュメントとファイルをC++Now!の二週間前くらいまでに用意するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#learned-developing-std-lib&#34; name=&#34;learned-developing-std-lib&#34;&gt;C++11標準ライブラリの策定を通じて学んだこと&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lessons Learned Developing the C++11 Standard Library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/lessons_from_the_library.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/lessons_from_the_library.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11の標準化作業はおおよそ8年かかり、標準ライブラリのサイズは少なくともページ数上では倍増した。標準化作業は標準ライブラリの設計を再確認し、おおよそ十年間で蓄積したBoostライブラリで得られた知見や開発技術をもって仕様をクリーンアップし、右辺値参照やコンセプト、並行処理のサポートといった、言語に導入が考えられた新しいアイデアについて学び、最後に新しい機能でライブラリを拡張した。この経験は有意だったか、それとも無意だったか？ 次の機会によりうまくやるために、いったい何を学んだのか？ 次のライブラリ TR を策定するにあたり、このレッスンをどう生かせばいいのか？&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#utilizing-modern-programming&#34; name=&#34;utilizing-modern-programming&#34;&gt;科学的ソフトウェア開発における現代的プログラミングテクニックとBoostライブラリの適用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Utilizing Modern Programming Techniques and the Boost Libraries for Scientific Software Development&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/josef-weinbub/&#34; target=&#34;_blank&#34;&gt;Josef Weinbub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_weinbub.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_weinbub.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現代的プログラミングテクニックとライブラリを利用することで、ソフトウェア開発者は膨大な機能と柔軟性を手にいれることができる。しかし、ジェネリックプログラミング、関数型プログラミング、メタプログラミングのような関連技術を利用するには、高度なプログラミングスキルが要求されるので、マニアかコンピュータサイエンティストでなければ使い熟し得ない。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、Boostライブラリのような現代的プログラミング技術を利用する科学的コンピューティングの範疇に含まれる3つの仕事について報告する。まず、主にBoost GraphライブラリとBoost Phoenixライブラリを利用した順次および並列タスクグラフ実行のための拡張可能なプラグインスケジューラを紹介する。次に、Boost MetaprogrammingライブラリとBoost Fusionライブラリを利用した、コンパイルタイムに任意のプロパティに基づいてコンポーネントのサブセットを選択するというメタプロパティの選択方法について紹介する。最後に、ジェネリックパラダイムのもと幾何学的アルゴリズムを一般化するためのアプローチについて示す。&lt;/p&gt;
&lt;p&gt;これらアプローチの紹介を通じて、現代的プログラミングテクニックとBoostライブラリの適用により、非常に汎用的で、維持可能で、コンパクトで、拡張可能なコードを生み出せることを示す。以上から、長期的には高度なC++スキルを習得するために費した時間はペイすると結論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#vs-ide&#34; name=&#34;vs-ide&#34;&gt;C++開発者むけVisual Studio IDEの最新情報&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What’s new in Visual Studio IDE for C++ Developers&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sumit-kumar/&#34; target=&#34;_blank&#34;&gt;Sumit Kumar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/visual_studio_ide_for_cpp%20_developers.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/visual_studio_ide_for_cpp%20_developers.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=XLrR3cJCjlI&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=XLrR3cJCjlI&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;きたるVisual Studio 11のリリースには、IDEとのやりとりやチーム内の他のC++開発者と共同作業するといった、日々のコーディング作業でC++開発をより効率的にするような新しい機能や革新が数多く詰まっている。&lt;/p&gt;
&lt;p&gt;本プレゼンテーションではデモをごらんいただきながら、構文の色分け、参照のハイライト、進化したインテリセンス、コード解析、プロファイリングといった機能に焦点を当てて紹介する。また、ドキュメントとの連携、検索やナビゲーションといった普段の作業を非常に簡易化するIDEの改善点についてもひととおりごらんいただく。このプレゼンテーションではコードレヴューやテスト、コードカヴァレッジといった統合機能についても概説する。Visual Studio 11はC++開発者チーム全体に有益である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#modules&#34; name=&#34;modules&#34;&gt;キーノート： C++におけるモジュール&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Modules in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/david-vandevoorde/&#34; target=&#34;_blank&#34;&gt;David Vandevoorde&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modules_aspen2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modules_aspen2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=8SOCYQ033K8&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=8SOCYQ033K8&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の幕開け以来、プリプロセッサはC++ライブラリインターフェースとやりとりするための手段としての役割を果たしてきた。しかし、長年にわたり、プリプロセッサであるがゆえに生じる制約によって、不愉快なビルド時間は増加の一途をたどっている。今日、プリプロセッサはよりよいC++開発ツールをつくるにあたり唯一最大の阻害要因になっている。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、C++に&#34;モジュール&#34;の概念を導入するための選択肢を紹介し、それらがもたらす課題と恩恵について議論する。次のC++標準仕様に向けて、C++標準委員会はこれらの選択肢について活発に検討している段階である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#generic-programming-real-world&#34; name=&#34;generic-programming-real-world&#34;&gt;C++でのジェネリックプログラミング： 実例を交えて&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming in C++: A Real-World Example&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/marshall-clow/&#34; target=&#34;_blank&#34;&gt;Marshall Clow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/marshall_generic_programming.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/marshall_generic_programming.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=SWGMq0_X32Q&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=SWGMq0_X32Q&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この90分のセッションでは、Boost MLでいただいたリクエストに答えようと思う。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;なぜBoostには&lt;code&gt;hex&lt;/code&gt;／&lt;code&gt;unhex&lt;/code&gt;関数がないのか？ とても有用だと思うけど。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;また、Boost.Algorithmライブラリにマッチしたこれらのアルゴリズムのデザインと実装についても概説する。&lt;/p&gt;
&lt;p&gt;この関数は単純であるけれども、非常に多くの興味深い設計決定が実装中になされている。これについてもこのプレゼンテーションで述べるつもりだ。&lt;/p&gt;
&lt;p&gt;カヴァーする議題は以下の通り：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ジェネリックプログラミングデザイン&lt;/li&gt;
&lt;li&gt;イテレータの取り扱い(出力イテレータの問題についても述べる)&lt;/li&gt;
&lt;li&gt;テンプレートメタプログラミング(&lt;code&gt;enable_if&lt;/code&gt;の用法についても述べる)&lt;/li&gt;
&lt;li&gt;Boost.Exception&lt;/li&gt;
&lt;li&gt;コードの最適化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#lowest-variational-methods&#34; name=&#34;lowest-variational-methods&#34;&gt;Boost.Protoを用いた最低次変分法のドメイン特化固有言語の実装&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Implementing a Domain Specific Embedded Language for lowest-order variational methods with Boost Proto&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jean-marc-gratien/&#34; target=&#34;_blank&#34;&gt;Jean-Marc Gratien&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/jmg_cppnow_2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/jmg_cppnow_2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このペーパーでは、FreeFEM様のドメイン特化言語を用いて線型離散と双線型離散の定義を対象とする拡散問題を解くための最低次変分法族の原実装を示す。Boost Protoフレームワークの利用によって、この言語のバックエンドとフロントエンドをどう実装したかについて議論する。種々の学術的問題の実装を行なうことで、このDSEL設計を検証する。この言語のオーヴァーヘッドは従来の実装と比較することで評価する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#cpp11-containers&#34; name=&#34;cpp11-containers&#34;&gt;C++11コンテナの最新情報&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What’s new with C++11 containers?&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/cppnow_containers.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/cppnow_containers.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11でピカピカのコンテナがいくつか導入された。すなわち、単方向リスト、ハッシュコンテナ、固定長同型コンテナ、そして異形コンテナである。しかしこれだけではない。前仕様C++98/03のコンテナも新しいメンバ関数の追加、ムーブのサポート、&#34;移動のみ&#34;のコンテナをつくれるように、&lt;code&gt;value_type&lt;/code&gt;に課されていた制限の緩和といった手直しがなされている。さあC++11のコンテナを有効利用する方法についてみていこう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#concept-clang&#34; name=&#34;concept-clang&#34;&gt;ConceptClang： C++ Conceptの実装モデル&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ConceptClang: An Implementation Model for C++ Concepts&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/andrew-lumsdaine/&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;,&lt;a href=&#34;http://cppnow.org/participant/larisse-voufo/&#34; target=&#34;_blank&#34;&gt;Larisse Voufo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/concept_clang.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/concept_clang.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Conceptはテンプレートに安全性を付与することを意図として、制約ベースのポリモルフィズムを行うために提案されたC++の拡張である。本プレゼンテーションではConceptClangを紹介する。これは、C族言語のLLVMフロントエンドであるClangをベースとする、Conceptデザインの検証を行うための基盤の実装例である。このプレゼンテーションでは、Conceptの提案された主要な機能(コンセプトに基づく探索、テンプレートのオーヴァーロード、テンプレートの拘束など)をどう実装したかについて述べるとともに、種々のConcept設計を深めていくために、ConceptClang基盤をいかに利用すればいいかについても示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#modern-cpp-techniques&#34; name=&#34;modern-cpp-techniques&#34;&gt;現代的C++テクニック入門&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Introduction to Modern C++ Techniques&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modern_cpp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modern_cpp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ポリシー、SFINAE、タグディスパッチ… ktkr! 現代的C++にノって弾みをつける準備はOK? Ciere C++ ニンジャシリーズから、このセッションでは基本的なことから、ジェネリックプログラミングで使われているテクニックやストラテジーを紹介する。このセッションで話すトピックは以下のとおり：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Concept&lt;/li&gt;
&lt;li&gt;Trait&lt;/li&gt;
&lt;li&gt;ポリシークラス&lt;/li&gt;
&lt;li&gt;CRTP (Curiously Recurring Template Pattern)&lt;/li&gt;
&lt;li&gt;SFINAE (Substitution Failure is not an Error)&lt;/li&gt;
&lt;li&gt;タグディスパッチ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この3時間のハンズオンチュートリアルは例がびっしりの参加型セッションである。ノートPCを持参されたし! 日々のコーディングで現代的C++の技法を使いたい開発者には、きっと得るものがあるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#smart-pointers-algorithm&#34; name=&#34;smart-pointers-algorithm&#34;&gt;C++11のスマートポインタとアルゴリズム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11 Smart Pointers and Algorithms&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/smart_pointers_algorithms.key?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/smart_pointers_algorithms.key?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++03で言うところのスマートポインタとは&lt;code&gt;auto_ptr&lt;/code&gt;だった。&lt;code&gt;auto_ptr&lt;/code&gt;は最良の型であり最悪の型である。このプレゼンテーションでは&lt;code&gt;auto_ptr&lt;/code&gt;がどのように&lt;code&gt;unique_ptr&lt;/code&gt;を触発したか、その違いはなにかについて説明する。&lt;code&gt;unique_ptr&lt;/code&gt;を比較対象として、&lt;code&gt;shared_ptr&lt;/code&gt;についても概説する。これらを使うべきときはいつか？ どちらのスマートポインタを使うべきか？&lt;/p&gt;
&lt;p&gt;加えて、このプレゼンテーションではC++11に新しく追加されたアルリズムについて、また、&lt;code&gt;unique_ptr&lt;/code&gt;のようなムーブのみ可能な型で動作するよう修正された多数の新旧アルゴリズムについても述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#voronoi&#34; name=&#34;voronoi&#34;&gt;Boost.Polygon.Voronoiライブラリを例に、堅牢かつ効率的多倍精度アルゴリズムの設計について&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Robust and efficient multi precision algorithms design based on Boost.Polygon.Voronoi library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/andrii-sydorchuk/&#34; target=&#34;_blank&#34;&gt;Andrii Sydorchuk&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/lucanus-simonson/&#34; target=&#34;_blank&#34;&gt;Lucanus Simonson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/voronoi_presentation_andrii_sydorchuk.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/voronoi_presentation_andrii_sydorchuk.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;複雑な数値計算アルゴリズムの設計と実装はユーザビリティ、拡張性、効率性、堅牢性という4つの要素を満たさねばならない。&lt;/p&gt;
&lt;p&gt;ユーザビリティとは、その分野に精通していないユーザーにとっての、公開されているアルゴリズムインターフェースのわかりやすさである。同時に、精通しているユーザーにとっての、アルゴリズムを構成できる幅のことでもある。&lt;/p&gt;
&lt;p&gt;拡張性とは、アルゴリズムそれ自身、依存するデータ構造、計算カーネル、数値型といった部分を再構成または置換する際、アルゴリズムに汎用性と柔軟性を持たせることである。&lt;/p&gt;
&lt;p&gt;効率性はまずアルゴリズムの複雑度とデータ構造の分析に始まり、メモリやパフォーマンスプロファイルを行い、システム/コンパイラ特異的な最適化に終わる。これには、数値型の操作および現実装と他のよく知られたアプローチとの比較も含まれる。&lt;/p&gt;
&lt;p&gt;堅牢性は数値アルゴリズムの最も重要な研究分野であろう。もし内部データ構造が実行時に破壊されたらどうなるか、という問いに対する答を用意しておくことである。アルゴリズムの出力と、出力がどの範囲で正常かつ信頼できるかを定義することでもある。言い変えれば、受けとった出力とランダムデータとの違いは何か、ということである。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、アルゴリズムの動機となった実世界の問題を見ていきながらアルゴリズムを紹介する。Boost.Polygon.Voronoiライブラリで用いているアルゴリズム設計テクニックと実装をもとに、上記で言及した要素全てについて示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#tool-for-class-and-library-authors&#34; name=&#34;tool-for-class-and-library-authors&#34;&gt;C++11: クラスやライブラリ実装者のための新しいツール&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11: New Tools for Class and Library Authors&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/schurr_cpp11_tools_for_class_authors.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/schurr_cpp11_tools_for_class_authors.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この新しい標準はクラスやライブラリ実装者のために、可変引数テンプレートや&lt;code&gt;static_assert&lt;/code&gt;、&lt;code&gt;constexpr&lt;/code&gt;、明示的な変換関数、および&lt;code&gt;decltype&lt;/code&gt;といった多数のツールが用意されている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#cmake-modularization&#34; name=&#34;cmake-modularization&#34;&gt;CMake、モジュール化と Ryppl 開発者向けプレヴュー&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CMake, Modularization and Ryppl Developer Preview&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rypplは、C++の開発や、構築、テストならびにBoostとそのユーザーの要求、すなわちC++コミュニティに合わせて設計された配信のための基盤フレームワークである。巨大化、複雑化、また潜在的にモジュール化がすすむBoostは、Rypplの完全なテストケースになりえる。このため我々は一年間、このコンセプトを証明するために必要なシステムと変更に取りくんできた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、CMakeを使ってビルドおよびテストできるように、なにもインストールせずに配置できるように、またBuildBotを用いてリモートでビルド、テストできるようにするための、Boostのモジュール化にむけた作業の進捗について示す。BoostCon(訳註：C++Now2012のことか)が始まった時点で、Boost開発者に利用いただける、コミュニティ全体で予備的なレヴュー可能なシステムの機能を完全に揃えている予定である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#now-what&#34; name=&#34;now-what&#34;&gt;キーノート： さて、これからどうしよう？ 3つの視点から&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Now What? A vignette in 3 parts&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sean-parent/&#34; target=&#34;_blank&#34;&gt;Sean Parent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/now_what.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/now_what.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=iGenpw2NeKQ&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=iGenpw2NeKQ&amp;amp;feature=plcp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;パート1： 美しさ&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は効率性が要求されるところでは復権を果たした。しかし、C++へ移行してきた者に対して、いまだ多くの者が歓迎していない。これはJavaやJavaScript、Pythonからきたプログラマにとって移行の脅威になりえる。C++コミュニティとして、美しく、効率的なコードを書くための、C++11で提供されるツールを梃入れする必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;パート2： 真実&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のハードウェア上では、単一スレッドで実行されるC++コードではマシン性能のたった0.25%ほどしか引き出せない。C++11ではほんのちょっとだけスレッドサポートが解禁された。未来を見据える言語、ライブラリに課せられた最大の試練は、いかにマシン性能の残り99.75%を引き出すか、ということに尽きるだろう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;パート3： 美点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;過剰なネットワークディヴァイスはソフトウェアの展望を変えつつある。インターネットの基盤は次第に裏方にまわり、増えつづける顧客はディヴァイス上にある情報を簡便に取得できるよう要求している。そのようなシステムが我々のソフトウェア設計と記述にどんな影響を与えるだろうか？この新しい世界におけるC++の果たす役割とは何だろうか。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#compile-time-reparsing&#34; name=&#34;compile-time-reparsing&#34;&gt;コンパイル時 &#39;再パース&#39;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Compile-time ‘reparsing’&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/gordon-woodhull/&#34; target=&#34;_blank&#34;&gt;Gordon Woodhull&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/gordon_woodhull_reparsing_2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/gordon_woodhull_reparsing_2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++コンパイラは今コードをパースしているとする。さて、その一部を再度パースしたいとしたらどうだろう？&lt;/p&gt;
&lt;p&gt;数年前から、ドメイン固有特化言語のためのメタプログラミングライブラリ群が提案され、ユーザーや特殊なライブラリアンはC++内に独自の言語を構築できるようになった。このようなユーザーやライブラリアンは皆、実行時表現のEric Niebler氏によるBoost.Protoに精通する必要がある。しかし、Ábel Sinkovic氏による、コンパイル時文字列パースのためのMetaparseや、&amp;lt;&amp;gt;表記をパースするための、プレゼンターが作成した&#34;とんがった(原：Angly)&#34;パーサもある。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではこれら三つのライブラリを研究し、計算的に等価であることを(一方で、ドメインや表現力の違いについても)示す。コンピュータサイエンスの視点からは、これらライブラリは全てプッシュダウン・オートマトンである。ではなぜインターフェースがこうも違っているのだろう？対象ドメインの違いから生れるものなのか？それともライブラリ著者のバックグラウンドによるものなのか？&lt;/p&gt;
&lt;p&gt;また、コードをごらんいただきながら、これらのライブラリが実際にどのように動作するかごらんいただきたいと思う。このプレゼンテーションの大きな目的は、これらライブラリでどんなテクニックが一般的になっているか見ていくことと、共通のパターンがあるかどうか見ること、そして聴衆の皆様にメタプログラミングテクニックについて習熟していただくことである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#type-string-conversions&#34; name=&#34;type-string-conversions&#34;&gt;型から文字列への変換と、その逆&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Type to string conversions, and vice-versa&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jeroen-habraken/&#34; target=&#34;_blank&#34;&gt;Jeroen Habraken&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/convert_types_to_strings.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/convert_types_to_strings.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=WLYcyu6mlgg&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=WLYcyu6mlgg&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、型から文字列への変換、またその逆に変換する際の、さまざまな選択肢について研究していく。古くは&lt;code&gt;atoi&lt;/code&gt;や&lt;code&gt;strtol&lt;/code&gt;から、真新しくは&lt;code&gt;std::stoi&lt;/code&gt;や、&lt;code&gt;boost::lexical_cast&lt;/code&gt;のようなBoostで提供されているものまで見る。これら選択肢のエラーハンドリングやフォールバック機構、localeサポートといった観点からみた利点と欠点についても研究する。&lt;/p&gt;
&lt;p&gt;利点と欠点を見ていただいた後は、それら利点と欠点をもとにGoogle Summer of Codeで作成したboost::coerceについて、現在の選択肢をどう補間するか紹介したい。このライブラリは速度や拡張性の面で優れている。このプレゼンテーションでは設計について概説し、またどう達成したかについて、使用法の豊富な例とともに紹介する。&lt;/p&gt;
&lt;p&gt;時間が許すなら、カスタマイズポイントやSpiritとの関連を見ていきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34; name=&#34;cpp11-gems&#34;&gt;C++11にある珠玉の品々&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Other C++11 Gems&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jeff-garland/&#34; target=&#34;_blank&#34;&gt;Jeff Garland&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp11_allocators.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp11_allocators.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp_gems_garland_chrono_ratio.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp_gems_garland_chrono_ratio.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非常に重要だが、それ単品では1セッションに満たないようなトピックについてとりあげる。GarlandとHinnantは&lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;から。またstateful allocatorとregexへのサポートについてもとりあげる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#linear-programming-proto&#34; name=&#34;linear-programming-proto&#34;&gt;Boost Protoで線型計画法を簡単に&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linear programming made easy with Boost Proto&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/patrick-mihelich/&#34; target=&#34;_blank&#34;&gt;Patrick Mihelich&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/linear_programming_proto.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/linear_programming_proto.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;オペレーションリサーチや金融、チップデザインに渡る分野の問題は、線型計画にモデル化できる。決定問題のための高度に汎用的で効率的なアルゴリズムがあるメソッドとして、線型計画法は有効なツールである。&lt;/p&gt;
&lt;p&gt;GLPKのような、線型計画を解くための強力なソフトウェアライブラリが存在するが、低レヴェルAPIが非常に使いにくいので、問題を一旦人が読みづらい形式に変換する必要がある。AMPLのようなモデリング言語を使えば、問題を容易に叙述的に表現できるが、汎用プログラミング言語としての力量と親和性が足りない。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは線型計画法を表現し解くための、Boost.Protoを用いたDSELであるCVX++を紹介する。Protoはどちらの世界、すなわちC++に組み込まれた叙述的プログラミングスタイルとして最高の役割を果たしてくれる。CVX++はGLPKをバックエンドソルバとして備え、Protoを用いて目的関数と制約をより機械が読みとりやすい表現に変換する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#solidfire&#34; name=&#34;solidfire&#34;&gt;SolidFireではC++11への移行をいかにして成しとげたか&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How we switched to C++11 at SolidFire and how it worked out&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/travis-gockel/&#34; target=&#34;_blank&#34;&gt;Travis Gockel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=43ej-H8yHWE&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=43ej-H8yHWE&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、SolidFireのコードベースをC++03からC++11に移行する過程について、まず作業チームがワクワクするところから順に見ていく。正確性の検証やパフォーマンステストをどう行なったか、またそれとともに、C++03とC++11のどちらでも動作するコードをどう書いたらいいか紹介していくつもりだ(また、どうやって障害を迅速に乗り越えたかについても)。&lt;/p&gt;
&lt;p&gt;C++03/C++11開発で最初の月を越したころ、我々はよりよいコードを書くためにC++03コードベースのサポートを放棄した。このプレゼンテーションの第二部は、新しい標準によってもたらされる新しいコーディングスタイルについて述べる。また、それなしでは実装できなかったとんでもなくトリッキーなクラスや、可読性を上げるためにややトリッキーなことをしているクラスについても紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#refactoring-clang&#34; name=&#34;refactoring-clang&#34;&gt;ClangでC++のリファクタリング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Refactoring C++ with Clang&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/chandler-carruth/&#34; target=&#34;_blank&#34;&gt;Chandler Carruth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cxxnow2012_refactoring.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cxxnow2012_refactoring.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=yuIOGfcOH0k&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=yuIOGfcOH0k&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;十年来、C++開発者はJavaなどの言語が持っているツールをうらやましく思っていた。Clangでとうとう、我々は安全な自動変換を構築することができるほど簡便にC++コードの推論ができるようになる。このプレゼンテーションでは特殊なC++パターンの自動認識と変換をサポートする、Clang上に組まれた基盤について紹介する。また、古いAPIから新しい別のAPIへ更新するための、実際のソースコード変換ツールを実装するために必要な知識・技術についても示す。&lt;/p&gt;
&lt;p&gt;ライブラリの利用者が自身のコードを新しいAPIに置換するためのユーザー向けのスタンドアロンツールを組みあげることは、Boostのような広く利用されているライブラリでは非常に重要だが、C++11においては、新しい言語機能の利益を教授するために大量のインターフェースが更新されることになる。これらのインターフェースの採用を自動化することは、広く利用されているライブラリでは、長期にわたってサポートしなければならない非推奨APIの増加を抑える意味でも、急速な進歩をする上でも極めて重大なことである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#state-machine-coroutine&#34; name=&#34;state-machine-coroutine&#34;&gt;Boost.Coroutineを用いてステートマシンを解決する&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using Boost.Coroutine to untangle a state machine&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/nat-goodspeed/&#34; target=&#34;_blank&#34;&gt;Nat Goodspeed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/coroutine.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/coroutine.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションはイヴェント駆動型プログラムにおけるスタートアップのケーススタディである。このプログラムは外部サーバーへの一連のリクエストを生成し、それぞれ結果が返ってくるまで次のリクエストの生成を待機している。&lt;/p&gt;
&lt;p&gt;もともと、これはグローバルな&lt;code&gt;int&lt;/code&gt;状態変数を使って、巨大な&lt;code&gt;switch&lt;/code&gt;文として実装されていた。内在する関数はすべてのフレームで呼び出され、現在のステートロジックにジャンプし、結果を受けて状態を更新する。&lt;/p&gt;
&lt;p&gt;共同研究者がこれをBoost.Statechartを使って、ロジックをクラスのコレクションとして表現することで再実装した。&lt;/p&gt;
&lt;p&gt;どちらのケースでもロジックの構造は明確だった。実際の制御フローを解明するために、全てのコンポーネントの念入りな研究が必要だった。&lt;/p&gt;
&lt;p&gt;我々は同じロジックを、外部サーバーへのリクエストを結果が返ってくるまで待機する関数呼び出しとして表現するコルーチンとして再実装した。このような関数呼び出しはコルーチンだけを阻害する。すなわち、メインスタックの通常のフレーム毎の処理が継続する。実際のスタートアップ制御フローは、C++に精通していれば誰でも読める三重ループとして表現できる。さらに、メンテナンス(例えば、新しいリクエストを挿入するとか)は非常に容易である - これは前の実装ではとても言えなかったことであるが。&lt;/p&gt;
&lt;p&gt;このようなユースケースにおけるスレッドとコルーチンの対比を行う。&lt;/p&gt;
&lt;p&gt;coroutine オブジェクトの操作法について示す。&lt;/p&gt;
&lt;p&gt;Boost.Coroutineライブラリの微調整についても触れる。&lt;/p&gt;
&lt;p&gt;Boost.Contextがマージされたら、CoroutineをContextで再実装するつもりである。これこそまさにContextがサポートしようとしている種類のライブラリである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#metaprogramming-cpp11&#34; name=&#34;metaprogramming-cpp11&#34;&gt;C++11でのメタプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaprogramming in C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11で導入された新機能で、メタプログラマの世界は変化した。このプレゼンテーションでは、C++11メタプログラムをどう記述するかについての研究結果と、特にこの新しい言語にあわせたBoost.MPLの設計について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#numerical-problems-metaprogramming&#34; name=&#34;numerical-problems-metaprogramming&#34;&gt;メタプログラミングの数学的問題への適用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaprogramming Applied to Numerical Problems&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/karsten-ahnert/&#34; target=&#34;_blank&#34;&gt;Karsten Ahnert&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mario-mulansky/&#34; target=&#34;_blank&#34;&gt;Mario Mulansky&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/generic_stepper.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/generic_stepper.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ルンゲ=クッタ法と呼ばれるメソッドの高速かつ汎用的な実装をつくるために、現代的テンプレートメタプログラミングの手法をつかう。ルンゲ=クッタ法は常微分方程式(ODE: Ordinary Differential Equation)の初期値問題の近似解を探索する数値アルゴリズムである。常微分方程式を解くのは化学者、物理学者、生物学者にとっては日常のことである…&lt;/p&gt;
&lt;p&gt;今日、異なる一連のパラメータ値をとり、近似解の精度が違う、様々なルンゲ=クッタ法が存在する。そこで、これらのルンゲ=クッタ法を汎用的に実装し、テンプレートメタプログラミングを利用することで、非常に汎用的な実装であるにもかかわらず、非常に高いパフォーマンスを達成した。これは数値計算アルゴリズムの領域においてもテンプレートメタプログラミングの力を印象づける事例である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#tr2-boost&#34; name=&#34;tr2-boost&#34;&gt;TR2に向けたBoostライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boosting Libraries for TR2&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/boosting_libraries_for_standardization.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/boosting_libraries_for_standardization.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準委員会のLibrary Working Group(LWG)は新しいライブラリの技術報告、TR2に向けたライブラリ提案を待っている。開発者以外の方でも、BoostライブラリをTR2に提案できる。&lt;/p&gt;
&lt;p&gt;このセッションはまず、TR2にBoost ライブラリをうまく提案し、委員会を通して提案を導いていく方法についてのチュートリアルから入る。話す予定のトピックは以下の通り：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;どうしてわざわざこんなことを - 経験から得られるもの&lt;/li&gt;
&lt;li&gt;標準化プロセスの概略&lt;/li&gt;
&lt;li&gt;提案募集&lt;/li&gt;
&lt;li&gt;委員会ウェブサイトの案内&lt;/li&gt;
&lt;li&gt;システム - 提案はどのようなものか、 いつどこで提出するのか&lt;/li&gt;
&lt;li&gt;初期の提案 - 何を詳細に見て、何を詳細に見るべきではないかについて - 演習つき&lt;/li&gt;
&lt;li&gt;提案の用語と標準の記述&lt;/li&gt;
&lt;li&gt;ドラフトとレヴューを手伝ってもらう&lt;/li&gt;
&lt;li&gt;提案提出 - のるかそるか&lt;/li&gt;
&lt;li&gt;委員会からのフィードバックへの対応&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;セッションの後ろ半分はTR2にむけて実際にBoostライブラリの提案を一緒にやるワークショップを開く。まず提案のテンプレートの空欄を埋めていくところから始める。このワークショップにはLWGメンバが何人かいらっしゃるので、彼らに助言をもらったり、意見を聞いたりするといいだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#how-i-code-and-why&#34; name=&#34;how-i-code-and-why&#34;&gt;どうしてそう書くの？なんで？&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How I Code and Why&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/how_i_code_and_why.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/how_i_code_and_why.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost委員会の方々(まだ未定。だが以前のBoostConで参加していただける旨をうかがった方の暫定リストはある)に、日々のコーディングで従っている原則について、なぜこの原則を適用していうのか、どのあたりに価値があると思っているかについて説明していただこうと思う。&lt;/p&gt;
&lt;p&gt;(例えば、私は、なぜ自分の好きなコミットワードが&#39;otherwise&#39;なのか、以前聞いたり読んだりされているかもしれないが、これに関連するどのようなアドヴァイスがあるか、この天啓に至った事件は何かを説明するつもりだ)
このプレゼンテーションの目的は、現実世界の話を時として書籍や講義で語られる高尚な理念に引き上げることである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#preparation-cppnow-2013&#34; name=&#34;preparation-cppnow-2013&#34;&gt;C++Now! 2013に向けた準備&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preparation of C++ Now! 2013&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来年の会合の準備委員会は早期に動きだす。提案があったり、支援していただける方はぜひご参加いただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;winrt&#34;&gt;WinRTにむけたC++コンポーネント拡張&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Component Extensions for WinRT&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/ale-contenti/&#34; target=&#34;_blank&#34;&gt;Ale Contenti&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/cpp_component_extensions_for_winrt_upload_version.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/cpp_component_extensions_for_winrt_upload_version.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は他のプログラミング言語やテクノロジー(例えば、 iOSのObjective-C、AndroidのJava、Windowsの.NETなど)を適用するプラットフォームにおいても活用されている。異種プログラミングプロジェクトがもたらす課題の一つに、C++の外部オブジェクトモデルとの結合という要求がある。CORBAやCOMといった既存の方法は一定の成功を収めているが、開発者は複雑性の増大というツケを払う羽目になる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、この問題に対処するために、Microsoftが取った二つのアプローチの詳細について述べる。最初のアプローチは、同じアプリケーションの中に、C++と非C++コンポーネント(外部オブジェクトモデル)が 混在するという複雑性に対処するためにC++抽象化レイヤを採用するというものである。この抽象化レイヤ(例えば Boostユーザーや開発者の方々にはおなじみの今日的C++テクニックをがっつり使ったWRLライブラリとか)はCOMコンポーネントの実装を単純化したが、このソリューションにある一般概念は他のいかなる異種混在環境においても拡張可能である。二つ目のアプローチは、異種言語で記述されたピア(訳註： 同格のコンポーネント)とやりとりするコンポーネントの宣言と定義ができるように、その構文にいくつかの拡張を追加して、C++自身の境界を押し上げることである。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではこれら二つのアプローチについて、長所と短所、利点と注意事項についてそれぞれ説明していく。最後に、これらの設計が、C++の進化にとって潜在的にどのような影響を与えるかについてお話しする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#value-semantics&#34; name=&#34;value-semantics&#34;&gt;値のセマンティクスとConceptベースの多態&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Value Semantics and Concepts-based Polymorphism&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sean-parent/&#34; target=&#34;_blank&#34;&gt;Sean Parent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/fri/value_semantics/value_semantics.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/fri/value_semantics/value_semantics.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プレゼンターであるSeanは先のキーノートの &lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#now-what&#34;&gt;&#34;Now What? A vignette in 3 parts.&#34;&lt;/a&gt; で話した値のセマンティクスとConceptベースの多態コンセプトについて、更に深めていくつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2012.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Boostの将来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Future of Boost&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostとC++Now!の発起人であるお三方が将来について語り、どう考えているのかお答えする。&lt;/p&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi、zak、DigitalGhost&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2013 -- C++ Now のリンクを修正</title>
      <link href="https://boostjp.github.io/cppnow/2013.html"/>
      <id>b1f0565297261a631dd64647d980ac086ff40284:cppnow/2013.md</id>
      <updated>2017-06-12T04:51:27+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2013&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2013&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2013&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#doe&#34;&gt;キーノート： DOEによるC++の高性能コンピューティング - 過去と未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#survey-of-mt&#34;&gt;C++11とBoostにおけるマルチスレッドプログラミングサポートの概説&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#qt-eventloop&#34;&gt;Qtのイベントループ、ネットワーク、入出力API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#container-boost&#34;&gt;Boostのコンテナ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#low-level-threading&#34;&gt;C++11での低レベルスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#zephyr-cpp11&#34;&gt;&#39;優しきそよ風&#39;の見たC++11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#proto-0x&#34;&gt;Proto-0x初お披露目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#nonalloc-future&#34;&gt;アロケートしない&lt;code&gt;std::future&lt;/code&gt;／&lt;code&gt;promise&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#debug-tmp&#34;&gt;C++テンプレートメタプログラムのデバッグとプロファイリング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#optimize-structure&#34;&gt;キーノート： C++の創発的構造を最適化する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#small-stuff&#34;&gt;おいしい小さな機能たち： 波カッコ初期化、共用体、列挙型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#agda&#34;&gt;Agdaへの知識向上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#hpx&#34;&gt;HPX: 非同期並列と分散コンピューティングのためのC++標準準拠ランタイムシステム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#scaling-cpp11&#34;&gt;C++11でスケールさせる！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#charm&#34;&gt;Charm++を使った並列プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#easy-binary-compatible&#34;&gt;C++の複数コンパイラ間バイナリ互換インタフェースを簡単に作る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#transactional-memory&#34;&gt;C++でのトランザクショナルメモリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#libcppa&#34;&gt;libcppa - C++11でのアクターセマンティックな設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#binary-compatibility&#34;&gt;ライブラリ開発者が知るべきバイナリ互換性について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#yet-another-paradigm-shift&#34;&gt;さらなるパラダイムシフト? (並行のMeta4モデル)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#spirit-x3&#34;&gt;Inside Spirit X3: C++11で再設計されたBoost.Spirit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#weak-hiding&#34;&gt;C++コンセプトのための弱い隠蔽: プログラミング言語の名前バインディングについて推論するフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#cpp11-qt5&#34;&gt;Qt5でC++11を使う： 課題と解法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#thread-safe-bag&#34;&gt;スレッドセーフでスレッド中立なbag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#practical-cpp11-odb&#34;&gt;実践C++11：ODBへのC++11サポート追加で学んだこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#bloomberg&#34;&gt;応用階層的再利用: Bloomberg基盤ライブラリの利用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#boost-dispatch&#34;&gt;Boost.Dispatch - 汎用タグディスパッチ基盤ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#vienna&#34;&gt;計算科学向けViennaライブラリについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#alignment&#34;&gt;C++のアラインメント: 利用法、制限、および拡張法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#community-dev&#34;&gt;C++ コミュニティの発展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#dynamic&#34;&gt;動的なC++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#debruijn&#34;&gt;DeBruijn Bind: シンプルさを維持するより強力なbind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#multi-threading&#34;&gt;C++11とBoostを利用したマルチスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#concept-lite&#34;&gt;軽量コンセプト: 述語による制約テンプレート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#html5&#34;&gt;ママ見て “C++を使ってデータベース更新からHTML5が生成されたよ”, 自動化して!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#odb&#34;&gt;C++(11)のためのORマッパー：ODB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#fusion&#34;&gt;Fusionで世界の謎を解く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#dds&#34;&gt;モダンなC++向けのデータ分散サーヴィス(DDS: Data Distribution Service)の標準化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#member-access-operator&#34;&gt;メンバーアクセス演算子のオーヴァーロード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#cern&#34;&gt;CERNでの対話的で内省的なC++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#haskell&#34;&gt;Haskellの力でMPLを強化しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#object-transmission&#34;&gt;Boost.AsioとBoost.Serialization: オブジェクト受け渡しのデザインパターン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#cppnow-2014&#34;&gt;C++Now 2014の準備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#hetero&#34;&gt;静的型付け言語における、動的で再帰的なヘテロ型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#projucer&#34;&gt;Projucer: C++とLLVM JIT エンジンを利用したライブコーディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#matrix&#34;&gt;EigenとBoost Protoライブラリを用いた有限要素マトリックス式の組み立て&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#deadlock-prevention&#34;&gt;侵入的動的解析を使用したリソースデッドロック防止システム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#future-of-boost&#34;&gt;Boostの未来&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#doe&#34; name=&#34;doe&#34;&gt;キーノート： DOEによるC++の高性能コンピューティング - 過去と未来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: C++ Use in High Performance Computing Within DOE: Past and Future&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/daniel-quinlan/&#34; target=&#34;_blank&#34;&gt;Daniel Quinlan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=zZGYfM1iM7c&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=zZGYfM1iM7c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#survey-of-mt&#34; name=&#34;survey-of-mt&#34;&gt;C++11とBoostにおけるマルチスレッドプログラミングサポートの概説&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Survey of Multi-Threaded Programming Support in C++11 and Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/rob-stewart/&#34; target=&#34;_blank&#34;&gt;Rob Stewart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルではBoostとC++11によるマルチスレッドプログラミング向けのツールについて概説します。&lt;/p&gt;
&lt;p&gt;このセッションの内容に取り入れる事が明らかな項目としては、例えば &lt;code&gt;std::thread&lt;/code&gt; や &lt;code&gt;boost::thread&lt;/code&gt; 、またより先進的な機能、 例えば &lt;code&gt;std::async&lt;/code&gt; 、それに、これらを実現する為のより基本的な部品として、例えばミューテックス(&lt;code&gt;std::mutex&lt;/code&gt;)、条件変数(&lt;code&gt;std::condition_variable&lt;/code&gt;)、アトミック(&lt;code&gt;std::atomic&lt;/code&gt;) などが挙げられる。&lt;/p&gt;
&lt;p&gt;つまるところこのセッションでは全体として、BoostやC++11が如何に皆さんのマルチスレッドプログラムのコーディングを助けてくれるのかについて概説します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#qt-eventloop&#34; name=&#34;qt-eventloop&#34;&gt;Qtのイベントループ、ネットワーク、入出力 API&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Qt event loop, networking and I/O API&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Qtフレームワークが誕生したのは1990年台始めの頃の事、その時Qtはまだ、単純な目的の為だけに開発されたんだ。そう、グラフィカルプリケーションを作る為のクロスプラットフォームなAPI（それもその当時はせいぜいデスクトップとワークステーション程度を対象にね）としてね。それからQtはその目標を遥かに超えてよく成長してくれました。今日ではGUIツールキットの枠を超えて他の多くのサブシステム群、データベース接続、WEB技術との統合、そしてパワフルな非同期I/Oとネットワーク周りの機能等々を提供するに至っている。このセッションではそれらの中から、QtのI/Oとネットワーク周りについてチュートリアル形式で紹介します。&lt;/p&gt;
&lt;p&gt;Qtの全ての非同期的なメカニズム群はイベントループないしメインループによるセントラルイベントハンドリングのループから呼び出されています。そうしてQtが提供する非同期I/Oによる子プロセスの動作や、TCP接続群のアクセプト、TCP接続群の発信の生成、TCPとUDPのI/Oハンドリング、その他のタスク群が構築されています。もちろんそれはHTTPとFTPのダウンロードとアップロードと言った高レベルなイベントにも至ります。このセッションではそれら全てのサブシステム群についてを取り上げ、どうやってアプリケーションにそれらを組み込んで使うのかについて、例示をしたり、それに一緒に議論をしたいと考えています。このセッションを通じてライブラリー開発者とアプリケーション開発者、双方の理解をQtを通して深める機会として頂ければ幸いです。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#container-boost&#34; name=&#34;container-boost&#34;&gt;Boostのコンテナ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Containers in Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-schaeling/&#34; target=&#34;_blank&#34;&gt;Boris Schäling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostライブラリは、多くの便利なコンテナと、標準コンテナの素敵な拡張を提供している。このセッションでは、Boostにある以下のコンテナ群を見ていく： Boost.Multiindex、Boost.Bimap、Boost.CircularBuffer、Boost.PropertyTree、Boost.DynamicBitset、Boost.PointerContainer、Boost.Intrusive。開発者は、自分のプロジェクトに恩恵をもたらすコンテナを選択できるようになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#low-level-threading&#34; name=&#34;low-level-threading&#34;&gt;C++11での低レベルスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Low Level Threading with C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は現在、「メモリモデル」を持っている。それは何を意味するのか、それはなぜあるのか、それが必要ならなぜこれまでなかったのか？これがあると我々は何ができるのか？これは新しく入ったアトミック操作と多少関連があるようだ。うーん・・・。&lt;/p&gt;
&lt;p&gt;(これは昨年やったチュートリアル「C++11の新たなメモリモデルとアトミック」のアップデートである。)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#zephyr-cpp11&#34; name=&#34;zephyr-cpp11&#34;&gt;&#39;優しきそよ風&#39;の見たC++11&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Zephyr Overview of C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/leor-zolman/&#34; target=&#34;_blank&#34;&gt;Leor Zolman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;去年の事、私はC++11の殆どの機能について、たった90分だけの&#34;嵐の様な&#34;セッションで質問に答える間も無く、その可能性について示すに留まった。&lt;/p&gt;
&lt;p&gt;そして今年、私は1本90分のセッション枠を拡大して、2本分のセッションを使える事になった。参加してくれるみんな（それに私自身も含めて）、今回はきちんと息をする余裕もあるよ。だから今回は質問に答えたり、それにひょっとしたらライブコーディングをできるチャンスもあるかもしれないね。&lt;/p&gt;
&lt;p&gt;内容については凡そ去年のそれと同じにするつもりだけど、去年は時間が無くて扱えなかった言語とライブラリーの機能、それと実装例なんかも用意したいね。&lt;/p&gt;
&lt;p&gt;(訳者註: Zephyr(ゼファー)はギリシア神話の風の神様の中で最も温和で春の訪れを告げる豊穣の優しいそよ風の神様のこと。)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#proto-0x&#34; name=&#34;proto-0x&#34;&gt;Proto-0x初お披露目&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A First Look at Proto-0x&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/eric-niebler/&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Protoは、C++に組み込みドメイン特化言語(EDSL)を構築するためのライブラリである。Boostでは、Spirit、Phoenix、Xpressive、MSM、それと提案中ではあるがBoost.SIMDのようなライブラリが、Protoによる式テンプレートベースで構築されている。Protoで定義されたEDSLは、手間のかかるテンプレートメタプログラミングの雑用からライブラリ作者を解放し、構文やセマンティックアクションといった面で、高レベルに表現できる。&lt;/p&gt;
&lt;p&gt;Boost.Protoの現在利用可能なバージョンは、C++03言語の限界を押し上げてはいるが、言語によって課せられる制約で苦しんでいる。このトークでは、C++11で再設計されたProtoの新バージョンについて話す。これは、EDSLの設計を、これまで以上に簡単かつ安全にできる。&lt;/p&gt;
&lt;p&gt;このトークでは、Proto-0xによる小さなEDSL定義の基本をカバーする。新しいProtoは、古いProtoと異なるポイントはあるが、その事前知識は必要ない。C++11の新機能がProtoの設計にどのような影響をもたらしたか、また、それらの機能が一般的なライブラリ設計を、根本的なところでより良くすることを紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#nonalloc-future&#34; name=&#34;nonalloc-future&#34;&gt;アロケートしないstd::future／promise&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Non-Allocating &lt;code&gt;std::future&lt;/code&gt;/&lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共有状態 - mutex/convarが待ち合わせるように別スレッドの処理の結果を置く場所 - は、&lt;code&gt;future&lt;/code&gt;と&lt;code&gt;promise&lt;/code&gt;はいつでもムーヴ、破棄され得るので、&lt;code&gt;future&lt;/code&gt;と&lt;code&gt;promise&lt;/code&gt;で別々にアロケートされる必要があると予想される。故に共有状態には別個のメモリ配置が必要である。&lt;/p&gt;
&lt;p&gt;本当にそうだろうか？&lt;/p&gt;
&lt;p&gt;このセッションでは、等式の右辺、左辺ともにムーヴ中もしくは破棄されようとしていても、アロケートなしで状態を共有するために細心の注意を払ってロックフリーの技術を用いる&lt;code&gt;std::future&lt;/code&gt;／&lt;code&gt;promise&lt;/code&gt;の草案について説明する。&lt;/p&gt;
&lt;p&gt;このセッションは非常にインタラクティヴなものになるだろう。聴者諸氏は実装に漏れがなくなるまで、実装のどのステップについても問題点を指摘していただきたい。このセッションでは、ロックフリーテクニックを現実のコードにどう適用したらいいか、感覚がつかめるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#debug-tmp&#34; name=&#34;debug-tmp&#34;&gt;C++テンプレートメタプログラムのデバッグとプロファイリング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Debugging and Profiling C++ Template Metaprograms&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/zoltan-porkolab/&#34; target=&#34;_blank&#34;&gt;Zoltan Porkolab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++テンプレートメタプログラミングは、テンプレートの巧妙な定義によって、C++コンパイラにコンパイル時にアルゴリズムを実行させる、よく知られた手法である。アプリケーションにおけるテンプレートメタプログラムには、式テンプレート、静的なインタフェースチェック、アダプトによるコード最適化、組み込みドメイン特化言語とアクティブライブラリなどがある。C++11の新機能は、テンプレートメタプログラミングをさらに魅力的にする。&lt;/p&gt;
&lt;p&gt;その重要性にもかかわらず、C++テンプレートメタプログラミングの設計、保守、分析を支援するためのツールは、驚くほど少ない。テンプレートの重いコードを使用することでプログラムに増加されるコンパイル時間は、その分野への挑戦が少なくなっている理由のひとつである。利用できるデバッガ、プロファイラといったツールの欠如は、テンプレートメタプログラミングの広い使用を妨げている。&lt;/p&gt;
&lt;p&gt;我々は、これまでの経験に基づいて、テンプレートメタプログラムのデバッガとプロファイラのプロトタイプツールセットを開発している。このツールセットの目的は、C++テンプレートの使用率が高い、大きなコードベースで作業している、開発者やメンテナのためのサポートを提供することだ。このツールセットは、C++テンプレートメタプログラムのバグやコンパイルボトルネックを調査するという、おもしろいことができる。&lt;/p&gt;
&lt;p&gt;このツールセットは、LLVM/ClangオープンソースC++コンパイラインフラストラクチャ上に構築されている。テンプレートに関連するコンパイラアクションの最も重要なキャプチャは、プログラムの「インスタンス化スタック」を記録し、XML形式のトレースファイルを出力する。このファイル内の全てのエントリは、テンプレートインスタンス化の最初か最後を表す。エントリには、Clang仕様のイベントの型が含まれる。さらにくわしい情報は、テンプレートの名前へのインスタンス化、およびインスタンス化によるコードの位置(通常は、呼び出し元)である。プロファイルに関連する情報は、インスタンス化の時間(これは実行時間:wall time)と実際のメモリ使用量が含まれるタイムスタンプである。時間とリソース消費のメモリプロファイリングは、オフにすることができる。プロファイリングの歪み(distortion)を最小限に抑えるには、XMLトレースファイルの内部バッファと生成の遅延を行う。我々の計測では、時間の歪みは3%未満だった。&lt;/p&gt;
&lt;p&gt;また、我々はトレースファイルに格納されている結果を資格する、Qtベースのフロントエンドも開発した。このフロントエンドは、実行時デバッガと同様、ユーザーがブレークポイントを設定でき、ステップバイステップでインスタンス化を再生できる、ソースコードビューを持っている。興味のないインスタンス化は、正規表現を使用して可視化から除外できる。他のビューとしては、インスタンス化にかかる時間と、オプショナルなメモリ使用量のプロファイル情報がある。最後に、インスタンス化の依存関係を表現し、インスタンス化手順のアニメーション化とグラフ化を行う。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#optimize-structure&#34; name=&#34;optimize-structure&#34;&gt;キーノート： C++の創発的構造を最適化する&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Optimizing the Emergent Structures of C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/chandler-carruth/&#34; target=&#34;_blank&#34;&gt;Chandler Carruth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=eR34r7HOU14&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=eR34r7HOU14&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日、C++ソフトウェアの複雑さはいや増している。この複雑さを管理し、大規模アプリケーションやシステムを構築するべく、C++は、シンプルなパターンを組み合わせて非常に複雑かつ強力なシステムをつくりだす創発的構造(自然界ではよく見られる、雪の結晶のような対象構造)をつくりだすべく努力している。このような構造により、各コンポーネントの複雑性を制限し、ソフトウェア開発する上で信頼できるスケーラビリティが得られる。&lt;/p&gt;
&lt;p&gt;手持ちのディヴァイスからウェアハウス級データセンターまで、よりディヴァイスを小さくしようとしたりと電力消費を抑えようとして、C++を利用すると、効率と複雑さが相応しないシステムになってしまうことは疑いない。今日も最適化がすすむC++コンパイラはかつてないほどその重要性が高まっているが、現役プログラマにはほとんどそれが伝わっていない。これらのことを鑑みると、高度創発的構造はC++システムを拡大し、しばしば最適化に関する独創的で未解決の問題を提起することがある。&lt;/p&gt;
&lt;p&gt;このセッションでは、今日の最適化されたコンパイラがC++コードをいかに高度にコンパイルするか、という概観から始める。次に、C++コードの創発的構造を単純かつエレガントに形成する鍵となる特殊な構造とパターンについて概説する。さらに、このような相互作用をいかに効率的にモデル化し解析できるかについて、効率的な完成プログラムを作るためのコンパイラを使って検証する。実際のケーススタディを例としてとりあげ、最新のC++コードベースで表現され、広く適用可能であることを示す。これらのパターンによる意味に気付いていただくために、最適化されたコンパイラとC++コード双方の相互作用を理解するためのフレームワークを示すことが目的である。最後に、特にそれぞれのコンポーネントが単純さを保持し、組み合わせによって力を発揮する、今日の最適化向けの方法を示すため、C++プログラムやライブラリの設計上、実装上の技術および原理について示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#small-stuff&#34; name=&#34;small-stuff&#34;&gt;おいしい小さな機能たち： 波カッコ初期化、共用体、列挙型&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sweating the Small Stuff: Brace Initialization, Unions and Enums&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11は多くの派手な新機能がある： ラムダ式、ムーブコンストラクタみたいな。このようなカッコイイ機能に比べてセクシーさでは劣るが、便利な変更がいくつか入った。このトークでは、初心者から中級レベルの専門家に向けて、C++11の波カッコ初期化(一様初期化とも呼ばれる)、共用体、列挙型について話す。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;agda&#34;&gt;Agdaへの知識向上&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Intellectual Ascent to Agda&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/david-sankel/&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数学とコンピュータサイエンスについて考えていると、漸近解析と物理シミュレーションのビックリするようなアルゴリズムが思いつくことがある。これらはいつも見過ごされがちな表示的意味論であり、構文と意味論の数学である。&lt;/p&gt;
&lt;p&gt;表示的設計(denotative design)、表示的意味論の実践は、シンプルで、合成可能で、信じられないほどパワフルなライブラリを作るトップダウン設計の方法論である。これは全く異なる文化のものだが、一般的に使用できる。そのパワフルなテンプレートエンジンは、C++に特に適している。&lt;/p&gt;
&lt;p&gt;このセッションでは、純粋関数型で依存型言語であるAgdaの構文を使用して、ドメイン固有の数学的エンティティからC++プログラムに派生させる表示的設計を、以下にして適用するかを学ぶ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#hpx&#34; name=&#34;hpx&#34;&gt;HPX: 非同期並列と分散コンピューティングのためのC++標準準拠ランタイムシステム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HPX: A C++ Standards Compliant Runtime System For Asynchronous Parallel And Distributed Computing&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/hartmut-kaiser/&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/vinay-amatya/&#34; target=&#34;_blank&#34;&gt;Vinay Amatya&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マルチコアとマルチスレッディングは、新しい計算手法であり、科学分野か非科学分野かに関わらず、システムの継続的なスケーラビリティを得るためには、ノード内だけでなくノード間もスケールさせる必要がある。新しいアーキテクチャにおける計算量やサイズ増加といったものは、スタベーション、レイテンシー、オーバーヘッド、競合解決待ちと呼ばれ、これらはシングルコアマシンでも存在はしていたが、表面化しにくかった。Exaflopレベルにシステムを拡張すると、この大幅に少ないリソース使用率の面でコストが増加する。その間、スケーリングシステムであっても、特定クラスのアプリケーションは従来の計算モデルを使用してスケールすることはできない。&lt;/p&gt;
&lt;p&gt;HPXは、新たな計算モデルに対する新たなランタイムシステムである(ParalleXは、上述した問題への挑戦である)。HPXはC++で実装され、最新のC++標準とBoostに準拠している。HPXは、新たな計算モデルに対する新たなランタイムシステムである(ParalleXは、上述した問題への挑戦である)。HPXは、様々な実績あるソフトウェア技術とアルゴリズムを、理解しやすくすることができます。HPX APIは、マルチコア・マルチスレッド化された混在アークテキチャとユーザーレベルソフトウェアアプリケーションのシームレスな統合のためのインタフェースを提供し、学ぶのを容易にする。&lt;/p&gt;
&lt;p&gt;非同期と計算、通信、それらを組み合わせることは、新たなマルチコア混在アーキテクチャをサポートする、新たな計算モデル要件のひとつとして重要である。非同期タスク(アクションという形式でのローカル関数やリモート関数)は、HPXの主要設計機能のひとつである。HPXは最新のC++標準がサポートしているローカル非同期関数だけでなく、リモート非同期関数も実装している：Actionという。これに加えて、非同期をサポートするのに本質的な、タスク実行中にFutureやDataFlowとしてデータを構築することができる。&lt;/p&gt;
&lt;p&gt;マルチコアドメインはシステムアーキテクチャ分野での巨大な飛躍にも関わらず、数十コアを超えたスケーラビリティ制限の課題がある。したがって、高パフォーマンスシステムでは、我々は複数ノードのBeowulfタイプのクラスターに依存している。通信の待ち時間が大幅に増加するようなシステムでは、非同期が大きな役割を果たしている。これに加えて、コアを数万を超えて拡張すると、新たなアドレッシングシステムが必要となり、アクティブアプリケーションのリモートスレッドオブジェクトを一時的に停止するのを許可するだけでなく、リソースの必要性(システム的な失敗やビジー状態)に従ってタスクを移動する必要がある。このアクティブなアドレッシングスキームは、HPXではActive Global Address Space(AGAS)として実装されている。このアドレッシングスキームは、HPXを、アプリケーションの必要性に応じた正しいリソース配置のためのリソースマネージャーをサポートすることを可能にする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#scaling-cpp11&#34; name=&#34;scaling-cpp11&#34;&gt;C++11でスケールさせる！&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scaling with C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/edouard-alligand/&#34; target=&#34;_blank&#34;&gt;Edouard Alligand&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プロセッサのコア数が増加するにつれて、ソフトウェアはムーアの法則からの恩恵を受けるために、複数のタスクを実行できるようにする必要がでてきます。これは並列アルゴリズムを書くという問題だけではなく、スレッド間の依存関係を正しく減らす、アプリケーション設計の問題でもあります。これらの依存関係を見つけることは、シリアルプログラミングの数十年の結果から見ても、非常に難しいことです。したがって、真にスケーラブルなソフトウェアを書くことは、精神状態を適切に適応させることよりも小さな、技術的な専門知識の問題です。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、超スケーラブルなデータベースである「quasardb」を書いたチームによって使用されている、設計、手法、ツールについて話します。具体的なスケーラビリティの課題として、典型的なマルチスレッドプログラミングのアンチパターンと、それを避ける方法を紹介します。説明するトピックは、以下のものをカバーします：アトミック、マイクロロック、Lock-freeとwait-freeなコンテナ、メモリ管理戦略(copy on write、スマートポインタ、完全転送)、スレッドローカル記憶域、非同期I/I、その他いろいろ！&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、システムプログラミングとC++11(ラムダと右辺値参照)の十分な知識を想定しています。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#charm&#34; name=&#34;charm&#34;&gt;Charm++を使った並列プログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Programming using Charm++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/phil-miller/&#34; target=&#34;_blank&#34;&gt;Phil Miller&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/axmikant-kale/&#34; target=&#34;_blank&#34;&gt;Laxmikant Kale&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/ramprasad-venkataraman/&#34; target=&#34;_blank&#34;&gt;Ramprasad Venkataraman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Charm++は、20年の実績があり、シングルワークステーションから世界最大のスーパーコンピュータまでカヴァーするハイパフォーマンスなC++ベースの並列プログラミングフレームワークである。このフレームワークは共有メモリシステムと分散メモリシステムを、双方のシステムで共通な技術で横断できる並列実行機能を備える。&lt;/p&gt;
&lt;p&gt;並列の単位としてオブジェクトを利用することで、Charm++は、関連するオブジェクトのコレクションによる並列アプリケーションロジックが表現できる。これにより、現存するハードウェアを十分効率的に利用する、結合可能な並列ソフトウェアが作成できる。実行中、Charm++のランタイムシステムはアプリケーションの挙動とシステムの状態を観測し、その結果に応じて、オブジェクトとプロセッサのマッピングを行なう。そうすることで、ランタイムシステムは効率よくロードバランスやエネルギー管理といったドメインに依存しない要求を自動化できる。それゆえ、アプリケーション開発者は、アプリケーションやユーザーからのそういった要求に取り組むことから解放される。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではCharm++での並列アプリケーション開発の原理について示す。このパラダイムを使った並列アルゴリズムを記述する利点についても述べる。高速でスケーラブルなソフトウェアを作成するためにCharm++をどのように使うかという例もいくつか紹介する。Charm++を使って、自身の並列プログラムを構築するための並列ロジックをどう組みあげるかについて学習する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#easy-binary-compatible&#34; name=&#34;easy-binary-compatible&#34;&gt;C++の複数コンパイラ間バイナリ互換インタフェースを簡単に作る&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Easy Binary Compatible C++ Interfaces Across Compilers&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/johnbandela/&#34; target=&#34;_blank&#34;&gt;John Bandela&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は他の生産性が高い言語から、使うのが難しいと認識されています。その理由のひとつに、バイナリコンポーネントの互換運用性の欠如があります。ライブラリを使用するとそのうち、ソースから構築したり、複数のバイナリを配布したりする必要が出てきます。たとえばWindowsでは、GCC Mingw、Visual C++ 2010(のリリース、デバッグ、静的と動的のCRT)、Visual C++ 2012などのバイナリを配布する必要があります。この問題を回避するための試みがいくつかある。たとえば、選択肢のひとつとしてextern Cを拡張してCOMやXPCOM、C++/CXといったものを追加することが考えられるが、このオプションにはコンパイラの拡張機能を必要とするとともに、現代のC++では低レベルであるように感じる。&lt;/p&gt;
&lt;p&gt;C++11を実装している多くのコンパイラは、ラムダ式や可変引数テンプレートといった便利な機能を持っており、これらを使用して簡単に複数のコンパイラ間で動作するバイナリインタフェースを実装できます。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、以下の恩恵を受けるための、ライブラリの設計と実装について議論します：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部ツールを必要としない&lt;/li&gt;
&lt;li&gt;インタフェースを一度だけ定義し、その定義を実装とユーザーコードで使用する&lt;/li&gt;
&lt;li&gt;インタフェースは、簡単に実装でき、一度だけ定義すればよい&lt;/li&gt;
&lt;li&gt;そのインタフェースで&lt;code&gt;std::string&lt;/code&gt;、&lt;code&gt;std::vector&lt;/code&gt;、&lt;code&gt;std::pair&lt;/code&gt;を使用する&lt;/li&gt;
&lt;li&gt;現実的な戻り値で使用する(エラーコードではない)&lt;/li&gt;
&lt;li&gt;例外を使用する実装と使い方&lt;/li&gt;
&lt;li&gt;COMとバイナリ互換性を持つ&lt;/li&gt;
&lt;li&gt;インタフェースの継承をサポートする&lt;/li&gt;
&lt;li&gt;実装の継承をサポートする&lt;/li&gt;
&lt;li&gt;実装は、WindowsのVisual C++の実行ファイルとGCCの.dllでテストした&lt;/li&gt;
&lt;li&gt;実装は、LinuxのGCCの実行ファイルと、Clangの.soでテストした&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、上記の機能の実装について議論し、そのいくつかのトレードオフを見ていきます。私は、参加者との、異なるアプローチでこれよりうまく作る方法について議論するのを待ちわびている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#transactional-memory&#34; name=&#34;transactional-memory&#34;&gt;C++でのトランザクショナルメモリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Transactional Memory in C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準のSG5は、2種類のトランザクションに基いて&lt;a href=&#34;https://sites.google.com/site/tmforcplusplus/&#34; target=&#34;_blank&#34;&gt;V1.1 of the Draft Transactional Memory for C++&lt;/a&gt;を4年間取り組んでいる。&lt;/p&gt;
&lt;p&gt;この提案は、2種類のトランザクションをサポートする：&lt;/p&gt;
&lt;p&gt;分離トランザクション(isolated transaction)はいくつかの種類の安全性アノテーションを通じて、非トランザクションコード(と同様のトランザクション)と通常のトランザクションを通信できる。&lt;/p&gt;
&lt;p&gt;我々はさらに、完全なコンパイル時チェックから動的チャックまで、様々なレベルの安全性アノテーションをサポートするための異なる手法を示し、プログラマの負担を軽減させる。&lt;/p&gt;
&lt;p&gt;これがSG5の技術仕様としてのBrisol 2013の提案意図である。&lt;/p&gt;
&lt;p&gt;現在あるいくつかのTMは、時期尚早だと考えているが、ハードウェアサポートが間もなく来るだろう、ということを言わせてほしい。Intelは最近Haswellを発表したし、IBMのBG/Q、それ以前にはSunのRockもある。ソフトウェアTMサポートとしては、IntelはSTMのDraft 1.0をかなり前からサポートしているし、直近ではGCC 4.7がほぼ完全なDraft 1.1をサポートしている。&lt;/p&gt;
&lt;p&gt;それでもまだ早すぎると思う場合は、Hans Boehmの発見のひとつが、ロックはジェネリックプログラミングでは実用的ではない、ということだったと言わせてほしい。なぜなら、ロックの順序は一般的にインスタンス化されるまで見えないからだ。C++11で導入されたロック(とアトミック)では、この問題を回避するのが困難だ。トランザクショナルメモリは、この問題を解決するひとつの方法である。それは不規則なデータ構造や、読み取りを主に行うデータ構造(read-mostly structure)に対して細粒度ロックするのにも役立つ。&lt;/p&gt;
&lt;p&gt;このトークでは、我々は使用経験やパフォーマンスデータを含む、標準C++への提案を紹介する。&lt;/p&gt;
&lt;p&gt;トランザクショナルメモリが十分に速いことに、まだ疑問を持っている？多くのソフトウェアトランザクショナルメモリシステムは異なるパフォーマンス特性を持っているので、どれかはあなたのニーズを満たすと思う。&lt;/p&gt;
&lt;p&gt;TMは様々な形(ハードウェア、ソフトウェア、ハイブリッドシステム、ロック省略)で到来している。すでに多くの言語がTMをサポートしているので、C++にこれを提案するのはいい時期だろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#libcppa&#34; name=&#34;libcppa&#34;&gt;libcppa - C++11でのアクターセマンティックな設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;libcppa - Designing an Actor Semantic for C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/dominik-charousset/&#34; target=&#34;_blank&#34;&gt;Dominik Charousset&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/matthias-vallentin/&#34; target=&#34;_blank&#34;&gt;Matthias Vallentin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;並列ハードウェアで効率的にプログラムを実行させるには、並行性は必須である。しかし、並行ソフトウェアを書くことは、挑戦的であり、エラーが起こりやすい。C++はマルチスレッドプログラミングの標準的な設備、acquire/relaseセマンティクスによるアトミック操作とRAIIのミューテックスロッキングを提供するが、これらのプリミティブはあまりにも低レベルである。それらを正しくかつ効率的に使用するには、まだ専門的な知識と手作りが必要だ。アクターモデルは、暗黙的な通信を、明示的なメッセージパッシングメカニズムによる共有で置き換える。これは分散的な並行性として適用でき、事前に次元が決定されたスレッドプール内の全てのアクターをスケジュールした軽量アクターモデルの実装は、スレッドベースアプリケーションと同等のパフォーマンスを出すことができる。しかしアクターモデルは、ネイティブプログラミング言語のベンダー固有のソリューションには入れない。オープンソースライブラリであるlibcppaで我々は、C++11のパフォーマンスとリソース効率を持つアクターモデルによって、信頼性の高い分散システムを構築する能力を統合したい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/dominik_charousset_paper_cppnow2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#binary-compatibility&#34; name=&#34;binary-compatibility&#34;&gt;ライブラリ開発者が知るべきバイナリ互換性について&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Binary compatibility for library developers&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C標準のように、C++標準はコンパイラの重要なふるまいと、合法なプログラムを構成するものを規定している。しかし、ABIとバイナリ互換性に関する問題については、意図的にうまく避けられている。今でさえ、それぞれ独自に管理されるモジュールやダイナミックリンクに関する問題や経験について、あまり議論されていない。Cよりもはるかに複雑かつ強力なので、コンパイラはCよりもはるかにややこしいC++ABIを作る。(原文: Because it is much more complex and powerful than C, compilers implement a C++ ABI that is an order of magnitude more complex than C++. 訳註: Cのtypoか)また、Cとは異なり、単一のプラットフォーム(オペレーティングシステムとアーキテクチャ)であっても、C++のABIはコンパイラごとに異なる。&lt;/p&gt;
&lt;p&gt;未だライブラリ開発者はしばしばCやC++標準に定義されていないこの種の問題について、理解したり解決したりする必要に迫られる。これは決して不可能なことではなく、リリース間のバイナリ互換性を保証するための信頼できる単純なガイドラインやチェックリスト、ツールや作業が存在する。これらを利用して、複数のリリースにわたって、大きなライブラリの長期間以前のヴァージョンとの互換性を維持することが可能である。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、この種の現実にある問題と主にQtやKDEで使われた解法について述べる。特に、Qt4がどうやって7年間にわたり、9つの機能リリースと数十個のパッチリリースをしてなおリリースバイナリの互換性を維持したのかについて示す。また、間違いとその修正についても示す。その後、どのようにコンパイラがABIを作るのかについて詳細な議論をしたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#yet-another-paradigm-shift&#34; name=&#34;yet-another-paradigm-shift&#34;&gt;さらなるパラダイムシフト? (並行のMeta4モデル)&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: yet another paradigm shift (yaps) ? (A Meta4 model of concurrency)   &lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/stanley-lippman/&#34; target=&#34;_blank&#34;&gt;Stanley Lippman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=SLLOSAm-OS0&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=SLLOSAm-OS0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特にC++の話として、C++の後ろに見え隠れする非常に先進的なアイデア/技術の兆候から、同型の多細胞生物の受精を例にとって、進化でも革新でもなく、単にmeta4layersの同期をとるだけというさらなるパラダイムシフトの提案に至るまでの言語のライフサイクルについて議論したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#spirit-x3&#34; name=&#34;spirit-x3&#34;&gt;Inside Spirit X3: C++11で再設計されたBoost.Spirit&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Inside Spirit X3: Redesigning Boost.Spirit for C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/joel-de-guzman/&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon ’07、’08、’09、’10で行ったSpiritの使い方に関するチュートリアルは、大きな成功を収めた。この時間では、Spiritの設計と実装に焦点を当てたプレゼンテーションを行う。さらなる挑戦として、C++11の新機能のアドバンテージを活かして、Boost.Spiritを大きく再設計した。この実験的なバージョン(X3)の、ひとつの大きな目標は、C++の言語機能不足のために失われた「Classic」のエレガントなシンプルさを取り戻すことだ。この90分のプレゼンテーションでは、現代的なC++11コードで今汚いポイントに挑み、私の経験に基づくC++11の欠点を共有した上でC++1yの希望について話したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#weak-hiding&#34; name=&#34;weak-hiding&#34;&gt;C++コンセプトのための弱い隠蔽: プログラミング言語の名前バインディングについて推論するフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Weak Hiding for C++ Concepts: via a Framework for Reasoning about Name Binding in Programming Languages&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/larisse-voufo/&#34; target=&#34;_blank&#34;&gt;Larisse Voufo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の名前探索とオーバーロード解決の規則は複雑で(伝統的なスコープ、ADL、テンプレート引数の推論とSFINAE、オーバーロード、それらの組み合わせ)、コンセプトを言語に追加すると、これらの規則がさらに複雑になります。コンセプト付きC++のために名前探索とオーバーロード解決の規則の最高の代替設計を行うことは、現在の規則が不透明であることから困難です。&lt;/p&gt;
&lt;p&gt;現在のものと提案中のもの、両方の規則を解説するために、プログラミング言語の名前探索(名前バインディングとも言う)のための解説システムのための統合フレームワークを紹介します。このフレームワークは、現在の規則を説明できるだけでなく、名前探索(とオーバーロード解決)に対してコンセプトの提案がどのような影響を与えるのか理解するのを用意にするためにも使用できます。このモデルは、異なる言語の微妙な違いや潜在的な拡張機能、ADLの複雑さ、演算子を使用する際の標準的な規則の誤解といったものを表現します。さらに、Clangの拡張であるConceptClangなどの既存のコンパイラに対して、C++のコンセプトの実装を調査することも可能にします。&lt;/p&gt;
&lt;p&gt;たとえば、C++にコンセプトが含まれていた最後のドラフト(N2914)での名前探索とオーバーロード解決の仕様では、制約テンプレートのところで、現在の規則の元で正しいコードを無効にしてしまいます。この問題が起きる原因は、制約名が、テンプレートの外で定義された名前と同じように扱われるからです。&lt;/p&gt;
&lt;p&gt;我々が提案するフレームワークは、「弱い隠蔽(Weak Hiding)」という別な選択肢をとります。これは周囲のスコープ(と関連する名前空間)にある名前が、テンプレート制約の名前のみを使用してオーバーロード解決に成功した場合のみ隠す、という中間のアプローチです。名前バインディングのための我々の統合フレームワークでは、このモデルは、名前バインディング、バインディングなし、(ADLのために)開く、弱い隠蔽という、4つのスコープの関係で表現され、そして関連するその他のアイディアは、言語と設計抽象的な最小限の2つの概念です。このプレゼンテーションでは、名前バインディングインフラストラクチャと主要な調査結果の要約をし、制約テンプレートを定義するための、弱い隠蔽の導入に焦点を当てます。はじめに、初心者と専門家両方の視点から、問題に対する実用的な例として、弱い隠蔽の必要性を示します。その後、我々のConceptClangが行ったいくつかの設計上の決定を説明します。このセッションが終わったあと、参加者は、現在のものと拡張案、両方のC++の名前探索のルールについてより良い理解が得られるでしょう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#cpp11-qt5&#34; name=&#34;cpp11-qt5&#34;&gt;Qt5でC++11を使う： 課題と解法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11 use in Qt5: Challanges and Solutions&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Qt5は昨年12月にリリースされた、有名なQtフレームワークの最新メジャー版である。C++フレームワークであるので、Qtの開発はもちろんC++11に大きな影響を受け、C++11のおもしろい機能、特に高速なコードの作成や可読性を向上させるような機能を利用しようとした。コンパイラがC++11の機能を実装するほどには、Qtのようなフレームワークは早く実装できなかった。加えて、Qtは二つの問題に直面した。一つ目は、まだ利用しているユーザーがいるので昔のコンパイラとツールチェインをサポートする必要があったこと。二つ目は、Qt4と可能な限りソース互換性を維持するというのが、Qt5の目標ひとつだったことである。このような要求に応えるために、当面のあいだ、C++11の大規模な採用は見送ることなった。&lt;/p&gt;
&lt;p&gt;それゆえ、Qt開発者はどのC++11機能を使うべきでないか、どの機能を使うべきか、C++98/03コンパイラ互換をどうやって維持するかについて考える必要性にせまられた。このセッションでは、結局どういう決定を下したのか、また、C++98/03とC++11モードそれぞれでさまざまなコンパイラをサポートする措置について話そうと思う。Qtで適用した解決法、およびC++11とC++03で利用可能である巨大なC++クラスライブラリ構築を試みる際の一般的な考えかたについて知見が得られるだろう。このプレゼンテーションでは、ようするに我々のように、C++03コンパイラ互換性を維持したまま、ライブラリやアプリケーションをC++11に移植する必要にせまられた、C++開発者向けの実践的ガイドラインを示すことが狙いである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#thread-safe-bag&#34; name=&#34;thread-safe-bag&#34;&gt;スレッドセーフでスレッド中立なbag&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Thread-safe and Thread-neutral Bags&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/richard-saunders/&#34; target=&#34;_blank&#34;&gt;Richard Saunders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bagは多数のスレッドが処理を実行するために継続的かつ非同期にbagからデータを取り出すようなスレッドシステムで使う基本的なコンテナである。bagはキー操作(get)を持ち、概念上はシンプルであるが、スレッドセーフ(bagの状態は複数のスレッドからアクセスされても一貫性を保持する)かつスレッド中立(スレッド同士が競合しない)に実装しようとするととてつもなく難しくなる。&lt;/p&gt;
&lt;p&gt;このセッションではスレッド環境下でのbagの実装について、さまざまな角度から、特に、多数のスレッドがbagに絶えまないアクセスや、作業の性質、マシンに積んでいるプロセッサの数とタイプ、高速な生産者/消費者関係などについて見ていく。ただ一種類のbagではあらゆる要求を満足できないのは明らかだ。この論文ではbagに関して、アプリケーションの性質に応じて引き出しと戸棚という二つの抽象化を紹介している。これらの新しい抽象化を、スレッドセーフでスレッド中立なbagを担保しうるC++11のマルチスレッドまわりの機能を利用して実装する。いずれの実装についても人工のベンチマークと実際のアプリケーションで利用し十分な吟味を行った。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/04/saunders_paper_cppnow2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#practical-cpp11-odb&#34; name=&#34;practical-cpp11-odb&#34;&gt;実践C++11：ODBへのC++11サポート追加で学んだこと&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Practical C++11: What I Learned Adding C++11 Support to ODB&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-kolpackov/&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ORMにC++11サポートを加えていく過程で、新しい言語機能や他のコンパイラのサポート状況といった実践的な経験が得られた。また、想像できるかもしれないが、これは大変な仕事だった。このセッションでは、新しい言語機能について利用できる経験則について議論したい。&lt;/p&gt;
&lt;p&gt;このセッションでは、完全転送とオーヴァーロードはとても相性が悪い(また、その対処方法)、値渡しと参照渡し(また、左辺値参照か右辺値参照か)の使いわけ、範囲forループの内側について話すつもりである。また、C++98とC++11をサポートするクロスプラットフォームライブラリで、実際に遭遇した実装面での問題についても取りあげたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#bloomberg&#34; name=&#34;bloomberg&#34;&gt;応用階層的再利用: Bloomberg基盤ライブラリの利用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Applied Hierarchical Reuse: Capitalizing on Bloomberg’s Foundation Libraries&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/john-lakos/&#34; target=&#34;_blank&#34;&gt;John Lakos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ライブラリの設計は大変な仕事である。特に、相互運用性のある組み換え可能なライブラリセットの設計ともなるといっそう困難である。複数のライブラリを機能面で分割すれば、それ固有の課題がでてくる。すなわち、ライブラリの機能はわかりやすく、冗長性は排除しなければならず、コンポーネントとライブラリにまたがるインターフェースと契約関係は、高性能なIDEがなくても容易に理解できるようにしなければならない、ということだ。さらに、ライブラリ間の依存性にはよく気をつけなければならない - ライブラリは首尾一貫して機能し、よく精査された語彙を定義、利用しながら、クライアントが必要とする機能分だけのコンパイル時間やリンク時間、実行ファイルサイズで済むものでなければならない。&lt;/p&gt;
&lt;p&gt;複数の相互運用可能なライブラリセット作成にも、それぞれのライブラリ作成と同様に多くの課題がある。そのライブラリセットは理解しやすく、利用しやすく、高性能で信頼性がなければならない。さらに、ライブラリ全体が共通の構造を取り、表現を根拠なく変えず、一貫した用語を使っていなければならない。ライブラリ全体でこのような高度な一貫性や性能、信頼性を達成することで、個々のライブラリにおける部分的な信頼性は非常に高くなる。さらに、単一のライブラリを作成する際にも、このような手法を採用すれば、かなりの恩恵にあずかれるだろう。&lt;/p&gt;
&lt;p&gt;小-中規模プロジェクト向けのソフトウェア方法論は多くあるが、これらをごく単純には大規模な開発にスケールすることはできない。このセッションでは、大規模開発における問題点や、実績のあるコンポーネントベースの方法論ではどうにもならない問題に対処すべく見いだし、Bloombergの実用的なアプリケーション開発を通じて洗練された関連技術について述べる。これらの方法論 - 三階層集約、非循環依存性、名詞句結合、高粒度機能分解、クラスカテオゴリ、限定的契約、コンポーネントレヴェルテスティングなど - の現実的応用については、最近リリースされたばかりのオープンソースディストリビューションであるBloomberg基盤ライブラリを利用して紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#boost-dispatch&#34; name=&#34;boost-dispatch&#34;&gt;Boost.Dispatch - 汎用タグディスパッチ基盤ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Dispatch - Generalized Tag Dispatching Infrastructure Library&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/joel-falcou/&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mathias-gaunard/&#34; target=&#34;_blank&#34;&gt;Mathias Gaunard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型制約を自由に組み合わせる種の関数特殊化を規定するのは、C++ではめんどうな仕事である。というのも、そのような制約はすぐにどんどん増えるし、どんどんややこしくなるからだ。この問題を解決するために、SFINAEやタグディスパッチなど様々なイディオムが利用されてきた。&lt;/p&gt;
&lt;p&gt;このセッションではBoost.Dispatchを紹介する。これは、タグやその関連性を定義するプロトコルを備え、任意のタグの組み合わせと関数実装とをマップし、自由で結合可能な方法で前述の特殊化リストを拡張できる、タグディスパッチの利用や管理を容易にする基盤ライブラリである。Boost.Dispatchの新しい利点は、関数の特性や型特性のより古典的な用法に加えてディスパッチを導くための構造上の情報を分類できる機能だ。&lt;/p&gt;
&lt;p&gt;このセッションではまずSFINAEや、C++でのオーヴァーロードとタグディスパッチの意味と、その限界についてざっと説明する。単純なライブラリ設計から、自明でない構造に依存する情報に基づいて、関数の最適な実装を選択するためのライブラリを利用する、実際の高効率コンピューティングコードにわたるサンプルとともに、Boost.Dispatchを紹介していく。さらに、ライブラリの実装についての詳細を見ていただき、未解決の課題について概説したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#vienna&#34; name=&#34;vienna&#34;&gt;計算科学向けViennaライブラリについて&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Discussion of Selected Vienna-Libraries for Computational Science&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/karl-rupp/&#34; target=&#34;_blank&#34;&gt;Karl Rupp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CUDA、OpenCL、OpenMPが利用可能な線型代数ライブラリであるViennaCL、メッシュデータ構造ライブラリであるViennaGrid、データ保存を受けもつViennaData、シンボリック計算カーネルであるViennaMathといった直交するライブラリ群を紹介することで、計算科学のとっつきにくさに取り組む。結びに、有限要素法パッケージであるViennaFEM内で、これら直交するライブラリ群がどのように相互作用しているか考察する。このセッションの主眼は様々なプログラミング技法の適用について、またC++がいかに計算科学向けの言語になりうるかについてである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/karl.rupp_.paper_.2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#alignment&#34; name=&#34;alignment&#34;&gt;C++のアラインメント: 利用法、制限、および拡張法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Alignment in C++: Use, Limitations, and Extension&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-spencer/&#34; target=&#34;_blank&#34;&gt;Michael Spencer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションではC++におけるアラインメントを調査する。まず最初に、C++11でのアラインメントまわりの変更について概説し、効果的な利用法について述べる。次にその制限について述べる。その次に、それら問題点に対処するために、アラインメントを型システムに載せることで解決する方法を提案する。最後に型安全性と実行時効率の恩恵について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#community-dev&#34; name=&#34;community-dev&#34;&gt;C++コミュニティの発展&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Community Development&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/jens-weller/&#34; target=&#34;_blank&#34;&gt;Jens Weller&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JensとJonは両名ともC++コミュニティの発展に意欲があり、C++カンファレンスに出席した経験がある。彼らはコミュニティの発展にはローカルグループこそがC++コミュニティ発展の鍵であると感じている。&lt;/p&gt;
&lt;p&gt;Jensは、ヨーロッパのC++Nowとも言えるMeeting C++の主催者として、またデュッセルドルフとベルリンのC++ユーザーグループを立ちあげた経験について紹介する。&lt;/p&gt;
&lt;p&gt;JonはシリコンバレーのACCU支部での経験や、シリコンバレーコードキャンプでのC++プログラミング経歴、C++Nowでの活動について紹介する。&lt;/p&gt;
&lt;p&gt;その後、パネルディスカッションスタイルで、質問やコメントを受けつけたり、聴講者の経験についてうかがう。&lt;/p&gt;
&lt;p&gt;ローカルでグループを立ちあげるコツや、個人的人脈やソーシャルメディアを通じてスピーカーや聴講者を募る方法、他のグループと連携する方法についても述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#dynamic&#34; name=&#34;dynamic&#34;&gt;動的なC++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/alex-fabijanic/&#34; target=&#34;_blank&#34;&gt;Alex Fabijanic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外部ソースから取り込むべき様々な型のデータには、データ型変換がつきものです。C++プログラマの皆さんは、リレーショナル・データベースやXMLデータベースからJSON形式やHTMLへのデータ変換をC++の型チェックという障壁を越えて、正確かつ効率的に、どのように変換されていますか？答えは型消去というテクニックを使用する事にあります。この講義では、最も一般的な C++型消去の手法について、列挙探査と比較を行います。&lt;/p&gt;
&lt;p&gt;上記の問題と同様に与えられた、歴史的なライブラリ（ANSI Cの共用体、&lt;code&gt;void*&lt;/code&gt;、マイクロソフト COMの&lt;code&gt;Variant&lt;/code&gt;型、&lt;code&gt;boost::variant&lt;/code&gt;、&lt;code&gt;boost::any&lt;/code&gt;、&lt;code&gt;boost::lexical_cast&lt;/code&gt;)と最近のライブラリ(&lt;code&gt;boost::type_erasure&lt;/code&gt;、Facebook &lt;code&gt;folly::dynamic&lt;/code&gt;)といった、開発トレンド(保留中の &lt;code&gt;boost::any&lt;/code&gt; というC++標準案を含む)、それは、C++言語の静的な型システムという性質を回避する手法が必要であることを示唆しています。この問題に関する解決法は複数存在します。この講義では、&lt;code&gt;boost::variant&lt;/code&gt;、&lt;code&gt;boost::any&lt;/code&gt;、&lt;code&gt;boost::type_erasure&lt;/code&gt;、&lt;code&gt;folly::dynamic&lt;/code&gt;、&lt;code&gt;Poco::Dynamic&lt;/code&gt;、これらに焦点を当てて掘り下げます。設計デザインと機能だけでなく、各ライブラリの長所と短所についても検討します。パフォーマンスベンチマークの比較も同様に検討されます。&lt;/p&gt;
&lt;p&gt;型安全はC++の重要な要素です。型消去は、現代のソフトウェア開発のために必要なテクニックです。この講義では、これら重要な型消去のライブラリの比較検討を行います。&lt;/p&gt;
&lt;p&gt;＊ Type Erasure を型消去と訳してます&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#debruijn&#34; name=&#34;debruijn&#34;&gt;DeBruijn Bind: シンプルさを維持するより強力なbind&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DeBruijn Bind: A more powerful bind that retains its simplicity&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/david-sankel/&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.LambdaやBoost.Phoenixのような、より強力なライブラリがあるなかでも、Boost.Bindはその非常に単純な構文と、学習のハードルが低いという点でその立ち位置を守っている。その構文はBoost.MPLのなかでコンパイル時variantとして利用されている。&lt;/p&gt;
&lt;p&gt;しかし、テンプレート実引数とともに使うため、または、&lt;code&gt;boost::protect&lt;/code&gt;を使いはじめるために、&lt;code&gt;boost::bind&lt;/code&gt;のネストに手を染めると、この単純さは&lt;code&gt;boost::bind&lt;/code&gt;のセマンティクスとその限界については不鮮明になってしまう。&lt;/p&gt;
&lt;p&gt;このセッションでは、解析を行ない、Boost.Bindのセマンティクスとは何かについて数学的に正しい理解に到達することを目的とする。ひととおりセマンティクスについて学べば、Boost.Bindがカヴァーしている要求を満たし、再帰可能であり、学習のハードルが低い単純な構文を維持する、説得力のある代替案の設計についての見識が得られるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#multi-threading&#34; name=&#34;multi-threading&#34;&gt;C++11とBoostを利用したマルチスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Multi-Threading With C++11 and Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/rob-stewart/&#34; target=&#34;_blank&#34;&gt;Rob Stewart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルでは、マルチスレッドコードを記述するためのC++11とBoostの機能を利用した多くの例をもとに、より深くその効用についいて段階的に学んでいく。&lt;/p&gt;
&lt;p&gt;例としてスレッドセーフキューについても取りあげ、独立したスケジュール上で並列タスクを実行するためにスレッドを利用したり、長時間実行中の並列タスクに割り込みを掛けてみる。これらの例をもとにスレッドやミューテックス、条件変数などの利用法を示す。C++11とBoostの機能的相違点についても議論するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#concept-lite&#34; name=&#34;concept-lite&#34;&gt;軽量コンセプト: 述語による制約テンプレート&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Concepts Lite: Constraining Templates with Predicates&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/andrew-sutton/&#34; target=&#34;_blank&#34;&gt;Andrew Sutton&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このトークでは、C++14に提案されている新言語機能である「テンプレート制約(またの名を軽量コンセプト)」について話します。制約は、テンプレートにおいてテンプレート引数が使えるかどうかを判定するための述語です。&lt;/p&gt;
&lt;p&gt;制約を使用して要件を直接示すことによって、テンプレートの宣言を改善できます。もちろん、制約に基いて関数オーバーロードすることもできます。制約は、型のエラーを使用時にすぐ捕捉できるため、コンパイルエラーのスタックを短いスクロールで確認できるようになることを意味します。&lt;/p&gt;
&lt;p&gt;言語機能としては、テンプレート制約は最小限で複雑でないものに抑え、テンプレート使用の正確さではなく、テンプレート定義の正確さを強化します。これは段階的かつ簡単に、既存のコードベースに採用できることを意味します。&lt;/p&gt;
&lt;p&gt;このトークは一般的なデータ構造、メンバ関数とコンストラクタ、オーバーロード、クラステンプレートの特殊化、制約の定義といった例を通して、制約をどのように使用するかを説明します。また、私が普段のプログラミングで制約を使用してきた経験についても説明します。これは制約のいいアイデアと、それほどよくないアイデアの両方を含みます。&lt;/p&gt;
&lt;p&gt;GCC 4.8ベースの実験的なコンパイラは、みなさんがすでに使えるよう公開してあります。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#html5&#34; name=&#34;html5&#34;&gt;ママ見て “C++を使ってデータベース更新からHTML5が生成されたよ”, 自動化して!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Look ma, “update DB to HTML5 using C++”, no hands!&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/alex-fabijanic/&#34; target=&#34;_blank&#34;&gt;Alex Fabijanic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ウェブを取り巻く環境は急速に変化しています。AJAXや非同期JSONの登場により、ユーザ・インタフェイスの応答性は、大幅に改善されてきました。この流れの基礎となるデータ・トランスポートのメカニズムは、まだ、リクエスト/レスポンスによるポーリング（プル）・モデルに基づいています。WebSocket規格は、ネットの先のストレージから標準となるHTML5インタフェイスへ、イベント・ドリブンなプッシュ・モデルというシームレスな接続の最後の障壁を取り除きました。流れとして、データ転送はイベント・ドリブン・モデルを使用し、リクエスト/レスポンス・モデルで行われていたネットワークおよびウェブサーバのオーバーヘッドを下げ、パフォーマンスの改善を標準規格に準拠して行う事ができます。講義の最初に、POCOフレームワーク・ネット・ライブラリを使用して、WebSocket HTML5ページを生成するHTTPサーバを構築します。次に、POCOデータ・ライブラリを使用して、SQLデータベースと連帯する機能をHTTPサーバに追加し、コールバック・フックを確立します。そのフックは、透過的にデータベースのデータ更新からウェブ・ページ変更を引き起こすためにパスを開きます。このソリューション・電子ブロックの構成要素である、データ型消去のための &lt;code&gt;Poco::Dynamic&lt;/code&gt;モジュール、動的フォーマット出力のための&lt;code&gt;Poco::Data::RowFormatter&lt;/code&gt;クラス、を詳細に説明します。&lt;/p&gt;
&lt;p&gt;この講義は、いくつかの鋭い問題に現実的解決案を提示します - 効率的かつ独立して転送されたデータ型からエンドユーザにシームレスウェブにネットワーク経由でストレージからデータを提供します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#odb&#34; name=&#34;odb&#34;&gt;C++(11)のためのORマッパー：ODB&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ODB, an ORM for C++(11)&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-kolpackov/&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ODBは、C++によるオブジェクト・リレーショナル・マッピング(ORM)システムのライブラリで、クロス・プラットフォームかつクロス・データベースなオープンソースです。&lt;/p&gt;
&lt;p&gt;このライブラリを使用すると、テーブル・カラム・SQLや、リレーショナル・マッピングのコードを手作業で書く事なく、C++のオブジェクトをリレーショナル・データベースに格納できます。&lt;/p&gt;
&lt;p&gt;Boostカンファレンス2011より数ヶ月前に、私はODBを導入しました。今回は我々が過去2年間に行った成果をお見せしたいと思います。講義の最初では、ODBの助けを借りて、リレーショナルデータベースにC++のオブジェクトを格納することが、いかに簡単できるかを話します。次に多様な興味深いトピック、C++11サポート、BoostとQtプロファイル、ポリモーフィズム、楽観的な同時実行制御、およびマルチデータベースサポートについて話します。私は、これからも、データベース・スキーマ革命！という野心的な困難に取り組むつもりです。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#fusion&#34; name=&#34;fusion&#34;&gt;Fusionで世界の謎を解く&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Solving World Problems with Fusion&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンパイル時MPLと実行時タプルの融合。Boost.Fusionはメタプログラミング世界のSTLである。FusionはBoostライブラリの内部的な機構を提供し、私たち自身のソースの一般的な要素となっている。&lt;/p&gt;
&lt;p&gt;この90分のセッションでは、Boost.Fusionライブラリの現実世界でのユースケースを探求する。具体的には、ライブラリインタフェースのシンプル化、宣言的なユーザーエクスペリエンス、効率的で非侵入的なハンドリングの例を見ていく。&lt;/p&gt;
&lt;p&gt;参加者は、いくつかの実用的な使用パターンの理解を得てさらなる先に進んで行くでしょう。ぜひSpirit、Xpressive、Geometry、Accumulators、odeint、Proto、Phoenix、MSMを自分のソースに取り入れる方法を学んでみてほしい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#dds&#34; name=&#34;dds&#34;&gt;モダンなC++向けのデータ分散サーヴィス(DDS: Data Distribution Service)の標準化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Standardizing the Data Distribution Service (DDS) API for Modern C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/sumant-tambe/&#34; target=&#34;_blank&#34;&gt;Sumant Tambe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++復権は多くの工業分野で広まっている。アプリケーション移植性の視点からC++を対象にした国際的なコンピュータシステム標準は、迅速にモダンなC++を導入してきている。国際標準化機構のObject Management Group(OMG)では、DDS-PSM-CxxとIDL2C++11標準が時代の先を行っている。DDS-PSM-Cxxは、高性能な分散リアルタイムシステム開発向けの主要なデータ分散サーヴィス(DDS)標準の関連標準である。正式には&#34;ISO/IEC C++ 2003 Language Platform Specific Mapping (PSM) for DDS&#34;として知られるDDS-PSM-Cxx標準は、2012/12に策定完了した。DDS-PSM-Cxxはモダンで、自然で、STLと親和性があり、表現力が高く、安全で、効率的なDDSプログラミング向けに可搬性のあるC++APIを提供している。DDS-PSM-CxxはC++03をターゲットにしており、C++11環境移行を可能にすべく特別な準備をしている。このセッションではDDS-PSM-Cxx標準の&#34;なぜ&#34; &#34;どうして&#34;について述べる。OMG標準化作業部会の投票委員と主要な貢献者が登壇する予定である。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションはDDS - リアルタイム分散システム向けのデータ中心の出版-購読型アーキテクチャの基礎を説明するところから始める。DDSと組み合わせたモダンなC++で記述した&#34;Hello World!&#34;アプリケーションとともに、DDS-PSM-Cxx標準の動機や問題点、高次構造について示す。また、規格に合致しているベンダー実装の当分の代替のサポートやベンダー固有拡張のための文脈的手掛かりといった、標準の興味深い点について深く掘りさげていく。この標準はBoostを直接的に利用していないものの、いくつかのBoostライブラリからアイディアを拝借している。このプレゼンテーションでは、DDSアプリケーション向けのクリーンで安全かつ効率的なAPIを提供するための、種々のC++03イディオム(例えば、RAII、型消去、型安全列挙、メソッドチェイン)の利用についても詳しく説明していく。さらに、聴者の興味を引くであろう、APIを構築する上で重要な点である例外安全の考慮についても述べる。特に、例外安全なAPIを設計する上で、ムーヴセマンティクスが如何に有用かご覧いただけるだろう。最後に、C++03規格に合致しているアプリケーションが、C++11環境でも合法となるように、標準に加えた特別なルールについて議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#member-access-operator&#34; name=&#34;member-access-operator&#34;&gt;メンバーアクセス演算子のオーヴァーロード&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Overloading the Member Access Operator&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/sebastian-redl/&#34; target=&#34;_blank&#34;&gt;Sebastian Redl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接メンバーアクセス演算子(&lt;code&gt;operator.&lt;/code&gt;)のオーヴァーロードは通常またはメタプログラミングでおもしろいユースケースがある。この演算子のオーヴァーロードの古典的な利用法は、アロー演算子のオーヴァーロードと同じく、別のオブジェクトを参照させたい場合に利用することである。&lt;/p&gt;
&lt;p&gt;このセッションでは、メタプログラミングを利用してプログラマが別の名前を利用できるようにする別の方法を紹介する。Clangコンパイラを利用したこの機能の実験的実装を紹介し、この実装のユースケースや、この機能の有用性、問題点、これを実装するにあたって得られた知見について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#cern&#34; name=&#34;cern&#34;&gt;CERNでの対話的で内省的なC++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interactive, Introspected C++ at CERN&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/vassil-vassilev/&#34; target=&#34;_blank&#34;&gt;Vassil Vassilev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CERNは、世界最大の素粒子物理学研究所である。そのような科学的ブレイクスルーを作るために、約15PB/yearを処理している。ROOTフレームワークのユニークな能力は物理学者がデータ解析するのをより効率的で、計算的で、賢いストレージを可能にする。ROOTの最新バージョンのコアはClingである。これは対話的なC++インタプリタで、C++11もサポートしている。Clingは、以前まで使用していたROOTの伝統的なメインユーザーインタフェースを置き換える。Clingは、Clang/LLVMインフラストラクチャ上に構築される。このインタプリタはそれだけでなく、ROOTのシリアライズ、デシリアライズ、C++のオブジェクト指向データの操作にも使用され、それでいて初心者がC++をより早く学ぶのを支援してくれる。&lt;/p&gt;
&lt;p&gt;C++のような静的言語のインタプリタを構築するのは、決して簡単ではない。私はClingの要件を説明し、その後コンパイラフレームワーク上にインタプリタを実装することに挑戦する。C++をより対話的な言語に変えるために、C++標準のいくつかの概念を説明する。インタプリタを使用して、型のイントロスペクション機構を簡単に説明する。C++の文脈解析で、ランタイムの力を改善する方法を提案する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#haskell&#34; name=&#34;haskell&#34;&gt;Haskellの力でMPLを強化しよう&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boosting MPL with Haskell elements&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/abel-sinkovics/&#34; target=&#34;_blank&#34;&gt;Abel Sinkovics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HaskellとC++テンプレートメタプログラミングの類似性が指摘されている[1,2]一方で、Haskellのほとんどの要素がテンプレートに導入されていない。これらをいくらかでも導入すれば、メタプログラミングはより使いやすくなり、テンプレートメタプログラミングツールセットであるBoost.MPLの強化につながるだろう。&lt;/p&gt;
&lt;p&gt;Haskellを含む関数プログラミング言語で利用されている式を、コードを読みやすくするために、そして構築しやすくするために利用してみよう。これはC++テンプレートメタプログラミングに対しても同じ目的で適用できるはずである。&lt;/p&gt;
&lt;p&gt;関数型プログラムを記述するとき、とりわけ、Haskellのdo notationとMonadの組み合わせは、書かなければならない鋳型コードの量を削減できる強力なツールである。コンパイル時計算にこの要素を導入すれば、これを利用したテンプレートメタプログラムの可読性の向上に寄与するだろう。&lt;/p&gt;
&lt;p&gt;多くのプログラミング言語について、リスト内包表記はリスト変換の理解に寄与する。リスト内包表記を実装するためにHaskellのList monadとdo notationを利用が利用されるように、テンプレートメタプログラミングでも同様にこれらを使って実装できる。&lt;/p&gt;
&lt;p&gt;エラーハンドリングはEither monadを利用すれば単純化できる。構文糖を混ぜることで、monadや例外ハンドリングがC++テンプレートメタプログラムで実装されていることを意識せずに、テンプレートメタプログラムにおいてもこのような例外ハンドリングが理解でき、利用可能である。&lt;/p&gt;
&lt;p&gt;これらのツールはBoost.MPL ライブラリを基礎として構築され、その拡張として利用されるので、既にBoost.MPLを利用しているメタプログラムに容易に展開可能である。&lt;/p&gt;
&lt;p&gt;このセッションで紹介するツールはMetamonadライブラリの構成要素である。Metamonadライブラリについては以下のリンクを参照すること:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://abel.web.elte.hu/mpllibs/metamonad&#34; target=&#34;_blank&#34;&gt;http://abel.web.elte.hu/mpllibs/metamonad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sabel83/mpllibs&#34; target=&#34;_blank&#34;&gt;https://github.com/sabel83/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションは高度なので、Boost.MPLに精通していることが望ましい。&lt;/p&gt;
&lt;p&gt;参考文献:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;[1] Stuart Golodetz – Functional programming using c++ templates (part 1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://accu.org/index.php/journals/1422&#34; target=&#34;_blank&#34;&gt;http://accu.org/index.php/journals/1422&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[2] Bartosz Milewski – What does Haskell have to do with C++?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/&#34; target=&#34;_blank&#34;&gt;http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#object-transmission&#34; name=&#34;object-transmission&#34;&gt;Boost.AsioとBoost.Serialization: オブジェクト受け渡しのデザインパターン&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Asio and Boost.Serialization: Design Patterns for Object Transmission&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bryce-adelstein-lelbach/&#34; target=&#34;_blank&#34;&gt;Bryce Adelstein-Lelbach&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jeroen-habraken/&#34; target=&#34;_blank&#34;&gt;Jeroen Habraken&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++でネットワークプログラミングするには、他のネットワーク終端へ受けわたしできる、再構築可能なバイトシーケンスとして、C++オブジェクトを表現する方法が必要である。PODのような単純なオブジェクトなら、シリアライズするのが一般的だろう。&lt;/p&gt;
&lt;p&gt;多態オブジェクトのような、より複雑なC++構造については、シリアライズする方法はより困難になる。このセッションでは、Boostにある二つの強力なライブラリであるAsioとSerializationについて、巨大な配列を扱えるC++ネットワークコードを構築するという観点から、その有用性について議論していく。&lt;/p&gt;
&lt;p&gt;このセッションではBoost.MPIとHPX(分散/並列プログラミング用のC++ランタイムシステム)を使って、Boost.AsioとBoost.Serializationを利用したオブジェクト変換を行う方法についても議論する。また、ほんの少しだが、別の解法についても議論するつもりだ。&lt;/p&gt;
&lt;p&gt;このセッションは、ネットワークプログラミングに従事している、もしくは興味がある(けれどもBoost.AsioやBoost.Serializationについてよく知らない)方を対象にしている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#cppnow-2014&#34; name=&#34;cppnow-2014&#34;&gt;C++Now 2014の準備&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preparation of C++Now 2014&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participants/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participants/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来年の会議にむけた計画委員会を早期に発足させる。もしご提案や、ご支援いただける方はぜひご参加ください。&lt;/p&gt;
&lt;p&gt;このセッションにはスライドはない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#hetero&#34; name=&#34;hetero&#34;&gt;静的型付け言語における、動的で再帰的なヘテロ型&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic, Recursive, Heterogeneous Types in Statically-Typed Languages&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/richard-saunders/&#34; target=&#34;_blank&#34;&gt;Richard Saunders&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/clinton-jeffery/&#34; target=&#34;_blank&#34;&gt;Clinton Jeffery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のソフトウェアはいろいろな言語で記述されている。すなわち Python、C++、Perl、Java、Javascript、Lua、Unicon、C言語などが、複雑なシステムの別個のコンポーネントを構成する環境のなかに混在している。このような言語の急激な拡散により、動的型づけ言語のコンセプトが静的型づけ言語に流入していく。&lt;/p&gt;
&lt;p&gt;動的言語によく見られる要素として、動的で、再帰的な、ヘテロな辞書構造が挙げられる。たとえば、Pythonのdict、Perlのhash、Javascriptのobject、Luaのtable、JSONにおけるIcon/Unicon tableはこの種の抽象化の実現であるし、より低水準なものとしては、XMLは言語に依存しない動的辞書構造と言えるだろう。C++やJavaのような静的型づけ言語は、スジがいい動的辞書構造の設計と実装に苦労してきた。さて、このセッションでは、C++言語の静的型に特有の機能を &lt;em&gt;採用&lt;/em&gt; し、動的構築を行なうためのシンプルで新規性のある解法で、いかにC++で辞書構造を表現するかについて考察する。その機能とは型推論、ユーザー定義の型変換、型選択、オーヴァーロードである。&lt;/p&gt;
&lt;p&gt;これらのこと組みあわせて、動的言語における動的辞書の操作性に近づけるべく、逆説的だがこれらの静的な機能から、C++からの操作が非常に容易な動的辞書構造を構築する。&lt;/p&gt;
&lt;p&gt;注意：これらのテクニックには特別なリフレクション機能やライブラリを必要としない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/saunders-jeffery.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#projucer&#34; name=&#34;projucer&#34;&gt;Projucer: C++とLLVM JIT エンジンを利用したライブコーディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Projucer: Live coding with C++ and the LLVM JIT engine&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/julian-storer/&#34; target=&#34;_blank&#34;&gt;Julian Storer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それぞれのクラスを連続的にリコンパイルし実行するために、Projucer IDE がいかにしてClangとLLVM JITエンジンを利用したC++コードのリファクタリングとリアルタイム実行を成しとげたのか、その裏側からごらんいただこう。&lt;/p&gt;
&lt;p&gt;JUCE GUI toolkitライブラリを利用しているこのProjucerは、C++プロジェクトの編集やアセンブルを行なうためのIDEである。Projucerは、Clangを利用してコンパイルを行ない、ユーザーコードベースのAST(Abstract Syntax Tree: 抽象構文木)を走査することで、適切なGUIクラスを決定し、スタンドアロンの実体としてインスタンス化する。このインスタンスはそのコードが編集された際、即座に更新される。これらのGUIクラスを動的に生成されるコードにラップすることで、ドラッグやリサイズといった一般的なGUI操作は、元のコードを動的にリファクタリングすることによって機能しその上で実行される。&lt;/p&gt;
&lt;p&gt;実際の動作についてのムービーは&lt;a href=&#34;http://youtu.be/imkVkRg-geI&#34; target=&#34;_blank&#34;&gt;こちら&lt;/a&gt;。より詳細については&lt;a href=&#34;http://rawmaterialsoftware.com/viewtopic.php?f=12&amp;amp;t=9793&#34; target=&#34;_blank&#34;&gt;私のサイト&lt;/a&gt;を参照のこと。&lt;/p&gt;
&lt;p&gt;C++通向きに、もっと細かいことや、諸問題、このシステムを効率的にするために使った狡猾なトリック、そしてClangやLLVMの特徴について掘り下げてみるつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#matrix&#34; name=&#34;matrix&#34;&gt;EigenとBoost Protoライブラリを用いた有限要素マトリックス式の組み立て&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Building finite-element matrix expressions with Boost Proto and the Eigen library&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bart-janssens/&#34; target=&#34;_blank&#34;&gt;Bart Janssens&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルでは、我々がドメイン特化言語を開発するにあたり障害となった二つの問題、すなわちBoost.Proto内での外部Expression Template Library(ここではEigen)の利用と、ユーザー定義関数の導入についていかに解決したかを示す。&lt;/p&gt;
&lt;p&gt;どちらの話についても、我々の有限要素マトリックスのコードとは関係のない、一般的な計算機様のプログラムで紹介するつもりである。これはステップバイステップ方式のBoost.Protoのチュートリアルになるだろう。最後に&lt;a href=&#34;http://coolfluid.github.com/&#34; target=&#34;_blank&#34;&gt;Coolfluid 3 code&lt;/a&gt;にあるアプリケーションを例にとって、Protoのようなライブラリが、実際のコードにどのような利点をもたらすかを示す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/janssens.abstract.pdf&#34; target=&#34;_blank&#34;&gt;Extended Abstract&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#deadlock-prevention&#34; name=&#34;deadlock-prevention&#34;&gt;侵入的動的解析を使用したリソースデッドロック防止システム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A system for resource deadlock prevention using intrusive dynamic analysis&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/louis-dionne/&#34; target=&#34;_blank&#34;&gt;Louis Dionne&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ミューテックス等を使用して共有データへ同期にアクセスするという旧来の方法は、2つ以上のスレッドがお互いに再帰的にブロックをしてしまう、リソースのデッドロックを可能にしてしまう。&lt;/p&gt;
&lt;p&gt;このようなバグは特定の状況下でしか発生しないため、多くの場合、その摘発は困難なものとなる。&lt;/p&gt;
&lt;p&gt;このトークでは、intrusive dynamic analysis(侵入的動的解析?)を使用して潜在的なリソースデッドロックを事前に発見するシンプルなフレームワークを、私達がどのように実装したかを説明する。&lt;/p&gt;
&lt;p&gt;また、そのフレームワークを既存のコードとどのように統合するかも説明する。&lt;/p&gt;
&lt;p&gt;そして最終的には、このプロジェクトをC++のより汎用的なdynamic analysisフレームワークにする可能性をもつ、プロジェクトの進化について議論しよう。&lt;/p&gt;
&lt;p&gt;マルチスレッドあるいはdynamic analysisについて興味のあるプログラマ向け。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2013.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Boostの未来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Future of Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participants/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participants/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostとC++ Now!のリーダー達が将来どうなるかについて話し、質問に答える。&lt;/p&gt;
&lt;p&gt;このセッションにスライドはない。&lt;/p&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, Usagi Ito, hotwatermorning, Miyuki OKI, zak&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2014 -- C++ Now のリンクを修正</title>
      <link href="https://boostjp.github.io/cppnow/2014.html"/>
      <id>b1f0565297261a631dd64647d980ac086ff40284:cppnow/2014.md</id>
      <updated>2017-06-12T04:51:27+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2014&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://cppnow2014.sched.com&#34; target=&#34;_blank&#34;&gt;https://cppnow2014.sched.com&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#axiomatic-programming&#34;&gt;キーノート： 公理的プログラミング： ユークリッド推論からC++テンプレート、その先へ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#through-the-looking-glass&#34;&gt;鏡の国のC++14&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#coroutine-fiber-thread&#34;&gt;Coroutines, Fibers, and Threads, Oh My&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#canonical-class&#34;&gt;規範的なクラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#geometric-algebra&#34;&gt;ジェネリック空間のジェネリックプログラミング： C++11を使用したコンパイル時幾何学的代数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#concept-clang&#34;&gt;ConceptClang：完全なC++コンセプトによる理論的な前進&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#tdd-with-boost-test-turtle&#34;&gt;Boost.TestとTurtle Mockによるテスト駆動開発&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#bounded-integer&#34;&gt;整数演算から未定義動作を排除する、&lt;code&gt;bounded::integer&lt;/code&gt;ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#afio&#34;&gt;Boostのピアレビューに向けてのC++11ライブラリAFIOの準備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#value-semantics-range&#34;&gt;値セマンティクスと範囲アルゴリズム - 合成と効率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#beware-cpp&#34;&gt;キーノート：C++に気をつけろ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#configuration-framework&#34;&gt;実用的なType Erasure： &lt;code&gt;boost::any&lt;/code&gt;ベースの構成フレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#mach7&#34;&gt;Mach7： C++のためのパターンマッチングライブラリの設計と進化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#intro-cpp11-14-1&#34;&gt;C++11/14入門 パート1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#intro-cpp11-14-2&#34;&gt;C++11/14入門 パート2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#space-plasma&#34;&gt;宇宙プラズマモデル開発でのC++11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#cpp11-library-design&#34;&gt;C++11ライブラリ設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#octopus&#34;&gt;Octopus: CFDシミュレーションのためのポリシー駆動フレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#better-code&#34;&gt;よりよいコードへの道しるべ：完全な型を実装する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#multiplatform-cpp&#34;&gt;マルチプラットフォームでのC++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#boost-library-incubator&#34;&gt;Boost Library Incubator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#optimization-network-server&#34;&gt;Boost.Asioベースのネットワーク・サーバ最適化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#undefined-behavior&#34;&gt;C++の未定義動作； それは何か、そしてなぜ気にしなければいけないか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#mpl11&#34;&gt;MPL11: C++11の新たなメタプログラミングライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#libcppa&#34;&gt;libcppa: C++での型安全なメッセージングシステム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#unicode&#34;&gt;C++でのUnicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#metaprogramming-shell&#34;&gt;Clangベースのインタラクティブなメタプログラミングシェル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#cpp-amp&#34;&gt;C++ AMPを用いたアクセラレータプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#cpp-components&#34;&gt;CppComponents: C++11のモダン,ポータブルなコンポーネントシステム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#ui&#34;&gt;UI、美学、C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#design-xml-api&#34;&gt;最新C++を使ったXML API設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#understanding-double-and&#34;&gt;&amp;amp;&amp;amp;を理解しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#concurrent-assembly&#34;&gt;並行アセンブリとしての最新のC++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#value-semantics&#34;&gt;値のセマンティクス：シンタックスについてじゃないよ!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#iterators-may-stay&#34;&gt;イテレータはまだ生き残る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#refactoring-tool&#34;&gt;Clangを使ったリファクタリングツールの自作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#combinatorial-algorithm&#34;&gt;C++を用いた複雑な組み合わせ最適化アルゴリズムの設計と実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#intro-fp&#34;&gt;C++における関数型プログラミング入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#object-lifetimes&#34;&gt;オブジェクト生存期間の管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#badcode&#34;&gt;0xBADC0DE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#global-threadlocal-static&#34;&gt;グローバル、スレッドローカル、および静的データの生存期間と利用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#expected&#34;&gt;Expected — 例外フレンドリーなエラーモナド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#async-msm&#34;&gt;Boost.MetaStateMachineと次世代非同期ライブラリを利用した非同期プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#functional-data-structures&#34;&gt;C++での関数型データ構造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#ownership-memory&#34;&gt;C++におけるメモリの所有権&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#disambiguation&#34;&gt;曖昧性解決における黒魔術&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#frp&#34;&gt;関数リアクティヴプログラミング - 滑かに抽象化された双方向性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#accelerator-programming&#34;&gt;将来のC++におけるアクセラレータプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#ripple-management&#34;&gt;C++におけるRipple Managementによる巨大なコードベース変更についての私見&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2014&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2014&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#axiomatic-programming&#34; name=&#34;axiomatic-programming&#34;&gt;キーノート： 公理的プログラミング： ユークリッド推論からC++テンプレート、その先へ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Axiomatic Programming: From Euclidean Deductions to C++ Templates and Beyond&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/gabriel_dos_reis.1rzxpiif?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Gabriel Dos Reis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公理的プログラミング(Axiomatic Programming)は構造的ジェネリックプログラミングとして一般に定義されている。ユークリッド幾何学はそれとは違い、シンプルで建設的な論理システムに依存する。これは、STLや多くの成功しているジェネリックライブラリの基盤でもある。このトークではツールのサポートに焦点を当て、C++テンプレートによる開発に現在および未来で可能な自動推論や証明の方式について話す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#through-the-looking-glass&#34; name=&#34;through-the-looking-glass&#34;&gt;鏡の国のC++14&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++14: Through the Looking Glass&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/michael_wong.1rzxpihy?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ISO曰く、「さぁいろんなことを話しあうときがついにやってきたのだ。ムーヴキャプチャやリテラルだの、lambdaを上手に歌わせるには、あるいは型推論がどうしてアツいのか、はたまた数値にハネ(&lt;code&gt;&#39;&lt;/code&gt;)が生えたらどうなるか。」&lt;/p&gt;
&lt;p&gt;次期C++標準について聞いたことがありますか？ &lt;br /&gt;
いやいや、C++11のことではありません。C++11が批准されてからそう時間が経っていませんが、来年にはC++11はC++14に刷新されることで
しょう。今や、私達はC++11について十分な知見を得て、C++11に欠けている、細かな、しかし重要な機能を知るに至りました。すなわち、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ラムダ式にムーヴキャプチャがないのはなぜか？&lt;/li&gt;
&lt;li&gt;標準ユーザー定義リテラルがあってもいいんじゃ？&lt;/li&gt;
&lt;li&gt;多態ラムダがないはどうして？&lt;/li&gt;
&lt;li&gt;ラムダ式の戻り型が推論できるのに、普通の関数でできないのはなぜ？&lt;/li&gt;
&lt;li&gt;数値リテラルに桁区切り文字が欲しいんだけど？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++14はバグフィックスリリース以上のもので、C++11をさらに機能強化したものが含まれています。これによって、C++11で知られていたいくつかの厄介な問題が解決されるでしょう。しかし、より重要なことは、C++14で言語やライブラリ、重要なイディオムがどのように変わるかではないでしょうか？&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#coroutine-fiber-thread&#34; name=&#34;coroutine-fiber-thread&#34;&gt;Coroutines, Fibers, and Threads, Oh My&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/nat_goodspeed.1rzxt7iu?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Nat Goodspeed&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前世紀では、オペレーティングシステムが一つのマシンで複数のプロセスを並行に走らせられるようになったのが大きなニュースだった。だがそれは必要十分ではなかった。この業界で数十年前から知られている問題を、C++11標準も公式に認めている：生産プロセスは、I/Oや他の時間のかかる作業を通常、ブロックできない。標準は2番目のレベルの並行性を与える：プロセス内で複数スレッドを使用する、ライブラリの機能を使用して同期とデータの受け渡しを管理する。&lt;/p&gt;
&lt;p&gt;新たなBoost.Fiberライブラリは、同様に細かい粒度の並行性を我々に与える：各スレッドで複数ファイバーを使用する、ライブラリの機能を使用して同期とデータの受け渡しを管理する。どのようなときに、スレッドの代わりにその機能を選択するだろうか？コルーチンとはどんなもので、どのようにこれら全体に適合するのか。&lt;/p&gt;
&lt;p&gt;C++標準に考えられているいくつかの並行機能についても触れる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#canonical-class&#34; name=&#34;canonical-class&#34;&gt;規範的なクラス&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Canonical Class&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/michael_caisse?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これまでは簡単だった。どの大学の学生も、週末にC++を学ぶ人も、クラスを定義する際にはコピーしたときと代入したときの振る舞いだけを自信を持って書くことができた。そこにはチェックリストがあった。チェックリストを埋め、ドメイン特化の振る舞いを追加し、回帰テストを行い、それで終わりだった。&lt;/p&gt;
&lt;p&gt;C++11になり、&lt;code&gt;delete&lt;/code&gt;キーワードの新たな使い道、演算子の&lt;code&gt;explicit&lt;/code&gt;指定、右辺値参照、完全転送など、魅力的な機能がいろいろ入った。いまあなたは、「シンプルな」クラスをどのように書くだろうか？&lt;code&gt;swap&lt;/code&gt;を含めた方がいいだろうか？ムーブ可能であるとは何だっただろうか、それに期待するセマンティクスとは何だろうか？&lt;code&gt;noexcept&lt;/code&gt;指定子を使用するのはどんなときか？&lt;/p&gt;
&lt;p&gt;この90分のセッションでは、C++11での定型コードを探求する。このセッションでは、クラスや構造体を定義する際に適用する、右辺値参照、ムーブセマンティクス、完全転送、&lt;code&gt;explicit&lt;/code&gt;、&lt;code&gt;noexcept&lt;/code&gt;、初期化子リスト、その他多くのセマンティクスに触れる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#geometric-algebra&#34; name=&#34;geometric-algebra&#34;&gt;ジェネリック空間のジェネリックプログラミング： C++11を使用したコンパイル時幾何学的代数&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming of Generic Spaces: Compile-Time Geometric Algebra with C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/pablo_colapinto.1rzy8qoa?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Pablo Colapinto&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このグラフィクスハンズオンでは、組み合わせ生成計算量のためのテンプレートメタプログラミングの強力さを事例として、Versorと呼ばれるC++11の軽量なライブラリを使用してコンパイル時にN次元ジオメトリと空間を合成することを探求する。
ジオメトリを構築するテンプレート(アフィン、投影、等角、または実験)は、可変引数テンプレートと定数式を器用に使用することによって表現した。具体的には、コンパイル時に独自の最適化戦略として、リスト操作、並べ替え、幾何学的代数(geometric algebra)の評価をコンパイル時に行う新技術を提案する。&lt;/p&gt;
&lt;p&gt;この議論では、これら技術の開発を補助するために使用したC++11の基本的な機能と幾何学的代数の論理を解説する。対話(interactive)と視覚(visual)の両方で、ジェネリックプログラミング技法とジェネリック空間コンピューティング(generic spatial computing)の融合が、次元的流動性の式(a dimensional fluidity of expression)を可能にすることを調査する。2次元を介して4次元あるいはその上で、群論、ベクトル、行列、テンソル、リー代数(lie algebra)の効率的な実装をC++11のイディオムに結びつけることができる。これら関数は、物質科学(material science)から量子計算(quantum computation)まで、幅広い分野の多様なアプリケーション集合に適用できる。このアプローチで作成したビデオは &lt;a href=&#34;http://vimeo.com/wolftype&#34; target=&#34;_blank&#34;&gt;http://vimeo.com/wolftype&lt;/a&gt; で見ることができる。Versorの詳細については、 &lt;a href=&#34;http://versor.mat.ucsb.edu/&#34; target=&#34;_blank&#34;&gt;http://versor.mat.ucsb.edu/&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#concept-clang&#34; name=&#34;concept-clang&#34;&gt;ConceptClang：完全なC++コンセプトによる理論的な前進&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ConceptClang: Theoretical Advances with Full C++ Concepts&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/larisse_voufo.6ee82o0?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Larisse Voufo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンセプトはジェネリックプログラミングに不可欠な機能であり、C++の言語拡張として10年以上前から期待されてきた。これまでにいくつかの異なる設計のコンセプトが提案されてきたが、標準化への合意がとれなかった。2010年に私たちは、コンセプト機能の理解を補助することを主な目的として、コンセプトの異なる設計をConceptClangを実装した。それによって浮上した問題のひとつに、名前のバインディング、すなわち使用する名前と参照する宣言を一致させるプロセスがあった。これは、あらゆるコンセプトの設計をフルサポートするには、「弱い隠蔽(weak hiding)」と呼ばれる名前バインディングの新たなスコープルールが有用だということを意味する。弱い隠蔽は、合法に見えるプログラムを維持するために、制約のないテンプレートを制約付きテンプレートに遷移させることを可能にする。弱い隠蔽を実装するために、私たちは2ステージの名前バインディング(Bindx2)を導入した。これは既存の名前バインディングを弱い隠蔽でいかに拡張するかを定義する。Bindx2は、単純な関数呼び出しを、関連メンバ(associated members, 特殊メンバを含む)、演算子、型の要件といった名前の使用へと一般化する。驚くべき結果として、オープン／拡張可能なクラス／構造体は、完全なC++コンセプトのためにこれをコストなしに提供できた。&lt;/p&gt;
&lt;p&gt;このトークは主に、ConceptClangを使用する練習や、ハイライティング、Bindx2や「構造オープニング(structure opening)」アーキタイプなどの実装構造の動機を与える主要コンポーネントに焦点を当てる。参加者はコンセプトをいかに実装するかというだけでなく、C++コンセプトの設計を学ぶことを期待できるが、それだけでなく、コンセプトの必要性が高まる他言語にも影響する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#tdd-with-boost-test-turtle&#34; name=&#34;tdd-with-boost-test-turtle&#34;&gt;Boost.TestとTurtle Mockによるテスト駆動開発&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Test-Driven Development With Boost.Test and Turtle Mock&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/richard_thomas.1rzxpiib?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Richard Thomson&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;テスト駆動開発に含まれる3つの簡単なルールは、以下のようになっている：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;失敗するユニットテストのパスを作らない限り、プロダクトコードを書くことは許可しない。&lt;/li&gt;
&lt;li&gt;失敗している間は、それ以上のユニットテストを書くことは許可しない。コンパイルの失敗も失敗である。&lt;/li&gt;
&lt;li&gt;一つでもユニットテストが失敗してる間は、プロダクトコードを書くことは許可しない。一言で言えば、テスト駆動開発では、ユニットテストの失敗への応答としてプロダクトコードを書いていく。
このチュートリアルでは、単体テストフレームワークであるBoost.Testを使用して、C++でテスト駆動開発のアイディアを適用する方法を示す。Boost.Testの主要な機能は、アサーションからテストケースの設計、その管理までをカバーする。我々は、Boost.TestのためのモックオブジェクトであるTurtle Mockを通じて、状態ベーステストと振る舞いベーステストの違いまでをカバーする。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;はじめに、テスト駆動開発のメカニクスを示すために、いくつかの演習をやっていく。その次に、機能を実装していくにあたって設計活動としてテスト駆動開発を適用していく考え方を学んでいく。このチュートリアルでは、小さく、凝集度が高く、関心の分離をしているクラスを設計するために、テスト駆動開発が強力な設計ツールになることを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#bounded-integer&#34; name=&#34;bounded-integer&#34;&gt;整数演算から未定義動作を排除する、bounded::integerライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Removing undefined behavior from integer operations: the &lt;code&gt;bounded::integer&lt;/code&gt; library&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/david_stone.1rzy8qkl?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;David Stone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cから派生した言語では、整数の算術演算が悪名高く危険です。符号付き整数では、オーバーフローすると未定義動作になってしまい、符号なしではエラーも起こらず静かに値が一周します。符号ありと符号なしの整数を比較すると、暗黙に符号なしと見なされるため、符号ありの-1は符号ありの12よりも大きくなります。&lt;code&gt;int&lt;/code&gt;に保証されたサイズは、人々が期待し、必要とするよりも小さいです。この状況を改善する多くの試みは、すべての整数演算に、実行時にオーバーヘッドを追加するというものでした。&lt;/p&gt;
&lt;p&gt;このトークでは、&lt;code&gt;bounded::integer&lt;/code&gt;ライブラリを紹介する( &lt;a href=&#34;https://bitbucket.org/davidstone/bounded_integer&#34; target=&#34;_blank&#34;&gt;https://bitbucket.org/davidstone/bounded_integer&lt;/a&gt; )。&lt;/p&gt;
&lt;p&gt;C++14で書かれたこのライブラリは、以下を目標とする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コンパイル時チェックが可能な場合には、決して実行時チェックを行わない。&lt;/li&gt;
&lt;li&gt;確実によくない変換は許可しない。&lt;/li&gt;
&lt;li&gt;よくない可能性のある変換については、明示的な変換のみを許可する。&lt;/li&gt;
&lt;li&gt;より大きい整数型への暗黙変換を許可する。&lt;/li&gt;
&lt;li&gt;空間的および時間的なオーバーヘッドを持たず、インライン化のようなコンパイラの基本的な最適化を仮定し、&lt;code&gt;bounded::integer&lt;/code&gt;を非常に大きなデータセットやリアルタイム要件なシステムで使用できるようにする。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;bounded::integer&lt;/code&gt;は、整数型に対して静的な境界要件による保証を提供します。典型的な宣言としては、 &lt;code&gt;bounded::integer&amp;lt;1, 10&amp;gt; x(5);&lt;/code&gt; のように書くと、&lt;code&gt;x&lt;/code&gt;は1から10の範囲を生成します。算術式は、算術結果を自動的に範囲内に範囲内に維持し、境界を調整します。つまり、 &lt;code&gt;x + x&lt;/code&gt; と書くと、結果の型は &lt;code&gt;bounded::integer&amp;lt;2, 20&amp;gt;&lt;/code&gt; となります。&lt;code&gt;auto&lt;/code&gt;とテンプレートの型推論のおかげで、ユーザーは(コンパイル時に)保証されるすべての中間結果が正しいことを、型のみで規定できます。さらに、コンパイラはすべての整数の正確な境界を知っているので、このライブラリは「&lt;code&gt;int&lt;/code&gt;を使用する場合は、どこでも危険を避けること」という戦略よりも、空間的／時間的最適化が高速になります。&lt;/p&gt;
&lt;p&gt;このトークは、このライブラリを使用する際のイディオムである、&lt;code&gt;boost::constrained_value&lt;/code&gt;、Adaの整数型、無限範囲の整数モデル、それと制限と設計に関するトレードオフといった従来の研究も含むつもりです。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#afio&#34; name=&#34;afio&#34;&gt;Boostのピアレビューに向けてのC++11ライブラリAFIOの準備&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preparing the C++11 Library AFIO for Boost Peer Review&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/paul_kirth.1rzy8qjc?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Paul Kirth&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost C++ Librariesは、その卓越さのために当然ながらよい評価がされており、それは彼らに貢献する抗い難い魅力です。&lt;/p&gt;
&lt;p&gt;このトークでは、AFIOの経験を元に、既存のライブラリをBoostに移植するプロセスを、実例を通して解説します。このライブラリは、Boostのピアレビューに提出するために、Google Summer of Code 2013の期間中にC++11のみで書きました。なぜなら、示すコード例は開発者が直面する問題を強調すべきで、かつ問題に対するひとつのソリューションセットを提供すべきだからです。このトークは、Boostのビルドシステムによるコンパイラの内部エラーへの対処、プロセスの明確化、その他私が遭遇した困難な問題への解決策を示します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#value-semantics-range&#34; name=&#34;value-semantics-range&#34;&gt;値セマンティクスと範囲アルゴリズム - 合成と効率&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Value Semantics and Range Algorithms - Composability and Efficiency&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/chandlerc?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Chandler Carruth&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特定の条件を満たすシーケンス内の先頭N要素を計算するコードを、1行で書きたい。そして、適切な場所(in-place)でそれができるかどうかに関わらず、同じ行でコードを書きたい：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;predicate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このトークでは、範囲アルゴリズムの設計に値のセマンティクスを与え、その合成を通じて設計上重要な表現力を提供する方法を紹介する。最後に、この設計の効率的な問題と、それを解決する多くの合理的な詳細を提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#beware-cpp&#34; name=&#34;beware-cpp&#34;&gt;キーノート：C++に気をつけろ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Beware of C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/nicolai_josuttis.1rzxpihg?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Nicolai Josuttis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11(やC++14)によって、C++は別な言語になっている。アプリケーションプログラマは、宣言、初期化、イテレート、ムーブといったことが、以前よりもはるかに簡単にできるようになった。しかしながら、そこには理想的な「基礎ライブラリ開発者」だけが支払わなければならないコストが存在する。それは本当だろうか？平均的なアプリケーションプログラマは、C++11で効果的なプログラムを書くためのトリッキーな詳細についてどのくらい知る必要があるだろうか？物事の変化にともなって、我々の基本的なプログラミングパターンや方向性はどのように／どれくらい変化する必要があるだろうか。たとえば、C++11で、我々はテンプレートパラメータをどのように宣言し、&lt;code&gt;explicit&lt;/code&gt;をいつ使うべきだろうか？&lt;/p&gt;
&lt;p&gt;しかし、C++標準化委員会のライブラリワーキンググループは、これらの質問に明確な答えを持っていない。私のこのプレゼンテーションでは、平均的なアプリケーションプログラマのために、C++11標準ライブラリにおけるいくつかの問題点(detects)についての議論に基いて、洞察の組み合わせによって問題を解決する方法を紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#configuration-framework&#34; name=&#34;configuration-framework&#34;&gt;実用的なType Erasure： boost::anyベースの構成フレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Practical Type Erasure: A boost::any Based Configuration Framework&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/cheinan_marks.1rzy8qja?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Cheinan Marks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;構成(コンフィグレーション)フレームワークは、古典的なINIファイルからBoost.PropertyTree、その他とても多くのものが長い間存在してきた。しかしC++による実装での一つの問題として、健全なインタフェースを保ちながら異なる型を保持したり返したりするには、どうすればいいかというものがある。&lt;/p&gt;
&lt;p&gt;このトークで紹介する構成フレームワークは、文字列キーに基いて、コピー可能なあらゆるC++オブジェクトを返すことを可能にするフロントエンドの機能を持っている。バックエンドは、フロントエンドが意識することなくデータをメモリ、ファイル、データベース、その他任意のストレージに保持する仕組みを持っている。グルーレイヤー(glue layer : レイヤー間を繋ぐレイヤー)はフロントエンドとバックエンドを繋ぎ、渡されるデータの性質を気にしなくていいようにする。このマジックは、&lt;code&gt;boost::any&lt;/code&gt;とオブジェクトの組み合わせで、C++03の範囲で全て完結できます。このプレゼンテーションでは、このフレームワークの目標、設計、使用方法、&lt;code&gt;boost::any&lt;/code&gt;とtype erasureを使用することによる実用例を紹介する。時間があれば、簡単なバックエンドのストレージオブジェクトを開発する。&lt;/p&gt;
&lt;p&gt;このフレームワークのオリジナルは、アメリカ政府のプロジェクトで開発され、アメリカ納税者の好意によってパブリックドメインとなっている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#mach7&#34; name=&#34;mach7&#34;&gt;Mach7： C++のためのパターンマッチングライブラリの設計と進化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mach7: The Design and Evolution of a Pattern Matching Library for C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/solodon?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Yuriy Solodkyy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;パターンマッチングは、ソースコードを大幅にシンプルにする抽象メカニズムです。とくに、型の検査を行うビジターパターンを、より使いやすく、より高速にする代替手段となります。C++で実装されたMach7という、関数型スタイルのパターンマッチングのライブラリを紹介します。その解決策は非侵入的で、かつ新たなパターンマッチングの導入とクラスの拡張性、両方に対してオープンになっています。このプレゼンテーションは、いくつかの設計選択、実装詳細、初期ユーザーからのフィードバック、およびその他の要因を主に話します。このプレゼンテーションは、より多くの開発者にパターンマッチングに興味を持ってもらうこと、そしてそれがC++のようなオブジェクト指向言語にとりいれることができることを知ってもらうことを、目的とします。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#intro-cpp11-14-1&#34; name=&#34;intro-cpp11-14-1&#34;&gt;C++11/14入門 パート1&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Tutorial Introduction to C++11/14 Part I&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/leor_zolman.1rzxt7h5?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Leor Zolman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これは、C++11とC++14の機能を紹介する2つのプレゼンテーションのひとつめです。言語の小さな側面(aspect)のほとんどをカバーしています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++のタイムライン&lt;/li&gt;
&lt;li&gt;C++11/14の目標&lt;/li&gt;
&lt;li&gt;よりシンプルなコア言語の新機能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;decltype&lt;/code&gt;, 末尾の戻り値型&lt;/li&gt;
&lt;li&gt;非メンバ関数版の&lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nullptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;範囲&lt;code&gt;for&lt;/code&gt;文&lt;/li&gt;
&lt;li&gt;テンプレートに特化した&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static_assert&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;extern template&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noexcept&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可変引数テンプレート&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;関数とデータ&lt;/li&gt;
&lt;li&gt;テンプレートによる別名付け&lt;/li&gt;
&lt;li&gt;新たな文字リテラル型&lt;/li&gt;
&lt;li&gt;生文字列リテラル&lt;/li&gt;
&lt;li&gt;リテラル文字列と&lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その他、スコープ付きの&lt;code&gt;enum&lt;/code&gt;、&lt;code&gt;long long&lt;/code&gt;、&lt;code&gt;alignas&lt;/code&gt;/&lt;code&gt;alignof&lt;/code&gt;、属性、インライン名前空間、汎用&lt;code&gt;union&lt;/code&gt;／POD、ガベージコレクションABI、ユーザー定義リテラルも紹介します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#intro-cpp11-14-2&#34; name=&#34;intro-cpp11-14-2&#34;&gt;C++11/14入門 パート2&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Tutorial Introduction to C++11/14 Part II&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/leor_zolman.1rzxt7h5?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Leor Zolman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これは、C++11とC++14の機能を紹介する2つのプレゼンテーションのふたつめです。言語に追加された、大きめな機能をカバーしています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;クラス設計のための機能：生成される関数への&lt;code&gt;default&lt;/code&gt;／&lt;code&gt;delete&lt;/code&gt;指定、移譲／継承コンストラクタ、柔軟性のある新たなクラス内初期化、明示的な型変換演算子、&lt;/li&gt;
&lt;li&gt;初期化： initializer list、一様初期化, 精度を損なうことの防止&lt;/li&gt;
&lt;li&gt;ラムダ式&lt;/li&gt;
&lt;li&gt;右辺値参照：左辺値と右辺値 (その現代的な見方)、ムーブセマンティクス、普遍的な参照(universal references)、完全転送(perfect forwarding)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a name=&#34;space-plasma&#34;&gt;宇宙プラズマモデル開発でのC++11&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11 in Space Plasma Model Development&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/ilja_honkonen.1rzxt7jj?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Ilja Honkonen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最新のC++標準規格の利点として、超並列計算(宇宙プラズマ)モデルの開発に関する議論ができるようになったというのがある。とくに可変引数テンプレートは、直列でも並列でもどちらに対しても、パフォーマンスを損なうことなく、読みやすく、非常に拡張性の高い計算モデルの開発を可能にする。このプレゼンテーションでは、可変引数テンプレートの基礎を理解しておくことは必要だが、宇宙プラズマの知識は必要ない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#cpp11-library-design&#34; name=&#34;cpp11-library-design&#34;&gt;C++11ライブラリ設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11 Library Design&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/eric_niebler?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;君がもしいま再利用可能なコードを書いていて、C++11の新機能をフル活用できないなら、ちょっと立ち止まってみてほしい！そのようなことをするためのルールは、下から(パラメータの渡し方とか)上まで(ライブラリのバージョニングとか)変わっている。C++11によって書かれたコードは、これまで以上に簡単に、より強力に、より安全に使えて、モジュール性が高く組み合わせもしやすくなり、ボイラープレートも少なくなる。つまり、妥協のないライブラリ設計ができるということだ。&lt;/p&gt;
&lt;p&gt;このトークでは、いくつかの関数、クラス、「モジュール」を、効率的に、再利用性が高く、組み合わせがしやすく、バージョニングもできるよう設計する、C++11をフル活用したベストプラクティスについて説明する。これは全体的に、作者が今日の現代的なコンパイラで数年間、再利用可能なコードについて学んだことだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#octopus&#34; name=&#34;octopus&#34;&gt;Octopus: CFDシミュレーションのためのポリシー駆動フレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Octopus: A Policy-Driven Framework for CFD Simulations&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/brycelelbach?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Bryce Adelstein-Lelbach&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Octopusは、HPX C++ランタイムシステム上に実装した、科学アプリケーション向けの解適合格子(Adaptive Mesh Refinement、AMR法)ライブラリである。Octopusは、ドメイン科学者が、AMR法として知られている技術を利用し、空間分解能の異なるスケールを持つ直交格子(Cartesian Mesh)の階層に対して計算流体力学(CFD : computational fluid dynamics)の問題を解くことを可能にする。ルイジアナ州立大学の天体物理学者は、連星合体(binary star mergers)のような重要な現象のシミュレートをするために、Octopusを使用している。&lt;/p&gt;
&lt;p&gt;Octopusはポリシー駆動のフレームワークである。ドメイン科学者はポリシーを選択し、カスタマイゼーションポイントとして知られているインタフェースを、コンパイル時または実行時に決定する。これらのポリシーは、アプリケーション機能を実装するために基礎フレームワークで使用される。Octopusの多くの側面は、時間の離散化(time discretization)、補完(interpolation)や空間分解(spatial decomposition)を、ポリシーによって完全にコントロールできる。&lt;/p&gt;
&lt;p&gt;このトークでは、効率的で、拡張性が高く、アクセスしやすいライブラリを、ポリシーを使用していかに構築するのかについて説明する。我々は、この強力なジェネリックプログラミング手法が、複雑なネットワークや同期コードを抽象化によって科学者から引き離せることを示す。&lt;/p&gt;
&lt;p&gt;このトークの対象者は、科学計算、ライブラリ設計やジェネリックプログラミングといった分野に関心のある開発者である。参加者は、背景となる数学や天体物理学といった専門知識を持っている必要はない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#better-code&#34; name=&#34;better-code&#34;&gt;よりよいコードへの道しるべ：完全な型を実装する&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Goals for Better Code: Implement Complete Types&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/sean_parent?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Sean Parent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GoingNative 2013の「C++ Seasoning」という発表では、よりよいコードのために3つの道しるべを説明した。その発表では、C++における基本的な要素である型、参照と、それらの基礎的な動作について話した。今回は、一般的なすべての型について、その型を定義すること（と、その物理的な本質）によって導かれる結果、そしてなぜ完全な型を実装することが賢いゴールなのかを見ていく。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#multiplatform-cpp&#34; name=&#34;multiplatform-cpp&#34;&gt;マルチプラットフォームでのC++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Multiplatform C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/edouard_alligand.1rzxt7if?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Edouard Alligand&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションは、クロスプラットフォームなソフトウェアを開発するに際によくある疑問を解決するためにある。「各環境によって提供される様々なツールチェインを使ってWindowsやLinuxでビルドするにはどうすればよいか？」「LinuxとFreeBSDのような違いにはどう対処すべきか？」「各環境を横断するツールはどのように使うべきか？」「急激に増えるメンテナンスコストをいかに抑えるか？」
さらにこのセッションでは、マルチプラットフォーム開発における隠れた恩恵なども紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#boost-library-incubator&#34; name=&#34;boost-library-incubator&#34;&gt;Boost Library Incubator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/robert_ramey.1rzy8qo7?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Robert Ramey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Boostはこれまでとんでもない成功を収めてきたが、同時に自身がその成功の餌食となってきている。泥沼なのである：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各ライブラリのレビューにはずいぶん時間がかかる&lt;/li&gt;
&lt;li&gt;レビューマネージャを探すのが大変&lt;/li&gt;
&lt;li&gt;満足にレビューされていない&lt;/li&gt;
&lt;li&gt;ライブラリの中にはメンテナがいないために放っておかれているものがある&lt;/li&gt;
&lt;li&gt;ライブラリのドキュメントは十分とはいいがたい&lt;/li&gt;
&lt;li&gt;ライブラリサイズはどんどん大きくなり、そして管理とデプロイがどんどん大変になっている&lt;/li&gt;
&lt;li&gt;いくつかのライブラリは時代遅れだが、それを廃止する方法もない&lt;b&gt;しかし&lt;/b&gt;、今まで以上に、C++はさらなるよりよいライブラリを必要としている!!!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は、上記のような問題に対する自分のアイディア考え、ウェブサイトに落とし込んだ。それがBoost Library Incubatorだ (&lt;a href=&#34;http://rrsd.com/blincubator.com/&#34; target=&#34;_blank&#34;&gt;http://rrsd.com/blincubator.com/&lt;/a&gt;)。私は、このウェブサイトを通して上記のような問題を提言していくつもりである。これが、これからのBoostのさらなる発展と革命に役立てばと思っている。ここにいるたくさんの熱意ある参加者達に期待しているよ!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#optimization-network-server&#34; name=&#34;optimization-network-server&#34;&gt;Boost.Asioベースのネットワーク・サーバ最適化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Optimization of a Boost.Asio-Based Networking Server&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/nikita_chumakov?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Nikita Chumakov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Yandexはロシア最大のインターネット企業の一つです．Yandexは，ウェブ検索や，e-mail, 地図，写真，ホスティングなどの双方向なネットワークサービスを提供しています．私達のチームでは，600万人のアクティブユーザが発する一日あたり5000万以上のメッセージを送信，処理，受診するためのe-mailバックエンドシステムを開発しています．&lt;/p&gt;
&lt;p&gt;本講演では，これらのタスクに対して，Boost-basedなソリューションを検討し，そのパフォーマンスに対する効果を議論します．まず初めに，シンプルなAsio+Spiritベースの実装についてその問題点と限界について議論し，その後，ワークアラウンドと最適化手法を提案します．特に，私達はどのようにリアクターパターンがパフォーマンスに影響を与えるか，どのようにコルーチンと私達が特別に改造したスマートstreambufsがメモリ/CPUリソースを削減するかについて示します．&lt;/p&gt;
&lt;p&gt;(最後に，我々は，本講演に参加こそされていませんが，本発表で用いているコードの作成に尽力して頂いたAlexander Drachevskiyの努力に感謝を表明します．)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#undefined-behavior&#34; name=&#34;undefined-behavior&#34;&gt;C++の未定義動作； それは何か、そしてなぜ気にしなければいけないか&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Undefined Behavior in C++; what is it, and why should I care&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/marshall15?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Marshall Clow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CやC++の未定義動作(UB : Undefined Behavior)は、先人たちによって次々と明らかにされてきた。これらはいくつかの大学では研究の題材としても注目されているが、コード生成器では最適化の際にごく普通にUBの情報を利用している。&lt;/p&gt;
&lt;p&gt;このセッションでは、まず初めにUBの例について示す。次に、コード生成時にオプティマイザはどのようにUBを処理しているかを示す。さらに、あなたのコードにUBが入り込まないようにするための戦略について述べる（これはBoostを題材にする）。そして最後に、既存コードからUBを発見するための最新の（＋将来の）ツールを紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#mpl11&#34; name=&#34;mpl11&#34;&gt;MPL11: C++11の新たなメタプログラミングライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MPL11: A New Metaprogramming Library for C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/ldionne?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Louis Dionne&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このトークには、2つの異なる、だが関連のある目標があります。はじめに、C++03からのピンポイントな改善として、C++11でのテンプレートメタプログラミングのベンチマークと事例研究を示します。これは、Boost.MPLの将来を客観的に議論できるようにするための基礎を提供します。ふたつめは、Boostに提案するBoost.MPLの後継となるC++11テンプレートメタプログラミングライブラリ( &lt;a href=&#34;https://github.com/ldionne/mpl11&#34; target=&#34;_blank&#34;&gt;https://github.com/ldionne/mpl11&lt;/a&gt; )の、一般的な目的を示します。ライブラリの中核となるコンセプトを導入し、いくつかの設計選択を説明し、現在のBoost.MPLと客観的な比較を行います。&lt;/p&gt;
&lt;p&gt;このトークは、テンプレートメタプログラミングと関数型プログラミングをよく知っている人向けです。TMPを多用し、FPに興味を持っている人は、最も恩恵を受けるでしょう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#libcppa&#34; name=&#34;libcppa&#34;&gt;libcppa: C++での型安全なメッセージングシステム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;libcppa: Type-safe Messaging Systems in C++&lt;/li&gt;
&lt;li&gt;スピーカー：  &lt;a href=&#34;http://cppnow2014.sched.org/speaker/dominik_charousset.1rzy8qml?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Dominik Charousset&lt;/a&gt;, &lt;a href=&#34;http://cppnow2014.sched.org/speaker/matthias_vallentin.1rzy8qmx?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Matthias Vallentin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;アクターモデル(actor model)というメッセージ指向のプログラミングパラダイムでは、並行および分散のアプリケーションを標準C++の機能を使うよりも、エラーを少なくし、簡潔に記述でき、理解しやすく、デバッグしやすくします。このトークでは、C++で複雑な分散アプリケーションを構築するために、libcppaによって提供されるコンセプトとサポートを調査します。&lt;/p&gt;
&lt;p&gt;前半は、Dominik CharoussetがC++Now! 2013以前から開発している、C++による新たなアクタープログラミングを導入する。具体的には、分散をアプリケーションで強い型付けのメッセージングを可能にする、アクターの型安全インタフェースという新機能を紹介する。&lt;/p&gt;
&lt;p&gt;後半は、Matthias Vallentinが、libcppaを使用して分散データベースを構築する、&#34;巨大な&#34;スケーラビリティについての事例研究をカバーします。このシステムは、アクターのみならずクラスターベースのデプロイでのネットワーク透明性機能を使用するが、データ取得やクエリ処理などといった、クリティカルパスへのきめ細やかな並列処理によってタスクをスピードアップする。また、プロファイラの結果分析を通じて並列パイプライン処理でのボトルネックコンポーネントを並列化する方法を紹介します。さらに、libcppaのアクターモデルが分散索引システム(distributed indexing system)の設計にどのように役立つかを示します。&lt;/p&gt;
&lt;p&gt;このトークのVallentinの部分は、録画されません。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#unicode&#34; name=&#34;unicode&#34;&gt;C++でのUnicode&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Unicode in C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/james_mcnellis.6ee6ir6?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;James McNellis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一部のプログラミング言語では、テキスト処理は簡単です。残念ながら、C++はその「一部」には含まれない言語です。C++の状況は改善されはじめてはいますが、Unicodeの組み込みサポートが欠如しています。&lt;/p&gt;
&lt;p&gt;このセッションは、テキストエンコーディングの概要、Unicodeの入門と、さまざまなUnicodeのエンコーディングから始めます。C++98の悲惨なUnicodeサポートを確認し、C++11で行われた改善と、標準化委員会に最近提案されているその他の改善を見てみましょう。最後に、C++で広く使われているUnicodeを操作しやすくするよう設計されたオープンソースライブラリ、International Components for Unicode (ICU)について説明します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#metaprogramming-shell&#34; name=&#34;metaprogramming-shell&#34;&gt;Clangベースのインタラクティブなメタプログラミングシェル&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interactive Metaprogramming Shell Based on Clang&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/abel_sinkovics.1rzy8qla?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Ábel Sinkovics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;メタプログラミングの開発はしんどい。Templight ( &lt;a href=&#34;http://plc.inf.elte.hu/templight/&#34; target=&#34;_blank&#34;&gt;http://plc.inf.elte.hu/templight/&lt;/a&gt; )はテンプレートメタプログラムの開発とデバッグをサポートしているが、コードの小さな変更のたびに再コンパイルが必要だし、結果に関する有用な情報を得るためにトリックを必要とする。&lt;/p&gt;
&lt;p&gt;多くの言語(Python, Haskell, Erlangなど)は、コードを試すとすぐに結果を表示する、インタラクティブなシェルを提供している。たとえばPythonのシェルで、簡単なリストへの要素追加は、以下のように結果表示される：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このシェルはすぐに結果を表示できる。開発者は、自分のコードをコンパイルし、式の結果を確認するデバッガを起動する必要はない。&lt;/p&gt;
&lt;p&gt;このトークでは、テンプレートメタプログラミングのためのインタラクティブなシェルである、Metashellを紹介する。これはPythonのシェルのように使いやすい、テンプレート メタプログラミングのためのテストと開発の環境を提供する。たとえば以下のように操作できる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34;&gt;&lt;pre&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mpl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hpp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mpl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push_front&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hpp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;metashell&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hpp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;namespace&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;boost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;push_front&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;boost_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mpl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このシェルは結果として、テンプレートメタプログラムを表示する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Metashellはここで利用できる： &lt;a href=&#34;https://github.com/sabel83/metashell&#34; target=&#34;_blank&#34;&gt;https://github.com/sabel83/metashell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ブラウザでオンラインで試すのはここ： &lt;a href=&#34;http://abel.web.elte.hu/shell&#34; target=&#34;_blank&#34;&gt;http://abel.web.elte.hu/shell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MetashellはlibClangライブラリをベースとしている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#cpp-amp&#34; name=&#34;cpp-amp&#34;&gt;C++ AMPを用いたアクセラレータプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Accelerator Programming with C++ AMP&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/brycelelbach?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Bryce Adelstein-Lelbach&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日，ヘテロジニアスプログラミングはC++が用いられる多くの領域で利用されています．データセンタでは大量のデータを処理するためにGPGPUを用い，スーパコンピューティングの分野では計算能力の大部分を提供するためにアクセラレータの利用が進み，モバイルデバイスでは，&#34;計算能力(capability)&#34;の高いCPU群と&#34;計算容量(capacity)&#34;の高いGPUを組み合わせることで，高効率な計算能力を提供しています．&lt;/p&gt;
&lt;p&gt;一般的には，アクセラレータはプログラムの一部の部分を実行することに適しています．アクセラレータは，プログラム全体の実行方針の決定やメインメモリへのアクセス，周辺ハードウェアへのアクセスのためにCPUに依存しています．この，CPUとアクセラレータ，その他システムコンポーネント間の頻繁なインタラクションは，ヘテロジニアスシステムを複雑にしています．&lt;/p&gt;
&lt;p&gt;さらに，アクセラレータはオフチップに実装されていたり，自身のプライベートメモリをもっていたり，大きな通信レイテンシを持っていたりします．ヘテロジニアスシステムは複数のベンダ固有のプロセッサインタコネクトで通信する複数のCPUを持っていることもあります．システムは，ストレージやネットワークを多用するアプリケーションによってさらに複雑になることがあります．&lt;/p&gt;
&lt;p&gt;多くのC++プログラマにとって，ヘテロジニアスプログラミングはもはや贅沢品ではなく，必要なものです．C++14は，ヘテロジニアスプログラミングに関する仕組みを提供していません．C++プログラマがアクセラレータの能力を利用するためには，ソフトウェアライブラリに頼る必要があります．アクセラレータを利用するための高品質なフレームワークは多くありますが，それらは特定のアクセラレータのみで利用可能であるか，純粋な同期オフローディングモデルを重要視したものです．&lt;/p&gt;
&lt;p&gt;マイクロソフトによって公開されたC++ AMPの仕様では，モダンなC++からアクセラレータを利用するためのハードウェアに依存しないインタフェースを提供しています．C++ AMPは，言語拡張と，STLライクなライブラリコンポーネントで構成され，同期，非同期両方のオフローディングモデルを提供します．C++ AMPによって，ユーザはヘテロジニアスなハードウェアについての詳細な知識なしに，アクセラレータを活用したアプリケーションを記述することが出きます．&lt;/p&gt;
&lt;p&gt;Visual Studioによる成熟したC++ AMP実装に加え，C++ AMPの実装は複数のプラットフォーム上に存在します．いくつか例を挙げると，インテルのShevlin Parkと呼ばれるものや，HSA Foundationが開発しているClang-based C++ AMP実装などが挙げられます．&lt;/p&gt;
&lt;p&gt;このチュートリアルでは，C++ AMPの概要について，ソフトウェア中心の視点から，以下のトピックスについて紹介します．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アクセラレータに対するデータの準備&lt;/li&gt;
&lt;li&gt;アークセラレータとの間のデータ転送&lt;/li&gt;
&lt;li&gt;アクセラレータへのコードのオフロード（例. &lt;code&gt;restring(amp)&lt;/code&gt;, &lt;code&gt;parallels_for_each&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;アクセラレータの並列性のコントロール(例. &lt;code&gt;tilling&lt;/code&gt;, &lt;code&gt;barrires&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本講演では，書き込み待ちなし(write wait-free offloading)のコードオフローディングを行うためにC++ AMPが提供する非同期インタフェースについて，特に強調します．&lt;/p&gt;
&lt;p&gt;対象とする聴衆は，アクセラレータを用いている/用いる予定のあるC++デベロッパです．本講演では，特定のアクセラレータや特定のC++ AMP実装に限った話が含まれます．本プレゼンテーションは，全てのプラットフォーム開発者に関係があり，windowsに限ったものではありません．&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#cpp-components&#34; name=&#34;cpp-components&#34;&gt;CppComponents: C++11のモダン,ポータブルなコンポーネントシステム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/john_bandela.1rzy8qkp?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;John Bandela&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;優れたコンポーネントシステムを持っていないことは，C++の大きな問題点の一つである．他の言語は、プレビルドされたライブラリを簡単にあなたのプロジェクトに組み入れる能力を持っている。一方，C++では、異なるコンパイラ、同じコンパイラの異なるバージョン、デバッグ/リリースビルドの違い、どの場合においてもABI互換性がないため、頻繁にコードのリビルドを行うことになる．良いコンポーネントシステムは、パッケージングや、ライブラリの利用を簡単にする．本講演では、あなたにCppComponetsを紹介する。CppComponetsは、あなたに別のプロジェクトでコンパイルされたバイナリや、スタンダードライブラリなどを簡単に利用する手段を与える。あなたはstring,vector,tuple,chronoなど標準ライブラリを関数パラメータや返り値，例外などに利用し続けたままCppComponentsを使用することが出来る．加えて，CppComponetはクロスABI互換関数，&lt;code&gt;futures&lt;/code&gt;, &lt;code&gt;promises&lt;/code&gt;, &lt;code&gt;executors&lt;/code&gt;, 及び&lt;code&gt;channels&lt;/code&gt;を提供する．これら全てはヘッダオンリライブラリであり，C++11標準ライブラリのみに依存する．&lt;/p&gt;
&lt;p&gt;本講演ではまず，CppComponetsを支える技術について紹介し，CppComponetsを使い，複数のコンパイラから利用可能なバイナリコンポーネントを簡単に作成する例を提供し，そのコンポーネントがマルチスレッドプログラムやネットワークプログラムをシンプルにする例をお見せする．その後，簡単な依存性注入や，動的な名前ベース呼び出しなどのいくつかの高度なテクニックを見ていく．
本講演のまとめとして，CppComponetsがどのようにC++PyPIや，C++を簡単に多くのドメインで利用可能にするためのC++ components renaissanceを可能とするかなどのCppComponetsの将来的な方向性についてまとめる．&lt;/p&gt;
&lt;p&gt;本講演の対象者は，中級，上級のC++プログラマであるが，初級のC++プログラマにとっても，有用な情報が含まれる．&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#ui&#34; name=&#34;ui&#34;&gt;UI、美学、C++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;UI. Aesthetics. C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/tony_van_eerd.1rzy8qjc?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そそられる感覚&lt;br /&gt;
作用と応答、原因と結果&lt;br /&gt;
これらのシンボルは何だろう？  &lt;/p&gt;
&lt;p&gt;このセッションはたぶんUIについてであり、もしかしたら美学についてであるが、もちろんC++についてである。願わくは新人プログラマにも熟練プログラマにもかかわる話になればよいのだが。少々哲学的かもしれないが、日々のコーディングに役立つかもしれない。&lt;/p&gt;
&lt;p&gt;ロックフリープログラミングについてではもちろんないので、どうぞ気分転換にでも。:-) &lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#design-xml-api&#34; name=&#34;design-xml-api&#34;&gt;最新C++を使ったXML API設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Designing XML API for Modern C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/boris5?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++向けのXMLパース/シリアライズライブラリが氾濫しているが、もともと他の言語向けに開発され、イディオムを最低限考証した程度のC++対応になっているものがほとんどであるようだ。万人が満足しうるXML APIを設計するのは極めて難しい。事実、Boostコミュニティで度々試みられたにもかかわらず、C++標準はもちろん、BoostにさえもXMLライブラリがないことがその証左となるだろう。実際、ストリーミング(SAX)対インメモリ(DOM)の議論から先にすすむことは滅多にない。&lt;/p&gt;
&lt;p&gt;このセッションでは、別のアプローチを試み、C++アプリケーションで一般的なXMLの利用パターンについてまず考えてみる。次に、このことから導出される、パースおよびシリアライズ可能なXML API設計と実装について示す。利用パターンは低レヴェルXML加工(ドキュメント中心アプリケーション)から、単にデータ保持媒体としてXMLを閲覧する(データ中心アプリケーション)まで幅があるので、提示するAPIは低レヴェルアクセスから始め、それをもとにより高度な抽象化を組みあげていく。&lt;/p&gt;
&lt;p&gt;完全を期すため、XML1.0パーサ適合であるとはどういうことか(ヒント：週末におもしろ半分で作ったようなものは多分適合していない)、既存のC++向けのXMLライブラリ/ツールと、その利点と欠点について、そしてXML Schema、XPath、XQueryのようなXML関連技術と、それらが全体図のどこに嵌まるのかについて、といったトピックにも触れることにする。&lt;/p&gt;
&lt;p&gt;聴講者が実際に直面しているユースケースを、このXML APIで満足できるかどうかについてのフィードバックも歓迎する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#understanding-double-and&#34; name=&#34;understanding-double-and&#34;&gt;&amp;amp;&amp;amp;を理解しよう&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Understanding &amp;amp;&amp;amp;&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/s.scott.schurr?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11では右辺値参照、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;が導入された。この単なる二つの&lt;code&gt;&amp;amp;&lt;/code&gt;はムーヴセマンティクスを与える魔力を持っている。しかし、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;は実のところ、さらに強力だ。&lt;code&gt;std::move&lt;/code&gt;と&lt;code&gt;std::forward&lt;/code&gt;に隠された力もやはり&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;だ。加えて、聞いたことがあるかもしれないがUniversal Referencesも&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;を基礎にしている。&lt;/p&gt;
&lt;p&gt;このような力をもつので、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;はややトリッキーであることがわかる。このプレゼンテーションでは&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;のさまざまな使いかたを説明する。読んだり書いたりするコードにでてくる&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;の持つさまざまな意味をどう区別するかについても触れる。さらに、コード中で&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;を利用するベストプラクティスについても述べる。このプレゼンテーションは、いったいぜんたい&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ってどういう事か知りたいC++初心者から、&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;を使おうとして思った通りに動かなかった中級者向けである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#concurrent-assembly&#34; name=&#34;concurrent-assembly&#34;&gt;並行アセンブリとしての最新のC++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Modern C++ as Concurrent Assembly&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/diego_perini.1rzy8qlm?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Diego Perini&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ — あらたに採用された、高速に進化する開発サイクルの助けを持つ — は、現世代のアセンブリ言語となった。C++には、それ自体で、並行性をサポートする、真新しい、ドメインに依存しない言語を開発する基礎が揃っている。&lt;/p&gt;
&lt;p&gt;Dopplは効率的なキャッシュ、高度な並行性、データ指向デザイン、言語の構成としてノンブロッキングロジックをもつプログラミング言語である。この言語はC++11と最新の安定標準ライブラリ実装の上に実装されている。&lt;/p&gt;
&lt;p&gt;このセッションでは、Dopplの機能を実現するにあたり利用した、&lt;code&gt;&amp;lt;thread&amp;gt;&lt;/code&gt;由来のツールや関数型プログラミング由来の材料、CそしてC++11で導入された機能について焦点をあてる。Dopplのサンプルソースコードはその高次構造を聴衆に紹介するために、参考としてのみご覧いただくつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#value-semantics&#34; name=&#34;value-semantics&#34;&gt;値のセマンティクス：シンタックスについてじゃないよ!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Value Semantics: It ain’t about the syntax!&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/john_lakos.1rzy8qns?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;John Lakos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;値のセマンティクス&lt;/strong&gt;を持つような型について議論するとき、値で関数に渡せる(もしくは返せる)、ということに着目しているだろう。このような型を設計するために、C++はその型についてコピーコンストラクタを要求するので、プログラマは「この型のオブジェクトはそもそもコピー可能であるべきか？」という疑問にフタをして、日常的に自分のクラスにコピーコンストラクタを実装している。もしそうなら、コピーの真実とはなんだろう？元のオブジェクトと完全に同じ状態を持つべきなのか？オブジェクトをコピーするとはなんなんだ？!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;値型&lt;/strong&gt;については、型は(値の)セットを特に表現するものと捉える人が多い。しかし、&lt;strong&gt;値のセマンティック型&lt;/strong&gt;については、数値と同様の操作を提供する抽象数値型(例えば整数、文字セット、複素数の配列)と捉えている。値のセマンティック型のオブジェクトをコピーしたとき、適切な値のセマンティック型の新しいオブジェクトは、元のオブジェクトと同じ値を持っているにもかかわらず、コピー先のオブジェクトは元のオブジェクトと同じ状態を保持していない可能性、さらには同じふるまいをしない可能性がある。&lt;/p&gt;
&lt;p&gt;このセッションでは、たとえば値の&lt;strong&gt;顕著な属性&lt;/strong&gt;の識別、および 自然に値を表現するオブジェクトとそうでないものとを比較することで、値の意味について直感的な感覚を得ることから始める。一般的な値型のシンタックス上特徴を概説した後、値のセマンティクスにかかわるより深い問題について考えていく。特に、値セマンティックオブジェクトにおいて、あらゆる&lt;strong&gt;顕著な&lt;/strong&gt;変化を伴う操作に適用される、微妙な「値の基本的性質」について探求し、より興味深い(値セマンティクスの)クラスを正しく設計するために、この特性を有効利用してみる。 &lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#iterators-may-stay&#34; name=&#34;iterators-may-stay&#34;&gt;イテレータはまだ生き残る&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Iterators May Stay&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/sebastian_redl.1rzy8qkf?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Sebastian Redl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンテナとアルゴリズムを繋ぐ便利なインタフェースへの探究は、標準ライブラリのイテレータでも止められなかった。Boost.Rangeは、たくさんあるインタフェース候補の1つにすぎない。近年、異なるアプローチがあれこれ現れ、C++標準化委員会のRangesグループもこの探究に参加し始めた。&lt;/p&gt;
&lt;p&gt;このセッションでは、これらの様々なアプローチを比較し、それぞれの利点と欠点を述べる。聴講者には、標準のアルゴリズム/コンテナライブラリに関する知識・経験を有していること、ジェネリックプログラミングに関する要点を理解していることが求められる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#refactoring-tool&#34; name=&#34;refactoring-tool&#34;&gt;Clangを使ったリファクタリングツールの自作&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Create Your Own Refactoring Tool with Clang&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/richard_thomas.1rzxpiib?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Richard Thomson&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++のリファクタリングツールは他の言語よりも遅れている。だれしもC++でパースと推論するのが非常に難しいからだという言いわけを聞いたことがあるだろう。それじゃ、Clangを使ったツール基盤を見てメロメロになってもらおうか。実に簡単にリファクタリングツールが書けるようになる。&lt;/p&gt;
&lt;p&gt;このセッションでは、段階的にClangを使って、関数の仮引数リストが「&lt;code&gt;(void)&lt;/code&gt;」になっているのを空のリスト「&lt;code&gt;()&lt;/code&gt;」に変換するリファクタリングツールを作っていく。この過程で、Clang由来のツールライブラリをどう使えばよいか、すなわち、パース済みの抽象構文木(AST: abstract syntax tree)の探査法、ASTの要素に合致するコードの記述、ツールライブラリを利用した、ソースコード変換を行なうための合致するノードの操作法といったことついて十分な知見が得られるだろう。&lt;/p&gt;
&lt;p&gt;時間があれば、リファクタリングツールの別の例についてもごらんいただき、その動作について議論したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#combinatorial-algorithm&#34; name=&#34;combinatorial-algorithm&#34;&gt;C++を用いた複雑な組み合わせ最適化アルゴリズムの設計と実装&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How to Design C++ Implementations of Complex Combinatorial Algorithms&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/piotr_wygocki.1rzy8qmt?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Piotr Wygocki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本講演では、最適化フレームワークの設計についての具体的な一つの方法に焦点を当てます。最適化アルゴリズムを設計する際には、汎用的かつ簡単に拡張可能であることだけでなく、ユーザフレンドリーなインタフェースを提供するという問題に直面するでしょう。私達は、C++11で導入された新しい機能を含む、テンプレートを主に用います。&lt;/p&gt;
&lt;p&gt;一つの例として、ローカルメタヒューリスティックサーチ問題を例にあげましょう。ローカルサーチは非常に有名な最適化手法の一つです。この手法は非常に自然な手法である一方、実際の問題に対して非常によい結果をもたらします。多くのシミュレーテッドアニーリングなどのヒューリスティック最適化アルゴリズムの非常に良い一般化であるローカルサーチに言及することには、大きな価値があります。&lt;/p&gt;
&lt;p&gt;本講演では、複雑なアルゴリズムをテンプレートメタプログラミングを用いて設計することに興味を持っている人に向けたものです。講演を理解するためには、一部C++11のスキルが必要となります．&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#intro-fp&#34; name=&#34;intro-fp&#34;&gt;C++における関数型プログラミング入門&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Intro to Functional Programming in C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/david_sankel.1rzy8ql9?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;関数プログラミングの核心とはなんだろう？ Haskellをやる必要はないのか？ 関数プログラミングはオールオアナッシングなものか？ C++を「より関数型に」するメリットは？ もしメリットがあるなら、どうやって関数型にしていけばいいの？ &lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#object-lifetimes&#34; name=&#34;object-lifetimes&#34;&gt;オブジェクト生存期間の管理&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Managing Object Lifetimes&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/marshall15?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Marshall Clow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の強力な機能として、決定性の、スコープベースのオブジェクト生存期間が挙げられる。適切に利用すれば、リソースリークのない、例外安全なコードが記述できる。このセッションでは例を示し、コードを単純に、読みやすく、もちろん正しく書くための技法について議論する。&lt;/p&gt;
&lt;p&gt;まずは構築/破棄の基礎からはじめ、RAIIとスマートポインタについて触れ、例外安全について議論し、最後にパラメータを渡すさいの所有権について議論する。&lt;/p&gt;
&lt;p&gt;話の途中で、このスタイルのプログラミングがより容易になるC++11とC++14の変更についても議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#badcode&#34; name=&#34;badcode&#34;&gt;0xBADC0DE&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/jens_weller.1rzy8qkc?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Jens Weller&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自身のフリーランサーやコーチとしての経験が、このセッションを行う動機になっている。いろいろなところで、いいコードも悪いコードもたくさん見てきた。&lt;/p&gt;
&lt;p&gt;このセッションでは悪いコードの例をみていくだけではなく、そもそも何故それが存在しているのか解析し、どのように対処ならびに修正していけばよいか述べる。話のなかでアンチパターンについて触れるけれども、このセッションはアンチパターンについてではなく、あくまで問題のなかの一つの例として取りあげる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#global-threadlocal-static&#34; name=&#34;global-threadlocal-static&#34;&gt;グローバル、スレッドローカル、および静的データの生存期間と利用法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lifetime and Usage of Global, Thread-local, and Static Data&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/daniel_dilts.1rzy8qlc?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Daniel Dilts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cはプログラム全体でデータを初期化、未初期化の如何にかかわらず宣言する機能がある。C++はグローバル、スレッドローカルなオブジェクトを生成するためにこの機能を拡張している。全てのオブジェクトと同じく、グローバルおよびスレッドローカルオブジェクトは生存期間の開始とともに構築され、終了とともに破棄される。&lt;/p&gt;
&lt;p&gt;このセッションでは、グローバル、スタティックそしてスレッドローカルオブジェクトの生存期間について、C++11標準が保証していることについて述べる。よって、コンパイラが実際にどうしているかについても話すつもりだ。複雑な初期化のために、どうグローバルデータを使ったらよいかについて議論する。&lt;/p&gt;
&lt;p&gt;グローバルデータの利用パターンや、グローバルデータの縮小についても議論したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#expected&#34; name=&#34;expected&#34;&gt;Expected — 例外フレンドリーなエラーモナド&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Expected — An Exception-friendly Error Monad&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/vicente_j_botet_escriba.1rzy8qjh?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Vicente J. Botet Escriba&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Expectedライブラリは、2012年にAndrei Alexandrescuによって紹介されたものをベースにしている。これはC++における新たなエラーハンドリングの方法であり、古典的なエラーコードを返す方法と例外の中間に位置する。Expectedは例外を送出するコードと完全な互換を持ち、例外フリーなインタフェースを設計することを補助する。クリーンなコードを維持しながらエラーハンドリングを強制するこの新技術は、Haskellのような関数型言語のモナドから拝借してきたものだ。しかし、モナドの事前知識は必要ない。&lt;/p&gt;
&lt;p&gt;このトークでは、既存のエラーハンドリング技法の紹介から始める。エラーコードの返却と例外システムを比較し、Expectedを導入する。&lt;code&gt;std::future&lt;/code&gt;クラスと&lt;code&gt;std::experimental::optional&lt;/code&gt;クラスが、類似のユーティリティクラスと概念的にどう異なるのかについても話す。&lt;/p&gt;
&lt;p&gt;Expectedライブラリのコアとなる、様々な機能とセマンティクスを、次の例を使用して紹介する。ユーザー定義のエラー型を使用した例外フリーなインタフェース定義を、expectedクラスではどのように使用するのかを議論する。&lt;/p&gt;
&lt;p&gt;monad errorのメソッドである&lt;code&gt;next&lt;/code&gt;と&lt;code&gt;recover&lt;/code&gt;を、いくつかの例を通じて紹介する。これらのプログラミング技法によって、エラーハンドリングのレイヤーと通常のコードフローを明確に見分けられるようになる。さらに、プログラマがエラーハンドリングを非侵入的に行うことも補助する。それと、関数型言語のモナドについて簡単な解説を行い、&lt;code&gt;expected&lt;/code&gt;がなぜモナドと見なせるのかについても話す。&lt;/p&gt;
&lt;p&gt;残りの時間では、潜在的なモナドクラスである&lt;code&gt;std::experimental::optional&lt;/code&gt;と&lt;code&gt;std::future&lt;/code&gt;について議論する。&lt;/p&gt;
&lt;p&gt;Haskellのモナドは、いくつかのシンタックスシュガーによって、コードをより読みやすくする。N3858 Resumable functionsのawait式と同様に、我々の新たなexpect式が例外送出のコードを読みやすくすることを示す。&lt;/p&gt;
&lt;p&gt;注： このライブラリは、C++標準にはまだ提案されていないが、カンファレンスのあとに提案するつもりだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#async-msm&#34; name=&#34;async-msm&#34;&gt;Boost.MetaStateMachineと次世代非同期ライブラリを利用した非同期プログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Asynchronous Programming Using Boost.MetaStateMachine and the Upcoming Asynchronous Library&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/christopher_henry.1rzy8qko?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Christophe Henry&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現実を直視しよう。巨大なアプリケーションでは&lt;code&gt;future&lt;/code&gt;が帰ってくるまで待っていては使いものにならないので、&lt;code&gt;std::async&lt;/code&gt;は成功したとは言えない。N3558、N3650でもまだ問題は解決していない。&lt;/p&gt;
&lt;p&gt;ASIO様のコールバックベースの解法ならよりよさそうではないか？&lt;/p&gt;
&lt;p&gt;まずはBoost Meta State Machineや次世代非同期ライブラリの非同期の部分を使った関数のふるまいについてQtアプリケーション(CDプレーヤー)を調査する。&lt;/p&gt;
&lt;p&gt;次に、非同期ライブラリのアクティヴオブジェクト、スレッドプール、アルゴリズムやその他の話題について焦点をあてる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#functional-data-structures&#34; name=&#34;functional-data-structures&#34;&gt;C++での関数型データ構造&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Functional Data Structures in C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/bartosz_milewski.1rzy8qnm?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Bartosz Milewski&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正しく効率的な並行、並列プログラムを書くには並行データ構造が必要である。vectorの頭にmutexをぽんと置くのが最適な解になるのは非常に稀である。関数プログラマ達は偉大なる技法を編み出した - すなわち本質的にスレッドセーフになる不変データ構造を使ったのである。だが、もしデータを変更できないとして、どうやってプログラムを書いたらいいのだろうか？また、単に&lt;code&gt;const vector&lt;/code&gt;を使うだけではなぜダメなのだろうか？&lt;/p&gt;
&lt;p&gt;つまり、効率的な関数型データ構造を設計するための研究分野があることがあることが分かる。&lt;/p&gt;
&lt;p&gt;舞台裏にはデータの変形や共有、そしてトリッキーな同期問題がある。例えば、(まぁ言ってみれば)単方向リストを定数時間で反転できる遅延評価をもちいてデータのコピーを引き伸ばすための技法がある。&lt;/p&gt;
&lt;p&gt;このセッションでは、関数型プログラミング、特にChris Okasakiの名著、『Purely Functional Data Structures』から得られた知識に基づいて、C++で効率的なスレッドセーフデータ構造の実装について紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#ownership-memory&#34; name=&#34;ownership-memory&#34;&gt;C++におけるメモリの所有権&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ownership of Memory in C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/david_stone.1rzy8qkl?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;David Stone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションでは、(&#34;スタックベース&#34;の)自動変数、生ポインタ、そしてスマートポインタといった、オブジェクトの所有権を定義する一般的な方法について検討する。また、C++標準ライブラリにあるスマートポインタの集合に対して細かな改良点を提案する。&lt;/p&gt;
&lt;p&gt;C++の所有権に関する議論では(たとえあったとしても)ほとんどが軽くパフォーマンスについて言及するのみで、それを使うべき(もしくは使わないべき)かについての切言が主になっている。このセッションでは、正しさを維持したままパフォーマンスとメモリ効率を効果的に最適化するにはどうするべきかについてのみ扱う時間を設けるつもりである。&lt;/p&gt;
&lt;p&gt;このセッションの主題はメモリに関連した所有権についてである。RAIIのような重要な指針についても概説するが、メモリ管理の文脈に限るものとし、一般的なリソース管理については対象外とする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#disambiguation&#34; name=&#34;disambiguation&#34;&gt;曖昧性解決における黒魔術&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Disambiguation: The Black Technology&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/zhihao_yuan.1rzy8qjx?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Zhihao Yuan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の関数呼び出しはCのそれよりも、オーヴァーロードにより高い柔軟性を備えている。だがオーヴァーロードはあいまいさの原因ともなるので、SFINAEやMPLのintegral_constant、タグディスパッチといった、一般的なツールを利用する。ところが、このようなツールの利用は関数名をただ変えるのに比べるとより&#34;黒魔術&#34;に近い。このセッションでは、関数のオーヴァーロードセットを管理するために、どのようにこれらのツールをつかえばよいかについて学ぶ。また、これらのツールで関数呼び出しのあいまいさを解決しなけらばならない時、すべき時、すべきでない時、できない時について理解できるだろう。&lt;/p&gt;
&lt;p&gt;ライブラリの提案、libc++、libstdc++、Boostなどの実装から例示する。MPLの経験は必要ではない。 &lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#frp&#34; name=&#34;frp&#34;&gt;関数リアクティヴプログラミング - 滑かに抽象化された双方向性&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Functional Reactive Programming - Cleanly Abstracted Interactivity&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/david_sankel.1rzy8ql9?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1997年にConal ElliotとPaul Hudakにより、関数リアクティヴプログラミング(FRP:functional reactive programming)と呼ばれる、双方向性の新しい数学モデルの発見が公開された。時間-関数に基づくモデルは根本的に典型的なイヴェントとコールバックパラダイムから出発し、対話型プログラムを書く上で、より自然かつ簡潔な方法 - タイムステップやフレーム、接続、またその他検討事項は完全に抽象化されている - をゴールとしている。&lt;/p&gt;
&lt;p&gt;このセッションではFRP方法論を紹介し、&#39;sfrp&#39;という、ロボット工学やコンピュータアニメーション、UIといったドメインで容易に利用可能な、新規の業務用途に耐える関数リアクティヴプログラミングフレームワークを紹介する。 &#39;sfrp&#39;と他のC++やHaskellのFRP実装との比較についてや、商用アプリケーションで&#39;sfrp&#39;を利用した経験についても紹介するつもりだ。このセッションに参加した各位がFRPパラダイムをいつつかうか、また&#39;sfrp&#39;をつかってどのようにアプリケーションに適用するか知っていただければ幸いである。&lt;/p&gt;
&lt;p&gt;本セッションの対象聴講者は、より強力かつ簡潔な対話型プログラムを作成することに興味がある、すべてのスキルレヴェルのC++開発者である。関数リアクティヴプログラミングや関数プログラミングの経験は不要である。 &lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#accelerator-programming&#34; name=&#34;accelerator-programming&#34;&gt;将来のC++におけるアクセラレータプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The Future of Accelerator Programming in C++
スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/sebastian_schaetz.1rzxpija?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Sebastian Schaetz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenCL、CUDA、C++AMP、OpenACC、RenderScript、Thrust、Bolt、VexCL、Boost.Compute、ViennaCL、MTL4、NT2、Arrayfire — このようにアクセラレータプログラミングのためのツールや環境、フレームワークやライブラリはいろいろある。 このセッションではこれらのツールについて概説し、アクセラレータ利用の異なるケースとひもづけていく。 開発者の生産性や、汎用性、性能といった観点でどのように比較したらよいだろうか？&lt;/p&gt;
&lt;p&gt;これらのツールを自由に使ってしまうと、アクセラレータプログラミングの問題は解決からほど遠くなってしまう。C++でデータ並列と並行を表現するよりよい方法があるはずだ。関数プログラミングコミュニティが我々の助けになるだろうか？または、Bret Victorが適切に述べたように、よりよい解を探すために単に「コンピュータについて考え、理解したことを全て忘れ、コンピュータが存在することを忘れ」るべきか。聴衆からのコメントはこのセッションの第二部で歓迎する。 &lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;https://boostjp.github.io/cppnow/2014.html#ripple-management&#34; name=&#34;ripple-management&#34;&gt;C++におけるRipple Managementによる巨大なコードベース変更についての私見&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;My Thoughts on Large Code Base Change Ripple Management in C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow2014.sched.org/speaker/nialldouglas?iframe=yes&amp;amp;w=700&amp;amp;sidebar=yes&amp;amp;bg=no&#34; target=&#34;_blank&#34;&gt;Niall Douglas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他の言語に比べて、C++98/03は非常に複雑だと言われつづけて久しい。C++11/14で追加された多数の機能は、次世代のC++コードベースがより一層複雑化することを示唆している。おそらく、計画中のC++17では、現時点で予測できない方向で事態はさらに悪化するだろう。&lt;/p&gt;
&lt;p&gt;ソフトウェアの複雑化に対し、2020年ごろまで見つもられている指数関数的成長からはずれたコンピュータハードウェアの性能向上では対抗できない。つまり全てのコンピューターソフトウェアについて予測することがより困難になるだろう。&lt;/p&gt;
&lt;p&gt;WG21 C++17の研究グループであるSG2 (モジュール)、SG7 (リフレクション)、SG8 (コンセプト)および、これらほどではないにせよ、SG10 (機能テスト) や、SG12 (未定義動作)は、C++17における複雑性管理を大幅に進化させる基礎であるが、C++の複雑性管理を進化させるこれらの研究についてまだあまり明確に言及されていない。&lt;/p&gt;
&lt;p&gt;本プレゼンテーションでは、全てのC++ユーザーにとって、将来のC++コードベースを大幅に扱いやすく理解しやすくするために、SG2とSG7をSG3 (ファイルシステム)で組み合わせることで、このような複雑性がスケールする問題に対するあたらしい実装方法、すなわち、C++ランタイムの根幹にBoost.ASIOやBoost.AFIO、そしてBoost.Graphを基礎とする標準化された非常に軽量なトランザクショナルグラフデータベースを提案する。&lt;/p&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, zak, eagle_raptor, chichimotsu&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2015 -- C++ Now のリンクを修正</title>
      <link href="https://boostjp.github.io/cppnow/2015.html"/>
      <id>b1f0565297261a631dd64647d980ac086ff40284:cppnow/2015.md</id>
      <updated>2017-06-12T04:51:27+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2015&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://cppnow2015.sched.org&#34; target=&#34;_blank&#34;&gt;https://cppnow2015.sched.org&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Library in a Week: C++ Application Configuration&lt;/li&gt;
&lt;li&gt;Conference Keynote: Generic Programming with Concepts&lt;/li&gt;
&lt;li&gt;Parallel Computing: Strategies and Implications&lt;/li&gt;
&lt;li&gt;Testing Battle.net (before deploying to millions of players)&lt;/li&gt;
&lt;li&gt;Your CPU Is Binary&lt;/li&gt;
&lt;li&gt;Functional Geometry: Producing Pure Spaces&lt;/li&gt;
&lt;li&gt;Lessons Learned&lt;/li&gt;
&lt;li&gt;Type Deduction in C++14&lt;/li&gt;
&lt;li&gt;Yomm11: Open Multi-Methods for C++11&lt;/li&gt;
&lt;li&gt;constexpr: C++ At Compile Time&lt;/li&gt;
&lt;li&gt;Biicode, a C/C++ dependency manager with a hosting service&lt;/li&gt;
&lt;li&gt;Boost 2.0&lt;/li&gt;
&lt;li&gt;Conference Keynote: Numerical Weather Prediction: Facing the Future with C++&lt;/li&gt;
&lt;li&gt;On the design and Boost-based implementation of two new C++ libraries for atmospheric research&lt;/li&gt;
&lt;li&gt;Thinking Portable: Why and how to make your C++ cross platform&lt;/li&gt;
&lt;li&gt;Why in heaven there is no dependency management for C++?&lt;/li&gt;
&lt;li&gt;Boost.Compute: A library for GPU/parallel-computing&lt;/li&gt;
&lt;li&gt;Developing EDSL&#39;s for Boost.Spirit&lt;/li&gt;
&lt;li&gt;Back to the Future&lt;/li&gt;
&lt;li&gt;Large-Scale C++: Advanced Levelization Techniques, Parts I &amp;amp; II&lt;/li&gt;
&lt;li&gt;switchAny - A Practical Exercise in Template Metaprogramming&lt;/li&gt;
&lt;li&gt;New Build System for New C++&lt;/li&gt;
&lt;li&gt;The Price of Shared Pointers or Why Passing them by-reference can be Useful&lt;/li&gt;
&lt;li&gt;Conference Keynote: Ranges for the Standard Library&lt;/li&gt;
&lt;li&gt;A review of C++ 11/14 only Boost libraries - Fiber, AFIO, DI and APIBind&lt;/li&gt;
&lt;li&gt;Type-safe configuration library&lt;/li&gt;
&lt;li&gt;How we reason about procedural programs&lt;/li&gt;
&lt;li&gt;Modern generic programming using the Tick and Fit libraries&lt;/li&gt;
&lt;li&gt;Functions Want To Be Free&lt;/li&gt;
&lt;li&gt;Boostache Exposed - the internals of Boost&#39;s template engine&lt;/li&gt;
&lt;li&gt;Lock-free by Example: Towards an Interesting Lock-free MPMC Queue&lt;/li&gt;
&lt;li&gt;Big Projects, and CMake, and Git, Oh My!&lt;/li&gt;
&lt;li&gt;Debugging using an exact recording of a program&#39;s execution.&lt;/li&gt;
&lt;li&gt;Details Matter&lt;/li&gt;
&lt;li&gt;The Rule of Seven (Plus or Minus Two): Modern C++ Boilerplate&lt;/li&gt;
&lt;li&gt;Parallelizing the Standard Template Library(STL)&lt;/li&gt;
&lt;li&gt;C++ metaprogramming: a paradigm shift&lt;/li&gt;
&lt;li&gt;Fun with C11 generic selection expression&lt;/li&gt;
&lt;li&gt;IIFE In C++ For Performance and Safety&lt;/li&gt;
&lt;li&gt;Better Code: Concurrency&lt;/li&gt;
&lt;li&gt;Using Spirit X3&lt;/li&gt;
&lt;li&gt;An Overview on Encryption in C++&lt;/li&gt;
&lt;li&gt;C++17 coroutines for app and library developers&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2015&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2015&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2016 -- C++ Now のリンクを修正</title>
      <link href="https://boostjp.github.io/cppnow/2016.html"/>
      <id>b1f0565297261a631dd64647d980ac086ff40284:cppnow/2016.md</id>
      <updated>2017-06-12T04:51:27+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2016&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://cppnow2016.sched.com&#34; target=&#34;_blank&#34;&gt;https://cppnow2016.sched.com&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Library in a Week: C++ Application Configuration&lt;/li&gt;
&lt;li&gt;Conference Keynote: Generic Programming with Concepts&lt;/li&gt;
&lt;li&gt;Parallel Computing: Strategies and Implications&lt;/li&gt;
&lt;li&gt;Testing Battle.net (before deploying to millions of players)&lt;/li&gt;
&lt;li&gt;Your CPU Is Binary&lt;/li&gt;
&lt;li&gt;Functional Geometry: Producing Pure Spaces&lt;/li&gt;
&lt;li&gt;Lessons Learned&lt;/li&gt;
&lt;li&gt;Type Deduction in C++14&lt;/li&gt;
&lt;li&gt;Yomm11: Open Multi-Methods for C++11&lt;/li&gt;
&lt;li&gt;constexpr: C++ At Compile Time&lt;/li&gt;
&lt;li&gt;Biicode, a C/C++ dependency manager with a hosting service&lt;/li&gt;
&lt;li&gt;Boost 2.0&lt;/li&gt;
&lt;li&gt;Conference Keynote: Numerical Weather Prediction: Facing the Future with C++&lt;/li&gt;
&lt;li&gt;On the design and Boost-based implementation of two new C++ libraries for atmospheric research&lt;/li&gt;
&lt;li&gt;Thinking Portable: Why and how to make your C++ cross platform&lt;/li&gt;
&lt;li&gt;Why in heaven there is no dependency management for C++?&lt;/li&gt;
&lt;li&gt;Boost.Compute: A library for GPU/parallel-computing&lt;/li&gt;
&lt;li&gt;Developing EDSL&#39;s for Boost.Spirit&lt;/li&gt;
&lt;li&gt;Back to the Future&lt;/li&gt;
&lt;li&gt;Large-Scale C++: Advanced Levelization Techniques, Parts I &amp;amp; II&lt;/li&gt;
&lt;li&gt;switchAny - A Practical Exercise in Template Metaprogramming&lt;/li&gt;
&lt;li&gt;New Build System for New C++&lt;/li&gt;
&lt;li&gt;The Price of Shared Pointers or Why Passing them by-reference can be Useful&lt;/li&gt;
&lt;li&gt;Lightning Talks&lt;/li&gt;
&lt;li&gt;MessagePack(msgpack): A Compact and Fast Serialization Library&lt;/li&gt;
&lt;li&gt;Fun with with&lt;/li&gt;
&lt;li&gt;Clang on SOC&lt;/li&gt;
&lt;li&gt;Surviving and Thriving in a Multiplatform, Multilanguage, Multiproduct, Multisite Continuous Integration Environment&lt;/li&gt;
&lt;li&gt;Sequences from Streams&lt;/li&gt;
&lt;li&gt;Multimethod as dynamic C++ overloading.&lt;/li&gt;
&lt;li&gt;Currying and other Functional Constructs in C++&lt;/li&gt;
&lt;li&gt;General Relativity Applied to Coding Styles&lt;/li&gt;
&lt;li&gt;When APIs Break, What Can You Do&lt;/li&gt;
&lt;li&gt;Constexpr Include Joke&lt;/li&gt;
&lt;li&gt;for_each_arg&lt;/li&gt;
&lt;li&gt;make_unique and Restricted Constructors&lt;/li&gt;
&lt;li&gt;Access Tuple by Runtime Index&lt;/li&gt;
&lt;li&gt;Conference Keynote: Ranges for the Standard Library&lt;/li&gt;
&lt;li&gt;A review of C++ 11/14 only Boost libraries - Fiber, AFIO, DI and APIBind&lt;/li&gt;
&lt;li&gt;Type-safe configuration library&lt;/li&gt;
&lt;li&gt;How we reason about procedural programs&lt;/li&gt;
&lt;li&gt;Modern generic programming using the Tick and Fit libraries&lt;/li&gt;
&lt;li&gt;Functions Want To Be Free&lt;/li&gt;
&lt;li&gt;Boostache Exposed - the internals of Boost&#39;s template engine&lt;/li&gt;
&lt;li&gt;Lock-free by Example: Towards an Interesting Lock-free MPMC Queue&lt;/li&gt;
&lt;li&gt;Big Projects, and CMake, and Git, Oh My!&lt;/li&gt;
&lt;li&gt;Debugging using an exact recording of a program&#39;s execution.&lt;/li&gt;
&lt;li&gt;Details Matter&lt;/li&gt;
&lt;li&gt;The Rule of Seven (Plus or Minus Two): Modern C++ Boilerplate&lt;/li&gt;
&lt;li&gt;Parallelizing the Standard Template Library(STL)&lt;/li&gt;
&lt;li&gt;C++ metaprogramming: a paradigm shift&lt;/li&gt;
&lt;li&gt;Fun with C11 generic selection expression&lt;/li&gt;
&lt;li&gt;IIFE In C++ For Performance and Safety&lt;/li&gt;
&lt;li&gt;Better Code: Concurrency&lt;/li&gt;
&lt;li&gt;Experimental Future Library&lt;/li&gt;
&lt;li&gt;Using Spirit X3&lt;/li&gt;
&lt;li&gt;An Overview on Encryption in C++&lt;/li&gt;
&lt;li&gt;C++17 coroutines for app and library developers&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2016&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>E Kawashima</name>
        <email>e-kwsm@users.noreply.github.com</email>
      </author>
    </entry>
  
</feed>