<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-01-21T23:02:36.714362</updated>
  <id>73091590-a742-4d52-a813-b5d5920b5540</id>

  
    <entry>
      <title>Date-Time Build-Compiler Information -- 不正なリンクを解消</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html"/>
      <id>738a312268b17912e7d754acfa635e9de3173ba7:archive/boost_docs/libs/date_time/build_info.md</id>
      <updated>2015-01-19 23:02:36 +0900</updated>
      
        <content type="html">&lt;h1&gt;Date-Time Build-Compiler Information&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Build-Compiler Information&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compilation-options&#34;&gt;Compilation Options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compiler-portability-notes&#34;&gt;Compiler/Portability Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#directory-structure&#34;&gt;Directory Structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#required-boost-libraries&#34;&gt;Required Boost Libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#overview&#34; name=&#34;overview&#34;&gt;Overview&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ライブラリ関数のいくつかはライブラリファイルを作成する必要がある。 これらの関数を含むライブラリ( &lt;strong&gt;libboost_date_time&lt;/strong&gt; )を作成するには、buildディレクトリにあるJamfileを使う。&lt;/p&gt;
&lt;p&gt;変数&lt;code&gt;DATE_TIME_INLINE&lt;/code&gt;は、ある特定のコア関数のインライン化を制御する。 デフォルトでこの変数はライブラリのコンパイル時に定義されている。 ライブラリを使っている全てのコンパイル単位でこの定義を含んでいなければ、リンクエラーになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compilation-options&#34; name=&#34;compilation-options&#34;&gt;Compilation Options&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;デフォルトでは &lt;code&gt;posix_time&lt;/code&gt; はナノ秒レベルの精度を提供するために内部で 64bit整数と32bit整数を使う。 選択肢として、一つの 64bit整数でマイクロ秒レベルの精度を提供することもできる。 この代替実装は、ナノ秒精度を必要としない多くのアプリケーションでパフォーマンスの向上と省メモリが期待できる。&lt;/p&gt;
&lt;p&gt;変数&lt;code&gt;BOOST_DATE_TIME_POSIX_TIME_STD_CONFIG&lt;/code&gt;はbuild/Jamfileで定義されており、これらのオプションを選択する。 64bit整数版を使う場合、単にJamfileからこの定義を削除する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compiler-portability-notes&#34; name=&#34;compiler-portability-notes&#34;&gt;Compiler/Portability Notes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost Date-Time libraryは、多くのコンパイラでビルドされテストされた。 しかしながら、いくつかのコンパイラと標準ライブラリで問題がある。 これらの問題のいくつかは回避可能であるが、回避できない問題も残っている。 以下のコンパイラはライブラリの機能を完全にサポートしている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 3.0.3 on Linux&lt;/li&gt;
&lt;li&gt;GCC 3.1 (cygwin)&lt;/li&gt;
&lt;li&gt;MSVC 7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特に、標準ロケールに対するサポートが完全でないと &lt;code&gt;iostream&lt;/code&gt; ベースの入出力サポートが制約される事がある。そういったコンパイラのために、より限定された文字列ベースの入出力を提供している。&lt;/p&gt;
&lt;p&gt;以下のコンパイラ及び標準ライブラリはこの制約を含む&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 2.9x on Linux&lt;/li&gt;
&lt;li&gt;Borland 5.1.1 and 5.6&lt;/li&gt;
&lt;li&gt;MSVC 6 SP5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ComeauやMetroworksといった他のコンパイラでは、ライブラリの初期バージョンでテストに成功している。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#directory-structure&#34; name=&#34;directory-structure&#34;&gt;Directory Structure&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;date_time&lt;/code&gt;のディレクトリ構成はBoostに合わせて変更された。&lt;/p&gt;
&lt;p&gt;ディレクトリ構成は次のようになっている&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ディレクトリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time&lt;/td&gt;
&lt;td&gt;共通ヘッダ及びテンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time/gregoran&lt;/td&gt;
&lt;td&gt;グレゴリオ暦システムのヘッダファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time/posix_time&lt;/td&gt;
&lt;td&gt;Posix Time系のヘッダファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/build&lt;/td&gt;
&lt;td&gt;ビルドファイルと出力ディレクトリ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test&lt;/td&gt;
&lt;td&gt;ジェネリックコードに関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test/gregorian&lt;/td&gt;
&lt;td&gt;グレゴリオ暦に関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/examples/gregorian&lt;/td&gt;
&lt;td&gt;グレゴリオ暦に関する良いコード例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/src/gregorian&lt;/td&gt;
&lt;td&gt;libboost_date_time用のcppファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test/posix_time&lt;/td&gt;
&lt;td&gt;Posix Time系に関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/examples/posix_time&lt;/td&gt;
&lt;td&gt;時間に関する良いコード例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/src/posix_time&lt;/td&gt;
&lt;td&gt;空 (ファイルが一つあるが、ソースコードではない)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#required-boost-libraries&#34; name=&#34;required-boost-libraries&#34;&gt;Required Boost Libraries&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このライブラリは以下のライブラリに依存している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost.tokenizer&lt;/li&gt;
&lt;li&gt;boost.integer(cstdint)&lt;/li&gt;
&lt;li&gt;boost.operators&lt;/li&gt;
&lt;li&gt;boost::lexical_cast&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;よって、最低限これらのライブラリがインストールされている必要がある。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>melpon</name>
        <email>melt@e-ml.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>Negators -- 不正なリンクを解消</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html"/>
      <id>738a312268b17912e7d754acfa635e9de3173ba7:archive/boost_docs/libs/functional/negators.md</id>
      <updated>2015-01-19 23:02:36 +0900</updated>
      
        <content type="html">&lt;h1&gt;Negators&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.5) 由来のネゲータアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binary_negate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;not1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このライブラリのネゲータは標準バージョンを二つの方法で改良する。&lt;/p&gt;
&lt;p&gt;適合関数オブジェクトではなく関数を否定する時、それらは &lt;code&gt;ptr_fun&lt;/code&gt; の必要を回避するために、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を用いる。&lt;/p&gt;
&lt;p&gt;それらは引数や適合された関数に渡す引数を宣言する最上の方法を決するため、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;call traits&lt;/a&gt; を用いる。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34;&gt;下記&lt;/a&gt;参照)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い型は標準ネゲータと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++ 標準 (§20.3.5) は unary negate をこのように定義 している。(binary negate も似ている):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type,&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; unary_negate(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; pred);
  &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であった場合、 &lt;code&gt;operator()&lt;/code&gt; の引数の型は参照の参照になることに注意しなさい。これは、現在の C++ では非合法である。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;しかしながら、もし代わりに &lt;code&gt;operator()&lt;/code&gt; を &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; を変更せずにそのまま採用して定義すると、それが値型であった場合不必要に非効率になってしまう。それは引数が二度コピーされることによる。一度は &lt;code&gt;unary_negate&lt;/code&gt; の &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時、さらに適合された関数で &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時にもう一度である。&lt;/p&gt;
&lt;p&gt;つまり&lt;code&gt;operator()&lt;/code&gt; を宣言する望ましい方法は、 &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であるか否かに依 る。もしそれが参照であれば、単純に &lt;code&gt;argument_type&lt;/code&gt; として宣言したいし、それが値であれば &lt;code&gt;const argument_type&amp;amp;&lt;/code&gt; として宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特 殊化版を用いて正確にこの判断を行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。実のところ、実際の宣言は関数オブジェクト特性を使うためもう少し複雑である。しかし効果は同様である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;この関数オブジェクト特性の両方と call traits はこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化版の機能を持つコンパイラでのみ有効である。 そうでないコンパイラでは、このライブラリのネゲータは標準内のそれらと非常に似た振る舞いをする - 関数に適合するために &lt;code&gt;ptr_fun&lt;/code&gt; が必要であるし、参照の参照は避けられないだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>melpon</name>
        <email>melt@e-ml.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>ジェネリックコンポーネントにおける例外安全性 -- 不正なリンクを解消</title>
      <link href="http://boostjp.github.io/archive/boost_docs/document/generic_exception_safety.html"/>
      <id>e9236caa98d749eefe1bafbc33e247f2cba1afa1:archive/boost_docs/document/generic_exception_safety.md</id>
      <updated>2015-01-19 23:01:30 +0900</updated>
      
        <content type="html">&lt;h1&gt;ジェネリックコンポーネントにおける例外安全性&lt;/h1&gt;
&lt;p&gt;C++標準ライブラリのために規定した例外安全性の経験から学んだこと&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;David Abrahams&lt;/li&gt;
&lt;li&gt;david.abrahams@rcn.com&lt;/li&gt;
&lt;li&gt;翻訳元：&lt;a href=&#34;http://www.boost.org/community/exception_safety.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/community/exception_safety.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;この文書は実世界の必要性に対する応答の中で蓄積された知識を表す: つまり、 C++ 標準テンプレートライブラリは、役立つ、そして明確な例外との相互作用を示し、 エラー捕捉の機構は C++ 言語の中核に組み込まれている。 この文書では、例外安全性の意味を探求し、例外と汎用性についての驚くべき神話を明らかにし、 プログラムの正当性を理由付けるための価値ある道具について述べ、 例外安全性を実証するための自動化されたテストの手続きを概説する。&lt;/p&gt;
&lt;p&gt;Keywords: exception-safety, exceptions, STL, C++&lt;/p&gt;
&lt;h2&gt;1 例外安全性とは何か&lt;/h2&gt;
&lt;p&gt;簡単に言えば、コンポーネントの例外安全性とは、 実行中に例外が投げられたとき、正当な振る舞いを示すことを意味する。 ほとんどの人にとって、「正当な」という用語は、エラー捕捉に対する通常の例外全てを含む: つまり、資源は漏れるべきではないし、プログラムは実行を継続できるように、 明確な状態であり続けるべきである。多くのコンポーネントにとって、 これはまた、エラーに出会った時に呼び出し元に報告されるような例外も含む。&lt;/p&gt;
&lt;p&gt;より公式に言えば、コンポーネントの中から例外が投げられたときに、 もしその不変性が損なわれないなら、そのコンポーネントは最小限の例外安全性を持っていると言える。 後に見るが、通常、少なくとも3種類の異なる例外安全性が区別されている。 これらの区別は巨大なシステムの振る舞いについて記述し、理由付けるのに役立つのである。&lt;/p&gt;
&lt;p&gt;汎用コンポーネントでは、通常我々は、さらに、 &lt;strong&gt;例外中立性&lt;/strong&gt; という期待をもつ。 これは、コンポーネントの型パラメータによって投げられた例外は、 そのコンポーネントの呼び出し元まで、変わることなく伝えられるべきである、 ということを意味する。&lt;/p&gt;
&lt;h2&gt;2 神話と迷信&lt;/h2&gt;
&lt;p&gt;例外安全性は、これまでのところ簡単なものに見える: それは、より伝統的なエラー捕捉の技術を使ったコードに期待する以上のことを、 何も構築したりはしない。しかし、心理学的な観点からこの用語を調べてみることは、価値があるだろう。 C++ が例外を持つ以前は、誰も「エラー安全性」について語らなかった。&lt;/p&gt;
&lt;p&gt;まるで例外は、正しいコードに対する &lt;strong&gt;ミステリアスな攻撃&lt;/strong&gt; であり、 我々が自らをその攻撃から守らなければいけないようなものであると見なされているかのようである。 言うまでもなく、これはエラー捕捉との健全な関係に繋がらない! 標準化の間、変更に対する幅広いサポートを要求する民主的な過程で、 私は広く支持された多くの迷信に出会った。 汎用コンポーネントにおける例外安全性の議論を始めるために、 それらのいくつかを見ておくことは意味のあることだろう。&lt;/p&gt;
&lt;p&gt;「テンプレートと例外の相互作用は、良く理解できない。」 これら両方が言語の新しい特徴であると考える人々から良く聞かれるこの神話は、 簡単に却下できる: そこには、相互作用はないのである。 テンプレートは、一度実体化されれば、全ての面で通常のクラスや関数と同じように機能する。 例外と関連したテンプレートの振る舞いを考えるための単純な方法は、 そのテンプレートの特別版の実体化がどう機能するかについて考えることである。 最後に、テンプレートの汎用性は、何も特別なことを引き起こさない。 コンポーネントのクライアントは操作の一部を提供するが(この操作は、もし特別版でないなら、 任意の例外を投げるだろう)、我々が良く親しんだ仮想関数や、 単純な関数ポインタを使った操作についても、同じことなのである。&lt;/p&gt;
&lt;p&gt;「例外安全性をもつ汎用コンテナを書くのが不可能であることは、 良く知られている」 この主張は、Tom Cargill による文書、 [^4] に関連してよく聞かれる。そこで彼は、汎用スタックテンプレートに対する例外安全性の問題について探求している。 彼の文書で、 Cargill は多くの役立つ問題を掲げているが、 残念ながらそれらの問題に対する解決法を提供できていない。彼は解決は不可能である、と提案して結論付けている。不幸にも彼の文書は、 多くの人に、そのような空論の 「証拠」 として読まれてしまった。 しかしこの文書が出版されてから、例外安全な汎用コンテナの多くの実例があったのである。 C++ 標準ライブラリコンテナもその中にはいる。&lt;/p&gt;
&lt;p&gt;「例外を扱うとコードは遅くなり、テンプレートは本質的に 可能な限りのパフォーマンスを得るために使われる。」 C++ の優れた実装は、例外が投げられるまでにその例外を扱うひとつの命令サイクルを費やすことはしないで、 例外は関数呼び出しの同じようなスピードで捕捉可能である [^7]。 それだけで、例外を使ったプログラムに、 エラーの可能性を無視したプログラムと同等のパフォーマンスを提供している。 例外を使うと実際は、結果的に別の理由で「伝統的な」エラー捕捉の方法よりも早くなる。 まず、 catch 節はコンパイラに、どのコードがエラー捕捉に費やされるかを明確に示す。 このため、通常の実行パスから分離することが可能であり、参照の局所性が改善する。 次に、「伝統的な」エラー捕捉を使ったコードは典型的に、単一の関数を呼び出した後、いつも返り値を検査しなければならない。 例外を使えば、このオーバヘッドは完全に消える。&lt;/p&gt;
&lt;p&gt;「例外はプログラムの振る舞いを推論することを難しくしてしまう」 通常、この神話が支持されて引用されるのは、 スタック巻き戻しの間に「隠れた」実行パスを通る、という意味においてである。 隠れた実行パスはローカル変数が関数から戻る前に破棄されることを期待している C++ プログラマにとっては、なにも新しいものではない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;ErrorCode &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;( &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; result )         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1 &lt;/span&gt;
{                                  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2 &lt;/span&gt;
    X x;                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3 &lt;/span&gt;
    ErrorCode err &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.g( result ); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4 &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( err &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; kNoError )         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5 &lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; err;                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 6 &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...More code here... &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; kNoError;               &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 7 &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;上の例では、6行目と7行目に &lt;code&gt;X::~X&lt;/code&gt; の「隠れた」呼び出しがある。 そう考えれば、例外を使うことで、エラー捕捉に対して、明白なコードの無駄は存在しない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;()                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1 &lt;/span&gt;
{                       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2 &lt;/span&gt;
    X x;                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3 &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; result &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.g(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4 &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...More code here... &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; result;      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5 &lt;/span&gt;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;例外をより良く知っている多くのプログラマにとって、2番目の例は実際は最初の例よりも、 読みやすく理解しやすい。 「隠れた」コードパスは同じくローカル変数のデストラクタを呼び出している。 更にこれは、冷害が起こった場合にそれぞれの関数呼び出しの後に、 潜在的なリターン文があるかのような、正確に振る舞う単純なパターンに従うのである。 通常の実行パスはエラー捕捉によって分かりにくくならないので、可読性は向上し、 返り値は自然なやり方で使えるように解放されるのである。 例外が正確さを向上することが出来る、さらに重要なやり方がある: それは、 単純なクラス不変性を可能にすることによる。 最初の例では、もし &lt;code&gt;X&lt;/code&gt; のコンストラクタが資源を確保する必要があるなら、 失敗を報告する手だてはない: C++ ではコンストラクタは返り値を持てないからである。 例外を使わない場合は通常、資源を要求するクラスが構築の仕事を完了する、 別の初期化関数を含まなければならない、という結果になる。 プログラマはそのため、クラス &lt;code&gt;X&lt;/code&gt; のオブジェクトが使われるとき、 完全な &lt;code&gt;X&lt;/code&gt; を手にしたのか、それともどこかで構築に失敗したものを手にしたのか、 決して確信をもてない(或いは更に悪いことに、誰かが単に初期化関数を呼び忘れたのかもしれない。)&lt;/p&gt;
&lt;h2&gt;3 例外安全性の契約的原則&lt;/h2&gt;
&lt;p&gt;非汎用的なコンポーネントは例外安全として記述することが出来るが、 汎用的なコンポーネントの場合は、クライアントによる構造化が可能なので、 例外安全性は通常、コンポーネントとクライアントの契約に依存する。 例えば、汎用的コンポーネントの設計者はコンポーネントのデストラクタで使われる演算が、 どんな例外も投げないことを要求するだろう。汎用的コンポーネントはその代わり、次の保証のうちのひとつを提供するだろう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本的保証&lt;/strong&gt; : コンポーネントの不変性は保持され、資源漏れはない。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;強い保証&lt;/strong&gt; : 演算は成功して完了するか、例外を投げるかのどちらかである。 例外を投げる場合、プログラムの状態は演算が始まる前の状態と全く同じである。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例外不送出保証&lt;/strong&gt; : 演算は例外を投げない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基本的保証&lt;/strong&gt; は、全てのコンポーネントに負わせることの出来る、 例外安全性に対する単純で最小限の基準である。 例外の後でもまだコンポーネントは以前のように使うことが出来ると述べているに過ぎない。 重要なことだが、不変性の保持によって、スタック巻き戻しの一部として潜在的に、 コンポーネントを破棄することが出来るのである。 この保証は実際には、見た目ほど役立つものではない。 もしコンポーネントが多くの有効状態を持つなら、例外の後にコンポーネントの状態が、 またはその状態だけが有効な状態なのかどうか知ることは出来ない。 この場合、回復のための選択肢は限られている: コンポーネントの破棄か、 さらに使う前に、ある既知の状態にコンポーネントをリセットするかである。 次の例を考えてみよう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; print_random_sequence() 
{ 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// A vector of 10 items &lt;/span&gt;
    try { 
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Provides only the basic guarantee &lt;/span&gt;
        v.insert( v.begin(), X() ); 
    } 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...) {} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ignore any exceptions above &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// print the vector&#39;s contents &lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v.size() &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;) &#34;&lt;/span&gt;; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;copy( v.begin(), v.end(), 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;( std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; &#34;&lt;/span&gt; ) ); 
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々はみんな、例外後に v が有効であることを知っているので、 この関数は &lt;code&gt;X&lt;/code&gt; のどんなランダムなシーケンスでも出力することが出来る。これはクラッシュしないと言う意味で「安全」ではあるが、出力の内容は予想できないものである。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;強い保証&lt;/strong&gt; は、「責任を持つか、巻き戻すか」という意味論を完全に提供する。 C++ 標準コンテナの場合、これは例えばもし例外が投げられても全てのイテレータは有効なままであることを意味する。 我々はまた、コンテナが例外が投げられる前と全く同じ要素を持っていることも知っている。 失敗したら、なんの効果も及ぼさない処理は、明らかに利点がある: 例外が発生した場合でも、 プログラムの状態は単純で予測可能なのである。 C++ 標準ライブラリでは、ノードを使うコンテナ、&lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;multiset&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;multimap&lt;/code&gt; のほとんど全ての演算が強い保証を提供している。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例外不送出保証&lt;/strong&gt; は最も強いものであり、演算は例外を投げないことを保証されている、 というものである: これは常に成功して完了する。 この保証はほとんどのデストラクタにとって必要なものであり、 C++ 標準ライブラリコンポーネントのデストラクタは実際にすべて、 例外を投げないことを保証されている。 例外不送出保証、他の理由で重要となることを我々は見るだろう。&lt;/p&gt;
&lt;h2&gt;4 法的論争&lt;/h2&gt;
&lt;p&gt;契約がより複雑になることは避けられない: その代わり整理することが可能である。 C++ 標準ライブラリには、任意の型引数にひとつの保証を与え、 例外を投げないというクライアント型からの約束が追加されれれば、より強い保証を与えているものもある。 例えば、標準コンテナ操作 &lt;code&gt;vector&amp;lt;T&amp;gt;::erase&lt;/code&gt; はどんな &lt;code&gt;T&lt;/code&gt; にも &lt;strong&gt;基本的保証&lt;/strong&gt; を与えるが、コピーコンストラクタとコピー代入演算子が例外を投げないなら、 &lt;strong&gt;例外不送出保証&lt;/strong&gt; を与えている。&lt;/p&gt;
&lt;h2&gt;5 コンポーネントはどのレベルの例外安全性を規定する必要があるか&lt;/h2&gt;
&lt;p&gt;クライアントの観点から、可能な限り最も強いレベルの安全性が理想的である。 もちろん &lt;strong&gt;例外不送出保証&lt;/strong&gt; は多くの演算に対して不可能であるが、 強い保証についてはどうだろうか? 例えば、 &lt;code&gt;vector&amp;lt;T&amp;gt;::insert&lt;/code&gt; に対してちょっとした振る舞いが欲しいと仮定しよう。  &lt;code&gt;vector&lt;/code&gt; の中間への挿入は、新しい要素のための場所を作るために、 挿入点以降の要素を、次の位置にコピーする必要がある。 もし要素のコピーが失敗に終われば、操作の巻き戻しは既に行われたコピーの「取り消し」を必要とする。&lt;/p&gt;
&lt;p&gt;ひとつの可能な選択肢は、新しい配列の内容を、毎回新しいメモリで構築して、 成功したときのみ古い内容を破棄するように &lt;code&gt;insert&lt;/code&gt; を再定義することである。 残念ながら、このアプローチにはコストがかかる: &lt;code&gt;vector&lt;/code&gt; の終端付近での挿入は、 以前ではほとんどコピーを行う必要がなかったが、 このアプローチでは全ての要素をコピーしなければいけない。 &lt;strong&gt;基本的保証&lt;/strong&gt; はこの操作に対する「自然な」水準の安全性である。 パフォーマンスを脅かすことなく保証を与えているのである。 実際ライブラリの全ての演算は、層のような「自然な」水準の安全性を提供している。&lt;/p&gt;
&lt;p&gt;パフォーマンスの要求は基準の草案の中では、確立した部分であり、 パフォーマンスは STL の基本的な目的であるので、 これらの要求の中で提供されうる、より強い安全性を明記する試みは為されなかった。 全てのライブラリが &lt;strong&gt;強い保証&lt;/strong&gt; を与えているわけではないが、 &lt;strong&gt;基本的保証&lt;/strong&gt; を提供する、標準コンテナほとんどの演算は、上に述べた、 「新たなコピーを作る」という戦略を使うことで、強い保証を持つことが出来る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Container&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BasicOp&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; MakeOperationStrong( Container&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; c, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; BasicOp&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; op ) 
{ 
    Container tmp(c); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Copy c &lt;/span&gt;
    op(tmp); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Work on the copy &lt;/span&gt;
    c.swap(tmp); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Cannot fail&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この技は、より強い保証を提供する(そして異なるパフォーマンス特性を提供する)、 似たようなコンテナを作るためのラッパクラスに導入することが出来る。&lt;/p&gt;
&lt;h2&gt;6 私たちは、私たちが得ることができる全てを得るべきか&lt;/h2&gt;
&lt;p&gt;特殊な実装を考えれば、安全性についての自然な水準を判断することを望めるだろう。 コンポーネントに対する要求を確立するのにこれを使うことで、 実装が制限されるという危険性が生じる。 我々が使いたくなるような、より効率的な実装を誰かが作り上げても、 それが我々の持つ例外安全性への要求を満たしていないことに気づくかもしれない。 STL が扱っているデータ構造とアルゴリズムという、よく研究された領域では、 このようなことに誰も期待を寄せないかもしれないが、 それでも実際、より優れたものが作られている。最近の &lt;strong&gt;introsort&lt;/strong&gt; アルゴリズムは、その良い例である [^6]。 これは、既に確立した &lt;strong&gt;quicksort&lt;/strong&gt; に対して、最悪の計算量を必要とするような場合での、 大幅な改善を示している。 実際に標準コンポーネントの要求がどの程度のものなのかを決定するために、 実世界の典型的な場合を考えた。 選ばれたテストケースは 「合成コンテナ」である。 2つ以上の標準コンテナの合成である、そのコンテナは広く必要とされているだけでなく、 巨大なシステムで不変性を維持することについての単純で代表的な事例である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// SearchableStack - A stack which can be efficiently searched &lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// for any value. &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SearchableStack&lt;/span&gt; 
{ 
 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; 
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; push(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;pop&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; contains(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; top() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(1) &lt;/span&gt;
 &lt;span style=&#34;color: #A0A000&#34;&gt;private:&lt;/span&gt; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; set_impl; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; list_impl; 
}; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;list&lt;/code&gt; は &lt;code&gt;set&lt;/code&gt; のイテレータのスタックとして振る舞う: 全ての要素は最初に &lt;code&gt;set&lt;/code&gt; に入り、その結果その位置が &lt;code&gt;list&lt;/code&gt; に入れられる。 不変性というのは、簡単なことである: &lt;code&gt;set&lt;/code&gt; と &lt;code&gt;list&lt;/code&gt; は常に、 同じ要素数を持ち、&lt;code&gt;set&lt;/code&gt; 全ての要素は &lt;code&gt;list&lt;/code&gt; の要素により参照されている、ということである。 以下の &lt;code&gt;push&lt;/code&gt; 関数の実装は、 &lt;code&gt;set&lt;/code&gt; と &lt;code&gt;list&lt;/code&gt; によって提供される自然な水準の例外安全性で、 &lt;strong&gt;強い保証&lt;/strong&gt; を提供するために設計されたものである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;                                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; SearchableStack&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;push(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t)         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2&lt;/span&gt;
{                                                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3&lt;/span&gt;
    set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; set_impl.insert(t);      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4&lt;/span&gt;
    try                                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5&lt;/span&gt;
    {                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 6&lt;/span&gt;
        list_impl.push_back(i);                   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 7&lt;/span&gt;
    }                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 8&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...)                                    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 9&lt;/span&gt;
    {                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 10&lt;/span&gt;
        set_impl.erase(i);                        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 11&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;throw&lt;/span&gt;;                                    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 12&lt;/span&gt;
    }                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 13&lt;/span&gt;
}                                                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このコードは実際に、ライブラリの何を要求するだろうか? 非 &lt;code&gt;const&lt;/code&gt; 演算が行われる行を調べてみる必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4行目: 挿入が失敗したが、 &lt;code&gt;set_impl&lt;/code&gt;がその過程で変更されている場合、 不変性は保たれない。そこで、&lt;code&gt;set&amp;lt;T&amp;gt;::insert&lt;/code&gt; からの &lt;strong&gt;強い保証&lt;/strong&gt; に頼ることが出来なければならない。&lt;/li&gt;
&lt;li&gt;7行目: 同様に &lt;code&gt;push_back&lt;/code&gt; が失敗して &lt;code&gt;list_impl&lt;/code&gt; がその過程で変更されているなら、不変性は保たれない。 そこで、&lt;code&gt;list&amp;lt;T&amp;gt;::insert&lt;/code&gt; からの &lt;strong&gt;強い保証&lt;/strong&gt; に頼ることが出来なければならない。&lt;/li&gt;
&lt;li&gt;11行目: ここで4行目の挿入を「巻き戻し」ている。もしこの操作が失敗すれば、 不変性を回復することは出来ないだろう。結局 &lt;code&gt;set&amp;lt;T&amp;gt;::erase&lt;/code&gt; からの &lt;strong&gt;例外不送出保証&lt;/strong&gt; に頼ることになる。&lt;/li&gt;
&lt;li&gt;11行目: 同じ理由で、 &lt;code&gt;i&lt;/code&gt; を &lt;code&gt;erase&lt;/code&gt; 関数に渡すことが出来るということにも、 頼らなければならない: &lt;code&gt;set&amp;lt;T&amp;gt;::iterator&lt;/code&gt; からの、 &lt;strong&gt;例外不送出保証&lt;/strong&gt; に頼る必要があるのである。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は標準化の際にこの方法で問題を扱うことで、多くを学んだ。 まず、合成コンテナに対して明示された保証は、実際はそのコンポーネントからのより強い保証 (11行目の &lt;strong&gt;例外不送出保証&lt;/strong&gt; )に依存するということである。 また、この単純な例を実装するために、自然な水準の例外安全性を全ての面で利用した。 そして、この分析は、以前私が、演算をそれぞれ独立したものと考えていたときには見逃していた、 イテレータへの要求を明らかにした。 結論は、可能な限り自然な水準の例外安全性を提供すべきだ、ということである。 より速く、しかしより安全ではない実装は常に、標準コンポーネントの拡張として提供されるべきである。&lt;/p&gt;
&lt;h2&gt;7 例外安全性の自動テスト&lt;/h2&gt;
&lt;p&gt;標準化の過程の一部として、私は STL での例外安全な参照の実装を作った。 エラー捕捉コードは実際にかなり厳密にテストされたが、 エラー状態を起こすことが難しいので、そのテストは部分的である。 初めて実行されたときにクラッシュしたエラー捕捉コードを考えるというのは、 とても一般的である-出荷される製品では。実装が実際に宣伝通りに動くという確信を強めるために、 私は自動化されたテストスイートを設計した。これは同僚の Matt Arnold の精緻な技術に基づいている。&lt;/p&gt;
&lt;p&gt;テストプログラムは基本的なところから始まった: 特にグローバル演算子 &lt;code&gt;new&lt;/code&gt; と&lt;code&gt;delete&lt;/code&gt;についての強化と計測である。 出来る限り多くの潜在的な問題を明らかにするために選ばれた型引数で、 コンポーネント(コンテナとアルゴリズム)の実体が作られた。 例えば、全ての型引数にはヒープ領域にメモリを割り当てられるポインタが与えられた。 そのため、コンテナに格納されたオブジェクトをリークさせることは、 メモリリークとして検出された。&lt;/p&gt;
&lt;p&gt;最後に、ポインタが間違って示す可能性のある場合に、その都度、 演算に例外を投げさせることが出来るような仕組みを設計した。 クライアントが提供し、例外を投げることが許されている全ての演算の最初に、 &lt;code&gt;ThisCanThrow&lt;/code&gt; の呼び出しが加えられた。 &lt;code&gt;ThisCanThrow&lt;/code&gt; の呼び出しはまた、 テストされる汎用的演算が例外を投げるかもしれない全ての場所にも加えられた。 例えば、より機能を強化したものに置き換えられた、グローバル演算子 &lt;code&gt;new&lt;/code&gt; である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Use this as a type parameter, e.g. vector&amp;lt;TestClass&amp;gt; &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; TestClass 
{ 
    TestClass( &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; ) 
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; p( ThisCanThrow(), &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;( v ) ) {} 
    TestClass( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; p( ThisCanThrow(), &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;( &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p ) ) {} 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        { ThisCanThrow(); &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p; } 
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt;( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        { ThisCanThrow(); &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p; } 
    ...etc... 
    &lt;span style=&#34;color: #666666&#34;&gt;~&lt;/span&gt;TestClass() { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;delete&lt;/span&gt; p; } 
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThisCanThrow&lt;/code&gt; は単に、「throw カウンタ」をデクリメントするだけであり、 もしそれが &lt;code&gt;0&lt;/code&gt; になったら、例外を投げる。 テスト毎に、外側のループで、徐々に大きな値にカウンターを設定して開始し、 演算のテストが完了するまで繰り返し試す、という形を取った。 結果は、失敗する可能性がある実行パスに沿って、連続的なステップで、オペレーションが例外を投げた。 例えば、 &lt;strong&gt;強い保証&lt;/strong&gt; をテストするのに使われた関数の単純なバージョンがある:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; gThrowCounter; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// The throw counter&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;ThisCanThrow&lt;/span&gt;() 
{ 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (gThrowCounter&lt;span style=&#34;color: #666666&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) 
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; 
} 

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Operation&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; StrongCheck(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; op) 
{ 
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; succeeded &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;false&lt;/span&gt;; 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;long&lt;/span&gt; nextThrowCount &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;succeeded; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;nextThrowCount) 
    { 
        Value duplicate &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; v; 
        try 
        { 
            gThrowCounter &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; nextThrowCount; 
            op( duplicate ); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Try the operation &lt;/span&gt;
            succeeded &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; 
        } 
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Catch all exceptions &lt;/span&gt;
        { 
            &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; unchanged &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; duplicate &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; v; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Test strong guarantee &lt;/span&gt;
            assert( unchanged ); 
        } 
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Specialize as desired for each container type, to check &lt;/span&gt;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// integrity. For example, size() == distance(begin(),end()) &lt;/span&gt;
        CheckInvariant(v); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Check any invariant &lt;/span&gt;
    } 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;注意すべきは、この種のテストは非汎用的なコンポーネントより、汎用的なものの方が 遙かに簡単で、煩わしさのないものである、ということである。 これは、テストに特化した型引数を、 テストされるコンポーネントのソースコードを変更することなく使うことが出来るからである。 また上の &lt;code&gt;StrongCheck&lt;/code&gt; のような汎用関数が広範な値と演算のテストを行うのに役立つ。&lt;/p&gt;
&lt;h2&gt;8 さらにくわしく知るための資料&lt;/h2&gt;
&lt;p&gt;私が知る限り、現在 STL の利用可能な例外安全性には2種類の記述しかない。 STL の例外安全の実装のリファレンスでの、オリジナルの仕様 [^2] は、非公式な仕様であり、単純で自明(そして冗長)である。 そこでは、この文書で概説してきた、基本的と強い保証の区別が使われている。 それは明らかに、資源漏れを禁止していて、最終的な C++ 標準と比べ、多くの面で同じなのだが、 保証という点では実質的に異なる。 私はこの文書の改訂版が速やかに作られることを望んでいる。 C++ 標準での例外安全性の記述[^1] はほんの少しだけ公式なものであるが、読みにくい「規格化」 で構成されていて、ウェブ上ではほとんど見ることが出来ない。とくに、資源漏れについては直接は全く扱われていない。 それが規格であるという利点を持っているに過ぎない。&lt;/p&gt;
&lt;p&gt;例外安全の実装[^5] に関するオリジナルのリファレンスは、SGI STL の古いバージョンである。 これは限られた能力の C++ コンパイラのために設計された。 これは完全な STL の実装ではないが、コードは読みやすいし、 役立つ基底クラスのテクニックを、コンストラクタでの例外捕捉をなくすために説明している。 参照の実装を検証するために使われた完全なテストスイート[^3] は、引き続き SGI STL の最近のバージョン全てで使われている。 そして他のベンダの実装をテスト(通らなかった)するのにも使われている。 文書で注記されているように、それは隠れたコンパイラのバグを明らかにするのに、特に最適化と例外捕捉コードが相互作用するような場所では、強力であるだろう。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;International Standard ISO/IEC 14882, Information Technology-Programming Languages-C++, Document Number ISO/IEC 14882-1998, available from &lt;a href=&#34;http://webstore.ansi.org/ansidocstore/default.asp&#34; target=&#34;_blank&#34;&gt;http://webstore.ansi.org/ansidocstore/default.asp&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. Abrahams, Exception Safety in STLport, available at &lt;a href=&#34;http://www.stlport.org/doc/exception_safety.html&#34; target=&#34;_blank&#34;&gt;http://www.stlport.org/doc/exception_safety.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. Abrahams and B. Fomitchev, Exception Handling Test Suite, available at &lt;a href=&#34;http://www.stlport.org/doc/eh_testsuite.html&#34; target=&#34;_blank&#34;&gt;http://www.stlport.org/doc/eh_testsuite.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Tom Cargill, &#34;Exception Handling: A False Sense of Security,&#34; C++ Report, Nov-Dec 1994, also available at &lt;a href=&#34;http://www.awl.com/cp/mec++-cargill.html&#34; target=&#34;_blank&#34;&gt;http://www.awl.com/cp/mec++-cargill.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;B. Fomitchev, Adapted SGI STL Version 1.0, with exception handling code by D. Abrahams, available at &lt;a href=&#34;http://www.metabyte.com/~fbp/stl/old.html&#34; target=&#34;_blank&#34;&gt;http://www.metabyte.com/~fbp/stl/old.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. R. Musser, &#34;Introspective Sorting and Selection Algorithms,&#34; Software-Practice and Experience 27(8):983-993, 1997.&lt;/li&gt;
&lt;li&gt;Bjarne Stroustrup, The Design And Evolution of C++. Addison Wesley, Reading, MA, 1995, ISBN 0-201-54330-3, Section 16.9.1.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;脚注&lt;/h2&gt;
&lt;p&gt;[^1]: おそらく Cargill の場合、解決に対する最も大きな障害は、 彼が、不幸な組み合わせの選択をしてしまったということであった: 彼がコンテナのために選んだインタフェースは、彼が要求する安全性の特徴と一致しないものだったのだ。 どちらかを変更すれば、彼は問題を解決できただろう。&lt;/p&gt;
&lt;p&gt;[^2]: C++ でデストラクタから例外が投げられることは通常進められない。 デストラクタは、それ自身他の例外によって引き起こされるスタック巻き戻しの途中で呼び出されるかもしれないからである。 2番目の例外がデストラクタを越えて伝えられることが可能なら、 問題はすぐに解決する。&lt;/p&gt;
&lt;p&gt;[^3]: 実践としては、 この関数はあまりにも貧弱なランダムシーケンス製作器である!&lt;/p&gt;
&lt;p&gt;[^4]: 変更操作を行うアルゴリズムが通常、 &lt;strong&gt;強い保証&lt;/strong&gt; を提供できないことは、 注目に値する: ある範囲の変更された要素を巻き戻すために、 例外を投げるかもしれない &lt;code&gt;operator=&lt;/code&gt; を使って、以前の状態に戻さなければならないのである。 C++ 標準ライブラリでは、この規則はほとんど守られていて、 巻き戻しの振る舞いは破棄だけで成立している: 例外は、&lt;code&gt;uninitialized_copy&lt;/code&gt;, &lt;code&gt;uninitialized_fill&lt;/code&gt;, &lt;code&gt;uninitialized_fill_n&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;[^5]: C++ 標準ライブラリのクライアントが提供する全ての型引数は、 デストラクタが例外を投げないことを要求される。 その代わりに、 C++ 標準ライブラリの全てのコンポーネントは少なくとも &lt;strong&gt;基本的保証&lt;/strong&gt; を提供するのである。&lt;/p&gt;
&lt;p&gt;[^6]: 変更操作を行う多くのアルゴリズムに対して C++ 規格では 似たような整理が為されている。しかし規格化の過程で時間の制約は全く考えられていない。&lt;/p&gt;
&lt;p&gt;[^7]: 要素の &lt;code&gt;Compare&lt;/code&gt; がコピー時に例外を投げるかもしれないような連想コンテナは、この技を使っていない。 スワップ関数が失敗するかもしれないからである。&lt;/p&gt;
&lt;p&gt;[^8]: これは、たびたび望まれ、しかしまだ見知らぬ &lt;code&gt;container_traits&amp;lt;&amp;gt;&lt;/code&gt; テンプレートのもう一つの潜在的な利用を示している。 例外安全性の制約を満たす、コンテナの自動選択である。&lt;/p&gt;
&lt;p&gt;[^9]: &lt;code&gt;set&amp;lt;T&amp;gt;&lt;/code&gt; に対する要求を減らし、 例外時の問題を減らすために、 &lt;code&gt;erase&lt;/code&gt; を &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; ブロックに入れようとするかもしれない。 しかし結局、問題なのである。 まず、&lt;code&gt;erase&lt;/code&gt; は失敗し、この場合必要な結果を産み出すための実行可能な代替案は存在しない。 また、より一般には、型引数が多様なので、汎用コンポーネントにたいして、 どんな選択肢も成功する保証はめったになされるものではない。&lt;/p&gt;
&lt;p&gt;[^10]: STL の設計の有力な哲学は、全ての利用にとって基本的でない機能は、その機能が必要なときに、基本のコンポーネントを適応することで得られる限り、 効率を求めないでいく、ということである。 これはそのような哲学に端を発しているが、 &lt;strong&gt;基本的保証&lt;/strong&gt; でさえ、 既にその保証を持っていない基本のコンポーネントを適応して、そのような保証を得ることは難しいか、不可能である。&lt;/p&gt;
&lt;p&gt;[^11]: メモリシステムをどのようにして守るかについての素晴らしい議論が、 次のものに書かれている: Steve Maguire, Writing Solid Code, Microsoft Press, Redmond, WA, 1993, ISBN 1-55615- 551-4.&lt;/p&gt;
&lt;p&gt;[^12]: この技は、テストされる操作が例外中立であることを必要とすることに注意すること。 もし操作が例外から回復して、処理を続けようとするなら、&lt;code&gt;throw&lt;/code&gt; カウンタは負の値になるだろう。 そしてその後の失敗するかもしれない操作は、例外安全性に対してテストされない。&lt;/p&gt;
&lt;p&gt;[^13]: 例外安全性を導入した規格草案に対する変更は、 変更される単語の数が多いという理由だけで修正が拒否されるような、 草案作成の過程のかなり遅い時期に為された。 不幸にも、この結果、簡潔さを求める余り、ある程度妥協したものとなった。 Greg Colvin はこれらの変更の範囲を最小化するために必要な、 賢い言語-法実務についての責任がある。&lt;/p&gt;</content>
      
      <author>
        <name>melpon</name>
        <email>melt@e-ml.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>The Boost Concept Check Library (BCCL) -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;The Boost Concept Check Library (BCCL)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/concept_check/concept_check.htm&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/concept_check/concept_check.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ヘッダーファイル： boost/concept_check.hpp と boost/concept_archetype.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ におけるジェネリック・プログラミングは、抽象データ型(あるいは「コンセプト」)を表現するためにテンプレート・パラメータを使用することを特徴としている。 しかし、C++ 言語には、クラス・テンプレートや関数テンプレートに対して、与えられたテンプレート引数がモデル化（もしくは順応）すべきコンセプトを明確に規定するためのメカニズムがない。 よく利用されているのは、必要とされるコンセプトのヒントとなるようにテンプレート・パラメータを命名し、付属文書においてコンセプトの要求事項を記述する方式である。 残念ながら、こういった要求事項の記述は、往々にして曖昧であったり不正確であったり、まったく存在しないこともある。 あるテンプレートが想定している引数の性質を、そのテンプレートのユーザーが正確に理解できなければ、それは由々しき問題となる。 さらに、以下の問題が起こりうる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不正なテンプレート引数に起因するコンパイラ・エラー・メッセージは、難解になることが多い。 大抵の場合、エラーの示す位置はテンプレートが使用された所ではなく、ユーザーが目にする必要のないテンプレートの実装内である。&lt;/li&gt;
&lt;li&gt;記述された要求事項が、テンプレートのコンセプトを完全に表現し切れていない場合、使用されたテンプレート引数が記述された要求事項を満足していたとしても、コンパイラ・エラーを受ける可能性がある。&lt;/li&gt;
&lt;li&gt;記述された要求事項が、テンプレートが実際に必要とするよりも厳格である場合がある。&lt;/li&gt;
&lt;li&gt;要求事項は、コードの中で明示的に記述されることは無い。 そのために、コードの理解がより困難になる。 さらに、コードと記述された要求事項が同期していない事態も生じる可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost コンセプト・チェック・ライブラリは、次のような手段を提供する：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレート・パラメータのコンパイル時チェックを導入するためのメカニズム。&lt;/li&gt;
&lt;li&gt;コンセプト・チェック用クラスによって、要求事項を明確化するためのフレームワーク。&lt;/li&gt;
&lt;li&gt;コンセプトの要求事項が、該当テンプレートをカバーしていることを確認するためのメカニズム。&lt;/li&gt;
&lt;li&gt;C++ 標準ライブラリのコンセプト要求事項に対応する、コンセプト・チェック用クラスおよび原型クラス一式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このメカニズムは C++ 標準の機能のみを使用し、実行時オーバーヘッドを課さない。 メカニズムを導入するコストは、コンパイル時間の増大のみである。&lt;/p&gt;
&lt;p&gt;クラス・テンプレートや関数テンプレートを記述するプログラマは、全員が通常のコード作成作業の一環としてコンセプト・チェックを含めるべきである。 コンセプト・チェックは、コンポーネントへのインターフェイスとして公開されている、すべてのテンプレート・パラメータに対して導入すべきである。 利用したいコンセプトが標準ライブラリーで用いられているものであれば、BCCL の該当するコンセプト・チェック用クラスを、そのまま使用すればよい。 そうでなければ、新たにコンセプト・チェック用クラスを記述することになるが、普通は数行程度に収まるはずだ。 新しいコンセプトを用いるならば、対応する原型クラスも作成すべきである。原型クラスとはコンセプトを表す最小限のスケルトン実装である。&lt;/p&gt;
&lt;p&gt;この文書を、以下の通り構成する。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating-example&#34;&gt;動機の例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#history&#34;&gt;歴史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#publications&#34;&gt;公開資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;コンセプト・チェックの利用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html&#34;&gt;コンセプトの充当化と原型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;コンセプトを用いたプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html&#34;&gt;コンセプト・チェックの実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt; はこのライブラリを寄稿した。 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/beman_dawes.html&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt; が公式レビューを管理した。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#introduction&#34; name=&#34;introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;コンセプト &#34;concept&#34; とは、ジェネリック・アルゴリズムに対する引数として与えられる型が、アルゴリズム内部で正しく使用されるために満足しなければならない要求事項(有効な式、関連型、セマンティクス不変、計算量保証など)の組み合わせである。 C++ では、コンセプトは関数テンプレート(ジェネリック・アルゴリズム)のテンプレート・パラメータとして表現される。 しかしながら、C++ にはコンセプトを表現するための明示的なメカニズムがない。テンプレート・パラメータはただのプレースホルダでしかないのだ。 慣例として、こういったパラメータには、必要とされるコンセプトに対応する名前を与える。しかし、テンプレート・パラメータを実際の型で確定するときに、C++ コンパイラはコンセプトへの遵守を強要しない。&lt;/p&gt;
&lt;p&gt;当然ながら、ジェネリック・アルゴリズムを、そのコンセプトの内、構文に関わる要求事項を満足していない型で呼び出した場合、コンパイル・エラーが生じる。 しかし、このエラーは、該当する型がコンセプトの要求事項すべてに適合していない事実を本質的に 反映したものではない。 それどころか、エラーはインスタンス化階層の深部で発生し、該当する型に対して式が有効でないか、想定された関連型が利用可能でないといったことが原因として挙げられることになるだろう。 こうして生じたエラーメッセージは、大抵において情報に乏しく、基本的に不可解である。&lt;/p&gt;
&lt;p&gt;必要とされるものは、インスタンス化位置(かその近傍)で「コンセプトセーフ」を強要するためのメカニズムである。 Boost コンセプト・チェック・ライブラリーは、早い段階でコンセプトの遵守を強要し、遵守していない場合のエラー・メッセージをより有用にするために C++ 標準の機能を使用する。&lt;/p&gt;
&lt;p&gt;注意すべき点は、この技術がコンセプトの要求事項のうち構文に関わる部分(有効な式および関連型)のみを扱うことである。 我々は、コンセプトの要求事項の一部であるセマンティクス不変あるいは計算量保証を扱わない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating-example&#34; name=&#34;motivating-example&#34;&gt;動機の例&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;テンプレート・ライブラリの不正な使用法と、その結果生じるエラーメッセージを例証するために単純なサンプルを示す。 下記のコードでは、標準テンプレート・ライブラリー (STL) のジェネリックな &lt;code&gt;std::stable_sort()&lt;/code&gt; アルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#generic-programming-and-the-stl&#34;&gt;3&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#stl-tutorial-and-reference-guide&#34;&gt;4&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#the-standard-template-library&#34;&gt;5&lt;/a&gt;] をリンクリストに適用している。&lt;/p&gt;
&lt;p&gt;bad_error_eg.cpp:&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;list&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main(int, char*[]) {
    std::list&amp;lt;int&amp;gt; v;
    std::stable_sort(v.begin(), v.end());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;この場合、&lt;code&gt;std::stable_sort()&lt;/code&gt; アルゴリズムは以下のようなプロトタイプを有する：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIterator first, RandomAccessIterator last);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Gnu C++ でこのコードをコンパイルすると、以下のコンパイラ・エラーを生成する。他のコンパイラ出力は Appendix にリストしてある(訳注 : このバージョンのドキュメントには記載されていない)。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;stl_algo.h: In function `void __merge_sort_loop&amp;lt;_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;,
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int)&#39;:
stl_algo.h:1448:   instantiated from `__merge_sort_with_buffer
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(
   _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;,
   int *, int *)&#39;
stl_algo.h:1485:   instantiated from `__stable_sort_adaptive&amp;lt;
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt;, _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int)&#39;
stl_algo.h:1524:   instantiated from here
stl_algo.h:1377: no match for `_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp; -
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;この場合、根本的なエラーの原因は、&lt;code&gt;std:list::iterator&lt;/code&gt; が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; コンセプトをモデル化していないことにある。 リストのイテレータは双方向でしかなく、(ベクタのイテレータのように) 完全なランダム・アクセスが可能なわけではない。 残念ながら、このエラーメッセージには、ユーザーにこの事実を示すものは何もない。&lt;/p&gt;
&lt;p&gt;C++ プログラマがテンプレート・ライブラリに十分な経験を持っていれば、この手のエラーに惑うことは無いかもしれない。 しかし未熟な者にとっては、次のような理由で、このメッセージが理解し難いものとなっている。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;エラーが生じる位置、bad_error_eg.cpp の６行目は、Gnu C++ がインスタンス化スタックを４レベルも深くまで探索して表示するという事実にもかかわらず、エラーメッセージで示されていない。&lt;/li&gt;
&lt;li&gt;エラーメッセージと、&lt;code&gt;std::stable_sort()&lt;/code&gt; および &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; に関する文書化された要求事項との間に、文面上の相関がない。&lt;/li&gt;
&lt;li&gt;エラーメッセージが過度に長く、ユーザーの知らない(かつ知るべきでない！) STL 内部実装用の関数がリストされている。&lt;/li&gt;
&lt;li&gt;エラーメッセージに、ライブラリ内部の実装用関数が数多くリストアップされているため、プログラマが、エラーの原因は自分のコードではなくライブラリ側にあるとの結論に、誤って飛びついてしまう可能性がある。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;次の例示は、より有用なメッセージとして斯くあるべきと我々が考えるものだ (また実際に Boost コンセプト・チェック・ライブラリが生成するものでもある)。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;boost/concept_check.hpp: In method `void LessThanComparableConcept
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;::constraints()&#39;:
boost/concept_check.hpp:334:   instantiated from `RandomAccessIteratorConcept
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;::constraints()&#39;
bad_error_eg.cpp:6:   instantiated from `stable_sort&amp;lt;_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;(_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, 
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;)&#39;
boost/concept_check.hpp:209: no match for `_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;
  &amp;lt; _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このメッセージは、標準的なエラー・メッセージがもつ欠点をいくつかの点で改善する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エラーの生じた位置 (bad_error_eg.cpp:6）がエラーメッセージに明示されている。&lt;/li&gt;
&lt;li&gt;メッセージは、STL 文書に記述されているコンセプト (&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;RandomAccessIterator&lt;/a&gt;) を明示的に言及している。&lt;/li&gt;
&lt;li&gt;エラーメッセージははるかに短くなり、STL の内部実装用関数を露呈しない。&lt;/li&gt;
&lt;li&gt;エラーメッセージの中に concept_check.hpp および &lt;code&gt;constraints()&lt;/code&gt; が示されることで、ライブラリ実装の中にではなくユーザーのコードにエラーがあるという事実をユーザーに警告している。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#history&#34; name=&#34;history&#34;&gt;歴史&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このコンセプト・チェック・システムの初期バージョンは、著者が SGI において、C++ コンパイラおよびライブラリ・グループの一員として勤務している間に開発された。 初期バージョンは今も SGI STL ディストリビューションの一部である。 Boost コンセプト・チェック・ライブラリは、エラーメッセージにおけるそれほど有用でない表現能力を犠牲にして、コンセプト・チェック用クラス定義を非常に単純化しており、その点で SGI STLのコンセプト・チェックとは異なっている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#publications&#34; name=&#34;publications&#34;&gt;公開資料&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oonumerics.org/tmpw00/&#34; target=&#34;_blank&#34;&gt;C++ テンプレート・ワークショップ2000&lt;/a&gt;、コンセプト・チェック。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;インスタンス化を引き起こすために関数ポインタを使用するアイディアは、Alexander Stepanov に拠る。 テンプレートの事前チェックに式を使用するアイディアに関して、その起源を確認できなかった。しかし、それは D&amp;amp;E[&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#design-and-evolution&#34;&gt;2&lt;/a&gt;] に記載されている。 STL コンセプトに関する優れた文書化と構造化を行った Matt Austern に感謝をささげる。このコンセプト・チェックは彼の仕事を基礎にしている。 有益なコメントとレビューを賜った Boost のメンバにも感謝を。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;次へ：「コンセプト・チェックの利用」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプトの充当化と原型 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/concept_covering.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンセプトの充当化と原型&lt;/h1&gt;
&lt;p&gt;これまで、コンポーネントへの入力に対して、最小限の要求事項(コンセプト)を選択することの重要性を議論してきた。 しかし、選択したコンセプトが対象のアルゴリズムを「充当 &#34;cover&#34;」していることを確認するのも、同様に重要である。 すなわち、発生する可能性のあるユーザ・エラーは全てコンセプト・チェックによって漏れなく捕らえられるべきである。 コンセプト充当性は、「原型クラス &#34;archetype class&#34;」を使用することで確認可能だ。 原型クラスとは、特定のコンセプトに関連するインタフェースの正確な実装である。 原型クラスの実行時の振舞いに重要性はなく、そのメンバ関数本体は空文のままでかまわない。 そうすれば、コンポーネントへの入力として原型クラスを与えてコンパイルするだけで、簡単なテスト・プログラムが作成できる。 そのプログラムがコンパイル可能であれば、対応するコンセプトがそのコンポーネントを充当していることが確認できたことになる。&lt;/p&gt;
&lt;p&gt;以下のコードは、&lt;a href=&#34;http://www.sgi.com/tech/stl/trivial.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;TrivialIterator&lt;/code&gt;&lt;/a&gt; コンセプトに対する原型クラスである。 原型が対応するコンセプトと正確に一致していることを保証するために、いくつかの点で注意しなければならないことがある。 例えば、コンセプトは &lt;code&gt;operator*()&lt;/code&gt; の戻り値型が値型に変換可能でなければならない。 だからといって、これはその戻り値型として、より厳格に &lt;code&gt;T&amp;amp;&lt;/code&gt; あるいは &lt;code&gt;const T&amp;amp;&lt;/code&gt; を要求している訳ではない。 それは、原型クラスの戻り値型として &lt;code&gt;T&amp;amp;&lt;/code&gt; あるいは &lt;code&gt;const T&amp;amp;&lt;/code&gt; を使用することが、誤りとなることを意味する。 正しいアプローチは、&lt;code&gt;T&lt;/code&gt; 型に変換可能なユーザー定義の戻り値型を作成することで、この例では &lt;code&gt;input_proxy&lt;/code&gt; として処理している。 原型クラスを用いたテストの妥当性は、完全にコンセプトとの正確な一致に依存しており、それを確認するためには慎重な（人手による）検査を必要とする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; input_proxy {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;() {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; static_object&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;get(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get a reference without constructing&lt;/span&gt;
  }
};
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;trivial_iterator_archetype&lt;/span&gt;
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; trivial_iterator_archetype self;
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  trivial_iterator_archetype() { }
  trivial_iterator_archetype(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { }
  self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; }
  input_proxy&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;() { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; input_proxy&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); }
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; std {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; trivial_iterator_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; T value_type;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ジェネリック・アルゴリズムのテストとして、一般的な複数の入力型に対してインスタンスの生成を行う場合が往々にしてある。 一例として、&lt;code&gt;std::stable_sort()&lt;/code&gt; に対して、イテレータとして組み込みのポインタ型を適用することが考えられる。 これは、アルゴリズムの実行時の振る舞いをテストするには適切であるが、コンセプト充当性の保証には有用ではない。 なぜなら、C++ の組み込み型は特定のコンセプトとー致を見ることは決してなく、たいていの場合、それが提供する機能は何らかのコンセプトが単独で必要とする最小のそれを上回っている。 すなわち、たとえ与えられた型で関数テンプレートがコンパイルできたとしても、そのコンセプトの要求事項は、その関数を充当する実際の要求事項に及ばないことがありうる。 それ故に、一般的な入力型でテストすることに加えて、原型クラスでコンパイルすることは重要である。&lt;/p&gt;
&lt;p&gt;以下は、記載されている &lt;a href=&#34;http://cpprefjp.github.io/reference/algorithm/stable_sort.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::stable_sort()&lt;/code&gt;&lt;/a&gt; の要求事項をチェックするために原型を使用する方法を示す、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/stl_concept_covering.cpp.html&#34;&gt;stl_concept_covering.cpp&lt;/a&gt; からの抜粋である。 この場合、&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;CopyConstructible&lt;/code&gt;（コピー・コンストラクト可能）&lt;/a&gt; と &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/Assignable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Assignable&lt;/code&gt;（割り当て可能）&lt;/a&gt; 要求事項が、SGI STL 文書から無視されているように見える (試しに、その原型を削除してみるとよい) 。 Boost の原型クラスは、階層構造が取れるように設計されている。 この例において、イテレータの値型は３つの原型から構成される。 下記で参照されている原型クラスでは、&lt;code&gt;Base&lt;/code&gt; という名前のテンプレート・パラメータが、階層化された原型を使用可能であることを示している。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; less_than_comparable_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; 
      sgi_assignable_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ValueType;
  random_access_iterator_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ValueType&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ri;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;stable_sort(ri, ri);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;次へ：「コンセプトを用いたプログラミング」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;前へ：「コンセプト・チェック用クラスの作成」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェック用クラスの作成 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/creating_concepts.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンセプト・チェック用クラスの作成&lt;/h1&gt;
&lt;p&gt;コンセプト・チェック用クラスを作成する方法の例証として、&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; コンセプトに対応するチェック用クラスを作成する方法を考察する。 最初に、命名規約として、コンセプト・チェック用クラスの名前を、対象コンセプトの名称に接尾辞として &#34;Concept&#34; を加えて生成する。 次に、コンセプトにおける有効式を試行する &lt;code&gt;constraints()&lt;/code&gt; という名のメンバ関数を定義しなければならない。 &lt;code&gt;function_requires()&lt;/code&gt; 関数は、この関数のシグネチャが正確に次に示すとおりであることを前提にしている：非 &lt;code&gt;const&lt;/code&gt; メンバ、パラメータ無し、戻り値型 &lt;code&gt;void&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constraints()&lt;/code&gt; 関数の最初の部分は、&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; と、それが基礎を置くコンセプト、&lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; 及び &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;LessThanComparable&lt;/code&gt;&lt;/a&gt; との間にある発展形 &#34;refinement&#34; の関係を表現する要求事項を含んでいる。 そうする代わりに、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロを使用して、クラス本体に要求事項を置くこともできる。しかし、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロは、C++ 言語機能としてはやや移植性に欠けるものを使用しているので、ここでは避けた。&lt;/p&gt;
&lt;p&gt;次に、イテレータの &lt;code&gt;iterator_category&lt;/code&gt; が &lt;code&gt;std::random_access_iterator_tag&lt;/code&gt; あるいはその派生クラスのいずれかであることをチェックする。 その後に、&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; コンセプトにおいて有効な式に当たるコードを書き加える。 &lt;code&gt;typedef&lt;/code&gt; も、関連型のコンセプトを強要するために付加することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; RandomAccessIterator_concept          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//（訳注１）&lt;/span&gt;
  {
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints() {
      function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; BidirectionalIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
      function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; LessThanComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
      function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ConvertibleConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator_category,
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;random_access_iterator_tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

      i &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; n;
      i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; n; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; i;
      i &lt;span style=&#34;color: #666666&#34;&gt;-=&lt;/span&gt; n;
      i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; n;
      n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; j;
      i[n];
    }
    Iter a, b;
    Iter i, j;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;difference_type n;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;(訳注１：いきなり命名規約に反してますが、ライブラリ内の正式版と被らないためだと思われます。よって、原文のまま。)&lt;/p&gt;
&lt;p&gt;コンセプト・チェック用クラスの設計中に陥りやすい潜在的な落し穴は、&lt;code&gt;constraint()&lt;/code&gt; 関数の中で必要よりも多くの式を使用することである。 例えば、式で必要なオブジェクトを作成するために、意図せずデフォルト・コンストラクタを使用してしまうのは良くあることだ（それに、すべてのコンセプトがデフォルト・コンストラクタを必要とするとは限らない)。 クラスのメンバ関数として我々が制約関数を記述するのは、この理由のためである。 式に関与するオブジェクトは、クラスのデータ・メンバとして宣言する。 制約クラス・テンプレートのオブジェクトはインスタンスとして生成されることは無いので、そのデフォルト・コンストラクタがインスタンス化されることはない。 従って、データ・メンバのデフォルト・コンストラクタもインスタンス化されない (C++ 標準 14.7.1 9)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html&#34;&gt;次へ：「コンセプトの充当化と原型」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;前へ：「コンセプト・チェックの利用」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェックの実装 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/implementation.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンセプト・チェックの実装&lt;/h1&gt;
&lt;p&gt;理想的には、実体化位置においてコンセプト侵害が捕らえられ、提示されるに及くはない。 D&amp;amp;E &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#design-and-evolution&#34;&gt;[2]&lt;/a&gt; が言及するように、エラーは、関数テンプレートが必要とする要求事項すべてを試行することにより捕らえることができる。 コードをコンパイルするのみで――一切実行することなく ――済ませたいが故に、要求事項（とくに有効式）を行使する方法は、まさに扱いにくい問題である。 我々のアプローチは、関数ポインタに代入される個別の関数に要求事項を試行させることである。 この場合、コンパイラは関数を実体化するだろうが、実際にそれを起動することはない。 さらに、コンパイラの最適化によって「死んでいるコード」としてポインタ代入は削除されうだろう（代入によって課される実行時オーバヘッドは、どんな場合でも些細であろうが）。 まず第一に、コンパイラが制約関数のセマンティクス解析およびコンパイルをスキップすることは考えられるかもしれない。 そうなれば、関数ポインタ・テクニックは効力を失うだろう。 しかし、不必要なコードおよび関数の除去が、通常はコンパイルの後半の段階で行われるので、これはありそうもない。 関数ポインタ・テクニックは、GNU C++、Microsoft Visual C++、およびいくつかの EDG ベースのコンパイラ（KAI C++、SGI MIPSpro）で問題なく使用できた。 以下のコードは、このテクニックを&lt;code&gt;std::stable_sort()&lt;/code&gt; 関数に適用する方法を示す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort_constraints(RandomAccessIterator i)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;difference_type n;
  i &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; n;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// exercise the requirements for RandomAccessIterator&lt;/span&gt;
  ...
}
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIterator first, RandomAccessIterator last)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;fptr_type)(RandomAccessIterator);
  fptr_type x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;stable_sort_constraints;
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;多くの場合、確認される必要のある要求事項の集合は多大なものとなる。 また、ライブラリ実装者にとって、すべての公開関数テンプレートのために &lt;code&gt;stable_sort_constraints()&lt;/code&gt; のような制約関数を書くのは煩わしいことだろう。 代わりに、対応するコンセプトの定義に従って、有効式の集合を一まとめにする。 各コンセプトに対して、テンプレート・パラメータがあるところでその型をチェックするために、コンセプト・チェック用クラステンプレートを定義する。 このクラスは、コンセプトの有効式をすべて試行する &lt;code&gt;contraints()&lt;/code&gt; メンバ関数を含んでいる。 &lt;code&gt;n&lt;/code&gt; や &lt;code&gt;i&lt;/code&gt; などのような制約関数の中で使用されるオブジェクトは、コンセプト・チェック用クラスのデータ・メンバとして宣言する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; RandomAccessIterator_concept
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints()
  {
    i &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; n;
    ...
  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;difference_type n;
  Iter i;
  ...
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これでメンバ関数ポインタを扱わなくてはならなくなったが、制約関数の実体化を引き起こすために関数ポインタ・メカニズムを使用することは、依然として可能である。 ライブラリ実装者がコンセプト・チェックを呼出すことを簡便にするために、&lt;code&gt;function_requires()&lt;/code&gt; という名前の関数の中に、メンバ関数ポインタ機構を隠蔽した。 以下のコード片は、イテレータが &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; であることを確かめるために &lt;code&gt;function_requires()&lt;/code&gt; を使用する方法を提示する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(Iter first, Iter last)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; RandomAccessIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;function_requires()&lt;/code&gt; の定義は以下のとおりである。 &lt;code&gt;Concept&lt;/code&gt; は、モデルとなる型によって実体化された、コンセプト・チェック用クラスである。 我々は、関数ポインタ &lt;code&gt;x&lt;/code&gt; に制約メンバ関数のアドレスを代入する。 そうすることで、制約関数の実体化およびコンセプトの有効式のチェックを行うことができる。 それから、変数が未使用であることを示すコンパイラ警告を回避するために、&lt;code&gt;x&lt;/code&gt; へ &lt;code&gt;x&lt;/code&gt; を代入し、名前衝突を防ぐために、全体を do-while ループで包む。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Concept&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; function_requires()
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; (Concept&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;x)() &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; BOOST_FPTR Concept&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;constraints;
  ignore_unused_variable_warning(x);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;クラス・テンプレートの型パラメータをチェックするために、クラス定義本体内で使用できる &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロを提供する（関数では本体内で &lt;code&gt;function_requires()&lt;/code&gt; のみを使用すればよいのと対照的である）。 このマクロは入れ子クラス・テンプレートを宣言し、そのテンプレート・パラメータは関数ポインタである。 それから、&lt;code&gt;typedef&lt;/code&gt; の中で、テンプレート引数として、制約関数への関数ポインタ型を渡して入れ子クラス型を使用する。 名前衝突を防ぐ支援として、入れ子クラスおよび &lt;code&gt;typedef&lt;/code&gt; 名において &lt;code&gt;type_var&lt;/code&gt; と&lt;code&gt;concept&lt;/code&gt;の名前を使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#define BOOST_CLASS_REQUIRE(type_var, ns, concept) \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;  typedef void (ns::concept &amp;lt;type_var&amp;gt;::* func##type_var##concept)(); \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;  template &amp;lt;func##type_var##concept _Tp1&amp;gt; \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;  struct concept_checking_##type_var##concept { }; \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;  typedef concept_checking_##type_var##concept&amp;lt; \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;    BOOST_FPTR ns::concept&amp;lt;type_var&amp;gt;::constraints&amp;gt; \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;    concept_checking_typedef_##type_var##concept&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;さらに、２つ以上の型の相互作用を必要とするコンセプトを扱うために、より多くの引数をとる &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; のバージョンがある。 コンパイラの中には、関数ポインタ型のテンプレート・パラメータを実装しないものが複数あるため、BCCL コンセプト・チェックの実装においては&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; を使用していない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;次へ：「リファレンス」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;前へ：「コンセプトを用いたプログラミング」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Programming with Concepts -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/prog_with_concepts.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Programming with Concepts&lt;/h1&gt;
&lt;p&gt;要求事項をまとめてコンセプトにする方法の決定と、各アルゴリズムで使用するコンセプトを決定する過程は、恐らくジェネリック・ライブラリを構築する上で最も困難な(けれども最も重要な) 段階である。 この過程を勤しむ際に使用する指針を、要求事項最小化原理と呼んでいる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要求事項最小化原理&lt;/strong&gt;：より再利用しやすくなるように、コンポーネントの入力パラメータに対する要求事項を最小限にすること。&lt;/p&gt;
&lt;p&gt;この文言には、相反する問題が含まれている。 定義によれば、コンポーネントは課されたタスクを遂行するために、入力パラメータを使用しなければならない(ここで「コンポーネント」とは、関数テンプレートもしくはクラス・テンプレートを意味する)。 その上で、入力に関する仮定を最小に限定する(最小必要条件)ような方法でコンポーネントを実装することが求められる。&lt;/p&gt;
&lt;p&gt;抽象 という従来からある概念は、最小要求事項というアイディアに直接結び付いている。 入力が抽象的であるほど、要求事項は少なくなる。 よって、コンセプトは、C++ テンプレート・プログラミングにおけるジェネリックな抽象データ型の単純な具象化である。&lt;/p&gt;
&lt;p&gt;ある問題領域に対するコンセプトを設計する場合、すなわち、コンポーネントへの入力に関する要求事項を表現するためには、その目的を念頭においておくことが重要である。 要求事項最小化原理に関しては、これは、コンセプトの極小化を意味する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html#translate-note&#34;&gt;訳注1&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;コンセプトにおける極小性は、表現されている問題領域の基礎的なセマンティックスに関連したプロパティである。 基本コンテナの問題領域では、単一方向へのトラバースを必要とすることは、両方向へ必要とするより小さな要求事項である (つまりは &lt;a href=&#34;http://www.sgi.com/tech/stl/ForwardIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; の相違である) 。 セマンティクスの違いは、前方イテレータを有する具象データ型の集合と、双方向イテレータを持つ集合との間にある差異から、容易に見い出すことができる。 例えば、単方向リンク・リストは、双方向イテレータではなく前方イテレータを有するデータ構造の集合に含まれるだろう。 さらに、前方イテレータだけを使用して実装することができるアルゴリズムの集合は、双方向イテレータ無しにはインプリメントできないアルゴリズム集合とは全く重なることがない。 このために、要求事項の一群をある程度きめ細かくコンセプト別に分類することが重要である。 例えば、イテレータに対する要求事項は、STL における６つのイテレータ・コンセプト(自明、出力、入力、前方、双方向、ランダムアクセス)に分類される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html&#34;&gt;次へ：「コンセプト・チェックの実装」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html&#34;&gt;前へ：「コンセプトの充当化と原型」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html#translate-note&#34; name=&#34;translate-note&#34;&gt;訳注1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ここには、重要な論点について記したパラグラフがありましたが、標準との整合性の理由からコメントアウトされています。コメントアウトされた内容を、以下に翻訳引用します：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;以下の文章は、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; の変更された標準定義およびニーズと一致しない。-Jeremy 

しかし、コンセプトの極小化が、コンセプト内で有効式の数を単純に減少させることに直結しないことは重要な注意点である。
例えば、std::stable_sort()関数は、値型のイテレータが &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; を満たすことを必要とするが、このコンセプトは operator&amp;lt;() だけでなく、operator&amp;gt;、operator&amp;lt;=()、operator&amp;gt;=() を含んでいる。
std::stable_sort() は operator&amp;lt;() のみを使用することが判明している。
そうなると、疑問が生じる：
std::stable_sort() の特殊化は、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; コンセプトに基づくべきなのか、あるいはただoperator&amp;lt;() のみを必要とするコンセプトに基づくべきなのだろうか。

operator&amp;lt;() から他の演算子をすべて自明な形で実装できるので、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; を用いても実際には要求事項最小化原理に触れてはいない、とまずは云うことができよう。
ここで「自明」が意味するのは、一行のコードと実行時に課される一定のコストに過ぎない。
とはいえ、より根源的に言えば、全ての比較演算子 (&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt;=) は (数学的な感覚において) 概念的に等価であるから、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; を用いたとしても要求事項最小化原理を犯すことにはならない。
概念的に等価な有効式を加えたとしても、セマンティクスの面からすれば、新しいものはなにも加わっていない――ただ新しい構文だけである――ので、要求事項最小化原理の侵害にはあたらない。
こういった構文の追加は再利用性を高めるのだ。

例えば、結局のところ比較演算子は等価であるから、std::stable_sort() の管理者がいつか operator&amp;lt;() の代わりに operator&amp;gt;() を使用するよう実装を変更するかもしれない。
要求事項は公開インタフェースの一部であるから、そのような変更は潜在的にクライアント・コードを破壊しかねない。
代わりに、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; がstd::stable_sort()の要求事項であれば、管理者がその仕事をこなす際に、妥当な程度の柔軟性を与えられることになる。
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>リファレンス -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/reference.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;リファレンス&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#functions&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#macros&#34;&gt;マクロ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#basic-concepts&#34;&gt;基本コンセプト･チェック用クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#iterator-concepts&#34;&gt;イテレータ･コンセプト･チェック用クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#function-object-concepts&#34;&gt;関数オブジェクト・コンセプト･チェック用クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#container-concepts&#34;&gt;コンテナ･コンセプト･チェック用クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#basic-archetype&#34;&gt;基本原型クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#iterator-archetype&#34;&gt;イテレータ原型クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#function-object-archetype&#34;&gt;関数オブジェクト原型クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#container-archetype&#34;&gt;コンテナ原型クラス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#functions&#34; name=&#34;functions&#34;&gt;関数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Concept&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; function_requires();
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#macros&#34; name=&#34;macros&#34;&gt;マクロ&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クラス定義内でコンセプト・チェックに適用する&lt;/span&gt;
BOOST_CLASS_REQUIRE(&lt;i&gt;type&lt;/i&gt;, &lt;i&gt;namespace&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;of&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;concept&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRE2(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;namespace&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;of&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;concept&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRE3(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;type&lt;/i&gt;3, &lt;i&gt;namespace&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;of&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;concept&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRE4(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;type&lt;/i&gt;3, &lt;i&gt;type&lt;/i&gt;4, &lt;i&gt;namespace&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;of&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;concept&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;推奨されないマクロ：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クラス定義内でコンセプト・チェックに適用する&lt;/span&gt;
BOOST_CLASS_REQUIRES(&lt;i&gt;type&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRES2(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRES3(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;type&lt;/i&gt;3, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRES4(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;type&lt;/i&gt;3, &lt;i&gt;type&lt;/i&gt;4, &lt;i&gt;concept&lt;/i&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#basic-concepts&#34; name=&#34;basic-concepts&#34;&gt;基本コンセプト・チェック用クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; IntegerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// T は組み込み整数型であるか？&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SignedIntegerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// T は組み込み符号付き整数型であるか？&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; UnsignedIntegerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// T は組み込み符号無し整数型であるか？&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ConvertibleConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// X は Y へ変換可能か？&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AssignableConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SGIAssignableConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; DefaultConstructibleConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; CopyConstructibleConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 20.1.3 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EqualityComparableConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 20.1.1 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; LessThanComparableConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 20.1.2 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ComparableConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;SGI STL LessThanComparable&lt;/a&gt; コンセプト&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#iterator-concepts&#34; name=&#34;iterator-concepts&#34;&gt;イテレータ･コンセプト･チェック用クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; TrivialIteratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_TrivialIteratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; InputIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.1 Table 72参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; OutputIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.2 Table 73参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ForwardIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.3 Table 74参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_ForwardIteratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BidirectionalIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.4 Table 75参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_BidirectionalIteratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; RandomAccessIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.5 Table 76参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_RandomAccessIteratorConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#function-object-concepts&#34; name=&#34;function-object-concepts&#34;&gt;関数オブジェクト・コンセプト･チェック用クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; GeneratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; UnaryFunctionConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BinaryFunctionConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; UnaryPredicateConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BinaryPredicateConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Const_BinaryPredicateConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptableGeneratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptableUnaryFunctionConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptableBinaryFunctionConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptablePredicateConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptableBinaryPredicateConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#container-concepts&#34; name=&#34;container-concepts&#34;&gt;コンテナ･コンセプト･チェック用クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ContainerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1 Table 65 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_ContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ForwardContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_ForwardContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ReversibleContainerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1 Table 66 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_ReversibleContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; RandomAccessContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_RandomAccessContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SequenceConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1.1 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; FrontInsertionSequenceConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BackInsertionSequenceConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AssociativeContainerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1.2 Table 69 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; UniqueAssociativeContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; MultipleAssociativeContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SimpleAssociativeContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; PairAssociativeContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SortedAssociativeContainerConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#basic-archetype&#34; name=&#34;basic-archetype&#34;&gt;基本原型クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;null_archetype&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// モデル化するコンセプトが無いことを示す型&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;default_constructible_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;assignable_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;copy_constructible_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;equality_comparable_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;convertible_to_archetype&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#iterator-archetype&#34; name=&#34;iterator-archetype&#34;&gt;イテレータ原型クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;trivial_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;mutable_trivial_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;input_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;forward_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;bidirectional_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;random_access_iterator_archetype&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#function-object-archetype&#34; name=&#34;function-object-archetype&#34;&gt;関数オブジェクト原型クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_function_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg2&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;binary_function_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;predicate_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;binary_predicate_archetype&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#container-archetype&#34; name=&#34;container-archetype&#34;&gt;コンテナ原型クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;構築中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;「はじめに」へ戻る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html&#34;&gt;前へ：「コンセプト・チェックの実装」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェックの利用 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/using_concept_check.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンセプト・チェックの利用&lt;/h1&gt;
&lt;p&gt;各コンセプトに対して、与えられた型 (あるいは型の集合) がコンセプトをモデル化していることを確かめるために使用することができる、何らかのコンセプト・チェック用クラスが存在する。 Boost コンセプト・チェック・ライブラリ (BCCL) は、C++ 標準ライブラリの中で使用される全てのコンセプト＋αを対象とした、コンセプト・チェック用クラスを含んでいる。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt; セクションに、このコンセプト・チェック用クラスをリストしてある。 さらに、他の Boost ライブラリも、ライブラリ独自の特別なコンセプトに対応するコンセプト・チェック用クラスを付随している。 例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.md.nolink&#34;&gt;graph concept&lt;/a&gt; および &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/property_map.md.nolink&#34;&gt;property map concept&lt;/a&gt; がある。 さらに、クラス・テンプレートや関数テンプレートを記述する者は、既存のコンセプトでカバーされていない要求事項を表現する必要のある場合は常に、新しいコンセプト・チェック用クラスを作成すべきである。 その方法は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt; セクションで説明する。&lt;/p&gt;
&lt;p&gt;BCCL のコンセプト・チェック用クラスの例として、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; クラスを挙げる。 このクラスは、C++ 標準 20.1.1 に記述されている &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) 要求事項および、SGI STL で文書化されている &lt;a href=&#34;http://www.sgi.com/tech/stl/EqualityComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;EqualityComparable&lt;/code&gt;&lt;/a&gt; (等値比較可能) コンセプトに相当する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EqualityComparableConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;テンプレート引数 &lt;code&gt;T&lt;/code&gt; はチェック対象の型と意図されている。 すなわち、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; の目的は、&lt;code&gt;T&lt;/code&gt; に対して与えられたテンプレート引数が 等値比較可能コンセプトをモデル化しているかどうか確認することである。&lt;/p&gt;
&lt;p&gt;個々のコンセプト・チェック用クラスには、該当するコンセプトにおいて有効な式を内包する &lt;code&gt;constraints()&lt;/code&gt; という名前のメンバー関数がある。 ある型が &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) であるかどうかチェックするためには、その型でコンセプト・チェック用クラスのインスタンスを生成し、次に、コンパイラに、実際に &lt;code&gt;constraints()&lt;/code&gt; 関数を実行することなくコンパイルさせる方法を見つける必要がある。 Boost コンセプト・チェック・ライブラリは、これを容易にする2つのユーティリティ： &lt;code&gt;function_requires()&lt;/code&gt; と &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; を定義している。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;function_requires()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;function_requires()&lt;/code&gt; 関数は関数本体の中で使用できる。また、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロはクラス定義本体で使用できる。 &lt;code&gt;function_requires()&lt;/code&gt; 関数は引数をとらないが、コンセプト・チェック用クラスを受けるためのテンプレート・パラメータを有する。 これは、以下に示すように、インスタンス化されたコンセプト・チェック用クラスを明示的にテンプレート引数として与えられなければならないことを意味する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; generic_library_function(T x)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; EqualityComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  foo f;
  generic_library_function(f);
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロは、ある型がコンセプトをモデル化しているかどうかチェックするために、クラス定義の内部で使用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; generic_library_class
{
  BOOST_CLASS_REQUIRE(T, boost, EqualityComparableConcept);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  generic_library_class&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; glc;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;以前の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating_example&#34;&gt;動機の例&lt;/a&gt; に対してコンセプト・チェックを応用する場合、良いやり方として、テンプレート・パラメータ型が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデル化していることを確認するために &lt;code&gt;std::stable_sort()&lt;/code&gt; の一番上に &lt;code&gt;function_requires()&lt;/code&gt; を挿入することが一つ挙げられる。 さらに、&lt;code&gt;std::stable_sort()&lt;/code&gt; は、イレテータの &lt;code&gt;value_type&lt;/code&gt; が&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;LessThanComparable&lt;/code&gt; (未満比較可能)&lt;/a&gt; を満足することが必要であるから、これをチェックするために、重ねて &lt;code&gt;function_requires()&lt;/code&gt; を使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIter first, RandomAccessIter last)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; RandomAccessIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type value_type;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; LessThanComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;value_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンセプトによっては複数の型を処理するものがある。 この場合、対応するコンセプト・チェック用クラスは複数のテンプレート・パラメータを持つことになる。 以下の例は、&lt;code&gt;function_requires()&lt;/code&gt; を、２つの型パラメータ（プロパティ・マップ型とそのキーとなる型）をとる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; コンセプトに対して使用する方法を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;IncidenceGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor Vertex;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ReadWritePropertyMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ColorMap, Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; の使用例として、&lt;code&gt;std::vector&lt;/code&gt; が有すべきコンセプト・チェックを考察する。 要素型に対して当てはめる要求事項の一つは、それが &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Assignable&lt;/code&gt; (割当可能)&lt;/a&gt;でなければならない、ということである。 これは、&lt;code&gt;std::vector&lt;/code&gt; の定義の一番上に&lt;code&gt;BOOST_CLASS_REQUIRE(T, boost, AssignableConcept)&lt;/code&gt;を挿入することにより、チェックすることができる。&lt;/p&gt;
&lt;p&gt;コンセプト・チェックは、ジェネリック・ライブラリの実装者が使用するために設計されているが、エンドユーザーにおいても有用である。 往々にして、ある型が特定のコンセプトをモデル化しているかどうか、不明確な場合がある。 こういうケースでは、問題の型とコンセプトを対象として &lt;code&gt;function_requires()&lt;/code&gt; を使用する、小さなプログラムを作成することで容易にチェックできる。 ファイル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/stl_concept_check.cpp.html&#34;&gt;stl_concept_checks.cpp&lt;/a&gt; は、STL コンテナにコンセプト・チェックを適応する実例となっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;次へ：「コンセプト・チェック用クラスの作成」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;前へ：「はじめに」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Distjoint Sets（互いに素な集合） -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/disjoint_sets.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Distjoint Sets（互いに素な集合）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、互いに素な集合（素集合）の演算に 順位による和集合 および パス圧縮 を提供する。disjoint-sets のデータ構造は、素集合の S = {S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ..., S&lt;sub&gt;k&lt;/sub&gt;} というコレクションを維持する。 各集合は、集合のいくつかの要素である 代表値 によって識別される。 集合は、Parent プロパティマップの中の符号化された有向木によって表わされる。 2つの発見的手法: 「順位による和集合」 および 「パス圧縮」 は、 演算を高速化するのに使われる  [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#tarjan83&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#clr90&#34;&gt;2&lt;/a&gt;]。&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;boost/disjoint_sets.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Rank&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値型が整数型で、キー型が集合の要素型と等しい &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Parent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルで、かつ、キー型および値型は集合の要素型と等しくなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;disjoint_sets&lt;/code&gt; に対する典型的な使用法の手本は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/kruskal_minimum_spanning_tree.md.nolink&#34;&gt;&lt;code&gt;kruskal_minimum_spanning_tree()&lt;/code&gt;&lt;/a&gt; アルゴリズムで見ることができる。 この例では、&lt;code&gt;union_set()&lt;/code&gt; の代わりに &lt;code&gt;link()&lt;/code&gt; を呼び出す。 なぜなら、&lt;code&gt;u&lt;/code&gt; および &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;find_set()&lt;/code&gt; から得られ、したがって、既にそれら集合の代表値であるからだ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;...
disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; dsets(rank, p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (ui  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G).first; ui &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vertices(G).second; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ui)
  dsets.make_set(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ui);
...
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; ( &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;Q.empty() ) {
  e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Q.front();
  Q.pop();
  u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(source(e));
  v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(target(e));
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( u &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v ) {
    &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;out&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; e;
    dsets.link(u, v);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(Rank r, Parent p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(const disjoint_sets&amp;amp; x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void make_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Element x&lt;/code&gt; を含む単集合を作成する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void link(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; で表わされる 2つの集合を結合する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void union_set(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; を含む 2つの集合を結合する。 これは、&lt;code&gt;link(find_set(x),find_set(y))&lt;/code&gt; に相当する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Element find_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; を含む集合のための代表値を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;std::size_t count_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;素集合の個数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void compress_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;すべての要素の親がその代表値であるように親ツリーを平滑化する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Complexity&lt;/h2&gt;
&lt;p&gt;時間計算量は、O(m alpha(m,n)) である。alpha は逆アッカーマン関数、 m は disjoint-set の演算（&lt;code&gt;make_set()&lt;/code&gt;、&lt;code&gt;find_set()&lt;/code&gt;、および &lt;code&gt;link()&lt;/code&gt;）の総数、n は要素数である。 alpha 関数はとても遅く、log 関数よりもはるかに遅くなる。&lt;/p&gt;
&lt;p&gt;参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_connected_components.md.nolink&#34;&gt;&lt;code&gt;incremental_connected_components()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ID,InverseID,FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、順位および親のプロパティのための記憶領域を内部で管理する。 記憶領域は、要素IDにより索引付けされた配列の中にある。ゆえに、ID および InverseID ファンクタを必要とする。 順位および親のプロパティは、構築中に初期化される、 したがって、各要素は自動的に集合の中にある（従って、このクラスのオブジェクトを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.md.nolink#sec:initialize-incremental-components&#34;&gt;&lt;code&gt;initialize_incremental_components()&lt;/code&gt;&lt;/a&gt; 関数で初期化することは必要でない。）。 このクラスは、頂点プロパティを格納する場所を提供しない &lt;code&gt;edge_list&lt;/code&gt; グラフの（動的）接続している構成要素を計算する場合に特に有用である。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0からN（集合中の要素の総数）までの整数に要素を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;InverseID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素に整数を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;representative_with_full_path_compression&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;p&gt;このクラスは、以下のメンバだけでなく &lt;code&gt;disjoint_sets&lt;/code&gt; のすべてのメンバも持っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage(size_type n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
                           ID id &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ID(),
                           InverseID inv &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; InverseID())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンストラクタ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ElementIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;
  normalize_sets(ElementIterator first, ElementIterator last)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;各集合の代表値が最も小さな ID を備えた要素になるように代表値を再整理する。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事後条件: &lt;code&gt;v &amp;gt;= parent[v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事前条件: 素集合の構造は圧縮されていなければならない。 &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_path_halving&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; と同じ構成要素のための代表的な頂点を検索するファンクタである。 代表値木を横断している間、ファンクタは、さらに木の高さを短くするためにパス二分技術を適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_full_path_compression&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; が属する集合のための代表的な要素を検索するファンクタである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~llee1&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:llee1@lsc.nd.edu&#34;&gt;llee1@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:lums@lsc.nd.edu&#34;&gt;lums@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 IKOMA Yoshiki &lt;a href=&#34;mailto:ikoma@mb.i-chubu.ne.jp&#34;&gt;ikoma@mb.i-chubu.ne.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>参考文献 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/disjoint_sets/bibliography.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#tarjan83&#34; nam=&#34;tarjan83&#34;&gt;1&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;R. E. Tarjan. &lt;/li&gt;
&lt;li&gt;Data Structures and Network Algorithms. &lt;/li&gt;
&lt;li&gt;Society for Industrial and Applied Mathematics, 1983.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#clr90&#34; name=&#34;clr90&#34;&gt;2&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;T. Cormen, C. Leiserson, and R. Rivest. &lt;/li&gt;
&lt;li&gt;Introduction to Algorithms. &lt;/li&gt;
&lt;li&gt;McGraw-Hill, 1990.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Improved Function Object Adapters -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Improved Function Object Adapters&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/functional/&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/functional/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準ライブラリの関数オブジェクトアダプタ(セクション 20.3.5 から 20.3.8)を強化する。この強化は主に二つの変更を行う。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我々は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;参照の参照&lt;/a&gt; 問題を回避し、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#args&#34;&gt;引数渡し&lt;/a&gt; の効率を良くするために、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; テンプレートを使う。&lt;/li&gt;
&lt;li&gt;我々は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html&#34;&gt;&lt;code&gt;ptr_fun&lt;/code&gt;&lt;/a&gt; の必要性を回避するために、このライブラリのアダプタとともに、ふたつの&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を使う。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;p&gt;このヘッダは以下の関数・クラステンプレートを含む:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分類&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;Function object traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_traits&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binary_traits&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクトや関数の引数型を決定するために使われる。&lt;code&gt;ptr_fun&lt;/code&gt;の必要性を除去する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html&#34;&gt;Negators&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binary_negate&lt;/code&gt;&lt;br /&gt; &lt;code&gt;not1&lt;/code&gt;&lt;br /&gt; &lt;code&gt;not2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.5 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html&#34;&gt;Binders&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;binder1st&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binder2nd&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bind1st&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bind2nd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.6 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html&#34;&gt;Adapters for pointers to functions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pointer_to_unary_function&lt;/code&gt;&lt;br /&gt; &lt;code&gt;pointer_to_binary_function&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptr_fun&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.7 に基づく。このライブラリとともに使用する場合はバインダやネゲータは関数に適合できるので不要である。しかし、サードパーティのアダプタに必要とされるかもしれない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html&#34;&gt;Adapters for pointers to member functions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mem_fun_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun1_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun1_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun1_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun1_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun_ref&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.8 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;これらのアダプタの使い方は標準関数オブジェクトアダプタの使い方にとてもよく似ている。唯一の違いは、&lt;code&gt;std::&lt;/code&gt; の代わりに &lt;code&gt;boost::&lt;/code&gt; と書く必要があることだけである。そうすればあなたの頭痛は軽減される。&lt;/p&gt;
&lt;p&gt;例えば、あなたが &lt;code&gt;set_name&lt;/code&gt; 関数を持つ&lt;code&gt;Person&lt;/code&gt;クラスを持っていると考えてほしい:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Person&lt;/span&gt;
{
  &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set_name(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;name);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;あなたは以下のように書くことによって、コレクション &lt;code&gt;c&lt;/code&gt; 中の &lt;code&gt;Person&lt;/code&gt; の束を改名できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Person&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set_name), &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Fred&#34;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もし代わりに標準アダプタが使われていれば、このコードは普通、コンパイルに失敗する。それは、&lt;code&gt;set_name&lt;/code&gt; が参照引数を取るからである。何故こうなるかを解明したければ、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;バインダのドキュメント&lt;/a&gt; の中のコメントを参照するとよい。&lt;/p&gt;
&lt;h2&gt;Compiler Compatibility&lt;/h2&gt;
&lt;p&gt;このヘッダと &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_test.cpp.html&#34;&gt;テストプログラム&lt;/a&gt; は以下のコンパイラでコンパイルされる:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;コンパイラ&lt;/th&gt;
&lt;th&gt;コメント&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Borland C++Builder 4 Update 2&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Borland C++ 5.5&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g++ 2.95.2&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft Visual C++ Service Pack 3&lt;/td&gt;
&lt;td&gt;コンパイラが部分特殊化版を欠いているため、このライブラリは標準アダプタによって提供されるより、少しだけしか多くの機能を提供しない。&lt;br /&gt; ・参照の参照問題を回避するための &lt;code&gt;call_traits&lt;/code&gt; メカニズムが使えない。それゆえ、このライブラリのアダプタはより少ない状況でしか使えないだろう。&lt;br /&gt; ・関数の引数や返り値型を特定するための &lt;code&gt;function_traits&lt;/code&gt; メカニズムが使えない。それゆえ、関数を適合させるため、&lt;code&gt;ptr_fun&lt;/code&gt; が引き続き必要になる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Future Directions&lt;/h2&gt;
&lt;p&gt;このライブラリの第一目的は、できる限り多くの標準ライブラリの互換性を 持つ、参照の参照問題に対する解である。これによって本や雑誌で読む技術を 今日のたくさんのコンパイラで使うことができる。&lt;/p&gt;
&lt;p&gt;長期的には、より良い解は以下のようなものだろう:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;幾人かの Boost のメンバは式テンプレートのライブラリを作成し ている。これらによって、関数の結合や適合が自然な文法で行えるだろう。 これは新しい技術なので、それが熟して、有名なコンパイラに広くサポートされるまでに時間がかかるかもしれないが、大きな成功となるだろう。それまでは、この functional.hpp ライブラリがギャップを埋める。&lt;/li&gt;
&lt;li&gt;標準委員会はテンプレートの実体化に際して参照の参照問題が起きることを認識していて、標準を修正する気になっている( &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Author&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/mark_rodgers.htm&#34; target=&#34;_blank&#34;&gt;Mark Rodgers&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/john_maddock.htm&#34; target=&#34;_blank&#34;&gt;John Maddock&lt;/a&gt; for suggesting the mechanism that allowed the function objects traits to work correctly. &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jens_maurer.htm&#34; target=&#34;_blank&#34;&gt;Jens Maurer&lt;/a&gt; provided invaluable feedback during the &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/more/formal_review_process.htm&#34; target=&#34;_blank&#34;&gt;formal review process&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Binders -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/binders.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Binders&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.6): 由来のバインダ関数オブジェクトアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binder1st&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binder2nd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bind1st&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind2nd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準ライブラリにあるそれらの代わりに、これらのアダプタを使う主な便益は、それらが &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;参照の参照&lt;/a&gt; 問題を回避することにある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い方は標準バインダと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Foo&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34; name=&#34;refref&#34;&gt;References to References&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下の使用例を考えなさい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Foo&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これがもし &lt;code&gt;std::bind2nd&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt; を使って書かれているならば、コンパイルできないだろう。&lt;/p&gt;
&lt;p&gt;この問題は &lt;code&gt;bar&lt;/code&gt; が参照引数を取ることが原因で起こる。標準は &lt;code&gt;std::mem_fun_ref&lt;/code&gt; を &lt;code&gt;second_argument_type&lt;/code&gt; が &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; である関数オブジェクトを作るように定義する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind2nd&lt;/code&gt; 呼び出しは &lt;code&gt;binder2nd&lt;/code&gt; を作り、それは標準が以下のように定義している:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Operation&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;binder2nd&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;first_argument_type,
                            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;result_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
...
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  binder2nd(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x,
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;second_argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; y);
  ...
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々の &lt;code&gt;Operation&lt;/code&gt; の &lt;code&gt;second_argument_type&lt;/code&gt; は &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; であるから、コンストラクタの中の &lt;code&gt;y&lt;/code&gt; の型は &lt;code&gt;std::ostream&amp;amp;&amp;amp;&lt;/code&gt; となるだろう。参照の参照を作ることはできないから、参照の参照は C++ では非合法であるとしてこの時点でコンパイルエラーになる。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;このライブラリのバインダは Boost &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; テンプレートを使うことによってこの問題を回避している。&lt;/p&gt;
&lt;p&gt;コンストラクタは以下のように宣言される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;binder2nd(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x,
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
             &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; binary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;second_argument_type
          &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type y)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;結果、&lt;code&gt;y&lt;/code&gt; は &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; 型を持つ。そして、我々の例はコンパイルされる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Function Object Traits -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/function_traits.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Function Object Traits&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは関数と関数オブジェクトのための、二つの特性クラステンプレートを提供します:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Contents&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;struct unary_traits&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;function_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクト自身の型 (例えば &lt;code&gt;T&lt;/code&gt;)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;param_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトをパラメータとして渡すために使われるべき型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの返り値の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;argument_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの引数の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;struct binary_traits&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;function_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクト自身の型 (例えば &lt;code&gt;T&lt;/code&gt;)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;param_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトをパラメータとして渡すために使われるべき型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの返り値の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;first_argument_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの第一引数の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;second_argument_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの第二引数の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;unary_traits&lt;/code&gt; は一引数を取る関数と適合一引数関数オブジェクト (例えば &lt;code&gt;std::unary_function&lt;/code&gt; を継承したクラス) や、同様の &lt;code&gt;typedef&lt;/code&gt; がなされたクラス)のどちらかとともに実体化されなければならない。(C++ 標準の §20.3.1 を参照せよ)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;binary_traits&lt;/code&gt; は二引数を取る関数と適合二引数関数オブジェクト (例えば &lt;code&gt;std::binary_function&lt;/code&gt; を継承したクラス) や、同様の &lt;code&gt;typedef&lt;/code&gt; がなされたクラス)のどちらかとともに実体化されなければならない。(C++ 標準の §20.3.1 を参照せよ)&lt;/p&gt;
&lt;p&gt;これらのテンプレートのもっとも一般的な使い方は、関数オブジェクトアダプタ内で、関数オブジェクトと同様に普通の関数を適合させることである。普段例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;と書く所ならどこでも、代わりに&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;unary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;argument_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;と書くだけで良い。&lt;/p&gt;
&lt;h2&gt;Additional Types Defined&lt;/h2&gt;
&lt;p&gt;標準の返り値と引数の &lt;code&gt;typedef&lt;/code&gt; に加えて、これらの特性テンプレートは二つの型を定義する。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;function_type&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;これは関数や関数オブジェクトの型である。そして、宣言の中で以下のように使われる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
{
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
  &lt;span style=&#34;color: #A0A000&#34;&gt;private:&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; unary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;function_type pred;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしこの &lt;code&gt;typedef&lt;/code&gt; がなければ、&lt;code&gt;unary_negate&lt;/code&gt;を関数型とともに実体化させることができる方法で、&lt;code&gt;pred&lt;/code&gt;を宣言することはできないだろう。(C++ 標準の §14.3.1 ¶3 を参照せよ)&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;param_type&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;これは関数や関数オブジェクトを他の関数に引数として渡すのに最適な型である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
{
  &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; unary_negate(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; unary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x)
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt;
        pred(x)
    {}
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;関数オブジェクトは定数参照で渡され、関数ポインタは値渡しされる。&lt;/p&gt;
&lt;h2&gt;Limitations&lt;/h2&gt;
&lt;p&gt;このライブラリは全てのアダプタ関数オブジェクトでこれらの特性を利用していて、理論的には、&lt;code&gt;ptr_fun&lt;/code&gt;を廃止されるようにする。しかし、サードパーティのアダプタは多分このメカニズムを利用しないだろうし、&lt;code&gt;ptr_fun&lt;/code&gt;は未だ必要である。このライブラリは標準関数ポインタアダプタの改善バージョンを提供する。&lt;/p&gt;
&lt;p&gt;これらの特性テンプレートも、テンプレートの部分特殊化版を提供できないコンパイラでは動かないだろう。これらのコンパイラでは、特性テンプレートは適合関数オブジェクトでのみ実体化され、このライブラリの関数オブジェクトとももに用いる場合でさえ、&lt;code&gt;ptr_fun&lt;/code&gt;を使う必要があるだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Member Function Adapters -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/mem_fun.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Member Function Adapters&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準ライブラリ (§ 20.3.8): 由来のメンバ関 数アダプタの全ての強化バージョンを含んでいる:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem_fun_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun1_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun1_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun1_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun1_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem_fun&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun_ref&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準のアダプタそれぞれから、以下の変更がなされている:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;first_argument_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; は &lt;code&gt;const_&lt;/code&gt; ファミリーのメンバ関数アダプタのために 修正されている。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#firstarg&#34;&gt;以下&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fun1_t&lt;/code&gt;やその変種に渡される引数は、メンバ関数の引数型として、&lt;code&gt;call_traits::param_type&lt;/code&gt; を用いて渡される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#firstarg&#34; name=&#34;firstarg&#34;&gt;first_argument_type&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;const_mem_fun1_t&lt;/code&gt; を例えば、以下のように指定する:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;S&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;const_mem_fun1_t&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;, A, S&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;const_mem_fun1_t&lt;/span&gt;(S (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;p)(A) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);
  S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, A x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;binary_function&lt;/code&gt; への第一引数が実際には &lt;code&gt;const T*&lt;/code&gt; であるにも関わらず、 &lt;code&gt;T*&lt;/code&gt; になっている点に注意しなさい。&lt;/p&gt;
&lt;p&gt;これはどういうことか？さて、我々が以下のように書くとき何が起こるかを考えなさい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Foo { &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;; };
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;cp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Foo;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind1st(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), cp);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は以下のようなものを効果的に含む &lt;code&gt;const_mem_fun1_t&lt;/code&gt; オブジェクトを作成した。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Foo&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; first_argument_type;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次に &lt;code&gt;bind1st&lt;/code&gt; はこの &lt;code&gt;typedef&lt;/code&gt; を &lt;code&gt;cp&lt;/code&gt; によって初期化されるメンバ型として用いる &lt;code&gt;binder1st&lt;/code&gt; オブジェクトを作成する。言い換えれば、我々は &lt;code&gt;Foo*&lt;/code&gt; メンバを &lt;code&gt;const Foo*&lt;/code&gt; メンバで初期化する必要がある！ 明らかに これは不可能であるので、標準ライブラリのベンダはこれを実装するために &lt;code&gt;cp&lt;/code&gt; の定数性を、おそらく &lt;code&gt;bind1st&lt;/code&gt; の本体の中で、キャストして取り除かなければならなかっただろう。&lt;/p&gt;
&lt;p&gt;このハックは改良された &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html&#34;&gt;バインダ&lt;/a&gt; とともに用いる場合十分ではないので、我々はメンバ関数アダプタの修正されたバージョンも同様に提供しなければならなかった。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;mem_fun1_t&lt;/code&gt; を例えば以下のように定義する (§20.3.8 ¶2):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;S&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;mem_fun1_t&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;, A, S&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;mem_fun1_t&lt;/span&gt;(S (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;p)(A));
  S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, A x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; の第二引数はメンバ関数の引数と全く同じであることに注意しなさい。もしこれが値型であれば、引数は二度値渡しされてコピーされる。&lt;/p&gt;
&lt;p&gt;しかしながら、もし我々が引数を代わりに &lt;code&gt;const A&amp;amp;&lt;/code&gt; として宣言することによってこの非効率性を削除しようとするならば、もし &lt;code&gt;A&lt;/code&gt; が参照型であれば、我々は参照の参照を持ってしまう。そしてそれは現在のところ非合法である。 (ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;operator()&lt;/code&gt; の引数を宣言する望ましい方法は、メンバ関数の引数が参照であるかないかに依っている。もしそれが参照であるならば、単純に &lt;code&gt;A&lt;/code&gt; と宣言したいのであり、もし値であれば &lt;code&gt;const A&amp;amp;&lt;/code&gt; と宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特殊化版を用いて正確にこの判断をを行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;call traits テンプレートはこの改良を実現するために使われる関数オブジェ クト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化の機能を持つコンパイラでのみ有効である。そうでないコンパイラでは、メンバ関数に渡される引数は(&lt;code&gt;mem_fun1_t&lt;/code&gt; ファミリの中で) 常に参照渡しとなるので、参照の参照の可能性を生みだすことになる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Negators -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/negators.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Negators&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.5) 由来のネゲータアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binary_negate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;not1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このライブラリのネゲータは標準バージョンを二つの方法で改良する。&lt;/p&gt;
&lt;p&gt;適合関数オブジェクトではなく関数を否定する時、それらは &lt;code&gt;ptr_fun&lt;/code&gt; の必要を回避するために、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を用いる。&lt;/p&gt;
&lt;p&gt;それらは引数や適合された関数に渡す引数を宣言する最上の方法を決するため、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;call traits&lt;/a&gt; を用いる。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34;&gt;下記&lt;/a&gt;参照)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い型は標準ネゲータと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++ 標準 (§20.3.5) は unary negate をこのように定義 している。(binary negate も似ている):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type,&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; unary_negate(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; pred);
  &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であった場合、 &lt;code&gt;operator()&lt;/code&gt; の引数の型は参照の参照になることに注意しなさい。これは、現在の C++ では非合法である。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;しかしながら、もし代わりに &lt;code&gt;operator()&lt;/code&gt; を &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; を変更せずにそのまま採用して定義すると、それが値型であった場合不必要に非効率になってしまう。それは引数が二度コピーされることによる。一度は &lt;code&gt;unary_negate&lt;/code&gt; の &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時、さらに適合された関数で &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時にもう一度である。&lt;/p&gt;
&lt;p&gt;つまり&lt;code&gt;operator()&lt;/code&gt; を宣言する望ましい方法は、 &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であるか否かに依 る。もしそれが参照であれば、単純に &lt;code&gt;argument_type&lt;/code&gt; として宣言したいし、それが値であれば &lt;code&gt;const argument_type&amp;amp;&lt;/code&gt; として宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.html&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特 殊化版を用いて正確にこの判断を行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。実のところ、実際の宣言は関数オブジェクト特性を使うためもう少し複雑である。しかし効果は同様である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;この関数オブジェクト特性の両方と call traits はこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化版の機能を持つコンパイラでのみ有効である。 そうでないコンパイラでは、このライブラリのネゲータは標準内のそれらと非常に似た振る舞いをする - 関数に適合するために &lt;code&gt;ptr_fun&lt;/code&gt; が必要であるし、参照の参照は避けられないだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Function Pointer Adapters -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/ptr_fun.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Function Pointer Adapters&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§ 20.3.7): 由来の関数ポインタアダプ タの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointer_to_unary_function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointer_to_binary_function&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ptr_fun&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;しかし、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を使用しているおかげで、このライブラリのアダプタと接続する場合、このアダプタを使う必要はない。しかしながら、あなたの実装が我々の特性クラスとともにきちんと働かない場合 (部分特殊化版が欠けていることによる) や、サードパーティの関数オブジェクトアダプタとともに使いたい場合に、使う必要があるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;これらのアダプタを使う必要がある場合、使い方は標準関数ポインタアダプタと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it
     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ptr_fun(bad)));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかしながら、このライブラリは関数オブジェクト特性をサポートする、強化された &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html&#34;&gt;ネゲータ&lt;/a&gt; を含んでいることに注意しなさい。それで、以上のソースと同様に以下のように書ける。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it
     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;pointer_to_unary_function&lt;/code&gt; をこのように定 義する(§20.3.8 ¶2):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Result&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;pointer_to_unary_function&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Arg, Result&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; pointer_to_unary_function(Result (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; f)(Arg));
  Result &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Arg x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; の引数はラップされる関数の引数と厳密に等しい型であることに注意しなさい。もしこれが値型であれば、引数は値渡しされ、二度コピーされる。&lt;code&gt;pointer_to_binary_function&lt;/code&gt; も同様の問題を持っている。&lt;/p&gt;
&lt;p&gt;しかしながら、引数を代わりに &lt;code&gt;const Arg&amp;amp;&lt;/code&gt; と宣言することによって非効率を削除しようとすると、&lt;code&gt;Arg&lt;/code&gt; が参照型であった場合、現 在では非合法な (ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)、参照の参照ができてしまう。&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;operator()&lt;/code&gt; の引数を宣言する望ましい方法は、ラップされる関数の引数が参照であるかないかに依っている。もしそれが参照であるならば、単純に &lt;code&gt;Arg&lt;/code&gt; と宣言したいのであり、もし値であれば &lt;code&gt;const Arg&amp;amp;&lt;/code&gt; と宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特殊化版を用いて正確にこの判断をを行う。&lt;code&gt;operator()&lt;/code&gt; を以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Result &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Arg&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;call traits テンプレートはこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化の機能を持つコンパイラでのみ有効である。そうでないコンパイラでは、関数に渡される引数は常に参照渡しとなるので、参照の参照の可能性を生みだすことになる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>the Boost Graph Library -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;the Boost Graph Library&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/table_of_contents.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/table_of_contents.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/bgl-cover.jpg&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;BGLへの序章&lt;/li&gt;
&lt;li&gt;歴史&lt;/li&gt;
&lt;li&gt;刊行物&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/acknowledgements.html&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;クイック・ツアー&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html&#34;&gt;基本的なグラフ理論の復習&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;チュートリアル&lt;ol&gt;
&lt;li&gt;Property Maps&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;adjacency_list&lt;/code&gt; class&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;例題&lt;ol&gt;
&lt;li&gt;ファイル依存関係の例&lt;/li&gt;
&lt;li&gt;Kevin Bacon の６次数&lt;/li&gt;
&lt;li&gt;Graph Coloring&lt;/li&gt;
&lt;li&gt;Sparse Matrix Ordering&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;BGL 拡張&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/constructing_algorithms.html&#34;&gt;BGLでグラフアルゴリズムを構築する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Converting Existing Graphs to BGL&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Boost Graph インタフェイス&lt;ol&gt;
&lt;li&gt;Graph&lt;/li&gt;
&lt;li&gt;Incidence Graph&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BidirectionalGraph.html&#34;&gt;Bidirectional Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;Adjacency Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vertex List Graph&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;Edge List Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vertex and Edge List Graph&lt;/li&gt;
&lt;li&gt;Mutable Graph&lt;/li&gt;
&lt;li&gt;Property Graph&lt;/li&gt;
&lt;li&gt;Mutable Property Graph&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The Property Map Library （専門的にはグラフ・ライブラリの部分ではないが、ここで使用される頻度が高い）&lt;/li&gt;
&lt;li&gt;ビジタ・コンセプト&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS （幅優先探査） Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS （深さ優先探査） Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;Bellman Ford Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;Event Visitor&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;EventVisitorList アダプタ&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html&#34;&gt;Event Visitor List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html&#34;&gt;&lt;code&gt;dijkstra_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html&#34;&gt;&lt;code&gt;bellman_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;イベント・ビジタ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・クラス&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・アダプタ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;subgraph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filtered_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector as Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Matrix as Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Leda Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Stanford GraphBase&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;イテレータ・アダプタ&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特性クラス&lt;ol&gt;
&lt;li&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bgl_named_params.html&#34;&gt;&lt;code&gt;bgl_named_params&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;核となるアルゴリズム・パターン&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html&#34;&gt;&lt;code&gt;breadth_first_visit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html&#34;&gt;&lt;code&gt;depth_first_visit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undirected_dfs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform_cost_search&lt;/code&gt; (非推奨、代わりに Dijkstra を使うこと)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・アルゴリズム&lt;ol&gt;
&lt;li&gt;最短経路アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html&#34;&gt;&lt;code&gt;dijkstra_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html&#34;&gt;&lt;code&gt;bellman_ford_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html&#34;&gt;&lt;code&gt;dag_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;johnson_all_pairs_shortest_paths&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最小全域木アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;code&gt;kruskal_minimum_spanning_tree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prim_minimum_spanning_tree&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/connected_components.html&#34;&gt;&lt;code&gt;connected_components&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strong_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Incremental Connected Components&lt;ol&gt;
&lt;li&gt;&lt;code&gt;initialize_incremental_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;incremental_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;same_component&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component_index&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最大流アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edmunds_karp_max_flow.html&#34;&gt;&lt;code&gt;edmunds_karp_max_flow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push_relabel_max_flow&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topological_sort&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transitive_closure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/copy_graph.html&#34;&gt;&lt;code&gt;copy_graph&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transpose_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isomorphism&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/cuthill_mckee_ordering.html&#34;&gt;&lt;code&gt;cuthill_mckee_ordering&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sequential_vertex_coloring&lt;/code&gt;(アンドキュメント)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minimum_degree_ordering&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;AT&amp;amp;T Graphviz フォーマット入出力ユーティリティ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;write_graphviz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_graphviz&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;補助コンセプト、補助クラス、補助関数&lt;ol&gt;
&lt;li&gt;&lt;code&gt;property&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BasicMatrix.html&#34;&gt;BasicMatrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;incident&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opposite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;bandwidth&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;ith_bandwidth&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tools for random graphs&lt;ol&gt;
&lt;li&gt;&lt;code&gt;random_vertex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;random_edge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;generate_random_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;randomize_property&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;目標と To-Do 項目&lt;/li&gt;
&lt;li&gt;トラブルシューティング&lt;/li&gt;
&lt;li&gt;既知の問題&lt;/li&gt;
&lt;li&gt;FAQ&lt;/li&gt;
&lt;li&gt;BGL Book Errata&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>AdjacencyGraph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/AdjacencyGraph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;AdjacencyGraph&lt;/h1&gt;
&lt;p&gt;AdjacencyGraph コンセプトは、グラフ中の頂点への隣接頂点の効率的なアクセス のためのインターフェースを供給する。これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; コンセプト (出辺の終点が隣接頂点である) と非常に良く似ている。 いくつかの状況では頂点への関心のみがあり、しかし一方、他の状況では辺も同様に重要になるため、両者のコンセプトが供給された。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフのモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;G&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このタグ型は &lt;code&gt;adjacency_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::adjacency_iterator&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;頂点 &lt;code&gt;v&lt;/code&gt; のための隣接イテレータは &lt;code&gt;v&lt;/code&gt; に隣接した頂点へのアクセスを提供する。そのため隣接イテレータの値型はそのグラフの頂点記述子型である。 隣接イテレータは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなければならない。&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;adjacent_vertices(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; に隣接している頂点へのアクセスを提供 するイテレータ範囲を返す。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html#note1&#34;&gt;[1]&lt;/a&gt;&lt;br /&gt; 返却型: &lt;code&gt;std::pair&amp;lt;adjacency_iterator, adjacency_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; 関数は定数時間内に終了するはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graphコンセプト&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdjacencyGraphConcept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
    adjacency_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IncidenceGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(v, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(v, g);
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator,adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor v;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;設計原理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; が同じ (それ以上の) 機能を実際に含んでいるので、AdjacencyGraph コンセプトはいくぶん軽薄である。 &lt;code&gt;adjacent_vertices()&lt;/code&gt; が &lt;code&gt;out_edges()&lt;/code&gt; よりも使用すると便利な状況があるので AdjacencyGraph コンセプトは存在する。 グラフ・クラスを構築しており、隣接イテレータを作成する余分な仕事を行いたくない場合は、恐れを持たないでいただきたい。 出辺イテレータから隣接イテレータを作成するために使用できる&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;と名付けられたアダプタ・クラスがある。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html#note1&#34; name=&#34;note1&#34;&gt;[1]&lt;/a&gt; &lt;strong&gt;multigraph&lt;/strong&gt; (多数の辺が同じ二つの頂点を接続できる) の 場合は、&lt;code&gt;adjacent_vertices()&lt;/code&gt; 関数によって返されたイテレータが各隣接頂点を一度含む範囲にアクセスするかどうか、また &lt;code&gt;out_edges()&lt;/code&gt; 関数 のふるまいと一致し、二度以上隣接した頂点を含むことがある範囲にアクセスすべき かどうかとしての問題が持ち出される。 この決定はグラフ・アルゴリズムの実装と共により多くの経験を考慮して再検討される必要があるかもしれないが、今のところふるまいは &lt;code&gt;out_edges()&lt;/code&gt; のそれと一致すると定義される。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>AdjacencyMatrix -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyMatrix.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/AdjacencyMatrix.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;AdjacencyMatrix&lt;/h1&gt;
&lt;p&gt;AdjacencyMatrix コンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; コンセプトを精製し、始点と終点によって与えられるグラフ中の任意の辺への効率的なアクセスのために必要なものを付け加えている。今のところどの Boost の グラフ・ライブラリ・アルゴリズムもこのコンセプトを使っていない。しかしながらこのコンセプトを必要とするであろう Floyd-Warshall のようなまだ実装されていないアルゴリズムが存在する。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このタグ型は &lt;code&gt;adjacency_matrix_tag&lt;/code&gt; に変換可能でなければならない。&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返却値型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接の辺アクセス&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge(u,v,g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&amp;lt;edge_descriptor, bool&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; の間に辺が存在するかどうかを述べるフラグと、辺が見つかった場合に辺記述子から成るペアを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdjacencyMatrix
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor edge_descriptor;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edge(u, v, g);
  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor u, v;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;, edge_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BFS（幅優先探査）Visitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/BFSVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;BFS（幅優先探査）Visitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは BFS Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;breadth_first_search()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BFS Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Graph&lt;/code&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点がキューからポップされた時に実行される。これは、頂点 &lt;code&gt;u&lt;/code&gt; の各出力辺に対して &lt;code&gt;examine_edge()&lt;/code&gt; が実行される直前に起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各辺が、探索木を形成する辺の要素になった時に、その辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Non-Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有向グラフでは後退辺と交差辺に対して、無向グラフでは交差辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gray Target&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に灰色に塗られている頂点を終点とする、木でない辺の部分集合に対して実行される。灰色は、頂点が今キューにいることを示す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Black Target&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に黒に塗られている頂点を終点とする、木でない辺の部分集合に対して実行される。黒は、頂点がキューから除去されたことを示す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある頂点の全ての出力辺が探索木に追加され、全ての隣接する頂点が発見された後に、その頂点に対して実行される (ただし、隣接する頂点の出力辺を調査するよりは前に) 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BasicMatrix -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BasicMatrix.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/BasicMatrix.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;BasicMatrix&lt;/h1&gt;
&lt;p&gt;BasicMatrix のコンセプトは2次元のテーブルの要素にアクセスするための 最小限のインタフェースを提供する。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{M,I,V}&lt;/td&gt;
&lt;td&gt;行列, インデックス, 値の型 で、BasicMatrix のコンセプトをモデル化する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;M&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;I&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;A[i][j]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;インデックス &lt;code&gt;(i,j)&lt;/code&gt; にある要素オブジェクトへの参照を返す。&lt;br /&gt; 返値の型: mutable &lt;code&gt;A&lt;/code&gt; に対しては、&lt;code&gt;V&amp;amp;&lt;/code&gt;。 constant &lt;code&gt;A&lt;/code&gt; に対しては、&lt;code&gt;const V&amp;amp;&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;要素へのアクセスは定数時間で終了する。&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;M&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;I&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BasicMatrixConcept
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints() {
    V&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; elt &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; A[i][j];
    const_constraints(A);
    ignore_unused_variable_warning(elt);      
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; const_constraints(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; M&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; A) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; V&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; elt &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; A[i][j];
    ignore_unused_variable_warning(elt);      
  }
  M A;
  I i, j;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 KANAHORI Toshihiro &lt;a href=&#34;mailto:kanahori@k.tsukuba-tech.ac.jp&#34;&gt;kanahori@k.tsukuba-tech.ac.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Bellman Ford Visitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/BellmanFordVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Bellman Ford Visitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html&#34;&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは Bellman Ford Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bellman Ford Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Graph&lt;/code&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ内の各辺に対して &lt;code&gt;num_vertices(g)&lt;/code&gt; 回実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、以下の条件が満たされれば、その辺は緩和される (距離が減らされる) 。この時、このメソッドが実行される。&lt;br /&gt; &lt;code&gt;tie(u,v) = incident(e, g);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;D d_u = get(d, u), d_v = get(d, v);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;W w_e = get(w, e);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;assert(compare(combine(d_u, w_e), d_v));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge_not_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、辺が緩和 (上を参照) されなければ、このメソッドが実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Minimized&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_minimized(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ内の各辺を調査する &lt;code&gt;num_vertices(g)&lt;/code&gt; 回の反復が終わった後に、各辺が最小化されたかをチェックするために最後の反復が行われる。辺が最小化されていれば、この関数が実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Minimized&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge_not_minimized(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺が最小化されていなければ、この関数が呼ばれる。グラフ内に負の閉路が存在する時に、これが起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html&#34;&gt;&lt;code&gt;bellman_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BidirectionalGraph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BidirectionalGraph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/BidirectionalGraph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;BidirectionalGraph&lt;/h1&gt;
&lt;p&gt;BidirectionalGraph コンセプトは、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; を精製し、各頂点の入辺への効率的なアクセスのために必要とされるものを付け加えている。 有向グラフにとって、入辺への効率的なアクセスは一般的により多くの記憶スペースを必要とし、多くのアルゴリズムは入辺へのアクセスを必要としないため、 このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; から分離されている。 無向グラフにとってはこれは問題とならない。というのは &lt;code&gt;in_edges()&lt;/code&gt; 関数 と &lt;code&gt;out_edges()&lt;/code&gt; 関数は同じであり、両方の関数は頂点に隣接した辺を返すからである。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;G&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このタグ型は &lt;code&gt;bidirectional_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::in_edge_iterator&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点 &lt;code&gt;v&lt;/code&gt; のための入辺イテレータは &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する。そのため入辺イテレータの値型はそのグラフの辺記述子型である。 入辺イテレータは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;in_edges(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺 (有向グラフ) または接続辺 (無向グラフ) へのアクセスを提供するイテレータ範囲を返す。 有向グラフと無向グラフの両方にとって、出辺の終点は頂点 &lt;code&gt;v&lt;/code&gt; で あることと、始点が &lt;code&gt;v&lt;/code&gt; に隣接している頂点であることが要求される。&lt;br /&gt; 返却値型: &lt;code&gt;std::pair&amp;lt;in_edge_iterator, in_edge_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;in_degree(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺の数 (有向グラフ) または 接続辺の数 (無向グラフ) を返す。&lt;br /&gt; 返却値型: &lt;code&gt;degree_size_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;degree(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺と出辺を足した数 (有向グラフ) または接続辺の数 (無向グラフ) を返す。&lt;br /&gt; 返却値型: &lt;code&gt;degree_size_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; で &lt;code&gt;Directed=bidirectionalS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; で &lt;code&gt;Directed=undirectedS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;in_edges()&lt;/code&gt; は定数時間であることを必要とする。 &lt;code&gt;in_degree()&lt;/code&gt; 関数と &lt;code&gt;degree()&lt;/code&gt; 関数は入辺の数 (有向グラフ) または接続辺の数 (無向グラフ) による線形時間であるはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BidirectionalGraph_concept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;in_edge_iterator
    in_edge_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IncidenceGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; in_edges(v, g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; in_edges(v, g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor v;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor e;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Buffer Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/Buffer.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Buffer Concept&lt;/h1&gt;
&lt;p&gt;Buffer とは、その中に何かしらアイテムを書き込んだり、削除したりできるものである。 Buffer のコンセプトは、ほとんど要求を持たない。 アイテムが格納の仕方や削除される時に関して、いかなる特定の順序付けも要求してはいないが、例によって、ソートに関しては順序付けのポリシーがいくつかある。&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer のモデルである型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;B&lt;/code&gt; の値の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;メンバ&lt;/h2&gt;
&lt;p&gt;Buffer をモデル化する型は、以下のメンバーを持たなければならない。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;value_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内に格納されるオブジェクトの型。 その値の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;Assignable&lt;/a&gt; でなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内のオブジェクトの数を表す符号無し整数型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void push(const T&amp;amp; t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt; を Buffer 内に挿入する。 &lt;code&gt;size()&lt;/code&gt; は 1 インクリメントされる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void pop()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer からオブジェクトを削除する。 &lt;code&gt;size()&lt;/code&gt; は 1 デクリメントされる。&lt;br /&gt; 事前条件: &lt;code&gt;empty()&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; であること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp; top()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内のあるオブジェクトへの非 &lt;code&gt;const&lt;/code&gt; な参照を返す。&lt;br /&gt; 事前条件: &lt;code&gt;empty()&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; であること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const T&amp;amp; top() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内のあるオブジェクトへの &lt;code&gt;const&lt;/code&gt; な参照を返す。&lt;br /&gt; 事前条件: &lt;code&gt;empty()&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; であること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void size() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内のオブジェクトの数を返す。&lt;br /&gt; 不変式: &lt;code&gt;size() &amp;gt;= 0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool empty() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;b.size() == 0&lt;/code&gt; と等価。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;push()&lt;/code&gt;、&lt;code&gt;pop()&lt;/code&gt; と &lt;code&gt;size()&lt;/code&gt; は Generalized Queue のサイズに関して、 高々線形時間の計算量でなければならない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;top()&lt;/code&gt; と &lt;code&gt;empty()&lt;/code&gt; は定数時間で終了しなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/stack.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::stack&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::mutable_queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University and C++ Library &amp;amp; Compiler Group/SGI (&lt;a href=&#34;mailto:jsiek@engr.sgi.com&#34;&gt;jsiek@engr.sgi.com&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ColorValue -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/ColorValue.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;ColorValue&lt;/h1&gt;
&lt;p&gt;このコンセプトは色付けを必要とする型として記述されており、グラフ中を探査する時に頂点が訪問済か色でマークするために利用される。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/EqualityComparable.html&#34; target=&#34;_blank&#34;&gt;EqualityComparable&lt;/a&gt; and &lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ColorValue モデルの型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;T&lt;/code&gt; のオブジェクト&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Get Color White&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::white()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;白色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Get Color Gray&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::gray()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;灰色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Get Color Black&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::black()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;黒色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;default_color_type&lt;/code&gt; (boost/graph/properties.hpp の中に記述)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>DFS Visitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/DFSVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;DFS Visitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは DFS Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;DFS Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、グラフの全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Start Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.start_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;探索の前に 1 度、始点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各辺が、探索木を形成する辺の要素になった時に、その辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Back Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.back_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの後退辺に対して実行される。無向グラフでは、辺 &lt;code&gt;(u,v)&lt;/code&gt; と辺 &lt;code&gt;(v,u)&lt;/code&gt; が同じ辺なので、木の辺か後退辺か曖昧な場合がある。この時は &lt;code&gt;tree_edge()&lt;/code&gt; 関数と &lt;code&gt;back_edge()&lt;/code&gt; 関数が両方とも実行される。この曖昧さを解決する 1 つの方法は、木の辺を記録し、既に木の辺として記録された後退辺を無視することだ。木の辺を記録するためには、 &lt;code&gt;tree_edge&lt;/code&gt; イベントで先行点を記録するのが簡単だ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Forward or Cross Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.forward_or_cross_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの先行辺と交差辺に対して実行される。無向グラフでは、このメソッドは決して呼ばれない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;頂点 &lt;code&gt;u&lt;/code&gt; を根とする DFS 木の全ての頂点に対して &lt;code&gt;finish_vertex&lt;/code&gt; が呼ばれた後に、頂点 &lt;code&gt;u&lt;/code&gt; に対して実行される。頂点 &lt;code&gt;u&lt;/code&gt; が DFS 木の葉であれば、 &lt;code&gt;u&lt;/code&gt; の全ての出力辺が調査された後に、 &lt;code&gt;u&lt;/code&gt; に対して &lt;code&gt;finish_vertex&lt;/code&gt; が呼ばれる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Dijkstra Visitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/DijkstraVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Dijkstra Visitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html&#34;&gt;&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースと、関連するアルゴリズムを定義する。ユーザはこのインタフェースに一致するクラスを作って、そのクラスのオブジェクトを &lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; に渡すことで、探索中に実行される操作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dijkstra Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;,&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WeightMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初期化される時に、グラフの各頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点がキューからポップされる時に、その頂点に対して実行される。これは頂点 &lt;code&gt;u&lt;/code&gt; の各出力辺に対して &lt;code&gt;examine_edge()&lt;/code&gt; が実行される直前に起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、以下の条件が満たされれば、その辺は緩和される (距離が減らされる) 。この時、このメソッドが実行される。&lt;br /&gt; &lt;code&gt;tie(u,v) = incident(e, g);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;D d_u = get(d, u), d_v = get(d, v);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;W w_e = get(w, e);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;assert(compare(combine(d_u, w_e), d_v));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、辺が緩和 (上を参照) されなければ、このメソッドが実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある頂点の全ての出力辺が探索木に追加され、全ての隣接する頂点が発見された後に、その頂点に対して実行される (ただし、隣接する頂点の出力辺を調査するよりは前に) 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html&#34;&gt;&lt;code&gt;dijkstra_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EdgeListGraph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/EdgeListGraph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;EdgeListGraph&lt;/h1&gt;
&lt;p&gt;EdgeListGraph コンセプトは Graph コンセプトを 精製し、グラフ中の全ての辺への効率的なアクセスに必要とされるものを付け加えている。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;EdgeListGraph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;このタグ型は &lt;code&gt;edge_list_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_iterator&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;edges(g)&lt;/code&gt; を経由して得られる辺イテレータは、グラフ中の全ての辺へのアクセスを提供する。辺イテレータの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなけれはならない。辺イテレータの値型はグラフの辺記述子型と同じでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edges_size_type&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;符号なし汎整数型はグラフ中の辺の数を表すのに使われる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返却値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edges(g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&amp;lt;edge_iterator, edge_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の全ての辺へのアクセスを提供するイテレータ範囲を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;num_edges(g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edges_size_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;source(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt; によって表される辺 &lt;code&gt;(u,v)&lt;/code&gt; の &lt;code&gt;u&lt;/code&gt; のための頂点記述子を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt; によって表される辺 &lt;code&gt;(u,v)&lt;/code&gt; の &lt;code&gt;v&lt;/code&gt; のための頂点記述子を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; 関数、&lt;code&gt;source()&lt;/code&gt; 関数、そして &lt;code&gt;target()&lt;/code&gt; 関数は、すべて定数時間内に終了するはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EdgeListGraphConcept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator 
    edge_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; GraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edges(g);
    E &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_edges(g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; source(e, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; target(e, g);
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edges(g);
    E &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_edges(g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; source(e, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; target(e, g);
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator,edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor u, v;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor e;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edges_size_type E;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Edge Mutable Graph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeMutableGraph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/EdgeMutableGraph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Edge Mutable Graph&lt;/h1&gt;
&lt;p&gt;Edge Mutable Graph コンセプトは、辺の追加と削除をサポートするグラフのためのインターフェースを定義する。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;add_edge(u, v, g)&lt;/code&gt; は &lt;code&gt;std::pair&amp;lt;edge_descriptor, bool&amp;gt;&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフ中に挿入することを試み、そして挿入された辺または多重辺、かつ辺が挿入されたかどうかを述べるフラグを返す。この操作はグラフの頂点記述子または頂点イテレータを無効にしないはずである。ただし、辺記述子または辺イテレータを無効にするかもしれない。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; がグラフ中の頂点であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;(u,v)&lt;/code&gt; がグラフの辺集合中にあること。返された辺記述子は &lt;code&gt;u&lt;/code&gt; を始点位置に、&lt;code&gt;v&lt;/code&gt; を終点位置に持つだろう。もしグラフが多重辺を許可しているなら、返されるフラグは常に &lt;code&gt;true&lt;/code&gt; である。もしグラフが多重辺を許可しておらず、辺 &lt;code&gt;(u,v)&lt;/code&gt; がすでにグラフ中にあったら返されるフラグは &lt;code&gt;false&lt;/code&gt; である。もし辺 &lt;code&gt;(u,v)&lt;/code&gt; がグラフ中になかったら返されるフラグは &lt;code&gt;true&lt;/code&gt; である。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから削除する。もしグラフが多重辺を許可しているなら、これは &lt;code&gt;(u,v)&lt;/code&gt; の全ての存在を削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;(u,v)&lt;/code&gt; がグラフの辺集合中にあること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;(u,v)&lt;/code&gt; がもはやグラフの辺集合中にないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;e&lt;/code&gt; をグラフから削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;e&lt;/code&gt; がグラフ中の辺であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;e&lt;/code&gt; はもはや &lt;code&gt;g&lt;/code&gt; のための辺集合中にないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;clear_vertex(u, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 頂点 &lt;code&gt;u&lt;/code&gt; への、そして頂点 &lt;code&gt;u&lt;/code&gt; からの全ての辺をグラフから削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; の有効な頂点記述子であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; 中のどの辺の始点または終点としても現れないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;工事中&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EventVisitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/EventVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;EventVisitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは単独イベントビジタのインタフェースを定義する。 EventVisitor は適用メンバ関数 (&lt;code&gt;operator()&lt;/code&gt;) を持つ。これは、 EventVisitor 内の &lt;code&gt;event_filter&lt;/code&gt; typedef で指定されるイベントが起きた時に、グラフアルゴリズム内で実行される。 EventVisitor を組み合わせて &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVistorList.html&#34;&gt;EventVistorList&lt;/a&gt; を作成できる。&lt;/p&gt;
&lt;p&gt;以下に、 BGL アルゴリズムによって実行されるイベントのタグのリストを示す。各タグは、アルゴリズムのビジタのメンバ関数と対応している。例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt; の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; には &lt;code&gt;cycle_edge()&lt;/code&gt; というメンバ関数がある。これに対応するタグは &lt;code&gt;on_cycle_edge&lt;/code&gt; だ。 &lt;code&gt;operator()&lt;/code&gt; の第1引数は、イベントタグによって決まる、辺か頂点の記述子でなければならない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_initialize_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_start_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_discover_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_examine_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_tree_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_cycle_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_finish_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_forward_or_cross_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_back_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_relaxed { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_not_relaxed { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_minimized { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_not_minimized { };
} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// namespace boost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;EventVisitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型か &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Event Filter&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V::event_filter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;どのイベントによってビジタが実行されるかを指定するタグ構造体。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Apply Visitor&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis(x, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;オブジェクト &lt;code&gt;x&lt;/code&gt; に対してビジタの操作を実行する。 &lt;code&gt;x&lt;/code&gt; はグラフの辺か頂点の記述子である。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/null_visitor.html&#34;&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html&#34;&gt;EventVisitorList&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EventVisitorList Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/EventVisitorList.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;EventVisitorList Concept&lt;/h1&gt;
&lt;p&gt;EventVisitorList は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; そのものか、 &lt;code&gt;std::pair&lt;/code&gt; で結合された EventVisitor のリストである。各グラフアルゴリズムには、 EventVisitorList を、アルゴリズムに必要な独自のビジタに変換するアダプタが定義されている。 以下に、イベントビジタを &lt;code&gt;std::pair&lt;/code&gt; で結合してリストにする方法の例と、アルゴリズムのビジタアダプタクラスの使い方の例を示す。&lt;/p&gt;
&lt;p&gt;仮に、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;深さ優先探索&lt;/a&gt;で、各頂点の発見／呼び出しの前後関係を、括弧を使った構造で出力したいとする。これを達成するには、 BGL アルゴリズム &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt; と2つのイベントビジタを使えばよい。以下の例の完全なソースコードは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dfs_parenthesis.cpp.html&#34;&gt;examples/dfs_parenthesis.cpp&lt;/a&gt; にある。まず、 2 つのイベントビジタを定義する。使うイベントビジタとして、 DFSVisitor に詳述されたイベントのリストの中から &lt;code&gt;on_discover_vertex&lt;/code&gt; と &lt;code&gt;on_finish_vertex&lt;/code&gt; を選ぶ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; open_paren &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; base_visitor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;open_paren&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; on_discover_vertex event_filter;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Vertex&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Vertex v, Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G) {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v;
  }
};
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; close_paren &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; base_visitor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;close_paren&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; on_finish_vertex event_filter;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Vertex&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Vertex v, Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G) {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;)&#34;&lt;/span&gt;;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次に2つのイベントビジタオブジェクトを作り、 &lt;code&gt;std::make_pair&lt;/code&gt; で作られる &lt;code&gt;std::pair&lt;/code&gt; を使って、この2つから EventVisitorList を作る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次にこのリストを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡したいところだが、 &lt;code&gt;depth_first_search()&lt;/code&gt; が要求しているのは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; であって、 EventVisitorList ではない。そこで EventVisitor のリストを DFSVisitor に変換するアダプタ、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt; を使う。他のビジタアダプタ同様、 &lt;code&gt;dfs_visitor&lt;/code&gt; には &lt;code&gt;make_dfs_visitor()&lt;/code&gt; という作成関数がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;make_dfs_visitor(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren()))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;さあこれで、以下のように、生成されたビジタオブジェクトを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡すことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフオブジェクト G を作る...&lt;/span&gt;

  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;default_color_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; color(num_vertices(G));

  depth_first_search(G, make_dfs_visitor(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren())),
                     color.begin());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;3つ以上のイベントビジタのリストを作りたければ、以下のように &lt;code&gt;std::make_pair&lt;/code&gt; をネストして呼び出せばいい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitor1,
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitor2,
    ...
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitorN&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;, visitorN)...));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>謝辞 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/acknowledgements.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/acknowledgements.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;謝辞&lt;/h1&gt;
&lt;p&gt;Boost Graph Library の開発において、我々に刺激を与え、励ましてくれた たくさんの人々に感謝したい。&lt;/p&gt;
&lt;p&gt;最も深い感謝を Alexander Stepanov に。彼のジェネリックプログラミングにおける 先駆的仕事と、励ましと、そして BGL に寄贈された彼のアルゴリズムに対して。 Matthew Austern には、 STL の概念を文書化する作業に対して感謝を。 それは BGL における概念を作る基盤となった。 Dietmar Kühl に感謝。彼のジェネリックなグラフアルゴリズムとデザインパターン、 とりわけプロパティマップの抽象化に。&lt;/p&gt;
&lt;p&gt;Dave Abrahams 、 Jens Maurer 、 Beman Dawes 、 Gary Powell 、 Greg Colvin 、 Valentin Bonnard 、 そして Boost の残りのグループは、 BGL インタフェースに有益なアドバイスを与え、 改善のための数多くのことを提案し、 ドキュメントの校正をして、 そしてコードを洗練する際に力を貸してくれた。 公式レビューのマネージメントしくれた Dave Abrahams に特に感謝したい。&lt;/p&gt;
&lt;p&gt;BGL の改良に役立つ質問をしてくれた BGL ユーザの Gordon Woodhull 、 Dave Longhorn 、 Joel Phillips 、そして Edward Luke にも感謝する。&lt;/p&gt;
&lt;p&gt;ドキュメントの編集と校正を担当してくれた Jeffrey Squyres に特別の感謝を。&lt;/p&gt;
&lt;p&gt;Boost Graph Library の当初の作業は、部分的に NSF 助成金 ACI-9982205 および 米国エネルギー省科学局 MICS プログラム (Director, Office of Science, Division of Mathematical, Information, and Computational Sciences of the U.S. Department of Energy) 契約番号 DE-AC03-76SF00098 の支援を受けた。&lt;/p&gt;
&lt;p&gt;また、米エネルギー省科学局が支援する 国立エネルギーリサーチ科学コンピューティングセンター (National Energy Research Scientific Computing Center) の資源も利用させて頂いた。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/adjacency_list.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_list&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed,
               VertexProperties, EdgeProperties,
               GraphProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスは一般化された隣接リストグラフ構造を実装する。 テンプレート・パラメータは要求を最も満たすクラスのバージョンを選べるように多くの形態の選択肢を提供する。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34;&gt;adjacency-list&lt;/a&gt; は基本的に二次元の構造で、ここで最初の次元の各要素は頂点を表し、頂点の各々はその辺リストの一次元構造を含んでいる。 Figure 1 は有向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 1:有向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータは外部の二次元コンテナを表すためにどんな種類のコンテナが使われるかを制御する。 &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータは辺リストを表すためにどんな種類の コンテナが使われるかを制御する。&lt;code&gt;EdgeList&lt;/code&gt; と &lt;code&gt;VertexList&lt;/code&gt; の 選択はグラフ構造の空間計算量を決定するだろう、そして様々なグラフ操作の時間計算量を決定するだろう。可能な選択とトレード・オフは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#choosing-graph-type&#34;&gt;Choosing the Edgelist and VertexList&lt;/a&gt; 中で論じられる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータはグラフが有向か無向か、または 入辺と出辺の両方にアクセスする (これを双方向性と呼ぶ) 有向かを制御する。 双方向性グラフは各辺が出辺リストと入辺リストの両方に現れるため、辺当たり有向グラフの二倍の空間を取る。Figure 2 は無向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 2:無向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの使い方のチュートリアルは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink&#34;&gt;Using &lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/family-tree-eg.cpp.html&#34;&gt;&lt;code&gt;examples/family-tree-eg.cpp&lt;/code&gt;&lt;/a&gt; 中にある例は家族の木 (family tree) をグラフで表現する方法を示す。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各々の頂点の辺リストを表わすために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの頂点リストを表すために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向か、無向か、または双方向の辺アクセス (出辺と入辺の両方にアクセス する) の有向かを選ぶ選択子。選択肢は &lt;code&gt;directedS&lt;/code&gt;、&lt;code&gt;undirectedS&lt;/code&gt;、 そして &lt;code&gt;bidirectionalS&lt;/code&gt; である。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ・オブジェクトのためのプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.md.nolink&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.md.nolink&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Vertex and Edge Properties&lt;/h2&gt;
&lt;p&gt;色、距離、重み、そしてユーザ定義のプロパティのようなプロパティは、プロパティ を用いてグラフの頂点と辺に結びつけることができる。プロパティの値はグラフに よって提供されるプロパティ・マップ経由で読み書きできる。プロパティ・マップ は get(property, g) 関数経由で得られる。プロパティの使い方は 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#adjacency-list-properties&#34;&gt;Internal Properties&lt;/a&gt; 内で述べられている。プロパティ・マップは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.md.nolink&#34;&gt;Property Map Concepts&lt;/a&gt; 内で定義されているインターフェースを実装するオブジェクトである。 &lt;code&gt;adjacency_list&lt;/code&gt; クラスから得られるプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.md.nolink&#34;&gt;Lvalue Property Map&lt;/a&gt; コンセプトのモデルである。もし &lt;code&gt;adjacency_list&lt;/code&gt; が &lt;code&gt;const&lt;/code&gt; なら、 プロパティ・マップは定数である。さもなくばプロパティ・マップは変更可能である。&lt;/p&gt;
&lt;p&gt;もしグラフの &lt;code&gt;VertexList&lt;/code&gt; が &lt;code&gt;vecS&lt;/code&gt; なら、グラフは &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティのためのプロパティ・マップを経由して アクセスされた組み込みの頂点の添え字を持っている。添え字は &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲内に整列し、連続している。頂点が 削除される時、添え字はそれらのプロパティを持ち続けるよう調整される。 これらの添え字を外部のプロパティの記憶領域にアクセスするために使う際には いくらか気をつけなければならない。 頂点の添え字のためのプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;Readable Property Map&lt;/a&gt; のモデルである。&lt;/p&gt;
&lt;h2&gt;Iterator and Descriptor Stability/Invalidation&lt;/h2&gt;
&lt;p&gt;辺の追加や削除によってグラフの構造を変更する時はいくらか注意しなければならない。&lt;code&gt;adjacency_list&lt;/code&gt; の型と操作に依存して、グラフ内を指すイテレータや記述子オブジェクトのいくつかは無効になるかもしれない。 例えば、次のコードは未定義の (悪い) 振る舞いの結果となるだろう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, vecS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=vecS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これでもまだ間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これが問題である理由は &lt;code&gt;remove_vertex()&lt;/code&gt; を呼び出しており、そしてそれが &lt;code&gt;VertexList=vecS&lt;/code&gt; の &lt;code&gt;adjacency_list&lt;/code&gt; とともに使われたとき、グラフのための全てのイテレータと記述子 (例えば &lt;code&gt;vi&lt;/code&gt; や &lt;code&gt;vi_end&lt;/code&gt;) を無効にするために、ループの次の繰り返し中に災難を引き起こす。&lt;/p&gt;
&lt;p&gt;もし異なる種類の &lt;code&gt;adjacency_list&lt;/code&gt; を使い、そして &lt;code&gt;VertexList=listS&lt;/code&gt; ならば、イテレータが削除された実際の頂点を指してなければ &lt;code&gt;remove_vertex&lt;/code&gt; を呼ぶことによってイテレータは無効にならない。次のコードはこれを説明する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, listS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=listS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これは大丈夫である&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;安定性の問題は更に頂点記述子と辺記述子に影響を及ぼす。例えば、最短経路木中の頂点の親 (または先行点) の過程を保持するために頂点記述子の &lt;code&gt;vector&lt;/code&gt; を使ったとしよう (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ)。&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; を呼んで親の &lt;code&gt;vector&lt;/code&gt; を作成し、 それからグラフから頂点を削除する。続いて親の &lt;code&gt;vector&lt;/code&gt; を使おうと試みるが、全ての頂点記述子は無効になっているので、結果は正しくない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(num_vertices(G));
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(num_vertices(G));

dijkstra_shortest_paths(G, s, distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
  predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));

remove_vertex(s, G); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// まずい考えだ！親 vector 中の頂点記述子を無効にする&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 次は間違った結果を生じる&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(tie(vi, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; p[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; is the parent of &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この議論の中でイテレータと記述子の無効化は、操作によって &lt;strong&gt;直接影響を受けない&lt;/strong&gt; イテレータと記述子の無効化に携わっていることに注意しなさい。 例えば、&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の実行は、&lt;code&gt;adjacency_list&lt;/code&gt; の種類に関係なく、いつも &lt;code&gt;(u,v)&lt;/code&gt; のためのどの辺記述子も、また&lt;code&gt;(u,v)&lt;/code&gt; を指すどの辺記述子も無効にするだろう。 このイテレータと記述子の無効化の議論中で、他の辺 (&lt;code&gt;(u,v)&lt;/code&gt; ではない) を指す辺記述子とイテレータにおける &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の影響にのみ携わっている。&lt;/p&gt;
&lt;p&gt;一般的に頂点記述子と辺記述子を安定に (決して無効にならない) したければ、 &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; と &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;listS&lt;/code&gt; または &lt;code&gt;setS&lt;/code&gt; を使いなさい。もし記述子とイテレータの安定性に気をもまないけれどもメモリの 消費量とグラフの巡回速度をより心配するなら、&lt;code&gt;VertexList&lt;/code&gt; かつ／または &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;vecS&lt;/code&gt; を使いなさい。&lt;/p&gt;
&lt;p&gt;下記の表はどの操作が記述子とイテレータを無効にする原因となるかを要約する。 表中で、&lt;code&gt;EL&lt;/code&gt; は &lt;code&gt;EdgeList&lt;/code&gt; の省略形で &lt;code&gt;VL&lt;/code&gt; は &lt;code&gt;VertexList&lt;/code&gt; を意味する。 &lt;strong&gt;Adj Iter (隣接イテレータ)&lt;/strong&gt; カテゴリは &lt;code&gt;out_edge_iterator&lt;/code&gt;、&lt;code&gt;in_edge_iterator&lt;/code&gt;、そして &lt;code&gt;adjacency_iterator&lt;/code&gt; 型を含む。記述子とイテレータの無効化の より詳しい説明は各操作のドキュメント中で示されている。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;頂点記述子&lt;/th&gt;
&lt;th&gt;辺記述子&lt;/th&gt;
&lt;th&gt;頂点イテレータ&lt;/th&gt;
&lt;th&gt;辺イテレータ&lt;/th&gt;
&lt;th&gt;隣接イテレータ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_out_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_in_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table: 記述子とイテレータの無効化の要約&lt;/p&gt;
&lt;h2&gt;Associated Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;adjacency_list_traits&amp;lt;EdgeList, VertexList, Directed&amp;gt;::vertex_descriptor
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた頂点記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた辺記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;VertexList=vecS&lt;/code&gt; なら &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;EdgeList=vecS&lt;/code&gt; なら &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;adjacency_iterator&lt;/code&gt; は &lt;code&gt;out_edge_iterator&lt;/code&gt; と同じイテレータ・ コンセプトをモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフが有向 (&lt;code&gt;directed_tag&lt;/code&gt;) か、無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) かについての情報を提供する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これはグラフのクラスが多重辺 (同じ始点と終点を持つ辺) の挿入を許可するかどうかを述べる。二つのタグは &lt;code&gt;allow_parallel_edge_tag&lt;/code&gt; と &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;code&gt;setS&lt;/code&gt; と &lt;code&gt;hash_setS&lt;/code&gt; の亜種は多重辺を許可しない一方で他の型は多重辺を許可する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点に接続する辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点プロパティまたは辺プロパティのためのプロパティ・マップの型。 具体的なプロパティは &lt;code&gt;Property&lt;/code&gt; テンプレート引数で指定され、グラフのための &lt;code&gt;VertexProperties&lt;/code&gt; もしくは &lt;code&gt;EdgeProperties&lt;/code&gt; で指定されたプロパティのどちらか一つと一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Property&lt;/code&gt; タグで指定されたグラフのプロパティのためのプロパティの値型。&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;デフォルト・コンストラクタ。0 個の頂点と0 個の辺からなる空のグラフ・ オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コピー・コンストラクタ。辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーである新しいグラフを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;代入演算子。&lt;code&gt;this&lt;/code&gt; に 辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーを入れる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(vertices_size_type n, 
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と 0 個の辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;template &amp;lt;class EdgeIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               vertices_size_type n, 
               edges_size_type m = 0, 
               const GraphProperty&amp;amp; p = GraphProperty())&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;
`n` 個の頂点と、範囲 `[first, last)` で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 `EdgeIterator` は [`InputIterator`](http://www.sgi.com/tech/stl/InputIterator.html) のモデルでなければならない。`EdgeIterator` の値型は `std::pair` でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは `[0, n)` の範囲内に整列していなければならない。


***
```cpp
template &amp;lt;class EdgeIterator, class EdgePropertyIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               EdgePropertyIterator ep_iter,
               vertices_size_type n,
               vertices_size_type m = 0,
               const GraphProperty&amp;amp; p = GraphProperty())
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と、範囲 &lt;code&gt;[first, last)&lt;/code&gt; で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; と &lt;code&gt;EdgePropertyIterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;code&gt;EdgeIterator&lt;/code&gt; の値型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは &lt;code&gt;[0, n)&lt;/code&gt; の範囲内に整列していなければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperties&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear()
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから全ての辺と頂点を削除する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; のグラフの頂点、辺、そしてプロパティと、グラフ&lt;code&gt;x&lt;/code&gt;の頂点、辺、そしてプロパティを交換する。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;h3&gt;Structure Access&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; の出辺へのアクセスを提供するイテレータ範囲を返す。もしグラフが無向グラフなら、このイテレータ範囲は 頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。 有向グラフと無向グラフの両方で、出辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; に隣接する頂点の場合は &lt;code&gt;source(e, g) == u&lt;/code&gt; かつ &lt;code&gt;target(e, g) == v&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
in_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する イテレータ範囲を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに &lt;code&gt;bidirectionalS&lt;/code&gt; が指定されている場合にのみ利用できる。 入辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; に隣接している何らかの頂点 &lt;code&gt;u&lt;/code&gt; に対して、グラフが有向であろうと無向であろうと、&lt;code&gt;target(e, g) == v&lt;/code&gt; かつ &lt;code&gt;source(e, g) == u&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; を出て行く辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
in_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; に入ってくる辺の数を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに&lt;code&gt;bidirectionalS&lt;/code&gt;が指定されている場合にのみ利用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type
num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type
num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点リスト中の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; と頂点 &lt;code&gt;v&lt;/code&gt; を結ぶ辺を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge_range(vertex_descriptor u, vertex_descriptor v,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; への全ての多重辺のための範囲を与える出辺イテレータのペアを返す。この関数は &lt;code&gt;adjacency_list&lt;/code&gt; 用の &lt;code&gt;EdgeList&lt;/code&gt; が終点に従って出辺をソートし、かつ多重辺を考慮するコンテナである時にのみ動作する。&lt;code&gt;multisetS&lt;/code&gt; 選択子はそのようなコンテナを選択する。&lt;/p&gt;
&lt;h3&gt;Structure Modification&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフに辺 &lt;code&gt;(u,v)&lt;/code&gt; を付け加え、新しい辺のための辺記述子を返す。 多重辺を許可しないグラフにとっては、もし辺がすでにグラフ中にあるなら、二重には付け加えられず、&lt;code&gt;bool&lt;/code&gt; フラグは &lt;code&gt;false&lt;/code&gt; になるだろう。同様に、もし &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; が 同じ頂点のための記述子 (ループを作っている) であり、かつグラフが無向グラフならば、辺は付け加えられずフラグは &lt;code&gt;false&lt;/code&gt; になるだろう。 フラグが &lt;code&gt;false&lt;/code&gt; の時は、返された辺記述子は既に存在している辺を指す。&lt;/p&gt;
&lt;p&gt;出辺リスト中の新しい辺の配置は一般に不定である。もっとも出辺リストの順序付けは &lt;code&gt;EdgeList&lt;/code&gt; の選択を通じて成し遂げられるが。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;VertexList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; でありかつ頂点記述子 &lt;code&gt;u&lt;/code&gt; または &lt;code&gt;v&lt;/code&gt; (それは整数である) がグラフ中の現在の頂点の数より大きな値を持っているなら、頂点の数が &lt;code&gt;std::max(u,v) + 1&lt;/code&gt; に なるようにグラフが拡大される。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; であれば、この操作によって頂点 &lt;code&gt;u&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; も無効になるだろう。 これはもし &lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;push(container, x)&lt;/code&gt; が呼び出されたときにそのイテレータを無効にするようなユーザ定義のコンテナ (章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#custom-storage&#34;&gt;Customizing the Adjacency List Storage&lt;/a&gt; を見なさい) であれば同様にあてはまる。 もしグラフが同様に双方向であれば、&lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;in_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりに グラフが無向グラフならば &lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりにグラフが有向グラフならば、 &lt;code&gt;add_edge()&lt;/code&gt; は同様にどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフに付け加え、&lt;code&gt;p&lt;/code&gt; を辺の内部のプロパティの記憶領域の値として添える。さらなる詳細のために前の &lt;code&gt;add_edge()&lt;/code&gt; 非メンバ関数も見なさい。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから取り除く。&lt;/p&gt;
&lt;p&gt;この操作は辺 &lt;code&gt;(u,v)&lt;/code&gt; を指すどの発行済みの辺記述子もイテレータも無効となる原因になる。加えて、もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; ならば無向と双方向のグラフの場合この操作は頂点 &lt;code&gt;u&lt;/code&gt; とまた頂点 &lt;code&gt;v&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; をグラフから取り除く。これは多重グラフの場合 &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数とは違う。この &lt;code&gt;remove_edge(e, g)&lt;/code&gt; 関数は一つの辺だけを取り除くのに対して &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数は全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を取り除く。&lt;/p&gt;
&lt;p&gt;この操作は記述子 &lt;code&gt;e&lt;/code&gt; が指す同じ辺のためのどの発行済みの辺記述子も イテレータも無効にする。加えて、この操作は &lt;code&gt;target(e, g)&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはグラフのためのどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(out_edge_iterator iter, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;remove_edge(*iter, g)&lt;/code&gt; と同じ効果を持つ。違いはこの関数は有向グラフの場合定数の時間計算量を持つのに対し、&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は O(E/V) の時間計算量を持つ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_out_edge_if(vertex_descriptor u, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                        adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;u&lt;/code&gt; の出辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_in_edge_if(vertex_descriptor v, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                       adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;v&lt;/code&gt; の入辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向と双方向の &lt;code&gt;adjacency_list&lt;/code&gt; グラフに利用できるが、有向グラフには利用できない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge_if(&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての辺を取り除く。すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点をグラフに付け加え、新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
           adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;指定されたプロパティを持つ頂点をグラフに付け加える。新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; への、そして &lt;code&gt;u&lt;/code&gt; からの全ての辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点または終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_out_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての出辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点として 持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出す時のそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向グラフには適用できない (代わりに &lt;code&gt;clear_vertex()&lt;/code&gt; を使いなさい)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_in_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての入辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は双方向グラフにのみ適用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; をグラフの頂点集合から取り除く。頂点が削除されるとき、 頂点 &lt;code&gt;u&lt;/code&gt; への、また頂点 &lt;code&gt;u&lt;/code&gt; への辺は存在しないものと仮定する。 これを確実にする一つの手段はあらかじめ &lt;code&gt;clear_vertex()&lt;/code&gt; を呼ぶことである。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータが &lt;code&gt;vecS&lt;/code&gt; なら、グラフのための全ての頂点記述子、辺記述子、そしてイテレータ はこの操作によって無効にされる。各頂点のための組み込みの &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティは操作の後もなお頂点の添え字が連続した範囲 &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; に配列しているように番号が付け直される。 もし組み込みの頂点の添え字に基づく外部のプロパティの記憶領域を使って いるなら、外部の記憶領域は調整される必要があるだろう。 他の選択は組み込みの頂点の添え字を使用せずに独自の頂点の添え字プロパティを付け加えるためにプロパティを代わりに使うことである。 もしたびたび &lt;code&gt;remove_vertex()&lt;/code&gt; 関数を使用する必要があるなら、 &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータには &lt;code&gt;listS&lt;/code&gt; 選択子が非常によい選択である。&lt;/p&gt;
&lt;h3&gt;Property Map Accessors&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PropertyTag&lt;/code&gt; で指定される頂点プロパティのためのプロパティ・マップ・ オブジェクトを返す。&lt;code&gt;PropertyTag&lt;/code&gt; はグラフの &lt;code&gt;VertexProperty&lt;/code&gt; テンプレート引数中に指定されたプロパティの一つに一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; が頂点記述子か辺記述子のどちらか一方である場合、これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を &lt;code&gt;value&lt;/code&gt; にする。&lt;code&gt;x&lt;/code&gt; は頂点記述子か辺記述子のどちらか一方である。&lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_list, PropertyTag&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; と互換でなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.md.nolink&#34;&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_traits.md.nolink&#34;&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list_traits -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/adjacency_list_traits.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_list_traits&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは &lt;code&gt;adjacency_list&lt;/code&gt; クラスに結びついた型のいくつかをアクセスする代替方法を提供する。このクラスの主な理由は値が頂点記述子または辺記述子であるグラフ・プロパティを時々作成したいと思うからである。もしこのために &lt;code&gt;graph_traits&lt;/code&gt; を使おうと試みるならば、相互に再帰的な型の問題にぶつかるだろう。この問題を避けるために &lt;code&gt;adjacency_list_traits&lt;/code&gt; クラスが提供され、それはユーザにグラフのためのプロパティ型を提供する 要求をすることなしにユーザが頂点記述子型または辺記述型にアクセスできるようにする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;EdgeList&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexList&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Directed&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; adjacency_list_traits {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... vertex_descriptor;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... edge_descriptor;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... directed_category;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... edge_parallel_category;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺コンテナの実装のための選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;頂点コンテナの実装のための選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向であるか無向であるかの選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;Assignable&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Type Requirements&lt;/h2&gt;
&lt;p&gt;工事中&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ中の頂点を識別するのに使われるオブジェクトのための型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edge_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ中の辺を識別するのに使われるオブジェクトのための型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;directed_category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;これはグラフが無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) であるか有向 (&lt;code&gt;directed_tag&lt;/code&gt;) であるかを述べる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edge_parallel_category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;これはグラフが多重辺の挿入を許可する (&lt;code&gt;allow_parallel_edge_tag&lt;/code&gt;) か、または自動的に多重辺を取り除く (&lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt;) かを述べる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_matrix -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/adjacency_matrix.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_matrix&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Directed, VertexProperty, 
                 EdgeProperty, GraphProperty,
                 Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt; クラスは 従来からの隣接行列を用いて BGL グラフインタフェースを提供する。 頂点数 V のグラフに対して、 V x V 行列を用いる。 その行列では、各要素 a&lt;sub&gt;ij&lt;/sub&gt; は 頂点 &lt;em&gt;i&lt;/em&gt; から 頂点 &lt;em&gt;j&lt;/em&gt; への辺が存在するか否かを示すブール値のフラグである。 図 1 ではグラフの隣接行列表現が示されている。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/figs/adj-matrix-graph3.gif&#34; /&gt; &lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/figs/adj-matrix.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 1: 有向グラフの隣接行列表現。&lt;/p&gt;
&lt;p&gt;この隣接行列形式の隣接リストに対する利点は辺の挿入と削除が定数時間で終了するという点である。 いくつか不便な点もある。 まず1つ目は、使用するメモリの量が O(V + E) (ここで、E は辺の数) ではなく、 O(V2) である という点である。 2つ目は、全ての辺を辿る処理(例えば、幅優先探索)は、 O(V2) 時間内で実行されるが、 隣接リストでは O(V + E) 時間である。 つまり、密度の高い(E が V2に近い)グラフに対しては、 &lt;code&gt;adjacency_matrix&lt;/code&gt; の方がよく、 密度の低い(E が V2 よりもずっと小さい)グラフに対しては、 &lt;code&gt;adjacency_list&lt;/code&gt; の方がよい ということである。 &lt;code&gt;adjacency_matrix&lt;/code&gt; クラスはプロパティテンプレートパラメータを介して頂点と辺にオブジェクトを付与することを可能とすることで、 既存のデータ構造を拡張したものである。 第 XXX 章には内部プロパティの使用方法について説明がある。 無向グラフの場合には、 &lt;code&gt;adjacency_matrix&lt;/code&gt; クラスは V x V 行列を全て使用せず、 代わりに下の三角部分(対角成分とその下)を用いる。 それは、無向グラフの隣接行列は対称行列となるからである。 これによって使用するメモリは (V2)/2 へと軽減される。 図 2 で無向グラフの隣接行列表現を示している。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph3.gif&#34; /&gt; &lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 2: 無向グラフの隣接行列表現。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;図1のグラフを生成する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { A, B, C, D, E, F, N };
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; name &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;ABCDEF&#34;&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;directedS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(N);
add_edge(B, C, g);
add_edge(B, F, g);
add_edge(C, A, g);
add_edge(C, C, g);
add_edge(D, E, g);
add_edge(E, D, g);
add_edge(F, A, g);

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;vertex set: &#34;&lt;/span&gt;;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_vertices(g, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;edge set: &#34;&lt;/span&gt;;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_edges(g, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;out-edges: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_graph(g, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;vertex set: A B C D E F 

edge set: (B,C) (B,F) (C,A) (C,C) (D,E) (E,D) (F,A) 

out-edges: 
A --&amp;gt; 
B --&amp;gt; C F 
C --&amp;gt; A C 
D --&amp;gt; E 
E --&amp;gt; D 
F --&amp;gt; A 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;図2のグラフを生成する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { A, B, C, D, E, F, N };
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; name &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;ABCDEF&#34;&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;undirectedS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; UGraph;
UGraph &lt;span style=&#34;color: #0000FF&#34;&gt;ug&lt;/span&gt;(N);
add_edge(B, C, ug);
add_edge(B, F, ug);
add_edge(C, A, ug);
add_edge(D, E, ug);
add_edge(F, A, ug);

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;vertex set: &#34;&lt;/span&gt;;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_vertices(ug, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;edge set: &#34;&lt;/span&gt;;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_edges(ug, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;incident edges: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_graph(ug, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力:&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;vertex set: A B C D E F 

edge set: (C,A) (C,B) (E,D) (F,A) (F,B) 

incident edges: 
A &amp;lt;--&amp;gt; C F 
B &amp;lt;--&amp;gt; C F 
C &amp;lt;--&amp;gt; A B 
D &amp;lt;--&amp;gt; E 
E &amp;lt;--&amp;gt; D 
F &amp;lt;--&amp;gt; A B 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;boost/graph/adjacency_matrix.hpp&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有効か無向かを選ぶ選択子。オプションは &lt;code&gt;directedS&lt;/code&gt; と &lt;code&gt;undirectedS&lt;/code&gt;。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部プロパティ記憶域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部プロパティ記憶域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフのオブジェクトの内部プロパティ記憶域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model Of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.html&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyMatrix.html&#34;&gt;AdjacencyMatrix&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.html&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Associates Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt; と対応付けられた頂点記述子の型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt; と対応付けられた辺記述子の型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 この頂点イテレータは&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;RandomAccessIterator&lt;/a&gt;のモデルである。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 この辺イテレータは&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt;のモデルである。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 このイテレータは&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt;のモデルである。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 このイテレータは出辺イテレータと同じコンセプトのモデルである。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;AdjacencyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフが 有向(&lt;code&gt;directed_tag&lt;/code&gt;)であるか無向(&lt;code&gt;undirected_tag&lt;/code&gt;)であるかに関する情報を提供する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;隣接行列は多重辺の挿入を許可しないので、 この型は常に &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点数を扱うための型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edges_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの辺数を扱うための型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点からの出辺数を扱うための型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, PropertyTag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, PropertyTag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点もしくは辺のプロパティに対するマップの型。 具体的なプロパティはテンプレート引数 &lt;code&gt;PropertyTag&lt;/code&gt; によって指定され、 グラフの &lt;code&gt;VertexProperty&lt;/code&gt; もしくは &lt;code&gt;EdgeProperty&lt;/code&gt; で 指定されているプロパティの内の1つに適合していなければならない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyGraph.html&#34;&gt;PropertyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_matrix(vertices_size_type n,
                 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点数 &lt;code&gt;n&lt;/code&gt;、辺数 0 であるグラフのオブジェクトを生成する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; EdgeIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacency_matrix(EdgeIterator first,
                 EdgeIterator last,
                 vertices_size_type n,
                 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点数 &lt;code&gt;n&lt;/code&gt; で、辺が &lt;code&gt;[first, last)&lt;/code&gt; の範囲で 与えられたリストで指定された辺をもつグラフのオブジェクトを生成する。 EdgeIterator の値の型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、それは整数型の組である。 それら整数は頂点に対応し、&lt;code&gt;[0, n)&lt;/code&gt; の範囲になければならない。
(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IteratorConstructibleGraph.html&#34;&gt;IteratorConstructibleGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; EdgeIterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; EdgePropertyIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacency_matrix(EdgeIterator first, EdgeIterator last,
                 EdgePropertyIterator ep_iter,
                 vertices_size_type n,
                 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点数 &lt;code&gt;n&lt;/code&gt; で、辺が &lt;code&gt;[first, last)&lt;/code&gt; の範囲で与えられたリストで指定された辺をもつグラフのオブジェクトを生成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; の値の型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、それは整数型の組である。 それら整数は頂点に対応し、&lt;code&gt;[0, n)&lt;/code&gt; の範囲になければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperty&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータの範囲を返す。 (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータの範囲を返す。 (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; で頂点 &lt;code&gt;v&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータの範囲を返す。 (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;AdjacencyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; で頂点 &lt;code&gt;v&lt;/code&gt; の出辺へのアクセスを提供するイテレータの範囲を返す。 グラフが無向であれば、このイテレータの範囲は、頂点 &lt;code&gt;v&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; を出る辺の数を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点数を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺数を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点リスト内の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; で、頂点 &lt;code&gt;u&lt;/code&gt; を頂点 &lt;code&gt;v&lt;/code&gt; へ接続する頂点を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyMatrix.html&#34;&gt;AdjacencyMatrix&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフへ追加し、その新しい辺への辺記述子を返す。 すでに辺があれば二重には追加されず、&lt;code&gt;bool&lt;/code&gt; のフラグは&lt;code&gt;false&lt;/code&gt;となる。 この処理はグラフのいかなるイテレータ及び記述子を無効化することはない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフへ追加し、その新しい辺にその辺の内部プロパティ記憶域の値として、 &lt;code&gt;p&lt;/code&gt; を付与する。 さらなる詳細は前にある非メンバ関数 &lt;code&gt;add_edge()&lt;/code&gt; を見よ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから辺 &lt;code&gt;(u,v)&lt;/code&gt; を削除する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから辺 &lt;code&gt;e&lt;/code&gt; を削除する。 この操作は &lt;code&gt;remove_edge(source(e, g), target(e, g), g)&lt;/code&gt; を呼び出すのと等価である。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺を削除する。 その頂点はグラフの頂点集合からは削除されない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(Property, adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Property&lt;/code&gt; で指定される頂点プロパティへのプロパティマップのオブジェクトを返す。 &lt;code&gt;Property&lt;/code&gt; はグラフのテンプレート引数 &lt;code&gt;VertexProperty&lt;/code&gt; で指定されるプロパティの1つと適合していなければならない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyGraph.html&#34;&gt;PropertyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
  typenamae property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点もしくは辺の記述子 &lt;code&gt;x&lt;/code&gt; に対するプロパティ値を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyGraph.html&#34;&gt;PropertyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; X, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;値&lt;code&gt;x&lt;/code&gt; をプロパティ値として &lt;code&gt;value&lt;/code&gt; にセットする。 &lt;code&gt;x&lt;/code&gt; は 頂点もしくは辺の記述子である。 &lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_matrix, Property&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; に変換可能でなければならない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyGraph.html&#34;&gt;PropertyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphProperty, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_value&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;GraphProperty, GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, GraphProperty)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフのオブジェクト &lt;code&gt;g&lt;/code&gt; に付与された &lt;code&gt;GraphProperty&lt;/code&gt; で指定されたプロパティを返す。 特性クラス &lt;code&gt;property_value&lt;/code&gt; は boost/pending/property.hpp で定義される。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphProperty, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_value&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;GraphProperty, GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, GraphProperty)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフのオブジェクト &lt;code&gt;g&lt;/code&gt; に付与された &lt;code&gt;GraphProperty&lt;/code&gt; で指定されたプロパティを返す。 特性クラス &lt;code&gt;property_value&lt;/code&gt; は boost/pending/property.hpp で定義される。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 KANAHORI Toshihiro &lt;a href=&#34;mailto:kanahori@k.tsukuba-tech.ac.jp&#34;&gt;kanahori@k.tsukuba-tech.ac.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bandwidth -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bandwidth.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;bandwidth&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; VertexIndexMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, VertexIndexMap index_map)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;無向グラフの 帯域幅 (bandwidth) は二つの隣接頂点の間の最大距離 で、頂点が構成単位間隔に置かれた線上で測定された距離である。別の言い方を すると、 もし無向グラフの頂点 &lt;code&gt;G=(V,E)&lt;/code&gt; に各々 &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;|V| - 1&lt;/code&gt; までの &lt;code&gt;index[v]&lt;/code&gt; によって与えられる添え字が割り当てられているなら、&lt;code&gt;G&lt;/code&gt; の帯域幅は以下である：&lt;/p&gt;
&lt;p&gt;B(G) = max { |index[u] - index[v]|  | (u,v) in E }&lt;/p&gt;
&lt;h2&gt;Defined in&lt;/h2&gt;
&lt;p&gt;boost/graph/bandwidth.hpp&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;ith_bandwidth&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt; (&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
ith_bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor i,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; VertexIndexMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
ith_bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor i,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
      VertexIndexMap index)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの &lt;code&gt;i&lt;/code&gt; 番目の帯域幅 (i-th bandwidth) は、 &lt;code&gt;i&lt;/code&gt; 番目の頂点とその隣接のいずれかとの間の最大距離である。&lt;/p&gt;
&lt;p&gt;B&lt;sub&gt;i&lt;/sub&gt;(G) = max { |index[i] - index[j]|  | (i,j) in E }&lt;/p&gt;
&lt;p&gt;それで帯域幅 B(G) は &lt;code&gt;i&lt;/code&gt; 番目の帯域幅 B&lt;sub&gt;i&lt;/sub&gt;(G) の最大値として表すことができる。&lt;/p&gt;
&lt;p&gt;B(G) = max { B&lt;sub&gt;i&lt;/sub&gt;(G)   | i=0...|V|-1 }&lt;/p&gt;
&lt;h2&gt;Defined in&lt;/h2&gt;
&lt;p&gt;boost/graph/bandwidth.hpp &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bellman_ford_shortest_paths -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bellman_ford_shortest_paths.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;bellman_ford_shortest_paths&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Size&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; bellman_ford_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, Size N, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Size&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;WeightMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredecessorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistanceMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;BinaryFunction&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;BinaryPredicate&lt;/a&gt;&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; bellman_ford_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, Size N, 
  WeightMap weight, PredecessorMap pred, DistanceMap distance, 
  &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;BinaryFunction&lt;/a&gt; combine, &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;BinaryPredicate&lt;/a&gt; compare, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; v)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Bellman-Ford アルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#bellman58&#34;&gt;4&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford62:_flows&#34;&gt;11&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#lawler76:_comb_opt&#34;&gt;20&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;8&lt;/a&gt;] は、正と負の両方の辺の重みを持つグラフの単一始点の最短経路問題を解く。最短経路問題の定義のために、 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-paths-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。 もし正の辺の重みを持つ最短経路問題を解く必要があるだけなら、Dijkstra の アルゴリズムがより効率的な代替手段を提供する。もし全ての辺の重みが 1 に等しいなら幅優先探索がより一層効率的な代替手段を提供する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; 関数を呼ぶ前に、ユーザは始点に 0 の 距離を割り当て、他の全ての頂点に無限大の距離を割り当てなければならない。 Bellman-Ford アルゴリズムはグラフ中の全ての辺を通してループし、各辺に リラックス操作 (減らす操作) を適用することによって進められる。下記の擬似コード中で、 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;u&lt;/code&gt; の隣接頂点で、&lt;code&gt;w&lt;/code&gt; は辺にそれらの重みをマップし、 &lt;code&gt;d&lt;/code&gt; は今の所見られる各辺への最短経路の長さを記録する距離マップである。&lt;code&gt;p&lt;/code&gt; は各辺の親を記録する先行点マップで、それは結局最短経路木中で親となるであろう。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;RELAX(u, v, w, d, p)
  if (w(u,v) + d[u] &amp;lt; d[v]) 
    d[v] := w(u,v) + d[u]      辺をリラックスする (減らす) (u,v)
    p[v] := u
  else
    ...                        辺 (u,v) は リラックスされていない (減らされていない)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;アルゴリズムはグラフ中に負の閉路が存在しないならば、各辺への距離が可能な限り最小に減らされた事が保証された後にこのループを &lt;code&gt;|V|&lt;/code&gt; 回 繰り返す。もし負の閉路が存在するならば、グラフ中に適当に最小化されない 辺が存在する事になるだろう。つまり、&lt;code&gt;w(u,v) + d[u] &amp;lt; d[v]&lt;/code&gt; であるような 辺 &lt;code&gt;(u,v)&lt;/code&gt; が存在することになるだろう。 アルゴリズムは全ての辺が最小化されたかどうか最後に一回調べるためにグラフ中の辺をループし、もしよければ &lt;code&gt;true&lt;/code&gt; を返し、そうでなければ &lt;code&gt;false&lt;/code&gt; を返す。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;BELLMAN-FORD(G)
  for each vertex u in V        頂点 u の初期化
    d[u] := infinity
    p[u] := u
  end for
  for i := 1 to |V|-1
    for each edge (u,v) in E    辺 (u,v) の調査
      RELAX(u, v, w, d, p)
    end for
  end for
  for each edge (u,v) in E
    if (w(u,v) + d[u] &amp;lt; d[v])
      return (false, , )        辺 (u,v) は最小化されていない
    else
      ...                       辺 (u,v) は最小化されている
  end for
  return (true, p, d)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。 ユーザが &lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・マップを提供するならばグラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう (もし関数が &lt;code&gt;true&lt;/code&gt; を返すなら)。 二番目の選択は最短経路木を &lt;code&gt;predecessor_map()&lt;/code&gt; に記録することである。 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点 であるか、または始点からは到達不能な頂点である場合を除く)。 これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間、アクションを取れる独自のビジタをそこに提供することができる。&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;EdgeListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;Edge List Graph&lt;/a&gt; のモデルの有向グラフまたは無向グラフでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;Size N&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の頂点の数。型 &lt;code&gt;Size&lt;/code&gt; は汎整数型でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重み　(そして「長さ」もしくは「コスト」として知られる)。 &lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。このプロパティ・マップのキー型はグラフの辺記述子でなければならない。重みマップの値型は距離マップの値型を伴った Addable でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。 アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN/OUT: &lt;code&gt;distance_map(DistanceMap d)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。プロパティ・マップのキー型は グラフの頂点記述子型でなければならず、距離マップの値型は &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;Less Than Comparable&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_distance, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BellmanFordVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビジタ・オブジェクトで、その型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;Bellman-Ford Visitor&lt;/a&gt; のモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bellman_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(BinaryFunction combine)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数オブジェクトはリラックス (減少) 段階中で、加算の役割を置き換える。 第一引数の型は距離マップの値型に一致していなければならず、第二引数の型は重みマップの値型に一致していなければならない。 結果型は距離マップの値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト:&lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(BinaryPredicate compare)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数オブジェクトはリラックス (減少) 段階中で、距離を比較する less-than (&lt;code&gt;&amp;lt;&lt;/code&gt;) 演算子の役割を置き換える。引数の型は距離マップの値型に一致していなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間複雑性は O(V E) である。&lt;/p&gt;
&lt;h2&gt;Visitor Event Points&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、グラフ中の各辺において &lt;code&gt;|V|&lt;/code&gt; 回呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は終点のための距離ラベルが減じられた時に呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった 辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし終点のための距離ラベルが減じられなかった時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_minimized(e, g)&lt;/code&gt; は、アルゴリズムの第二段階の間、各辺が最小化されたかどうかの検査の間に呼び出される。もし辺が最小化されていればこの関数が呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_minimized(e, g)&lt;/code&gt; もまた、アルゴリズムの第二段階の間、各辺が最小化されたかどうかの検査の間に呼び出される。もし辺が最小化されていなければ、この関数が呼び出される。これはグラフ中に負の閉路が存在する時に起こる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;Bellman-Ford のアルゴリズムを用いた例が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bellman-example.cpp.html&#34;&gt;examples/bellman-example.cpp&lt;/a&gt; 中にある。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われず ビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたは リファレンスによってこの状態をビジタに保持させる事を望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bellman_visitor&lt;EventVisitorList&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bellman_visitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;bellman_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/bellman_ford_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.me&#34;&gt;BellmanFordVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが EventVisitorList の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bellman_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_bellman_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; に適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.me&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bfs_visitor&lt;EventVisitorList&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bfs_visitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;bfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;以下は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs.cpp.html&#34;&gt;examples/bfs.cpp&lt;/a&gt; からの抜粋である。ここでは 3 つのイベントビジタを結合して BFS ビジタを作っている。関数 &lt;code&gt;boost::record_distances&lt;/code&gt; 、 &lt;code&gt;boost::record_predecessors&lt;/code&gt; 、 &lt;code&gt;copy_graph&lt;/code&gt; は全て、イベントビジタを作る関数だ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Construct graph G and obtain the source vertex s ...&lt;/span&gt;

boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;breadth_first_search(G, s, 
 boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_bfs_visitor(
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;record_distances(d, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_tree_edge()),
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;record_predecessors(p.begin(), 
                                            boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_tree_edge()),
                 copy_graph(G_copy, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_examine_edge())))) );
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリスト。&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/null_visitor.html&#34;&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが EventVisitorList の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_bfs_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを BFS ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bgl_named_params&lt;Param, Type, Rest&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bgl_named_params.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bgl_named_params.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;bgl_named_params&amp;lt;Param, Type, Rest&amp;gt;&lt;/h1&gt;
&lt;p&gt;多くの Boost.Graph アルゴリズムは長いパラメータ列を持ち、その多くはデフォルト値を持つ。これがいくつかの問題を起こす。 1つは、 C++ がテンプレート関数のデフォルト値を扱う仕組みを持っていないことだ。しかし、異なる数のパラメータを持つ複数のバージョンのアルゴリズムを作り、各バージョンが一部のパラメータにデフォルト値を与えることで、この問題は克服される。これは Boost.Graph の以前のバージョンで使われていたアプローチだ。しかし、この解決法はまだ、いくつかの理由で不十分だ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータのデフォルト値は特定の順序でしか使えない。デフォルト値の順序がユーザの状況に合わなければ、ユーザは全てのパラメータを与えるという手段をとらなければならない。&lt;/li&gt;
&lt;li&gt;パラメータ列が長いので、順序を忘れやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;より良い解決法を与えるのが &lt;code&gt;bgl_named_params&lt;/code&gt; だ。このクラスを使えば、パラメータを任意の順序で与えることができ、パラメータ名によって引数をパラメータに適合できる。&lt;/p&gt;
&lt;p&gt;以下のコードで、名前付きパラメータのテクニックを使って &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; を呼び出す例を示す。各引数は、引数がどのパラメータに与えられるのかを示す名前を持つ関数に渡される。それぞれの名前付きパラメータは、カンマではなくピリオドで区切られる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), 
     boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;weight_map(weight).
     distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
     predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;引数が正しいパラメータ関数に適合される限り、引数が与えられる順序はどうでも良い。これは、上のコードと等価な &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; の呼び出しである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), 
   boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
   distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
   weight_map(weight));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;一般に、ユーザは &lt;code&gt;bgl_named_params&lt;/code&gt; クラスを直接使う必要はない。 &lt;code&gt;boost::weight_map&lt;/code&gt; のような &lt;code&gt;bgl_named_params&lt;/code&gt; のインスタンスを作る関数があるからだ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>参考文献 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bibliography.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#aho83:_data_struct_algo&#34; name=&#34;aho83:_data_struct_algo&#34;&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. V. Aho, J. E. Hopcroft, and J. D. Ullman.&lt;/li&gt;
&lt;li&gt;Data Structures and Algorithms.&lt;/li&gt;
&lt;li&gt;Addison-Wesley, 1983.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#austern99:_gener_progr_stl&#34; name=&#34;austern99:_gener_progr_stl&#34;&gt;2&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M. H. Austern.&lt;/li&gt;
&lt;li&gt;Generic Programming and the STL.&lt;/li&gt;
&lt;li&gt;Professional computing series. Addison-Wesley, 1999.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#baumgartner95:_signatures&#34; name=&#34;baumgartner95:_signatures&#34;&gt;3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G. Baumgartner and V. F. Russo.&lt;/li&gt;
&lt;li&gt;Signatures: A language extension for improving type abstraction and subtype polymorphism in C++.&lt;/li&gt;
&lt;li&gt;Software-Practice and Experience, 25(8):863-889, August 1995.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#bellman58&#34; name=&#34;bellman58&#34;&gt;4&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R. Bellman.&lt;/li&gt;
&lt;li&gt;On a routing problem.&lt;/li&gt;
&lt;li&gt;Quarterly of Applied Mathematics, 16(1):87-90, 1958.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#bruce95&#34; name=&#34;bruce95&#34;&gt;5&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K. B. Bruce, L. Cardelli, G. Castagna, the Hopkins Objects Group, G. T. Leavens, and B. Pierce.&lt;/li&gt;
&lt;li&gt;On binary methods.&lt;/li&gt;
&lt;li&gt;Theory and Practice of Object Systems, 1:221-242, 1995.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman85:_algor&#34; name=&#34;coleman85:_algor&#34;&gt;6&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T. F. Coleman, B. S. Garbow, and J. J. Mor&#39;e.&lt;/li&gt;
&lt;li&gt;Algorithm 649: Fortran subroutines for estimating sparse hessian matrices.&lt;/li&gt;
&lt;li&gt;ACM Transactions on Mathematical Software, 11(4):378, December 1985.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman84:_estim_jacob&#34; name=&#34;coleman84:_estim_jacob&#34;&gt;7&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T. F. Coleman and J. J. Mor&#39;e.&lt;/li&gt;
&lt;li&gt;Estimation of sparse jacobian matrices and graph coloring problems.&lt;/li&gt;
&lt;li&gt;SIAM Journal on Numerical Analysis, 20:187-209,, 1984.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34; name=&#34;clr90&#34;&gt;8&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T. Cormen, C. Leiserson, and R. Rivest.&lt;/li&gt;
&lt;li&gt;Introduction to Algorithms.&lt;/li&gt;
&lt;li&gt;McGraw-Hill, 1990.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#curtis74:_jacob&#34; name=&#34;curtis74:_jacob&#34;&gt;9&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. Curtis, M. Powell, and J. Reid.&lt;/li&gt;
&lt;li&gt;On the estimation of sparse jacobian matrices.&lt;/li&gt;
&lt;li&gt;Journal of the Institute of Mathematics and its Applications, 13:117-119, 1974.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#dijkstra59&#34; name=&#34;dijkstra59&#34;&gt;10&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. Dijkstra.&lt;/li&gt;
&lt;li&gt;A note on two problems in connexion with graphs.&lt;/li&gt;
&lt;li&gt;Numerische Mathematik, 1:269-271, 1959.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford62:_flows&#34; name=&#34;ford62:_flows&#34;&gt;11&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L. R. Ford and D. R. Fulkerson.&lt;/li&gt;
&lt;li&gt;Flows in networks.&lt;/li&gt;
&lt;li&gt;Princeton University Press, 1962.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#gamma95:_design_patterns&#34; name=&#34;gamma95:_design_patterns&#34;&gt;12&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. Gamma, R. Helm, R. Johnson, and J. Vlissides.&lt;/li&gt;
&lt;li&gt;Design Patterns: Elements of Reusable Object-Oriented Software.&lt;/li&gt;
&lt;li&gt;Professional Computing. Addison-Welsey, 1995.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george93:graphtheory&#34; name=&#34;george93:graphtheory&#34;&gt;13&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. George, J. R. Gilbert, and J. W. Liu, editors.&lt;/li&gt;
&lt;li&gt;Graph Theory and Sparse Matrix Computation.&lt;/li&gt;
&lt;li&gt;Springer-Verlag New York, Inc, 1993.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george81:__sparse_pos_def&#34; name=&#34;george81:__sparse_pos_def&#34;&gt;14&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. George and J. W.-H. Liu.&lt;/li&gt;
&lt;li&gt;Computer Solution of Large Sparse Positive Definite Systems.&lt;/li&gt;
&lt;li&gt;Computational Mathematics. Prentice-Hall, 1981.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#graham85&#34; name=&#34;graham85&#34;&gt;15&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R. Graham and P. Hell.&lt;/li&gt;
&lt;li&gt;On the history of the minimum spanning tree problem.&lt;/li&gt;
&lt;li&gt;Annals of the History of Computing, 7(1):43-57, 1985.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#hart68&#34; name=&#34;hart68&#34;&gt;16&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P. E. Hart, N. J. Nilsson, and B. Raphael.&lt;/li&gt;
&lt;li&gt;A formal basis for the heuristic determination of minimum cost paths.&lt;/li&gt;
&lt;li&gt;IEEE Transactions on Systems Science and Cybernetics, 4(2):100-107, 1968.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#kruskal56&#34; name=&#34;kruskal56&#34;&gt;18&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;J. B. Kruskal.&lt;/li&gt;
&lt;li&gt;On the shortest spanning subtree of a graph and the traveling salesman problem.&lt;/li&gt;
&lt;li&gt;In Proceedings of the American Mathematical Sofiety, volume 7, pages 48-50, 1956.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#kuehl96:_design_patterns_for_graph_algo&#34; name=&#34;kuehl96:_design_patterns_for_graph_algo&#34;&gt;19&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Kühl.&lt;/li&gt;
&lt;li&gt;Design patterns for the implementation of graph algorithms.&lt;/li&gt;
&lt;li&gt;Master&#39;s thesis, Technische Universität Berlin, July 1996.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#lawler76:_comb_opt&#34; name=&#34;lawler76:_comb_opt&#34;&gt;20&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. L. Lawler.&lt;/li&gt;
&lt;li&gt;Combinatorial Opimization: Networks and Matroids.&lt;/li&gt;
&lt;li&gt;Holt, Rinehart, and Winston, 1976.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#LIU:MMD&#34; name=&#34;LIU:MMD&#34;&gt;21&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;J. W. H. Liu.&lt;/li&gt;
&lt;li&gt;Modification of the minimum-degree algorithm by multiple elimination.&lt;/li&gt;
&lt;li&gt;ACM Transaction on Mathematical Software, 11(2):141-153, 1985.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#mehlhorn99:_leda&#34; name=&#34;mehlhorn99:_leda&#34;&gt;22&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K. Mehlhorn and St. Näher.&lt;/li&gt;
&lt;li&gt;The LEDA Platform of Combinatorial and Geometric Computing.&lt;/li&gt;
&lt;li&gt;Cambridge University Press, 1999.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#meyer88:_object_soft_const&#34; name=&#34;meyer88:_object_soft_const&#34;&gt;23&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B. Meyer.&lt;/li&gt;
&lt;li&gt;Object-oriented Software Construction.&lt;/li&gt;
&lt;li&gt;Prentice Hall International Series in Computer Science. Prentice Hall, 1988.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#myers95:_trait&#34; name=&#34;myers95:_trait&#34;&gt;24&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N. C. Myers.&lt;/li&gt;
&lt;li&gt;Traits: a new and useful template technique.&lt;/li&gt;
&lt;li&gt;C++ Report, June 1995.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#prim57:_short&#34; name=&#34;prim57:_short&#34;&gt;25&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R. Prim.&lt;/li&gt;
&lt;li&gt;Shortest connection networks and some generalizations.&lt;/li&gt;
&lt;li&gt;Bell System Technical Journal, 36:1389-1401, 1957.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#saad96:imsms&#34; name=&#34;saad96:imsms&#34;&gt;26&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Y. Saad.&lt;/li&gt;
&lt;li&gt;Iterative Methods for Sparse Minear System.&lt;/li&gt;
&lt;li&gt;PWS Publishing Company, 1996.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#tarjan83:_data_struct_network_algo&#34; name=&#34;tarjan83:_data_struct_network_algo&#34;&gt;27&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R. E. Tarjan.&lt;/li&gt;
&lt;li&gt;Data Structures and Network Algorithms.&lt;/li&gt;
&lt;li&gt;Society for Industrial and Applied Mathematics, 1983.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#parter61:_gauss&#34; name=&#34;parter61:_gauss&#34;&gt;28&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Seymour Parter.&lt;/li&gt;
&lt;li&gt;The use of linear graphs in Gauss elimination.&lt;/li&gt;
&lt;li&gt;SIAM Review, 1961 3:119-130.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#matula72:_graph_theory_computing&#34; name=&#34;matula72:_graph_theory_computing&#34;&gt;29&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Matula, G. Marble, and J. Isaacson&lt;/li&gt;
&lt;li&gt;Graph coloring algorithms in Graph Theory and Computing.&lt;/li&gt;
&lt;li&gt;Academic Press, pp.104-122, 1972.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#garey79:computers-and-intractability&#34; name=&#34;garey79:computers-and-intractability&#34;&gt;30&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M.R. Garey and D.S. Johnson&lt;/li&gt;
&lt;li&gt;Computers and Intractibility: A Guide to the Theory of NP-Completeness&lt;/li&gt;
&lt;li&gt;W.H. Freeman, New York, 1979.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#welsch67&#34; name=&#34;welsch67&#34;&gt;31&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Welsch and M. B. Powel&lt;/li&gt;
&lt;li&gt;An upper bound for the chromatic number of a graph and its application to timetabling problems Computer Journal, 10:85-86, 1967.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#brelaz79:_new&#34; name=&#34;brelaz79:_new&#34;&gt;32&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Br&#39;elaz&lt;/li&gt;
&lt;li&gt;New methods to color the vertices of a graph&lt;/li&gt;
&lt;li&gt;Communications of the ACM, vol. 22, 1979, pp. 251-256.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#heber99:_saw&#34; name=&#34;heber99:_saw&#34;&gt;33&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G. Heber, R. Biswas, G.R. Gao&lt;/li&gt;
&lt;li&gt;Self-Avoiding Walks over Adaptive Unstructured Grids&lt;/li&gt;
&lt;li&gt;Parallel and Distributed Processing, LNCS 1586, Springer-Verlag, 1999, pp. 968-977&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ng-raghavan&#34; name=&#34;ng-raghavan&#34;&gt;34&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Esmond G. Ng amd Padma Raghavan&lt;/li&gt;
&lt;li&gt;Performance of greedy ordering heuristics for sparse {C}holesky factorization&lt;/li&gt;
&lt;li&gt;SIAM Journal on Matrix Analysis and Applications (To appear)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#George:evolution&#34; name=&#34;George:evolution&#34;&gt;35&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alan George and Joseph W. H. Liu&lt;/li&gt;
&lt;li&gt;The Evolution of the Minimum Degree Ordering Algorithm&lt;/li&gt;
&lt;li&gt;SIAM Review, March 1989, vol. 31, num. 1, pp. 1-19.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford56:_maxim&#34; name=&#34;ford56:_maxim&#34;&gt;36&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L. R. Ford and D. R. Fulkerson&lt;/li&gt;
&lt;li&gt;Maximal flow through a network.&lt;/li&gt;
&lt;li&gt;Can. Journal of Mathematics 1956 pp.399-404&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goldberg85:_new_max_flow_algor&#34; name=&#34;goldberg85:_new_max_flow_algor&#34;&gt;37&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. V. Goldberg&lt;/li&gt;
&lt;li&gt;A New Max-Flow Algorithm.&lt;/li&gt;
&lt;li&gt;MIT Tehnical report MIT/LCS/TM-291, 1985.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#karzanov74:_deter&#34; name=&#34;karzanov74:_deter&#34;&gt;38&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. V. Karzanov&lt;/li&gt;
&lt;li&gt;Determining the maximal flow in a network by the method of preflows.&lt;/li&gt;
&lt;li&gt;Sov. Math. Dokl. 1974&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ahuja93:_network_flows&#34; name=&#34;ahuja93:_network_flows&#34;&gt;39&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ravindra K. Ahuja and Thomas L. Magnanti and James B. Orlin&lt;/li&gt;
&lt;li&gt;Network Flows: Theory, Algorithms, and Applications.&lt;/li&gt;
&lt;li&gt;Prentice Hall, 1993.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#edmonds72:_improvements_netflow&#34; name=&#34;edmonds72:_improvements_netflow&#34;&gt;40&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jack Edmonds and Richard M. Karp&lt;/li&gt;
&lt;li&gt;Theoretical improvements in the algorithmic efficiency for network flow problems.&lt;/li&gt;
&lt;li&gt;Journal of the ACM, 1972 19:248-264&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#tarjan72:dfs_and_linear_algo&#34; name=&#34;tarjan72:dfs_and_linear_algo&#34;&gt;41&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Robert E. Tarjan&lt;/li&gt;
&lt;li&gt;Depth first search and linear graph algorithms.&lt;/li&gt;
&lt;li&gt;SIAM Journal on Computing, 1(2):146-160, 1972&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#eppstein97:dynamic_graph&#34; name=&#34;eppstein97:dynamic_graph&#34;&gt;42&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;David Eppstein, Zvi Galil, and Giuseppe F. Italiano&lt;/li&gt;
&lt;li&gt;Dynamic Graph Algorithms.&lt;/li&gt;
&lt;li&gt;Chapter 22, CRC Handbook of Algorithms and Theory of Computation, 1997.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#cuthill69:reducing_bandwith&#34; name=&#34;cuthill69:reducing_bandwith&#34;&gt;43&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. Cuthill and J. McKee&lt;/li&gt;
&lt;li&gt;Reducing the bandwidth of sparse symmetric matrices.&lt;/li&gt;
&lt;li&gt;Proceedings of the 24th National Conference of the ACM, 1969.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#liu75:anal_cm_rcm&#34; name=&#34;liu75:anal_cm_rcm&#34;&gt;44&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;J. Liu and A. Sherman&lt;/li&gt;
&lt;li&gt;Comparative analysis of the Cuthill-Mckee and the reverse Cuthill-Mckee ordering algorithms for sparse matrices.&lt;/li&gt;
&lt;li&gt;SIAM Journal of Numerical Analysis. 13 (1975), pp. 198-213.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george71:fem&#34; name=&#34;george71:fem&#34;&gt;45&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alan George&lt;/li&gt;
&lt;li&gt;Computer implementation of the finite element method&lt;/li&gt;
&lt;li&gt;Technical Report STAN-CS-208, Stanford University (1971).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#fortin96:_graph_iso_prob&#34; name=&#34;fortin96:_graph_iso_prob&#34;&gt;46&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scott Fortin&lt;/li&gt;
&lt;li&gt;The Graph Isomorphism Problem&lt;/li&gt;
&lt;li&gt;TR 96-20, Dept. of Computer Science, University of Alberta (1996)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#mckay81:_pract_graph_iso&#34; name=&#34;mckay81:_pract_graph_iso&#34;&gt;47&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Brendan D. McKay&lt;/li&gt;
&lt;li&gt;Practical Graph Isomorphism&lt;/li&gt;
&lt;li&gt;Congressus Numerantium (1981)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#reingold77:_combin_algo&#34; name=&#34;reingold77:_combin_algo&#34;&gt;48&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reingold, Nievergelt, and Deo&lt;/li&gt;
&lt;li&gt;Combinatorial Algorithms: Theory and Practice&lt;/li&gt;
&lt;li&gt;Prentice Hall (1977)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#moore59&#34; name=&#34;moore59&#34;&gt;49&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Edward Moore&lt;/li&gt;
&lt;li&gt;The shortest path through a maze&lt;/li&gt;
&lt;li&gt;International Symposium on the Theory of Switching (1959)&lt;/li&gt;
&lt;li&gt;Harvard University Press&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#nuutila95&#34; name=&#34;nuutila95&#34;&gt;50&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. Nuutila&lt;/li&gt;
&lt;li&gt;Efficient transitive closure computation in large digraphs&lt;/li&gt;
&lt;li&gt;PhD Thesis, Helsinki University of Technology, 1995. &lt;/li&gt;
&lt;li&gt;Acta Polytechnica Scandinavica, Mathematics and Computing in Engineering Series, No. 74.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goral79&#34; name=&#34;goral79&#34;&gt;51&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. Goralcikova and V. Koubek&lt;/li&gt;
&lt;li&gt;A reduct and closure algorithm for graphs&lt;/li&gt;
&lt;li&gt;In Mathematical Foundations of Computer Science, &lt;/li&gt;
&lt;li&gt;volume 74 of Lecture Notes in Computer Science, pages 301-307. &lt;/li&gt;
&lt;li&gt;Springer-Verlag, 1979&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#simon86&#34; name=&#34;simon86&#34;&gt;52&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Klaus Simon&lt;/li&gt;
&lt;li&gt;An Improved Algorithm for Transitive Closure on Acyclic Digraphs&lt;/li&gt;
&lt;li&gt;Theoretical Computer Science 58&lt;/li&gt;
&lt;li&gt;Automata, Languages and Programming, 376-386, 1986&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#purdom70&#34; name=&#34;purdom70&#34;&gt;53&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P. Purdom&lt;/li&gt;
&lt;li&gt;A Transitive Closure Algorithm&lt;/li&gt;
&lt;li&gt;BIT, 10, 1970, pp. 76-94.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>breadth_first_search -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/breadth_first_search.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;breadth_first_search&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は有向グラフまたは無向グラフの幅優先巡回(breadth-first traversal) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#moore59&#34;&gt;[49]&lt;/a&gt; を行う。幅優先巡回は、始点から遠方に離れた頂点を訪れる前に近い頂点を訪れる。 この文脈中で「距離」とは始点からの最短経路中の辺の数として定義される。 &lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は始点から全ての到達可能な頂点への最短経路を計算するのに使用でき、結果として最短経路の距離が得られる。 BFS に関連した更なる定義は章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34;&gt;Breadth-First Search&lt;/a&gt; を見よ。&lt;/p&gt;
&lt;p&gt;BFS は巡回を実装するのに二つのデータ構造を使っている: 各頂点のカラー・マーカーとキューである。白色の頂点は未発見で、一方灰色の頂点は発見されたけれども未発見の隣接頂点を持つ。黒色の頂点は発見されており、他の黒色もしくは灰色の頂点にのみ隣接している。アルゴリズムは頂点 &lt;code&gt;u&lt;/code&gt; をキューから取り除き、 各出辺 &lt;code&gt;(u,v)&lt;/code&gt; を調べながら進められる。もし隣接頂点 &lt;code&gt;v&lt;/code&gt; がまだ 未発見ならば、灰色に色づけしてキューに置く。すべての出辺を調べた後、頂点 &lt;code&gt;u&lt;/code&gt; を黒色に色づけして手順を繰り返す。BFS アルゴリズムの疑似コードを下に示す。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;BFS(G, s)
  for each vertex u in V[G]      頂点uの初期化
    color[u] := WHITE 
    d[u] := infinity 
    p[u] := u 
  end for
  color[s] := GRAY 
  d[s] := 0 
  ENQUEUE(Q, s)                  頂点sの発見
  while (Q != Ø) 
    u := DEQUEUE(Q)              頂点uの調査
    for each vertex v in Adj[u]  辺(u,v)の調査
      if (color[v] = WHITE)      辺(u,v)は木の辺
        color[v] := GRAY 
        d[v] := d[u] + 1  
        p[v] := u  
        ENQUEUE(Q, v)            頂点vの発見
      else                       (u,v)は木でない辺
        if (color[v] = GRAY) 
          ...                    (u,v)は灰色の終点を持つ
        else
          ...                    (u,v)は黒色の終点を持つ
    end for
    color[u] := BLACK            頂点uの終了
  end while
  return (d, p)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は一定のイベント・ポイントと呼ばれる、 ユーザ定義のアクションで拡張することができる。アクションはビジタ・オブジェクトの形で提供されなければならない。すなわち、型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; の要求を満たしているオブジェクトである。上の擬似コード内で、イベント・ポイントは右側のラベルである。さらに各イベント・ポイントの記述を以下に示した。デフォルトでは &lt;code&gt;breadth_first_search()&lt;/code&gt; 関数はどんなアクションも実行しない。距離や先行点の記録さえも。しかしながらこれらは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; のイベント・ビジタを用いて容易に追加できる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; コンセプトで指定されたイベント・ポイントで呼び出されるビジタ・オブジェクト。 ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 アルゴリズムは開始時に全ての頂点の色を白色に初期化するため、ユーザは &lt;code&gt;breadth_first_search()&lt;/code&gt; を呼ぶ前にカラー・マップを初期化する必要はない。もし複合的な幅優先探索をグラフ上で行う必要があるなら (例えばいくつかの切断された成分があるなら) &lt;code&gt;breadth_first_visit()&lt;/code&gt; 関数を使って独自の初期化を行うこと。
    &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならなく、そのキー型はグラフの頂点記述子型でなければならなく、カラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;code&gt;iterator_property_map&lt;/code&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。 このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。 &lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;buffer(Buffer&amp;amp; Q)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点が発見される順序を決定するために使用されるキュー。もしFIFOキューが使われると、 巡回は通常の BFS 順序付けに従う。他の型のキューも使用できるが、巡回順序は異なる。例えば Dijkstra のアルゴリズムは優先度付きキューを用いて実装することができる。&lt;code&gt;Buffer&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt; のモデルでなければならない。&lt;code&gt;buffer&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; はグラフの &lt;code&gt;vertex_descriptor&lt;/code&gt; 型でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;boost::queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E + V) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(v, g)&lt;/code&gt; は、探索の開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、各頂点においてそれがキューから削除される時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、頂点が キューから削除された後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に加えて 辺が木の辺の場合に呼び出される。辺 &lt;code&gt;e&lt;/code&gt; の終点はこの時に発見される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、アルゴリズムが初めて頂点 &lt;code&gt;u&lt;/code&gt; を通った時に呼び出される。始点に近い全ての頂点が発見されており、始点から遠方に離れた頂点はまだ発見されていない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に加えて辺が tree edge でない場合に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が灰色に色づけされている場合に呼び出される。灰色は頂点が現在 キュー中にある印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が黒色に色づけされている場合に呼び出される。黒色は頂点がもはやキュー中にはない印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、 &lt;code&gt;u&lt;/code&gt; の全ての出辺が調べられ、全ての隣接頂点が発見された後で呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs-example.cpp.html&#34;&gt;examples/bfs-example.cpp&lt;/a&gt; 中にある例は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34;&gt;Figure 6&lt;/a&gt; のグラフにおいて BGL 幅優先探索アルゴリズムを用いて実演している。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs-example2.cpp.html&#34;&gt;examples/bfs-example2.cpp&lt;/a&gt; のファイルは同じ例を含むが、使われている &lt;code&gt;adacency_list&lt;/code&gt; クラスは &lt;code&gt;VertexList&lt;/code&gt; を持っており、&lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;listS&lt;/code&gt; に置かれている。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>breadth_first_visit -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/breadth_first_visit.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;breadth_first_visit&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_visit(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_visit
  (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; vis, ColorMap color)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数はカラー・マーカーがアルゴリズム中で初期化されないことを除けば、基本的に &lt;code&gt;breadth_first_search()&lt;/code&gt; と同じである。 ユーザはアルゴリズムを呼ぶ前に全ての頂点の色が白色であることを確かめる責任がある。この違いでグラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; である代わりに &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; であることのみが要求される。 さらにこの違いはカラー・プロパティ・マップ中のより多くの柔軟性を考慮に入れている。例えば頂点上の部分的な関数を実装するだけのマップを使うことができる。そしてそれは探索がグラフのごく一部にしか及ばない場合、より良い空間効率であることができる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; コンセプトで指定されたイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならなく、そのキー型はグラフの頂点記述子型でなければならなく、カラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_color, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;buffer(Buffer&amp;amp; Q)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点が発見される順序を決定するために使用されるキュー。 もしFIFO キューが使われると、巡回は通常の BFS 順序付けに従う。 他の型のキューも使用できるが、巡回順序は異なる。 例えば Dijkstra のアルゴリズムは優先度付きキューを用いて実装することができる。 &lt;code&gt;Buffer&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt; のモデルでなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;boost::queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(v, g)&lt;/code&gt; は、探索の開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、各頂点においてそれがキューから削除される時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、 頂点がキューから削除された後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt;に加えて辺が木の辺の場合に呼び出される。辺 &lt;code&gt;e&lt;/code&gt; の終点はこの時に発見される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、アルゴリズムが初めて頂点 &lt;code&gt;u&lt;/code&gt; に通った時に呼び出される。始点に近い全ての頂点が発見されており、始点から遠方に離れた頂点はまだ発見されていない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に 加えて辺が木の辺でない場合に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が灰色に色づけされている場合に呼び出される。 灰色は頂点が現在キュー中にある印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が黒色に色づけされている場合に呼び出される。 黒色は頂点がもはやキュー中にはない印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、 &lt;code&gt;u&lt;/code&gt; の全ての出辺が調べられ、全ての隣接頂点が発見された後で呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>connected_components -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/connected_components.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/connected_components.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;connected_components&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ComponentMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ComponentMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
connected_components(VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, ComponentMap comp,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この関数の名前なしパラメータバージョンは存在しない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;connected_components()&lt;/code&gt; 関数は、無向グラフの連結成分を DFS に基づく方法を用いて計算する。無向グラフの連結成分はすべての互いに到達可能な頂点の集合である。もしグラフが増大する間、連結成分を保持する必要があるなら、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.html&#34;&gt;&lt;code&gt;incremental_components()&lt;/code&gt;&lt;/a&gt; 関数の素集合に基づく方法の方が速い。「静的な」グラフには この DFS に基づく方法の方が速い &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;[8]&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;このアルゴリズムの出力は成分プロパティ・マップ &lt;code&gt;comp&lt;/code&gt; に記録され、そしてそれは各頂点に割り当てられた成分番号を与える数を含んでいる。 全成分数が関数の返却値である。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/connected_components.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const Graph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; かつ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;ComponentMap c&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このアルゴリズムはグラフ中にある連結成分数を計算し、各成分に整数のラベルを割り当てる。このアルゴリズムはそれから成分プロパティ・マップ中の成分番号を記録することによってグラフ中の各頂点がどの成分に属しているかを登録する。&lt;code&gt;ComponentMap&lt;/code&gt; 型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/[WritablePropertyMap.html&#34;&gt;Writable Property Map&lt;/a&gt; のモデルでなければならない。値型は汎整数型であるべきで、できればグラフの &lt;code&gt;vertices_size_type&lt;/code&gt; に等しい方が望ましい。キー型はグラフの頂点記述子型でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付き引数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフの進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; 型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。 このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。 &lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。 グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;連結成分のアルゴリズムの時間計算量もまた O(V + E) である。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/strong_components.html&#34;&gt;&lt;code&gt;strong_components()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.html&#34;&gt;&lt;code&gt;incremental_components()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;ファイル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/connected_components.cpp.html&#34;&gt;examples/connected_components.cpp&lt;/a&gt; は無向グラフの連結成分を計算する例を含む。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BGLでグラフアルゴリズムを構築する -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/constructing_algorithms.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/constructing_algorithms.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;BGLでグラフアルゴリズムを構築する&lt;/h1&gt;
&lt;p&gt;BGLの主な目標は、精密なグラフ・クラスを提供することにあるのではなく、また再利用可能なグラフ・アルゴリズムの広範囲にわたる集合を提供することにあるのでもない (それらは目標であるにもかかわらず)。BGLの主な目標は、他者に再利用可能なグラフのアルゴリズムを書くよう奨励することである。再利用可能とは最大限に再利用可能であることを意味する。ジェネリックプログラミングはアルゴリズムを最大限に再利用可能にする手法であり、この章でジェネリックプログラミングをいかにグラフ・アルゴリズムを構築するのに応用するかについて論ずるつもりである。&lt;/p&gt;
&lt;p&gt;ジェネリックプログラミングの過程を説明するために、グラフの着色アルゴリズムの構築を歩み抜けてみようと思う。グラフの着色問題 (またはもっと具体的に頂点着色問題) はグラフ &lt;code&gt;G&lt;/code&gt; 中の各頂点を、同じ色で彩られた隣接した二つの頂点がないように、そして最小の色数が使われるようにすることである。一般的に、グラフの着色問題はNP完全問題で、それゆえ適度な量の時間で最適解を見つけるのは不可能である。しかしながら、最小に近い着色を見つけるために発見的手法を使う多くのアルゴリズムが存在する。&lt;/p&gt;
&lt;p&gt;ここで示す今問題にするアルゴリズムは疎なヤコビ行列とヘッセン行列の消去法 [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#curtis74:_jacob&#34;&gt;9&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman84:_estim_jacob&#34;&gt;7&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman85:_algor&#34;&gt;6&lt;/a&gt;] 中で用いられている 線形時間の SEQ サブルーチンに基づいている。このアルゴリズムはグラフ中の全ての頂点を入力された順序によって定義される順番に従って訪れる。各頂点において、アルゴリズムは隣接頂点の色を印付け、それから現時点の頂点の色のために最小のまだ印付けられていない色を選ぶ。もし全ての色がすでに印付けられていたら、新しい色が作成される。色の印番号が現在の頂点番号に等しいなら、色は印付けられているとみなされる。これは各頂点のために印を置き直さねばならない厄介ごとから守る。このアルゴリズムの有効性は入力された頂点の順番に大きく依存する。最大先頭 (largest-first) 順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#welsch67&#34;&gt;[31]&lt;/a&gt;、 最小後尾 (smallest-last) 順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#matula72:_graph_theory_computing&#34;&gt;[29]&lt;/a&gt;、そして接続次数 (incidence degree) による順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#brelaz79:_new&#34;&gt;[32]&lt;/a&gt; を含むいくつかの順序付けアルゴリズムが存在し、そしてそれらはこの着色アルゴリズムの有効性を改善する。&lt;/p&gt;
&lt;p&gt;汎用グラフ・アルゴリズムを構築する際にする最初の決定は、どのグラフ操作がアルゴリズムの実装のために必要か決定すること、そしてその操作にどのグラフ・コンセプトを結びつけるか決定することである。このアルゴリズム中で頂点の色を初期化するために全ての頂点を通して巡回する必要があるだろう。さらに隣接頂点もアクセスする必要がある。それゆえ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; コンセプトを選択するつもりである。というのは、これらの操作を含む最小の概念であるからである。グラフの型はこのアルゴリズムのためにテンプレート関数中で引数が決められるだろう。グラフの型を BGL &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; のような特定のグラフ・クラスには限定しない。なぜかというとこれはアルゴリズムの再利用可能性を著しく制限するだろうからである (今まで書かれたほとんどのアルゴリズムはそうであるが)。グラフの型を &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; をモデルとする型にぜひ限定しよう。これはアルゴリズム中のそれらのグラフ操作の使用によって、その上 &lt;code&gt;function_requires()&lt;/code&gt; とともにコンセプト・チェックとして付け加えられた明示的な要求として強いられる (コンセプト・チェックについてのさらなる詳細のために章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;Concept Checking&lt;/a&gt; を見なさい)。&lt;/p&gt;
&lt;p&gt;次に、このプログラム中でどの頂点プロパティまたは辺プロパティが使われるであろうかについて考える必要がある。この場合、唯一のプロパティは頂点の色である。頂点の色へのアクセスを指定する最も融通のきく方法はプロパティ・マップのインターフェースを使うことである。これはアルゴリズムの使用者にどのようにプロパティを格納したいかを決定する能力を与える。色の読み書き両方が必要であろうから、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;ReadWritePropertyMap&lt;/a&gt; としての要求を指定する。カラー・マップの &lt;code&gt;key_type&lt;/code&gt; はグラフからの &lt;code&gt;vertex_descriptor&lt;/code&gt; でなければならず、&lt;code&gt;value_type&lt;/code&gt; は 整数の種類でなければならない。さらに &lt;code&gt;order&lt;/code&gt; 引数のためのインターフェースをプロパティ・マップとして指定する。この場合 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;ReadablePropertyMap&lt;/a&gt; である。順序付けのために、&lt;code&gt;key_type&lt;/code&gt; は整数のオフセットで、 &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;vertex_descriptor&lt;/code&gt; である。再びコンセプト・チェックとともにこれらの要求を適用する。このアルゴリズムの返却値はグラフを着色するのに必要な色の数で、従って関数の返却値型はグラフの &lt;code&gt;vertices_size_type&lt;/code&gt; である。次のコードはテンプレート関数としてのグラフのアルゴリズムのためのインターフェース、コンセプト・チェック、そしていくつかの &lt;code&gt;typedef&lt;/code&gt; を示す。実装は容易であり、上述で論ぜられていない唯一の段階は色の初期化段階で、そしてそこで全ての頂点の色を「着色されてない」状態にする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Order&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Color&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
  sequential_vertex_color_ting(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
    Order order, Color color)
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; GraphTraits;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertex_descriptor vertex_descriptor;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertices_size_type size_type;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Color&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type ColorType;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Order&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type OrderType;

    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; VertexListGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ReadWritePropertyMapConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Color, vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IntegerConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ColorType&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; size_type, ReadablePropertyMapConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Order&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; same_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;OrderType, vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type req_same;

    size_type max_color &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; size_type V &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_vertices(G);
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;size_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
      mark(V, numeric_limits_max(max_color));

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertex_iterator v, vend;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(v, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); v &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;v)
      color[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;v] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; V &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// which means &#34;not colored&#34;&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; V; i&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;) {
      vertex_descriptor current &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; order[i];

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 隣接頂点の全ての色を印付ける&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;adjacency_iterator ai, aend;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(ai, aend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(current, G); ai &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; aend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ai)
        mark[color[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ai]] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i; 

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 隣接頂点によって使われていない最小の色を見つける&lt;/span&gt;
      size_type smallest_color &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; (smallest_color &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; max_color &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mark[smallest_color] &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; i) 
        &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;smallest_color;

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// もし全ての色を使い切ったら、色の数を増やす&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (smallest_color &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; max_color)
        &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;max_color;

      color[current] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; smallest_color;
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; max_color;
  }
} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// namespace boost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_graph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/copy_graph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/copy_graph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;copy_graph&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; copy_graph(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G_copy,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数はグラフ &lt;code&gt;G&lt;/code&gt; から &lt;code&gt;G_copy&lt;/code&gt; へとすべての頂点と辺をコピーする。また、頂点と辺のプロパティも、 &lt;code&gt;vertex_all&lt;/code&gt; と &lt;code&gt;edge_all&lt;/code&gt; プロパティマップを用いるか、あるいはユーザが与えたコピー関数を用いてコピーする。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/copy.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; G&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向または無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; モデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;MutableGraph&amp;amp; G_copy&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフのコピー結果。 グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;Mutable Graph&lt;/a&gt; モデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_copy(VertexCopier vc)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは オリジナルのグラフの頂点のプロパティをコピーの対応する頂点にコピーする &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;vertex_copier&amp;lt;VertexListGraph, MutableGraph&amp;gt;&lt;/code&gt; これはグラフからプロパティマップにアクセスするためにプロパティタグ &lt;code&gt;vertex_all&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;edge_copy(EdgeCopier ec)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは オリジナルのグラフの辺のプロパティをコピーの対応する辺にコピーする &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;edge_copier&amp;lt;VertexListGraph, MutableGraph&amp;gt;&lt;/code&gt; これはグラフからプロパティマップにアクセスするためにプロパティタグ &lt;code&gt;edge_all&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点添え字マップの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; モデルでなければならず、また &lt;code&gt;G&lt;/code&gt; の頂点デスクリプタを &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;num_vertices(G)&lt;/code&gt; までの整数にマップしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, G)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;orig_to_copy(Orig2CopyMap c)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはオリジナルのグラフの頂点をコピーの頂点にマップする。&lt;/li&gt;
&lt;li&gt;デフォルト: 出力グラフの頂点デスクリプタ型のサイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から 作られる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、 添え字マップのために &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(V + E) 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cuthill_mckee_ordering -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/cuthill_mckee_ordering.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/cuthill_mckee_ordering.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;cuthill_mckee_ordering&lt;/h1&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;構成要素&lt;/th&gt;
&lt;th&gt;値&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;グラフ&lt;/td&gt;
&lt;td&gt;無向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;プロパティ&lt;/td&gt;
&lt;td&gt;色、次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;計算量&lt;/td&gt;
&lt;td&gt;`time: O(log(m)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;IncidenceGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;OutputIterator&lt;/span&gt;,
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DegreeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; 
cuthill_mckee_ordering(IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
                       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
                       OutputIterator inverse_permutation, 
                       ColorMap color, DegreeMap degree)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;OutputIterator&lt;/span&gt;, 
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DegreeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; 
cuthill_mckee_ordering(VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, OutputIterator inverse_permutation, 
                       ColorMap color, DegreeMap degree)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Cuthill-Mckee(と逆Cuthill-Mckee)順序アルゴリズム[&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george81:__sparse_pos_def&#34;&gt;14&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#cuthill69:reducing_bandwith&#34;&gt;43&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#liu75:anal_cm_rcm&#34;&gt;44&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george71:fem&#34;&gt;45&lt;/a&gt;]の目的は、各頂点に割り当てられている添え字を再順序付けすることによって、グラフの&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;帯域幅&lt;/a&gt;を減らすことである。Cuthill-Mckee の順序付けアルゴリズムは、 i 番目の帯域幅の局所最小化によって動作する。頂点は基本的に幅優先探索順に割り当てられる。ただし各段階において、隣接頂点がキュー中に次数の昇順で並べられることを除く。&lt;/p&gt;
&lt;p&gt;このアルゴリズムのバージョン (1) がユーザに「始点」を選ばせるのに対し、 バージョン (2) は疑似周辺ペアの発見的手法を用いて良好な始点を見つける。「始点」の選択は順序付けの品質上、重要な影響を持つ傾向がある。&lt;/p&gt;
&lt;p&gt;このアルゴリズムの出力は、新しい順序付けになっている頂点である。使用した出力イテレータの種類に依存して、Cuthill-Mckee の順序付け、または逆 Cuthill-Mckee の順序付けのどちらか一方を得られる。例えば、出力を &lt;code&gt;vector&lt;/code&gt; のリバース・イテレータを用いて &lt;code&gt;vector&lt;/code&gt; に格納すれば、逆 Cuthill-Mckee 順序付けを得る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; inv_perm(num_vertices(G));
cuthill_mckee_ordering(G, inv_perm.rbegin());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;どちらの方法でも、出力を &lt;code&gt;vector&lt;/code&gt; に格納することは、新しい順序付けから古い順序付けへの順列を与える。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;inv_perm[new_index[u]] &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; u
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;多くの場合、ほしい順列は逆の順列、つまり古い添え字から新しい添え字への順列である。これは次の方法で簡単に計算され得る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; inv_perm.size(); &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
  perm[old_index[inv_perm[i]]] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;バージョン (1) 用:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vertex_descriptor s&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OutputIterator inverse_permutation&lt;/code&gt;  (OUT) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しい頂点の順序付け。頂点は新しい順序で &lt;a href=&#34;http://www.sgi.com/tech/stl/OutputIterator.html&#34; target=&#34;_blank&#34;&gt;output iterator&lt;/a&gt; に書かれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ColorMap color_map&lt;/code&gt;  (WORK) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部的にアルゴリズムの進行過程を保持するために使われる (同じ頂点を二回訪れるのを回避するために)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DegreeMap degree_map&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点を次数にマップしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バージョン (2) 用&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OutputIterator inverse_permutation&lt;/code&gt;  (OUT) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しい頂点の順序付け。頂点は新しい順序で出力イテレータに書かれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ColorMap color_map&lt;/code&gt;  (WORK) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部的にアルゴリズムの進行過程を保持するために使われる (同じ頂点を二回訪れるのを回避するために)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DegreeMap degree_map&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点を次数にマップしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/cuthill_mckee_ordering.cpp.html&#34;&gt;examples/cuthill_mckee_ordering.cpp&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;bandwidth&lt;/code&gt;&lt;/a&gt;、それと boost/graph/properties.hpp 中の &lt;code&gt;degree_property_map&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dag_shortest_paths -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/dag_shortest_paths.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;dag_shortest_paths&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Param&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Tag&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Rest&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dag_shortest_paths(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Param,Tag,Rest&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DijkstraVisitor&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistanceMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;WeightMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredecessorMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Compare&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Combine&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistInf&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistZero&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dag_shortest_paths(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   DistanceMap distance, WeightMap weight, ColorMap color,
   PredecessorMap pred, DijkstraVisitor vis, 
   Compare compare, Combine combine, DistInf inf, DistZero zero)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズム &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;[8]&lt;/a&gt; は 重み付きの非循環有向グラフ (DAG) の単一始点の最短経路問題を解く。 このアルゴリズムは DAG にとって、Dijkstra や Bellman-Ford アルゴリズムより 一層効率的である。全ての辺の重みが 1 に等しい時はこのアルゴリズムの代わりに幅優先探索を使いなさい。最短経路問題の定義のために、最短経路問題のいくつかの背景についての章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-path-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dag_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。&lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・マップを提供するならばグラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう。さらに最短経路木を先行点マップ (predecessor map) に記録する事ができる。その場合 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点であるかまたは始点からは到達不能な頂点である場合を除く)。これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間アクションをとれる独自のビジタを提供することができる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dag_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムが適用されるグラフオブジェクト。&lt;code&gt;VertexListGraph&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。全ての距離はこの頂点から計算され、最短経路木はこの頂点を根とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重みまたは「長さ」。&lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。グラフの辺記述子型は重みマップのキー型として使用できる必要がある。マップの値型は距離マップの値型を伴った Addable でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。これは辺がリラックスされた (減らされた) 時、ヒープ・データ構造を効率よく更新するのに必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;distance_map(DistanceMap d_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点 &lt;code&gt;s&lt;/code&gt; から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。最短経路の重みは、最短経路に沿った辺の重みの和である。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。グラフの頂点記述子型は距離マップのキー型として使用できる必要がある。距離マップの値型は &lt;code&gt;combine&lt;/code&gt; 関数 オブジェクトと単位要素のための &lt;code&gt;zero&lt;/code&gt; オブジェクトから作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; の要素型である。さらに距離の値型は &lt;code&gt;compare&lt;/code&gt; 関数オブジェクトによって供給される &lt;a href=&#34;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&#34; target=&#34;_blank&#34;&gt;StrictWeakOrdering&lt;/a&gt; の順序付けを持っていなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;WeightMap&lt;/code&gt; の値型の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(CompareFunction cmp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数はどの頂点が始点により近いか決定するために距離を比較するのに使われる。 &lt;code&gt;CompareFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Predicate&lt;/a&gt; のモデルでなければならず、&lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致する引数型を持たなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(CombineFunction cmb)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数は道の距離を計算するために、距離を結合するのに使われる。 &lt;code&gt;CombineFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; のモデルでなければならない。二項関数の第一引数の型は &lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならず、第二引数の型は &lt;code&gt;WeightMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならない。結果型は距離の値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_inf(D inf)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inf&lt;/code&gt; オブジェクトは &lt;code&gt;D&lt;/code&gt; オブジェクトのどの値よりも最も大きくなければならない。すなわち、&lt;code&gt;d != inf&lt;/code&gt; の場合どれでも &lt;code&gt;compare(d, inf) == true&lt;/code&gt; でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::numeric_limits&amp;lt;D&amp;gt;::max()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_zero(D zero)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zero&lt;/code&gt; の値は距離の値と &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトによって作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; のための単一要素でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;D()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap c_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点に印をつけるためにアルゴリズムの実行の間使われる。頂点は白色から始めて、それがキュー中に挿入された時に灰色になる。それからそれがキューから取り除かれた時に黒色になる。アルゴリズムの終了時に、始点から到達可能な頂点は黒色に色づけされている。その他の全ての頂点は白色のままである。&lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。頂点記述子はマップのキー型として使用できる必要があり、マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; のモデルでなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;visitor(DijkstraVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズム内の一定のイベント・ポイントの間に起こしたいアクションを指定するのに使いなさい。&lt;code&gt;DijkstraVisitor&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt; コンセプトのモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dijkstra_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(V + E) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt; は、アルゴリズムの開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた時に呼び出される。この時点で &lt;code&gt;(p[u],u)&lt;/code&gt; は最短経路木の辺であることがわかるので、 &lt;code&gt;d[u] = delta(s,u) = d[p[u]] + w(p[u],u)&lt;/code&gt; である。さらに調査された頂点の距離は単調増加 &lt;code&gt;d[u1] &amp;lt;= d[u2] &amp;lt;= d[un]&lt;/code&gt; である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、頂点の各出辺において、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は、辺 &lt;code&gt;(u,v)&lt;/code&gt; において、 もし &lt;code&gt;d[u] + w(u,v) &amp;lt; d[v]&lt;/code&gt; であるなら呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(v, g)&lt;/code&gt; は、頂点 &lt;code&gt;v&lt;/code&gt; において、 &lt;code&gt;(u,v)&lt;/code&gt; が調査されて &lt;code&gt;v&lt;/code&gt; が白色である時に呼び出される。頂点が発見されていれば灰色に色づけされており、各到達可能な頂点はきっかり一度発見されるからである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし辺がリラックスされない (上を見よ) なら呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、頂点の出辺が全て調査された後に呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dag_shortest_paths.cpp.html&#34;&gt;examples/dag_shortest_paths.cpp&lt;/a&gt; を見よ。これはこのアルゴリズムの使用例である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われず ビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>depth_first_search -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/depth_first_search.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;depth_first_search&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;class&lt;/span&gt; P, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; vis, ColorMap color)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; vis, ColorMap color, 
                        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor start)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;depth_first_search()&lt;/code&gt; 関数は、有向グラフ中の頂点の深さ優先巡回(depth-first traversal)を行う。可能な時は、深さ優先巡回は次に訪れるために現在の頂点の隣接頂点を選ぶ。もし全ての隣接頂点がすでに発見されているならば、もしくは隣接頂点が存在しないならば、アルゴリズムは未発見の隣接を持つ前の頂点へとバックトラックする。一旦全ての到達可能な頂点が訪問されたら、アルゴリズムは残っている未発見の頂点のどれかを選び出し、巡回を続ける。このアルゴリズムは全ての頂点が訪問された時に終了する。深さ優先探索はグラフ中の辺を分類するのと、頂点を順序づけるのに役立つ。章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;Depth-First Search&lt;/a&gt; は DFS の様々な特性を記述し、適当に例をあげている。&lt;/p&gt;
&lt;p&gt;BFS に似て、頂点が発見された過程を保持するためにカラー・マーカーが使われる。白色はまだ発見されていない頂点を印づけ、灰色は発見されたけれどもまだ未発見の隣接している頂点を持つ頂点を印づける。黒い頂点はどの白い頂点にも隣接していない発見された頂点である。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;depth_first_search()&lt;/code&gt; 関数は、アルゴリズムの内部で一定のイベント・ポイントにおいて、ユーザ定義のアクションを呼び出す。これは一般的な DFS アルゴリズムが使用できる多くの状況に適用させるための機構を提供する。下の疑似コード中で、 DFS のためのイベント・ポイントは三角形と右側のラベルで示されている。ユーザ定義のアクションはビジタ・オブジェクトの形で提供されなければならない。すなわち、型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; の要求を満たしているオブジェクトである。擬似コード中では、先行点を計算するアルゴリズムを &lt;code&gt;p&lt;/code&gt;、発見時間を &lt;code&gt;d&lt;/code&gt;、そして終了時間を &lt;code&gt;t&lt;/code&gt; と表す。デフォルトでは、&lt;code&gt;depth_first_search()&lt;/code&gt; 関数はこれらのプロパティを計算しない。しかしながら、これを実行するのに使える &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; のような、あらかじめ定義されたビジタが存在する。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;DFS(G)
  for each vertex u in V 
    color[u] := WHITE              頂点 u の初期化
    p[u] = u 
  end for
  time := 0
  if there is a starting vertex s
    call DFS-VISIT(G, s)           頂点 s の開始
  for each vertex u in V 
    if color[u] = WHITE
      call DFS-VISIT(G, u)         頂点 u の開始
  end for
  return (p,d_time,f_time) 

DFS-VISIT(G, u) 
  color[u] := GRAY                 頂点 u の発見
  d_time[u] := time := time + 1 
  for each v in Adj[u]             辺 (u,v) の調査
    if (color[v] = WHITE)
      p[v] = u                     (u,v) は木の辺
      call DFS-VISIT(G, v)
    else if (color[v] = GRAY) 
      ...                          (u,v) は後退辺
    else if (color[v] = BLACK) 
      ...                          (u,v) は交差辺または前方辺
  end for
  color[u] := BLACK                頂点 u の終了
  f_time[u] := time := time + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IN: &lt;code&gt;Graph&amp;amp; g&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;有向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(DFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; コンセプトで指定されるイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;root_vertex(typename graph_traits&amp;lt;VertexListGraph&amp;gt;::vertex_descriptor start)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは深さ優先探索が開始されるべき頂点を指定する。型は与えられたグラフの頂点記述子型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;*vertices(g).first&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E + V) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt; は、グラフの探索の開始前にグラフの各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.start_vertex(s, g)&lt;/code&gt; は、探索の開始前に始点において一度呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、初めて頂点に通った時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、それが発見された後に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、各辺において、それが探索木を構成する辺のメンバになった時に呼び出される。もし先行点の記録を望むなら、このイベント・ポイントで行いなさい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.back_edge(e, g)&lt;/code&gt; は、グラフ中の後退辺において呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.forward_or_cross_edge(e, g)&lt;/code&gt; は、グラフ中の前方辺または交差辺において呼び出される。無向グラフ中ではこのメソッドは決して呼ばれない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、出辺の全てが探索木に追加され、全ての隣接頂点が発見された (ただし、それらの出辺が調査される前に) 後の頂点において呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dfs-example.cpp.html&#34;&gt;examples/dfs-example.cpp&lt;/a&gt; 中の例は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;Figure 1&lt;/a&gt; にあるグラフへ適用された DFS を示す。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html&#34;&gt;&lt;code&gt;depth_first_visit&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/undirected_dfs.html&#34;&gt;&lt;code&gt;undirected_dfs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>depth_first_visit -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/depth_first_visit.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;depth_first_visit&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_visit(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; vis, ColorMap color)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph/doc/graph_theory_review.html#dfs-algorithm&#34;&gt;depth-firstパターン&lt;/a&gt; を使って、始点 &lt;code&gt;s&lt;/code&gt; と同じ連結成分中にある全ての頂点を訪れる。時々単独で有用ではあるが、この関数の主な目的は &lt;code&gt;depth_first_search()&lt;/code&gt; の実装のためにある。&lt;/p&gt;
&lt;p&gt;ユーザによって提供される &lt;code&gt;DFSVisitor&lt;/code&gt; はアルゴリズムの内側の各イベント・ポイントで行われるアクションを決定する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ColorMap&lt;/code&gt; は訪れられた頂点の過程を保持するためにアルゴリズムによって使われる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN &lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;DFSVisitor visitor&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; コンセプトで指定されるイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;ColorMap color&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E) である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたは リファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dfs_visitor&lt;EventVisitorList&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/dfs_visitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;dfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;例は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた EventVisitor のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは DFSVisitor に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが &lt;code&gt;EventVisitorList&lt;/code&gt; の中の EventVisitor にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_dfs_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを DFS ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dijkstra_shortest_paths -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/dijkstra_shortest_paths.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;dijkstra_shortest_paths&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; P, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
dijkstra_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前なしパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; PredecessorMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistanceMap,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; WeightMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; IndexMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Compare&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Combine&lt;/a&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistInf, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistZero&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dijkstra_shortest_paths
  (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   PredecessorMap predecessor, DistanceMap distance, WeightMap weight, 
   IndexMap index_map,
   &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Compare&lt;/a&gt; compare, &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Combine&lt;/a&gt; combine, DistInf inf, DistZero zero,
   &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; vis)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#dijkstra59&#34;&gt;10&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;8&lt;/a&gt;] は、全ての辺の重みが負でない場合の、重みづけされた有向グラフまたは無向グラフの単一始点の最短経路問題を解く。いくつかの辺の重みが負である場合は Bellman-Ford のアルゴリズムを使いなさい。全ての辺の重みが 1 に等しい時は Dijkstra のアルゴリズムの代わりに幅優先探索を使いなさい。最短経路問題の定義のために、最短経路問題のいくつかの背景 についての章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-path-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。&lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・ マップを提供するならば、グラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう。さらに最短経路木を先行点マップ (predecessor map) に記録することができる。その場合 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点であるかまたは始点からは到達不能な頂点である場合を除く)。 これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間アクションを取れる独自のビジタを提供することができる。&lt;/p&gt;
&lt;p&gt;Dijkstra のアルゴリズムは最短経路を知っている頂点集合 &lt;code&gt;S&lt;/code&gt; を反復的に「育てる」ことによって、始点から他の頂点への全ての最短経路を発見する。アルゴリズムの各段階で、&lt;code&gt;S&lt;/code&gt; に追加される次の頂点は優先度付きキューによって決定される。キューは、距離ラベルによって優先された &lt;code&gt;V - S&lt;/code&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt; 中に頂点を含む。そして距離ラベルとはいまの所見られる各頂点への最短経路の長さである。それから優先度付きキューの先頭にある頂点 &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;S&lt;/code&gt; に加えられ、その各先行辺はリラックス (距離が減らされる) される。つまり、もし &lt;code&gt;u&lt;/code&gt; への距離に出辺 &lt;code&gt;(u,v)&lt;/code&gt; の重みを加えた結果が &lt;code&gt;v&lt;/code&gt; の 距離ラベルより小さいなら、頂点 &lt;code&gt;v&lt;/code&gt; の評価された距離は減らされる。 それからアルゴリズムは元に戻り、優先度付きキューの先頭の次の頂点の処理をする。優先度付きキューが空になった時にアルゴリズムは終了する。&lt;/p&gt;
&lt;p&gt;アルゴリズムは各頂点がどの集合中にあるかの過程を保持するためにカラー・マーカー (白色、灰色、そして黒色) を使う。黒色に色づけされた頂点は &lt;code&gt;S&lt;/code&gt; 中にある。 白色または灰色に色づけされた頂点は &lt;code&gt;V-S&lt;/code&gt; 中にある。白色の頂点はまだ発見されていず、灰色の頂点は優先度付きキュー中にある。デフォルトでは、グラフ中の各頂点のためのカラー・マーカーを格納するための配列を割り当てる。&lt;code&gt;color_map()&lt;/code&gt; パラメータによって独自の記憶域と色へのアクセスを提供することができる。&lt;/p&gt;
&lt;p&gt;下記の擬似コードは Dijkstra の単一始点の最短経路アルゴリズムである。 &lt;code&gt;w&lt;/code&gt; は辺の重み、&lt;code&gt;d&lt;/code&gt; は距離ラベル、そして &lt;code&gt;p&lt;/code&gt; は最短経路木を符号化するのに使われる各頂点の先行点である。&lt;code&gt;Q&lt;/code&gt; は減少キー操作 (DECREASE-KEY operation) を備える優先度付きキューである。ビジタのイベント・ポイントは右側のラベルによって示されている。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;DIJKSTRA(G, s, w)
  for each vertex u in V           頂点 u の初期化
    d[u] := infinity 
    p[u] := u 
    color[u] := WHITE
  end for
  color[s] := GRAY 
  d[s] := 0 
  INSERT(Q, s)                     頂点 s の発見
  while (Q != Ø)
    u := EXTRACT-MIN(Q)            頂点 u の調査
    S := S U { u }
    for each vertex v in Adj[u]    辺 (u,v) の調査
      if (w(u,v) + d[u] &amp;lt; d[v])
        d[v] := w(u,v) + d[u]      辺 (u,v) はリラックスされた (減らされた)
        p[v] := u 
        if (color[v] = WHITE) 
          color[v] := GRAY
          INSERT(Q, v)             頂点 v の発見
        else if (color[v] = GRAY)
          DECREASE-KEY(Q, v)
      else
        ...                        辺 (u,v) はリラックスされない (減らされない)
    end for
    color[u] := BLACK              頂点 u の終了
  end while
  return (d, p)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dijkstra_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムが適用されるグラフオブジェクト。&lt;code&gt;VertexListGraph&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。全ての距離はこの頂点から計算される。そして最短経路木はこの頂点を根とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重みまたは「長さ」。重みは全て非負でなければならず、辺の一つが負であればアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/exception.html#negative_edge&#34;&gt;&lt;code&gt;negative_edge&lt;/code&gt;&lt;/a&gt; 例外を投げる。&lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。グラフの辺記述子型は重みマップのキー型として使用できる必要がある。このマップの値型は距離マップの値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。これは辺がリラックスされた (減らされた) 時、ヒープ・データ構造を効率よく更新するのに必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;distance_map(DistanceMap d_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点 &lt;code&gt;s&lt;/code&gt; から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。最短経路の重みは、最短経路に沿った辺の重みの和である。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。グラフの頂点記述子型は距離マップのキー型として使用できる必要がある。距離マップの値型は &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトと単位要素のための &lt;code&gt;zero&lt;/code&gt; オブジェクトから作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; の要素型である。さらに距離の値型は &lt;code&gt;compare&lt;/code&gt; 関数オブジェクトによって提供される &lt;a href=&#34;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&#34; target=&#34;_blank&#34;&gt;StrictWeakOrdering&lt;/a&gt; の順序付けを持っていなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;WeightMap&lt;/code&gt; の値型の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(CompareFunction cmp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数はどの頂点が始点により近いか決定するために距離を比較するのに使われる。&lt;code&gt;CompareFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Predicate&lt;/a&gt; のモデルでなければならず、&lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・ マップの値型に一致する引数型を持たなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(CombineFunction cmb)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数は道の距離を計算するために、距離を結合するのに使われる。 &lt;code&gt;CombineFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; のモデルでなければならない。二項関数の第一引数の型は &lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならず、 第二引数の型は &lt;code&gt;WeightMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならない。結果型は距離の値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_inf(D inf)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inf&lt;/code&gt; オブジェクトは &lt;code&gt;D&lt;/code&gt; オブジェクトのどの値よりも最も大きく なければならない。すなわち、&lt;code&gt;d != inf&lt;/code&gt; の場合どれでも &lt;code&gt;compare(d, inf) == true&lt;/code&gt; でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::numeric_limits&amp;lt;D&amp;gt;::max()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_zero(D zero)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zero&lt;/code&gt; の値は距離の値と &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトによって 作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; のための単一要素でなければならない。&lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;D()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap c_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点に印をつけるためにアルゴリズムの実行の間使われる。頂点は白色から始めて、それがキュー中に挿入された時に灰色になる。それからそれがキューから取り除かれた時に黒色になる。アルゴリズムの終了時に、始点から到達可能な頂点は黒色に色づけされている。その他の全ての頂点は白色のままである。&lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。頂点記述子はマップのキー型として使用できる必要があり、マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;visitor(DijkstraVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズム内の一定のイベント・ポイントの間に起こしたいアクションを指定するのに使いなさい。&lt;code&gt;DijkstraVisitor&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt; コンセプトのモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_2&#34;&gt;[2]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dijkstra_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O((V + E) log V) か、もし全ての頂点が始点から到達可能ならちょうど O(E log V) になる。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt; は、アルゴリズムの開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、頂点が優先度付きキューから取り除かれ、集合 &lt;code&gt;S&lt;/code&gt; に加えられた時に呼び出される。この時点で &lt;code&gt;(p[u],u)&lt;/code&gt; は最短経路木の辺であることが分かるので &lt;code&gt;d[u] = delta(s,u) = d[p[u]] + w(p[u],u)&lt;/code&gt; である。さらに、調査された頂点の距離は単調増加 &lt;code&gt;d[u1] &amp;lt;= d[u2] &amp;lt;= d[un]&lt;/code&gt; である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、頂点の各出辺において、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は、辺 &lt;code&gt;(u,v)&lt;/code&gt; において、もし &lt;code&gt;d[u] + w(u,v) &amp;lt; d[v]&lt;/code&gt; であるなら呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(v, g)&lt;/code&gt; は、頂点 &lt;code&gt;v&lt;/code&gt; において、&lt;code&gt;(u,v)&lt;/code&gt; が調査されて &lt;code&gt;v&lt;/code&gt; が白色である時に呼び出される。頂点が発見されていれば灰色に色づけされており、各到達可能な頂点はきっかり一度発見されるからである。これは頂点が優先度付きキューに挿入される時にも言える。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし辺がリラックスされない (上を見よ) なら呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、頂点の出辺が全て調査された後に呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ。これは Dijkstra のアルゴリズムの使用例である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ここで使われているアルゴリズムは全ての &lt;code&gt;V - S&lt;/code&gt; 頂点を一度に優先度付きキュー中に置かないことによって、わずかなスペースを節約している。その代わり、発見された &lt;code&gt;V - S&lt;/code&gt; 中のこれらの頂点だけであり、それゆえ無限より少ない距離を持っている。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_2&#34; name=&#34;note_2&#34;&gt;[2]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dijkstra_visitor&lt;EventVisitorList&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/dijkstra_visitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;dijkstra_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;以下は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dave.cpp.html&#34;&gt;examples/dave.cpp&lt;/a&gt; からの抜粋である。ここでは Dijkstra のアルゴリズムで計算された最短経路木のコピーを作るために、 &lt;code&gt;copy_graph&lt;/code&gt; という単独イベントビジタを使っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;dijkstra_shortest_paths
  (G, vertex(a, G), 
   distance_map(make_iterator_property_map(distance.begin(), vertex_id, distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;])).
   predecessor_map(make_iterator_property_map(parent.begin(), vertex_id, parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;])).
   visitor(make_dijkstra_visitor(copy_graph(G_copy, on_examine_edge()))));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた EventVisitor のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dijkstra_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが &lt;code&gt;EventVisitorList&lt;/code&gt; の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dijkstra_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_dijkstra_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを Dijkstra ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。 &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>distance_recorder&lt;DistanceMap, EventTag&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/distance_recorder.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;distance_recorder&amp;lt;DistanceMap, EventTag&amp;gt;&lt;/h1&gt;
&lt;p&gt;これは、グラフ探索中に、ある始点から各頂点までの距離を (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.html&#34;&gt;property map&lt;/a&gt; を使って) 記録する &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; である。辺 &lt;code&gt;e = (u,v)&lt;/code&gt; に対して実行されると、 &lt;code&gt;v&lt;/code&gt; への距離は &lt;code&gt;u&lt;/code&gt; への距離より大きくなる。 &lt;code&gt;distance_recorder&lt;/code&gt; は &lt;code&gt;on_tree_edge&lt;/code&gt; や &lt;code&gt;on_relax_edge&lt;/code&gt; イベントでよく使われる。頂点イベントには使用できない。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt; などのアルゴリズム別のアダプタでラップすることで、 &lt;code&gt;distance_recorder&lt;/code&gt; を グラフアルゴリズムで使えるようになる。また、&lt;code&gt;std::pair&lt;/code&gt; を使って他のイベントビジタと結合して、 EventVisitorList を作れる。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;例は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/visitors.hpp&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;キーの型と値の型がグラフの頂点記述子型である &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/WritablePropertyMap.html&#34;&gt;WritablePropertyMap&lt;/a&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html#translate_note_1&#34;&gt;[訳注1]&lt;/a&gt;。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventTag&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフアルゴリズム中、いつ &lt;code&gt;distance_recorder&lt;/code&gt; が呼び出されるかを指定するタグ。 &lt;code&gt;EventTag&lt;/code&gt; は辺イベントでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;distance_recorder::event_filter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータ &lt;code&gt;EventTag&lt;/code&gt; と同じ型。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;distance_recorder(DistanceMap pa);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;距離プロパティマップ &lt;code&gt;pa&lt;/code&gt; を使って &lt;code&gt;distance_recorder&lt;/code&gt; オブジェクトを構築する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Edge, class Graph&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void operator()(Edge e, const Graph&amp;amp; g);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺 &lt;code&gt;e = (u,v)&lt;/code&gt; を渡されると、 &lt;code&gt;u&lt;/code&gt; への距離に 1 を足したものを &lt;code&gt;v&lt;/code&gt; への距離として記録する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class DistanceMap, class Tag&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;distance_recorder&amp;lt;DistanceMap, Tag&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;record_distances(DistanceMap pa, Tag);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;distance_recorder&lt;/code&gt; を作る便利な方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2&gt;訳注&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html#translate_note_1&#34; name=&#34;translate_note_1&#34;&gt;[訳注1]&lt;/a&gt; 値の型は整数である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>edge_list&lt;EdgeIterator, ValueType, DiffType&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/edge_list.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;edge_list&amp;lt;EdgeIterator, ValueType, DiffType&amp;gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; クラスは辺イテレータのペアを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; をモデルとするクラスに変えるアダプタである。辺イテレータの &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;std::pair&lt;/code&gt; (もしくは少なくとも &lt;code&gt;first&lt;/code&gt; メンバと &lt;code&gt;second&lt;/code&gt; メンバを持っている) でなければならない。ペアの &lt;code&gt;first_type&lt;/code&gt; と &lt;code&gt;second_type&lt;/code&gt; は同じでなければならず、それらはグラフの &lt;code&gt;vertex_descriptor&lt;/code&gt; のために使われるだろう。 &lt;code&gt;ValueType&lt;/code&gt; と &lt;code&gt;DiffType&lt;/code&gt; のテンプレート・パラメータは、コンパイラが部分特殊化版をサポートしていない時にのみ必要である。そうでなければデフォルトは正しい型になる。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;Bellman-Ford の最短経路アルゴリズムを &lt;code&gt;edge_list&lt;/code&gt; に適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { u, v, x, y, z, N };
&lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; name[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;u&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;v&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;y&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;z&#39;&lt;/span&gt; };

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; E;
E edges[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { E(u,y), E(u,x), E(u,v),
              E(v,u),
              E(x,y), E(x,v),
              E(y,v), E(y,z),
              E(z,u), E(z,x) };

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; weight[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt; };

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; Graph;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(edges, edges &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;sizeof&lt;/span&gt;(edges) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;sizeof&lt;/span&gt;(E));

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(N, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;short&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;max());
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(N,&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;);

distance[z] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
parent[z] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; z;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), weight,
                                            distance.begin(),
                                            parent.begin());
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (r)  
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; N; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name[i] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; distance[i]
              &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name[parent[i]] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;negative cycle&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力は最短経路木中の根と各頂点の親からの距離になる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;u: 2 v
v: 4 x
x: 7 z
y: -2 u
z: 0 z
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/edge_list.hpp&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;value_type&lt;/code&gt; が頂点記述子のペアである &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;InputIterator&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ValueType&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt;。&lt;br /&gt; デフォルト: &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::value_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DiffType&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt; の &lt;code&gt;difference_type&lt;/code&gt;。&lt;br /&gt; デフォルト: &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::difference_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; に結びつけられた頂点記述子のための型。これは &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::value_type::first_type&lt;/code&gt; と同じ型であるだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; に結びつけられた辺記述子のための型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータのための型。&lt;code&gt;edge_iterator&lt;/code&gt; のイテレータの種類は &lt;code&gt;EdgeIterator&lt;/code&gt; のそれと同じであるだろう。&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edge_list(EdgeIterator first, EdgeIterator last) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;範囲 &lt;code&gt;[first,last)&lt;/code&gt; で与えられる辺リストで指定された &lt;code&gt;n&lt;/code&gt; 個の頂点と辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>edmunds_karp_max_flow -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/edmunds_karp_max_flow.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/edmunds_karp_max_flow.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;edmunds_karp_max_flow&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; detail&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;edge_capacity_value&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
edmunds_karp_max_flow(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor src,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor sink,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;CapacityEdgeMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ResidualCapacityEdgeMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ReverseEdgeMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredEdgeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;CapacityEdgeMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
edmunds_karp_max_flow(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor src,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor sink,
   CapacityEdgeMap cap, ResidualCapacityEdgeMap res, ReverseEdgeMap rev, 
   ColorMap color, PredEdgeMap pred)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edmunds_karp_max_flow()&lt;/code&gt; 関数はネットワークの最大流を計算する。最大流の記述のために章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#network-flow-algorithms&#34;&gt;Network Flow Algorithms&lt;/a&gt; を見なさい。計算された最大流が関数の返却値になるだろう。関数はさらに &lt;code&gt;E&lt;/code&gt; 中の全ての &lt;code&gt;(u,v)&lt;/code&gt; のために流量 &lt;code&gt;f(u,v)&lt;/code&gt; を計算する。そしてそれは、残差容量 &lt;code&gt;r(u,v) = c(u,v) - f(u,v)&lt;/code&gt; の形で返される。&lt;/p&gt;
&lt;p&gt;このアルゴリズムのために、入力グラフとプロパティ・マップのパラメータにいくつかの特別な必要条件がある。最初に、ネットワークを表す有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; は、 &lt;code&gt;E&lt;/code&gt; 中の各辺のための逆辺 (reverse edge) を含むために増やされなければならない。換言すれば、入力グラフは &lt;code&gt;G&lt;sub&gt;in&lt;/sub&gt; = (V,{E U ET})&lt;/code&gt; であるべきである。&lt;code&gt;ReverseEdgeMap&lt;/code&gt; 引数 &lt;code&gt;rev&lt;/code&gt; は元のグラフ中の各辺をその逆辺にマップしなければならない。すなわち &lt;code&gt;E&lt;/code&gt; 中の全ての &lt;code&gt;(u,v)&lt;/code&gt; に対して &lt;code&gt;(u,v) -&amp;gt; (v,u)&lt;/code&gt; である。&lt;code&gt;CapacityEdgeMap&lt;/code&gt; 引数 &lt;code&gt;cap&lt;/code&gt; は &lt;code&gt;E&lt;/code&gt; 中の各辺を正の数にマップしなければならず、&lt;code&gt;E&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; 中の各辺は &lt;code&gt;0&lt;/code&gt; にされなければならない。&lt;/p&gt;
&lt;p&gt;このアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#edmonds72:_improvements_netflow&#34;&gt;Edmonds and Karp&lt;/a&gt; に負っている。もっとも &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ahuja93:_network_flows&#34;&gt;Network Flows&lt;/a&gt; に述べられている「ラベリング・アルゴリズム」と呼ばれる亜種を使っているが。&lt;/p&gt;
&lt;p&gt;このアルゴリズムは、最大流問題を実装するための大変単純で容易な解答である。しかしながら、このアルゴリズムが &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/push_relabel_max_flow.html&#34;&gt;&lt;code&gt;push_relabel_max_flow()&lt;/code&gt;&lt;/a&gt; アルゴリズムほどには良くないいくつかの理由がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非整数の容量の場合、時間計算量は最疎グラフを除く全てのグラフにとって push-relabel アルゴリズムの O(V&lt;sup&gt;2&lt;/sup&gt;E&lt;sup&gt;1/2&lt;/sup&gt;) より悪い O(V E&lt;sup&gt;2&lt;/sup&gt;) である。&lt;/li&gt;
&lt;li&gt;整数の容量の場合、もし容量の範囲 &lt;code&gt;U&lt;/code&gt; が大変大きいならば、アルゴリズムに長い時間がかかるだろう。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/edmunds_karp_max_flow.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; のモデルでなければならない。グラフ中の各辺 &lt;code&gt;(u,v)&lt;/code&gt; のために、逆辺 &lt;code&gt;(v,u)&lt;/code&gt; もまたグラフ中になければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor src&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流れのネットワーク・グラフのためのソース頂点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor sink&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流れのネットワーク・グラフのためのシンク頂点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;capacity_map(CapacityEdgeMap cap)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;辺容量プロパティ・マップ。型は定数 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_capacity, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;residual_capacity_map(ResidualCapacityEdgeMap res)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは辺をその残差容量にマップする。型は変更可能の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_residual_capacity, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;reverse_edge_map(ReverseEdgeMap rev)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を逆辺 &lt;code&gt;(v,u)&lt;/code&gt; にマップする辺プロパティ・ マップ。マップは定数 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_reverse, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;幅優先探索の段階の間、進行過程を保持するためにアルゴリズムによって使われる。アルゴリズムの終了時に、白色の頂点は最小カット集合を定義する。マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの頂点記述子型であるべきで、値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;predecessor_map(PredEdgeMap pred)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;増大した道を格納するためにアルゴリズムによって使われる。マップは変更可能の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; でなければならない。キー型はグラフの頂点記述子型であるべきで、値型は グラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の 辺記述子の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフの各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において唯一の整数にマップしなさい。このプロパティ・マップはカラー・マップまたは先行点マップのためにデフォルトが使われた時にのみ必要である。頂点添え字マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの頂点記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は、通常の場合には O(V E&lt;sup&gt;2&lt;/sup&gt;) で、もしくは容量値が 定数 &lt;code&gt;U&lt;/code&gt; で範囲づけられた整数であるならば O(V E U) である。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/edmunds-karp-eg.cpp.html&#34;&gt;examples/edmunds-karp-eg.cpp&lt;/a&gt; 中のプログラムは最大流問題の例 (辺容量を伴うグラフ) を DIMACS 形式で書かれた ファイルから読み、最大流を計算する。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/push_relabel_max_flow.html&#34;&gt;&lt;code&gt;push_relabel_max_flow()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>基本的なグラフ理論の復習 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/graph_theory_review.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;基本的なグラフ理論の復習&lt;/h1&gt;
&lt;p&gt;この章は、基本的なグラフ理論を思い出させることを意図している。読者があらかじめグラフアルゴリズムの知識があるのなら、始めるにあたりこの章は十分であろう。もし読者がグラフアルゴリズムの知識がないのならば、 Cormen, Leiserson, Rivestの&lt;a href=&#34;http://www.toc.lcs.mit.edu/~clr/&#34; target=&#34;_blank&#34;&gt;Introduction to Algorithms&lt;/a&gt; のようなもっと詳しいものを薦める。&lt;/p&gt;
&lt;h2&gt;グラフ抽象&lt;/h2&gt;
&lt;p&gt;グラフは、多くの種類の問題を解くのに有効な数学的抽象化である。基本的には、グラフは頂点と辺から構成され、辺は二つの頂点を結ぶ。もっと正確には、グラフ(graph)とは組&lt;code&gt;(V,E)&lt;/code&gt;で表され、&lt;code&gt;V&lt;/code&gt;は有限集合で、&lt;code&gt;E&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の２項関係である。&lt;code&gt;V&lt;/code&gt;は &lt;strong&gt;頂点集合(vertex set)&lt;/strong&gt; と呼ばれ、その要素を &lt;strong&gt;頂点(vertex)&lt;/strong&gt; と呼ぶ。&lt;code&gt;E&lt;/code&gt;は辺の集合で、 &lt;strong&gt;辺(edge)&lt;/strong&gt; とは&lt;code&gt;(u,v)&lt;/code&gt;の組で&lt;code&gt;u&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の要素である。 &lt;strong&gt;有向グラフ(directed graph)&lt;/strong&gt; においては、辺は順序付けられた組で、 &lt;strong&gt;始点(source)&lt;/strong&gt; を &lt;strong&gt;終点(target)&lt;/strong&gt; へと接続する。無向グラフ(undirected graph)においては、辺は順序付けされていない組で、２つの頂点を両方向につなぐ。つまり、無向グラフでは &lt;code&gt;(u,v)&lt;/code&gt;と&lt;code&gt;(v,u)&lt;/code&gt;は同じ辺の２通りの書き方である。&lt;/p&gt;
&lt;p&gt;グラフのこの定義は、いくつかの点であいまいである。辺や頂点が何を表現するかが述べられていない。グラフの例としては、連絡道路やハイパーリンク付きのウェブページなどを挙げることができる。これらの詳細がグラフの定義からは除外されているのは、大きな理由がある。それらの詳細はグラフの &lt;strong&gt;抽象化&lt;/strong&gt; の中では必要な部分ではない。詳細を定義から除外することで再利用可能な理論を構築でき、そのことは多くの異なった種類の問題を解く際に役に立つのである。&lt;/p&gt;
&lt;p&gt;定義にもどろう。グラフは頂点と辺の集合である。実際の様子を見せるため、頂点に文字のラベルがついたグラフを考え、辺を単純に文字の組としよう。ここで、有向グラフの例を次のように書くことができる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y } 
E = { (b,y), (b,y), (y,v), (z,a), (x,x), (b,x), (x,v), (a,z) } 
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このグラフを図示すると 図1 のようになる。辺 &lt;code&gt;(x,x)&lt;/code&gt; は &lt;strong&gt;輪(self-loop)&lt;/strong&gt; と呼ばれる。&lt;code&gt;(b,y)&lt;/code&gt;と &lt;code&gt;(b,y)&lt;/code&gt;は &lt;strong&gt;平行辺(parallel edges)&lt;/strong&gt; であり、これは &lt;strong&gt;マルチグラフ(multigraph)&lt;/strong&gt; でのみ許される(ただし、通常は有向グラフでも無向グラフでも許されない)。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/digraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図1: 有向グラフの例&lt;/p&gt;
&lt;p&gt;次に似たようなグラフを示すが、今度は無向グラフである。これは図2に図示する。無向グラフでは輪は許されない。上記のグラフ(から平行辺&lt;code&gt;(b,y)&lt;/code&gt;を除いたもの)の &lt;strong&gt;無向版(undirected version)&lt;/strong&gt; である。それはつまり、同じ頂点をもち、同じ辺から方向を除いたものを持つことを意味し、&lt;code&gt;(a,z)&lt;/code&gt;と&lt;code&gt;(z,a)&lt;/code&gt;という２つの辺は一つの辺に退化する。また、逆を考えることもできる。無向グラフの &lt;strong&gt;有向版(directed version)&lt;/strong&gt; は、すべての辺をそれぞれの方向を向く２つの辺で置き換えることで得られる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y }
E = { (b,y), (y,v), (z,a), (b,x), (x,v) }
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undigraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図2: 無向グラフの例&lt;/p&gt;
&lt;p&gt;ここでさらにグラフの用語を定義する。辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるとき、頂点&lt;code&gt;v&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;について &lt;strong&gt;隣接している(adjacent)&lt;/strong&gt; と言う。有向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は 頂点&lt;code&gt;u&lt;/code&gt;の &lt;strong&gt;出辺(out-edge)&lt;/strong&gt; であり、頂点&lt;code&gt;v&lt;/code&gt;の &lt;strong&gt;入辺(in-edge)&lt;/strong&gt; である。無向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を &lt;strong&gt;接合している(incident on)&lt;/strong&gt; という。&lt;/p&gt;
&lt;p&gt;図1で、頂点&lt;code&gt;y&lt;/code&gt;は頂点&lt;code&gt;b&lt;/code&gt;に対して隣接している (ただし&lt;code&gt;b&lt;/code&gt;は&lt;code&gt;y&lt;/code&gt;に対して隣接していない)。辺&lt;code&gt;(b,y)&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;の出辺であり、&lt;code&gt;y&lt;/code&gt;の入辺である。図2で、&lt;code&gt;y&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;に隣接していて、また逆も同様である。辺&lt;code&gt;(y,b)&lt;/code&gt;は頂点&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;を接合している。&lt;/p&gt;
&lt;p&gt;有向グラフにおいて、ある頂点の出辺の数は &lt;strong&gt;出次数(out-degree)&lt;/strong&gt; と呼ばれ、入辺の数は &lt;strong&gt;入次数(in-degree)&lt;/strong&gt; と呼ばれる。無向グラフにおいて、ある頂点に対して接合している辺の数は &lt;strong&gt;次数(degree)&lt;/strong&gt; と呼ばれる。図1で、頂点&lt;code&gt;b&lt;/code&gt;の出次数は3であり、入次数は0である。図2では単純に頂点&lt;code&gt;b&lt;/code&gt;の次数は2である。&lt;/p&gt;
&lt;p&gt;グラフの &lt;strong&gt;路(path)&lt;/strong&gt; とは辺の列で、それぞれの辺の終点が次の辺の始点であるものである。頂点&lt;code&gt;u&lt;/code&gt;から始まり頂点&lt;code&gt;v&lt;/code&gt;で終わる路があれば、頂点&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;から &lt;strong&gt;到達可能(reachable)&lt;/strong&gt; であるという。路が &lt;strong&gt;単純(simple)&lt;/strong&gt; であるとは、辺の列の中でどの頂点も繰り返し現れないことである。路&lt;code&gt;&amp;lt;(b,x), (x,v)&amp;gt;&lt;/code&gt;は単純であるが、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は単純ではない。また、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は最初の頂点と最後の頂点が一致するので、 &lt;strong&gt;サイクル(cycle)&lt;/strong&gt; と呼ばれる。サイクルのないグラフは &lt;strong&gt;アサイクリック(acyclic)&lt;/strong&gt; と呼ばれる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平面的グラフ(planar graph)&lt;/strong&gt; とは、すべての辺が交差しないように平面上に描けるグラフのことである。そのように描かれたものは &lt;strong&gt;平面グラフ(plane graph)&lt;/strong&gt; と呼ばれる。平面グラフの &lt;strong&gt;面(face)&lt;/strong&gt; とは、辺に囲まれた連結成分のことである。平面的グラフの重要な特性は、面、辺、頂点の数がオイラーの定理：&lt;code&gt;|F| - |E| + |V| = 2&lt;/code&gt;によって関係付けられることである。このことは、平面的グラフは最大でもO(|V|)個の辺しか持たないことを意味する。&lt;/p&gt;
&lt;h2&gt;グラフデータ構造&lt;/h2&gt;
&lt;p&gt;データ構造を考えるときに最初に考えるべきグラフの属性は、&lt;strong&gt;まばらさ(sparsity)&lt;/strong&gt; である。まばらさとは、頂点に対する相対的な辺の数である。&lt;code&gt;E&lt;/code&gt;が&lt;code&gt;V²&lt;/code&gt;に近いグラフは &lt;strong&gt;密(dense)&lt;/strong&gt; であると呼ばれ、&lt;code&gt;E = alpha V&lt;/code&gt;で&lt;code&gt;alpha&lt;/code&gt;が&lt;code&gt;V&lt;/code&gt;より十分に小さい場合は、まばらな(sparse)グラフと呼ばれる。密なグラフについては、通常、 &lt;strong&gt;隣接行列表現(adjacency-matrix representation)&lt;/strong&gt; が最良の選択であり、一方まばらなグラフについては &lt;strong&gt;隣接リスト表現(adjacency-list representation)&lt;/strong&gt; が最良である。また、まばらなグラフについては &lt;strong&gt;辺リスト表現(edge-list representation)&lt;/strong&gt; も適切な状況下では記憶効率面でよい選択である。&lt;/p&gt;
&lt;h3&gt;隣接行列表現&lt;/h3&gt;
&lt;p&gt;グラフの隣接行列表現はV x Vの２次元配列である。 行列a&lt;sub&gt;uv&lt;/sub&gt;の要素は、辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるかどうかを示すブーリアン値である。図3に図1(から&lt;code&gt;(b,y)&lt;/code&gt;を引いたもの)の隣接行列表現を表す。保存に必要な領域はO(V²)である。任意の辺について、アクセス、追加、除去にかかる時間はO(1)である。 頂点の追加や除去は、再割り当てとすべてのグラフのコピーが必要になり、手順数はO(V²)になる。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;クラスは、隣接行列表現によってBGLグラフインターフェースを実装する。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_matrix.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図3: 隣接行列によるグラフの表現&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34; name=&#34;adjacency-list-representation&#34;&gt;隣接リスト表現&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;グラフの隣接リスト表現では、すべての頂点に対して出辺の列を保存する。まばらなグラフでは、こうすることでメモリ領域を節約でき、必要な領域はO(V + E)だけになる。さらに、すべての頂点の出辺にはより効果的にアクセスできる。辺の挿入のコストはO(1)で、任意の辺へのアクセスはO(alpha)である。ここで、alphaは行列のまばらさ(グラフ中のすべての頂点についての出辺の数の最大値)である。図4は図1のグラフの隣接リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;は隣接リスト表現の実装である。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図4: 隣接リストによるグラフ表現&lt;/p&gt;
&lt;h3&gt;辺リスト表現&lt;/h3&gt;
&lt;p&gt;グラフの辺リスト表現は、単純に辺の列であり、辺は頂点のIDの組で表される。必要なメモリはO(E)だけである。辺挿入のコストはO(1)であり、特定の辺のアクセスするのはO(E)(あまり効果的でない)である。図5は図1のグラフの辺リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;アダプタクラスは、辺リスト表現の実装を作るのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/edge_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図5: 辺リストによるグラフの表現&lt;/p&gt;
&lt;h2&gt;グラフアルゴリズム&lt;/h2&gt;
&lt;h3&gt;グラフ探索アルゴリズム&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;木辺(tree edge)&lt;/strong&gt; とは、グラフ探索アルゴリズムをグラフに適用することによって作られた探索木(またはフォレスト)の辺ことである。辺&lt;code&gt;(u,v)&lt;/code&gt;は木辺であるのは、辺&lt;code&gt;(u,v)&lt;/code&gt;の探索(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;ビジタ&lt;/a&gt;の&lt;code&gt;explore()&lt;/code&gt;メソッドにあたる)をしているときに&lt;code&gt;v&lt;/code&gt;が最初に見つかるときである。&lt;strong&gt;後退辺(back edge)&lt;/strong&gt;とは、探索木上で頂点を先祖につなぐ辺である。したがって、辺&lt;code&gt;(u,v)&lt;/code&gt;では&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;の先祖である。輪は後退辺とみなされる。&lt;strong&gt;先行辺(forward edge)&lt;/strong&gt;は木辺ではない辺&lt;code&gt;(u,v)&lt;/code&gt;で、探索木上&lt;code&gt;u&lt;/code&gt;を子孫&lt;code&gt;v&lt;/code&gt;へとつなぐ。&lt;strong&gt;交差辺(cross edge)&lt;/strong&gt;とは、以上の３つのカテゴリに含まれない辺のことである。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34; name=&#34;bfs-algorithm&#34;&gt;幅優先探索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;幅優先探索(Breadth-First Search, BFS)とは、グラフに対して横断的であり、特定の原点から到達可能な頂点をすべて探索する。また横断する順番については、頂点のすべての近傍を探索してから近傍の近傍の探索へと進む。幅優先探索について考えるには、例えば水溜りに石を落としたときに波が放射状に広がるように拡散すると思えばよい。同じ「波」の中の頂点は原点から同じ距離にある。頂点は最初にアルゴリズムによって遭遇するときに&lt;strong&gt;発見される(discovered)&lt;/strong&gt;と言う。頂点は、その近傍がすべて探索されたときに&lt;strong&gt;完了した(finished)&lt;/strong&gt;と言われる。これらをわかりやすくする例がある。グラフを図6に示し、そのBFSにおける発見と完了の順番をその下に示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/bfs_example.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図6: 広さ優先探索がグラフに広がる様子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順番: s r w v t x u y &lt;/li&gt;
&lt;li&gt;完了の順番: s r w v t x u y&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt;から開始して、最初は&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;(&lt;code&gt;s&lt;/code&gt;の近傍)にたどり着く。&lt;code&gt;s&lt;/code&gt;の両方の希望に到達してから、&lt;code&gt;r&lt;/code&gt;の近傍(頂点&lt;code&gt;v&lt;/code&gt;)に到達し、&lt;code&gt;w&lt;/code&gt;の近傍&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;に到達する (&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;の順序は意味を持たない)。最後に&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の近傍、&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;に到達する。&lt;/p&gt;
&lt;p&gt;今グラフ上のどこにいるか、次にどこの頂点に行くかをアルゴリズムが把握するために、BFSは頂点に色を塗る。塗る色を置く場所は、グラフの中でもよいし、アルゴリズムに引数として渡すこともできる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34; name=&#34;dfs-algorithm&#34;&gt;深さ優先探索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;深さ優先探査(Depth-First Search, DFS) は、グラフ中の全頂点を探査する。このアルゴリズムでは、常にグラフ中の「深い」部分を、次に探査すべき辺として選択していく。これは、到達した頂点が未訪問の隣接頂点を持たなくなるまで次の未訪問な隣接頂点を選択していき、端に到達すれば前の頂点へと戻り、その頂点から任意の未探査な辺へと探査を継続していくことである。深さ優先探査は、出発する頂点から到達可能な全ての頂点を訪問した後に、残りの未訪問な頂点のうちから１頂点を選択して探査を継続していく。このプロセスは、深度優先の森からともに深度優先の木という集合を形成する。深さ優先探索は、グラフ中の辺を３つのカテゴリーに分類する：木辺、後退辺、先行辺か交差辺(どちらにも明確に分類しない)。与えられたグラフから多くの有効な深度優先の森が典型的に存在し、それゆえ辺を分類するには様々な(かつ等しく有効な)方法がある。&lt;/p&gt;
&lt;p&gt;深さ優先探査の興味深い特性は、各頂点の発見時と完了時の間において、括弧（入れ子）構造を形成するということである。頂点が発見される場合、私たちが開いた括弧を使用すれば、頂点が探査終了される場合には閉じた括弧が使用され、その結果、括弧により適切に入れ子にされた集合ができあがる。図7は、探査された順番にラベル付けされた辺による無向グラフに適応された DFS （深さ優先探査）である。図の下に、探査を開始した順序と探査を終了した順序を示し、それらから導かれる括弧構造を示す。DFS （深さ優先探査）は、２つが接続されたコンポーネント・アルゴリズム、トポロジカル・ソート、などを含む他のグラフ・アルゴリズムによって使用される核となるアルゴリズムである。これは循環を検知するために利用できる（ファイル依存関係の例における&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/file_dependency_example.html#cycles&#34;&gt;循環依存 （Cylic Dependencies）&lt;/a&gt; の節を見よ）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/dfs.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 7: 無向グラフにおける深度優先探査&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順序: a b e d c f g h i&lt;/li&gt;
&lt;li&gt;完了の順序: d f c e b a&lt;/li&gt;
&lt;li&gt;括弧構造: (a (b (e (d d) (c (f f) c) e) b) a) (g (h (i i) h) g)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#minimum-spanning-tree&#34; name=&#34;minimum-spanning-tree&#34;&gt;最小全域木問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最小全域木問題は、以下のように定義される：グラフ &lt;code&gt;E&lt;/code&gt; 中の全頂点を接続する循環のサブセット &lt;code&gt;T&lt;/code&gt; を接続の全コストが最小となるように選択することである。全コストは下記により与えられる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(T) = T における辺 (u,v) におけるコスト w(u,v) の合計、 w(u,v) は辺 (u,v) のコスト
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T&lt;/code&gt; は&lt;strong&gt;全域木(spanning tree)&lt;/strong&gt;と呼ばれる.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-paths-algorithms&#34; name=&#34;shortest-paths-algorithms&#34;&gt;最短経路問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;グラフ理論における古典的問題のひとつは、グラフ中の２頂点間を結ぶ最短経路を見つけることである。形式的に経路はグラフ &lt;code&gt;G = (V, E)&lt;/code&gt; 中の頂点のシーケンス &lt;code&gt;&amp;lt;v0,v1,...,vk&amp;gt;&lt;/code&gt; で表される（辺 &lt;code&gt;(vi,vi+1) for i=0,1,...,k-1&lt;/code&gt; は 辺の集合 &lt;code&gt;E&lt;/code&gt; ）。シーケンスにおいて各頂点は次の頂点へ接続される。最短経路問題において、各辺は重みを数値として与えられている。それゆえ、&lt;strong&gt;経路の重み(weight of a path)&lt;/strong&gt;について記す&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(p) = i=1..k of w(vi-1,vi) の合計
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; に至る&lt;strong&gt;最短経路の重み(shortest path weight)&lt;/strong&gt;は&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;delta (u,v) = min { w(p) : u --&amp;gt; v } もし 頂点 u から v に至る経路が存在すれば
delta (u,v) = 無限(infinity ) そうでなければ（ u から v に至る経路がなければ）
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;最短経路は、重みの合計が最小となる経路といえる。&lt;/p&gt;
&lt;p&gt;最短経路問題には、いくつかの変形された問題がある。ここでは単一ペアの問題を定義した、しかし、さらに単一出所問題(グラフ中の1つの頂点から各頂点ごとまでの最短のパス)があり、等価な単一目的地問題、全ペア問題、などである。単一出所の問題を解決するアルゴリズムより漸近的に速い、単一ペアの問題を解決するアルゴリズムは存在しない。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短経路木(shortest-paths tree)&lt;/strong&gt;は、グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; 中のある頂点を原点とした有向サブグラフである。&lt;code&gt;V&#39;&lt;/code&gt; を &lt;code&gt;V&lt;/code&gt; のサブセット、&lt;code&gt;E&#39;&lt;/code&gt; を &lt;code&gt;E&lt;/code&gt; のサブセットとし、 &lt;code&gt;V&#39;&lt;/code&gt; は&lt;code&gt;G&#39;&lt;/code&gt; から到達可能な頂点の集合、&lt;code&gt;G&#39;&lt;/code&gt; は原点から連なる経路木を成すものとすれば、&lt;code&gt;V&#39;&lt;/code&gt; 中の全ての頂点 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;G&#39;&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; から唯一の経路を持つ。再帰的に、単一頂点アルゴリズムによる結果は最短経路木である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#network-flow-algorithms&#34; name=&#34;network-flow-algorithms&#34;&gt;ネットワークフロー問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ネットワークの流れは&lt;strong&gt;送信(source)&lt;/strong&gt;頂点 &lt;code&gt;s&lt;/code&gt; から&lt;strong&gt;受信(sink)&lt;/strong&gt;頂点&lt;code&gt;t&lt;/code&gt;へと向かう有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; である。各辺は数値による、&lt;strong&gt;容量(capacity)&lt;/strong&gt;関数 &lt;code&gt;c&lt;/code&gt; 、および、&lt;strong&gt;流れ(flow)&lt;/strong&gt;関数 &lt;code&gt;f&lt;/code&gt; を持つ。流れ関数は次の３条件を満たしていなければならない：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;f(u,v) &amp;lt;= c(u,v) for all (u,v) in V x V (容量制限) 
f(u,v) = - f(v,u) for all (u,v) in V x V (流れ対称性)
sumv in V f(u,v) = 0 for all u in V - {s,t} (流れ保存則)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;ネットワークにおける&lt;strong&gt;流れ(flow)&lt;/strong&gt;は、受信頂点 &lt;code&gt;t&lt;/code&gt; に流れ込む集合の流れである（それは、送信頂点 &lt;code&gt;s&lt;/code&gt; から流れ出るネットの流れに等価である）。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;|f| = sumu in V f(u,t) = sumv in V f(s,v)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;辺における&lt;strong&gt;余剰容量(residual capacity)&lt;/strong&gt;を &lt;code&gt;r(u,v) = c(u,v) – f(u,v)&lt;/code&gt; とする。 &lt;code&gt;r(u,v) &amp;gt; 0&lt;/code&gt; を満たす辺は余剰辺 &lt;code&gt;E&lt;sub&gt;f&lt;/sub&gt;&lt;/code&gt; であり、それは余剰グラフ &lt;code&gt;G&lt;sub&gt;f&lt;/sub&gt; = (V, E&lt;sub&gt;f&lt;/sub&gt;)&lt;/code&gt; を成す。 &lt;code&gt;r(u,v) = 0&lt;/code&gt; を満たす辺は&lt;strong&gt;飽和(saturated)&lt;/strong&gt;している。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大流問題(maximum flow problem)&lt;/strong&gt;は、最大に可能な流量値 &lt;code&gt;|f|&lt;/code&gt; を決定することであり、そのときのグラフ中における各辺に対する流量値を決定することである。&lt;/p&gt;
&lt;p&gt;ネットワークの流れを 図 8 に示す。 &lt;code&gt;A&lt;/code&gt; は送信頂点で、&lt;code&gt;H&lt;/code&gt; は受信頂点。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/max-flow.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 8: 最大流ネットワーク。各辺は（流れ/容量）のラベルで示している。&lt;/p&gt;
&lt;p&gt;最大流ネットワーク問題を解決するには長い歴史があり、最初のアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford56:_maxim&#34;&gt;Ford と Fulkerson&lt;/a&gt;による。現在に至る最良のアルゴリズムである push-relabel アルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goldberg85:_new_max_flow_algor&#34;&gt;Goldberg&lt;/a&gt; によるもので、これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#karzanov74:_deter&#34;&gt;Karzanov&lt;/a&gt; による &lt;strong&gt;preflow&lt;/strong&gt; introduced という概念を元に成り立っている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 KATO Kimikazu, &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mem_fn.hpp -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/mem_fn.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;mem_fn.hpp&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34;&gt;FAQ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34;&gt;インタフェース&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34;&gt;実装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34;&gt;ファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34; name=&#34;purpose&#34;&gt;目的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::mem_fn&lt;/code&gt; は、標準関数である&lt;code&gt;std::mem_fun&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt;の一般化である。&lt;code&gt;mem_fn&lt;/code&gt;は、2つ以上の引数をとる メンバ関数へのポインタをサポートし、また&lt;code&gt;mem_fn&lt;/code&gt;の戻す関数オブジェクトは第一引数に、 (訳注: そのメンバ関数の属するクラスのインスタンスを指すような) ポインタ、参照、スマートポインタをとることができる。 &lt;code&gt;mem_fn&lt;/code&gt;は、メンバ変数へのポインタも、引数をとらず自身への定数参照を 戻す関数とみなすことによってサポートする。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;の目的は2つある。一つ目は、コンテナにスマートポインタが格納されている場合であっても、 次のような&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;見慣れた文法によって、メンバ関数の呼び出しを可能にすることである。&lt;/p&gt;
&lt;p&gt;二つ目は、メンバ関数へのポインタを関数オブジェクトのように取り扱いたいライブラリ開発者に、 実装の道具として使用して貰うことである。例えば、あるライブラリは次のようにしてより便利な &lt;code&gt;for_each&lt;/code&gt;アルゴリズムを提供することができ、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;It&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; for_each(It first, It last, R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(first, last, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(pmf));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムは次のようにして手軽に利用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;for_each(v.begin(), v.end(), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムの機能を文書化する際には、単に次のように書けば良い：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;template&amp;lt;class It, class R, class T&amp;gt;&lt;/code&gt;
&lt;code&gt;void for_each(It first, It last, R (T::*pmf) ());&lt;/code&gt;
&lt;strong&gt;結果:&lt;/strong&gt; &lt;code&gt;std::for_each(first, last, boost::mem_fn(pmf));&lt;/code&gt; と同等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ここで、 &lt;code&gt;boost::mem_fn&lt;/code&gt; の部分はこのページへのリンクとするとよいだろう。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bindのドキュメント&lt;/a&gt; にそのような例があるので参照のこと。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; は1つの引数(メンバ関数へのポインタ)をとり、標準あるいは独自の アルゴリズムに渡すのに適した関数オブジェクトを戻す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X
{
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f();
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;h&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X &lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;k&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;戻される関数オブジェクトは、引数のメンバ関数ポインタと同じ引数をとることに加え、 インスタンスを表すための「柔軟な」第一引数をとる。&lt;/p&gt;
&lt;p&gt;関数オブジェクトが、適切なクラス(上の例では &lt;code&gt;X&lt;/code&gt;)を指すポインタでも参照でも ない第一引数&lt;code&gt;x&lt;/code&gt;をもって呼ばれた場合、関数オブジェクトは&lt;code&gt;get_pointer(x)&lt;/code&gt; を用いて&lt;code&gt;x&lt;/code&gt;からポインタを得ようとする。 スマートポインタの作者は、自分たちのスマートポインタ向けの適切な&lt;code&gt;get_pointer&lt;/code&gt;関数 を定義(overload)しておくことで、それを&lt;code&gt;mem_fn&lt;/code&gt;対応とすることができる。&lt;/p&gt;
&lt;p&gt;[注意: &lt;code&gt;get_pointer&lt;/code&gt; の戻り値はポインタでなくともよい。 &lt;code&gt;(x-&amp;gt;*pmf)(...)&lt;/code&gt;という形式でメンバ関数が呼び出せるなら、どんなオブジェクトでも問題ない。]&lt;/p&gt;
&lt;p&gt;[注意: ライブラリは、&lt;code&gt;get_pointer&lt;/code&gt; の非限定的 (訳注:名前空間を明示しない) 呼び出しを行なう。 そのため、引数依存検索の過程では、オーバーロードされた&lt;code&gt;boost::get_pointer&lt;/code&gt;関数群に加えて、 そのスマートポインタが定義された名前空間内の&lt;code&gt;get_pointer&lt;/code&gt;関数群も検索対象になる。]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;が戻す全ての関数オブジェクトは、&lt;code&gt;result_type&lt;/code&gt;なる&lt;code&gt;typedef&lt;/code&gt;を開示する。 この&lt;code&gt;typedef&lt;/code&gt;は、メンバ関数の戻り型を表す。メンバ変数を渡した場合には、&lt;code&gt;result_type&lt;/code&gt; はそのメンバ変数の型の定数参照として定義される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34; name=&#34;faq&#34;&gt;FAQ&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34; name=&#34;Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。単純な使い方では、&lt;code&gt;mem_fn&lt;/code&gt; は標準のアダプタが提供しないいくつかの機能を提供する。 &lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;Boost.Compose&lt;/a&gt; と標準のアダプタを組み合わせるような複雑な使い方をしている場合は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;&lt;code&gt;boost::bind&lt;/code&gt;&lt;/a&gt; を使用するように書き換えることで、&lt;code&gt;mem_fn&lt;/code&gt;の恩恵を自動的に受けることができる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34; name=&#34;Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いいえ。そうする強い理由がないならすべきではない。&lt;code&gt;mem_fn&lt;/code&gt; は、標準のアダプタに 非常に良く似ているが、100%の互換性があるわけではない。特に、&lt;code&gt;mem_fn&lt;/code&gt;は、標準の アダプタとは違って &lt;code&gt;std::[const_]mem_fun[1][_ref]_t&lt;/code&gt; 型のオブジェクトを戻さないので、 標準の &lt;code&gt;argument_type&lt;/code&gt; 及び &lt;code&gt;first_argument_type&lt;/code&gt; という (nested) &lt;code&gt;typedef&lt;/code&gt; を 用いて第一引数の型を記述することが (完全には) できない。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。&lt;code&gt;#define BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; とすれば可能である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;特定のベンダへの依存を避けるため、可搬性のない拡張は、一般にデフォルトでオフにされるべきである。 もし &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; がデフォルトで有効であったなら、あなたはそうとは気づかずに その拡張を使ってしまい、結果としてあなたのコードの可搬性が損なわれるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34; name=&#34;interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34; name=&#34;synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost
{

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ());

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt;&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-5&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-6&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 実際には、より多くの引数をとるような関数が、更にいくつかオーバーロードされている&lt;/span&gt;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34; name=&#34;requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Synopsis で述べられた全ての &lt;em&gt;unspecified-N&lt;/em&gt; 型は &lt;code&gt;CopyConstructible&lt;/code&gt; (コピーコンストラクト可能) かつ &lt;code&gt;Assignable&lt;/code&gt; (代入可能) であること。そのためのコピーコンストラクタ及び代入演算子 は例外を送出しないこと。 &lt;em&gt;unspecified-N&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;mem_fn&lt;/code&gt; に渡されたメンバ関数ポインタの戻り型、と定義されること (Synopsis での &lt;code&gt;R&lt;/code&gt;)。 &lt;em&gt;unspecified-2-1&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;R const &amp;amp;&lt;/code&gt; 、と定義されること。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34; name=&#34;get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34; name=&#34;mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt;あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2-1&lt;/span&gt;&lt;/i&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;t.*pm&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;get_pointer(t)-&amp;gt;*pm&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-5&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-6&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34; name=&#34;implementation&#34;&gt;実装&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34; name=&#34;files&#34;&gt;ファイル&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;boost/mem_fn.hpp (メインヘッダ)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_cc.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_vw.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_template.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_test.cpp (テスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_derived_test.cpp (派生オブジェクトでのテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_fastcall_test.cpp (&lt;code&gt;__fastcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_stdcall_test.cpp (&lt;code&gt;__stdcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_void_test.cpp (戻りが&lt;code&gt;void&lt;/code&gt;であるケースのテスト)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34; name=&#34;dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Config&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34; name=&#34;number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;この実装では、8つまでの引数をとるメンバ関数がサポートされている。これは、設計に固有の 制限という訳ではなく、実装の詳細である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34; name=&#34;stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いくつかのプラットフォームでは、 &lt;strong&gt;呼び出し規則&lt;/strong&gt; (どのように関数が起動されるかの規則: 引数はどのように渡されるのか、戻り値はどのように扱われるのか、もしスタックを使用したなら、 誰がそれを奇麗にするのか) の異なるような何種類かのメンバ関数を作成できる。&lt;/p&gt;
&lt;p&gt;例えば、Windows API の関数と、COMインタフェースのメンバ関数は、 &lt;code&gt;__stdcall&lt;/code&gt; という呼び出し規則を用いるし、 Borland の VCL コンポーネントは &lt;code&gt;__fastcall&lt;/code&gt; を用いる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__stdcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__fastcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_FASTCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;[注意: これは可搬性のない拡張であり、インタフェースの一部ではない。]&lt;/p&gt;
&lt;p&gt;[注意: いくつかのコンパイラは、 &lt;code&gt;__stdcall&lt;/code&gt; キーワードに対して最小限のサポートしか提供していない。]&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get_pointer&lt;/code&gt;ベースの設計は、Rene Jageによる、特性クラスを用いて &lt;code&gt;mem_fn&lt;/code&gt;を ユーザ定義のスマートポインタに適合させるという提案に影響されたものである。&lt;/p&gt;
&lt;p&gt;フォーマルレビューの期間に、Richard Crossley、 Jens Maurer、 Ed Brey、その他の方々の示唆によって、たくさんの 改良があった。レビューマネージャは Darin Adler であった。&lt;/p&gt;
&lt;p&gt;Steve Anichini は、COMインタフェースが &lt;code&gt;__stdcall&lt;/code&gt; を使用していることを指摘した。&lt;/p&gt;
&lt;p&gt;Dave Abrahams は、不完全なコンパイラにおいても &#34;戻り値なし&#34; をサポートすべく、&lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;mem_fn&lt;/code&gt; を改良した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2001, 2002 by Peter Dimov and Multi Media Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 SATO Yusuke &lt;a href=&#34;mailto:y-sato@y-sa.to&#34;&gt;y-sato@y-sa.to&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Assignable -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/utility/Assignable.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Assignable&lt;/h1&gt;
&lt;h2&gt;説明&lt;/h2&gt;
&lt;p&gt;その型のオブジェクトから、その型の他のオブジェクトに代入が可能である場合、その型はAssignableである。&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;はAssignableモデルの型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト、もしくは可能であれば&lt;code&gt;const T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義&lt;/h2&gt;
&lt;h2&gt;妥当な式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値の型&lt;/th&gt;
&lt;th&gt;意味論&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;代入&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t = u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.lsc.nd.edu/~jsiek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Copy Constructible -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/utility/CopyConstructible.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;Copy Constructible&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;説明&lt;/h2&gt;
&lt;p&gt;オブジェクトのコピーが可能である場合、その型はCopy Constructibleである。&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;はCopy Constructibleモデルの型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;const T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義&lt;/h2&gt;
&lt;h2&gt;妥当な式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値の型&lt;/th&gt;
&lt;th&gt;意味論&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T(t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T(t)&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T(u)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;T(u)&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;デストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t.~T()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;アドレス演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;のアドレスを意味する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;アドレス演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;のアドレスを意味する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; CopyConstructibleConcept
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints() {
    T a(b);            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require copy constructor&lt;/span&gt;
    T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ptr &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;a;       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require address of operator&lt;/span&gt;
    const_constraints(a);
    ignore_unused_variable_warning(ptr);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; const_constraints(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; a) {
    T c(a);            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require const copy constructor&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ptr &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;a; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require const address of operator&lt;/span&gt;
    ignore_unused_variable_warning(c);
    ignore_unused_variable_warning(ptr);
  }
  T b;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;Default Constructible&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.lsc.nd.edu/~jsiek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>MultiPassInputIterator -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/utility/MultiPassInputIterator.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1&gt;MultiPassInputIterator&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/MultiPassInputIterator.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/utility/MultiPassInputIterator.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このコンセプトは&lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;Input Iterator&lt;/a&gt;を精製し、範囲を複数のパスで通るようイテレータを使用してもよいという要件を追加しており、&lt;code&gt;it1 == it2&lt;/code&gt;かつ&lt;code&gt;++it1 == ++it2&lt;/code&gt;のとき、&lt;code&gt;it1&lt;/code&gt;は間接参照可能である。このMulti-Pass Input Iteratorは、&lt;a href=&#34;http://www.sgi.com/tech/stl/ForwardIterator.hmtl&#34; target=&#34;_blank&#34;&gt;Forward Iterator&lt;/a&gt;によく似ている。唯一の違いは、&lt;a href=&#34;http://www.sgi.com/tech/stl/ForwardIterator.hmtl&#34; target=&#34;_blank&#34;&gt;Forward Iterator&lt;/a&gt;の&lt;code&gt;reference&lt;/code&gt;型が&lt;code&gt;value_type&amp;amp;&lt;/code&gt;であることを要求するのに対し、MultiPassInputIteratorは&lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;Input Iterator&lt;/a&gt;のように&lt;code&gt;reference&lt;/code&gt;が&lt;code&gt;value_type&lt;/code&gt;に変換できるということである。&lt;/p&gt;
&lt;h2&gt;設計ノート&lt;/h2&gt;
&lt;p&gt;Valentin Bonnardからのコメント：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;私は、Multi-Pass Input Iteratorの導入は、正しい解決ではないと考える。これと同様に、Multi-Pass Bidirectional IteratorやMulti-Pass Random Access Iteratorを定義したいと思うだろうか？私は思わない、確実に。これは問題を混乱させるだけだ。この問題は、既存のイテレータ階層に含まれている移動性(movavility)と変更性(modifiability)と左辺値らしさを混ぜ合わせたものであり、これらは明確に独立している。

Forward、Bidirectional、Random Accessは移動性に関しての用語であり、それ以外の意味に使用すべきではない。イテレータが不変(immutable)か変更可能(mutable)かは、完全に直交する。左辺値のイテレータもまた、不変性(immutability)は直交する。これらのクリーンなコンセプトでは、Multi-Pass Input Iteratorは素直にForward Iteratorと呼べる。

他の変換は以下のようになる：

std::Forward Iterator -&amp;gt; ForwardIterator &amp;amp; Lvalue Iterator

std::Bidirectionnal Iterator -&amp;gt; Bidirectionnal Iterator &amp;amp; Lvalue Iterator

std::Random Access Iterator -&amp;gt; Random Access Iterator &amp;amp; Lvalue Iterator

私のForward Iteratorで許可しておらず、std::Forward Iteratorでは許可されている唯一の操作は「&amp;amp;*it」である。私は、「&amp;amp;*」はジェネリックコードではほとんど必要ないと考える。
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Jeremy Siekからの返信：&lt;/p&gt;
&lt;p&gt;Valentinの分析は正しい。もちろん、ここには後方互換性の問題がある。現在のSTLの実装は、古いForward Iteratorの定義に基いている。これに対するアクションの正しい道筋は、標準C++のForward Iteratorやその他の定義を変更することである。そうすれば、我々はMulti-Pass Input Iteratorをなくすことができる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>エラーと例外のハンドリング -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/document/error_handling.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/document/error_handling.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;エラーと例外のハンドリング&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元：&lt;a href=&#34;http://www.boost.org/community/error_handling.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/community/error_handling.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照&lt;/h2&gt;
&lt;p&gt;次の文書は堅牢で汎用的なコンポーネントを書くときのいくつかの問題に対する、 良い手引きである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Abrahams: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_exception_safety.html&#34;&gt;&#34;Exception Safety in Generic Components&#34;(邦訳：「ジェネリックコンポーネントにおける例外安全性」)&lt;/a&gt;, originally published in &lt;a href=&#34;http://www.springer.de/cgi-bin/search_book.pl?isbn=3-540-41090-2&#34; target=&#34;_blank&#34;&gt;M. Jazayeri, R. Loos, D. Musser (eds.): Generic Programming, Proc. of a Dagstuhl Seminar, Lecture Notes on Computer Science 1766&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ガイドライン&lt;/h2&gt;
&lt;h3&gt;いつ例外を使うべきか?&lt;/h3&gt;
&lt;p&gt;単純な答えは: 「例外のセマンティクスとパフォーマンスの性質が適していればいつでも」&lt;/p&gt;
&lt;p&gt;よく引用されるガイドラインは 「これは例外的な(或いは期待されていない)状況なのか?」 とあなた自身に問うことである。このガイドラインはその問題に対して、 魅力的な響きがするが、通常間違っている。問題はある人間の「例外的」 が、別の人間の 「期待通り」 である、ということである: その述語をあなたが本当に注意深く見るとき、例外的と期待通りの間の区別は消えて無くなり、 ガイドラインはもはやあなたのもとには残らない。 結局、もしエラーの状態をチェックするなら、ある意味であなたはそれが起こるのを期待しているか、 そうでなければそのチェックは全く無駄なコードなのである。&lt;/p&gt;
&lt;p&gt;この問題により相応しい問いは: 「ここでスタックを巻き戻したいか?」 ということである。実際に例外を扱うことは、コードの主流を実行するより かなり遅いと考えられるので、あなたは更にこう問うべきである: 「私はここでスタックを巻き戻す余裕があるのか?」 例えば長い計算を行っているデスクトップアプリケーションは、ユーザがキャンセルボタンを押したかどうか、 定期的にチェックするだろう。例外を投げれば、キャンセルは美しく行われる。 一方、この計算の内側のループで例外を投げ、 &lt;em&gt;扱う&lt;/em&gt; ことはおそらく適していない。 パフォーマンスにおおいに影響するからである。&lt;/p&gt;
&lt;h3&gt;プログラマのエラーについては?&lt;/h3&gt;
&lt;p&gt;開発者として、もし私が自分の使っているライブラリの事前条件を違反したなら、 私はスタックを巻き戻したくはない。私が行いたいことは、コアダンプを吐くか、 それと同等のことである。つまり、問題が発見された実際の場所で、 プログラムの状態を調べる方法が欲しいのである。 これは通常、 &lt;code&gt;assert()&lt;/code&gt; などである。&lt;/p&gt;
&lt;p&gt;ほとんどの種類の、クライアントの誤用に耐えうる、 回復力のある API が必要なときもあるだろう。 しかし、このアプローチには通常、大きなコストが伴う。 例えば、これは通常、クライアントが使うオブジェクトそれぞれについて追跡することで、 その妥当性をチェックすることが出来るだろう。 もしその種の保護を行う必要があるなら、通常、単純な API の最も上の層として 提供することができる。もっともこれは、中途半端な方法だということに気づかなければならない。 多くの誤用に - しかし全てではない - 対する回復を約束する API は災いを招く。 クライアントはその保護に頼り、その期待はインタフェースが守らない部分にまでふくらむだろう。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Windows 開発者のための注意&lt;/strong&gt; : 不幸にも、多くの Windows コンパイラに寄って使われるネイティブの例外操作は、 あなたが &lt;code&gt;assert()&lt;/code&gt; を使ったときに、実際に例外を投げる。 実際、これはセグメンテーション違反や、ゼロ除算などの他のプログラマのエラーについては正しい。 これに関するひとつの問題は、もしあなたが JIT(Just In Time) デバッグを行えば、 デバッガが動く前に対応する例外巻き戻しが起こってしまうということである。 幸運にも、単純だが余り知られていない回避手段がある。それは、 次の決まり文句を使うことである:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;C&#34;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; straight_to_debugger(&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, EXCEPTION_POINTERS&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;throw&lt;/span&gt;;
}
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;C&#34;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;old_translator)(&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt;, EXCEPTION_POINTERS&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;)
         &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; _set_se_translator(straight_to_debugger);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;© Copyright David Abrahams 2001. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 19 August, 2001&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:k_takahashi@cppll.jp&#34;&gt;Kohske Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ジェネリックプログラミング手法 -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/document/generic_programming.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/document/generic_programming.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;ジェネリックプログラミング手法&lt;/h1&gt;
&lt;p&gt;これは boost ライブラリで使われている、 ジェネリックプログラミング技術の不完全な概観である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元：&lt;a href=&#34;http://www.boost.org/community/generic_programming.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/community/generic_programming.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#introduction&#34;&gt;はじめに(Introduction)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#the-anatomy-of-a-concept&#34;&gt;コンセプトの分析(The Anatomy of a Concept)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#traits&#34;&gt;特性クラス(Traits)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#tag-dispatching&#34;&gt;タグ分岐(Tag Dispatching)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#adaptors&#34;&gt;アダプタ(Adaptors)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#type-generators&#34;&gt;型生成器(Type Generators)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#object-generators&#34;&gt;オブジェクト生成器(Object Generators)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#policy-classes&#34;&gt;ポリシークラス(Policy Classes)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#introduction&#34; name=&#34;introduction&#34;&gt;はじめに(Introduction)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ジェネリックプログラミングはソフトウェアコンポーネントに汎用化に関するものであり、 これによりコンポーネントを多様な状況で容易に再利用することが出来る。 C++ ではクラステンプレートと関数テンプレートがジェネリックプログラミング技術に対して特に効果的である。 なぜなら、これらは効率を犠牲にすることなく汎用化を可能にするからである。&lt;/p&gt;
&lt;p&gt;ジェネリックプログラミングの簡単な例として、C 標準ライブラリの &lt;code&gt;memcpy()&lt;/code&gt; 関数をどのように汎用化するか見てみよう。 &lt;code&gt;memcpy()&lt;/code&gt; の実装は次のようになっている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;memcpy&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; region1, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; region2, &lt;span style=&#34;color: #B00040&#34;&gt;size_t&lt;/span&gt; n)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;)region2;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ((&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;)region2) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; n;
  &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; result &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;)region1;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; (first &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; last)
    &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;result&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;first&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; result;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;memcpy()&lt;/code&gt; 関数は既に、 &lt;code&gt;void*&lt;/code&gt; を使うことである程度汎用化されているので、 この関数は異なる種類のデータ配列のコピーに使うことが出来る。 しかし、コピーしたいデータが配列の中になかったらどうだろう。 これは、リンクリストかもしれない。コピーの概念を、 どんな要素のシーケンスにでも汎用化できるだろうか。 &lt;code&gt;memcpy()&lt;/code&gt; の中身を見ると、この関数の &lt;strong&gt;最小限の要求&lt;/strong&gt; は、ある種のポインタを使うことで、シーケンスを &lt;em&gt;横断&lt;/em&gt; し、 指された要素に &lt;em&gt;アクセス&lt;/em&gt; し、要素を目的地に &lt;em&gt;書き込み&lt;/em&gt; 、 いつ停止するかを知るためにポインタを &lt;em&gt;比較する&lt;/em&gt; 必要がある。 C++ 標準ライブラリはこのような要求を &lt;strong&gt;コンセプト&lt;/strong&gt; の中にグループ化する。 この場合は、 &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;Input Iterator&lt;/a&gt; コンセプト(region2) と &lt;a href=&#34;http://www.sgi.com/tech/stl/OutputIterator.html&#34; target=&#34;_blank&#34;&gt;Output Iterator&lt;/a&gt; コンセプト (region1) である。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;memcpy()&lt;/code&gt; を関数テンプレートとして書き直し、テンプレート引数の要求を述べるために、 &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;Input Iterator&lt;/a&gt; と &lt;a href=&#34;http://www.sgi.com/tech/stl/OutputIterator.html&#34; target=&#34;_blank&#34;&gt;Output Iterator&lt;/a&gt; を利用するなら、次のようにして、高度に再利用可能な &lt;code&gt;copy()&lt;/code&gt; 関数を実装することが出来る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; InputIterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; OutputIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
OutputIterator
copy(InputIterator first, InputIterator last, OutputIterator result)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; (first &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; last)
    &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;result&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;first&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; result;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;汎用の &lt;code&gt;copy()&lt;/code&gt; 関数を使うことで、どんな種類のシーケンスからでも要素をコピーできるようになるのである。 これには、&lt;code&gt;std::list&lt;/code&gt; のような、イテレータを外部に置いているリンクリストも含まれる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; region1(N);
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; region2;

  region2.push_back(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);
  region2.push_back(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;);
  region2.push_back(&lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;);

  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;copy(region2.begin(), region2.end(), region1.begin());

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; N; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; region1[i] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; &#34;&lt;/span&gt;;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#the-anatomy-of-a-concept&#34; name=&#34;the-anatomy-of-a-concept&#34;&gt;コンセプトの分析(The Anatomy of a Concept)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;コンセプト&lt;/strong&gt; は要求の集合であり、要求は有効な式、関連型、不変量、 そして計算量の保証から出来ている。要求の集合を満たす型は、コンセプトの モデル と言われる。 コンセプトは他のコンセプトの要求を拡張することが可能であり、これは &lt;strong&gt;発展型(refinement)&lt;/strong&gt; と呼ばれる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有効な式&lt;/strong&gt; とは、 コンセプトの &lt;em&gt;モデル&lt;/em&gt; とみなされる式に関わるオブジェクトに対して、 コンパイルが成功しなければならない C++ の式である。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;関連型&lt;/strong&gt; とは、 モデル型と関係する型であり、関連型はそのモデル型の中のひとつ以上の有効な式に加わっている。 典型的には関連型は、モデル型のためのクラス定義の中でネストされた &lt;code&gt;typedef&lt;/code&gt; によって、 または &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#traits&#34;&gt;特性クラス&lt;/a&gt; によってアクセスされる。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不変量&lt;/strong&gt; とは、常に真となる、オブジェクトの実行時特性である。 つまり、そのオブジェクトを含む関数はこれらの特性を維持しなければならない。 不変量は事前条件と事後条件の形を取ることが多い。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;計算量保証&lt;/strong&gt; は有効な式の実行にかかる時間、 またはその計算が使う様々な資源の上限である。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 標準ライブラリで使われているコンセプトは &lt;a href=&#34;http://www.sgi.com/tech/stl/table_of_contents.html&#34; target=&#34;_blank&#34;&gt;SGI STL site&lt;/a&gt; で文書化されている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#traits&#34; name=&#34;traits&#34;&gt;特性クラス(Traits)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;特性クラスは、コンパイル時の実体(型、汎整数定数、アドレス)に情報を関連付ける手段を提供する。例えば、クラステンプレート&lt;code&gt;std::iterator_traits&amp;lt;T&amp;gt;&lt;/code&gt; は次のようになっている:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; iterator_traits {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... iterator_category;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... value_type;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... difference_type;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... pointer;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... reference;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この特性クラスの &lt;code&gt;value_type&lt;/code&gt; は、イテレータが &#34;指し示す先の&#34; 型に対して、 汎用的なコードを与える。 &lt;code&gt;iterator_category&lt;/code&gt; はイテレータの能力に依存して、 より効率的なアルゴリズムを選択するために利用することが出来る。&lt;/p&gt;
&lt;p&gt;特性テンプレートの核となる特徴は、これらが &lt;em&gt;でしゃばりではない&lt;/em&gt; ということである: これらは、組み込みの型、サードパーティのライブラリで定義された型を含め、 任意の型に情報を関連付けることを可能にする。通常、特性は特性テンプレートを(部分)特殊化することで、 特定の型に特化されている。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::iterator_traits&lt;/code&gt; についての詳細な記述は、 SGI が提供している &lt;a href=&#34;http://www.sgi.com/tech/stl/iterator_traits.html&#34; target=&#34;_blank&#34;&gt;このページ&lt;/a&gt; を見よ。 標準ライブラリでの、大きく異なる別の特性の式は &lt;code&gt;std::numeric_limits&amp;lt;T&amp;gt;&lt;/code&gt; である。これは、 数値型の範囲と能力を記述する定数を提供している。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#tag-dispatching&#34; name=&#34;tag-dispatching&#34;&gt;タグ分岐(Tag Dispatching)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;特性クラスと同時に使われることが多い技術に、タグ分岐がある。 これは、型の性質に基づいて分岐するために、関数オーバーロードを使う方法である。 これについてのよい例は、C++ 標準ライブラリの &lt;a href=&#34;http://www.sgi.com/tech/stl/advance.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::advance()&lt;/code&gt;&lt;/a&gt; 関数である。 これは、イテレータを &lt;code&gt;n&lt;/code&gt; 回インクリメントする。 イテレータの種類によって、実装の中では適用される、異なる最適化がある。 もしイテレータが &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;random access&lt;/a&gt; (前方、後方に任意の距離、ジャンプすることが可能である) なら、 &lt;code&gt;advance()&lt;/code&gt; 関数は単に &lt;code&gt;i += n&lt;/code&gt; で実装され、これは非常に効率的、つまり定数時間である。 他のイテレータでは、 ステップ数が &lt;strong&gt;上昇&lt;/strong&gt; し、演算は &lt;code&gt;n&lt;/code&gt; に対する線形時間になる。 もしイテレータが、 &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;双方向&lt;/a&gt; なら、 &lt;code&gt;n&lt;/code&gt; が負であっても良いので、 イテレータをインクリメントするかデクリメントするか選ばなければならない。&lt;/p&gt;
&lt;p&gt;タグ分岐と特性クラスの関係は、分岐に使われる性質(この場合では &lt;code&gt;iterator_category&lt;/code&gt;) が特性クラスによってアクセスされることが多い、ということである。 主たる &lt;code&gt;advance()&lt;/code&gt; 関数は &lt;code&gt;iterator_category&lt;/code&gt; を得るために &lt;a href=&#34;http://www.sgi.com/tech/stl/iterator_traits.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;iterator_traits&lt;/code&gt;&lt;/a&gt; クラスを使う。 それから、オーバーロードされた &lt;code&gt;advance_dispatch()&lt;/code&gt; 関数を呼び出すのである。 &lt;code&gt;iterator_category&lt;/code&gt; をどんな型に解決するかに基づいて、 コンパイラにより、 &lt;a href=&#34;http://www.sgi.com/tech/stl/input_iterator_tag.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;input_iterator_tag&lt;/code&gt;&lt;/a&gt; か &lt;a href=&#34;http://www.sgi.com/tech/stl/bidirectional_iterator_tag.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;bidirectional_iterator_tag&lt;/code&gt;&lt;/a&gt; か &lt;a href=&#34;http://www.sgi.com/tech/stl/random_access_iterator_tag.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;random_access_iterator_tag&lt;/code&gt;&lt;/a&gt; の中から適した &lt;code&gt;advance_dispatch()&lt;/code&gt; が選ばれるのである。 &lt;strong&gt;タグ&lt;/strong&gt; はタグ分岐や、似たような技術で使うための性質を伝える、 という目的だけを持つ単純なクラスである。 イテレータタグのより詳細な記述については、&lt;a href=&#34;http://www.sgi.com/tech/stl/iterator_tags.html&#34; target=&#34;_blank&#34;&gt;このページ&lt;/a&gt; を参照すること。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; std {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; input_iterator_tag { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; bidirectional_iterator_tag { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; random_access_iterator_tag { };

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; detail {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;InputIterator&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Distance&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; advance_dispatch(InputIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; i, Distance n, input_iterator_tag) {
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; (n&lt;span style=&#34;color: #666666&#34;&gt;--&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i;
    }

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BidirectionalIterator&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Distance&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; advance_dispatch(BidirectionalIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; i, Distance n, 
       bidirectional_iterator_tag) {
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; (n&lt;span style=&#34;color: #666666&#34;&gt;--&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; (n&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;--&lt;/span&gt;i;
    }

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Distance&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; advance_dispatch(RandomAccessIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; i, Distance n, 
       random_access_iterator_tag) {
      i &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; n;
    }
  }

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;InputIterator&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Distance&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; advance(InputIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; i, Distance n) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;InputIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator_category category;
    detail&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;advance_dispatch(i, n, category);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#adaptors&#34; name=&#34;adaptors&#34;&gt;アダプタ(Adaptors)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;アダプタ&lt;/em&gt; は別の型や、新しいインタフェース、振る舞いの変種を提供する型を構築する、 クラステンプレートである。 標準のアダプタの例は、 &lt;a href=&#34;http://www.sgi.com/tech/stl/ReverseIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::reverse_iterator&lt;/code&gt;&lt;/a&gt; にある。これは、インクリメント、デクリメントに対しその動きを逆転させる、イテレータ型に対するアダプタである。 &lt;a href=&#34;http://www.sgi.com/tech/stl/stack.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::stack&lt;/code&gt;&lt;/a&gt; は単純なスタックインタフェースを提供するコンテナに対するアダプタである。&lt;/p&gt;
&lt;p&gt;標準でのアダプタについての、より解りやすいレビューは &lt;a href=&#34;http://www.cs.rpi.edu/~wiseb/xrds/ovp2-3b.html#SECTION00015000000000000000&#34; target=&#34;_blank&#34;&gt;ここ&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#type-generators&#34; name=&#34;type-generators&#34;&gt;型生成器(Type Generators)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;型生成器&lt;/em&gt; はテンプレート引数 [^1] に基づいて新しい型を合成することだけが目的のテンプレートである。 生成された型は通常、ネストされた &lt;code&gt;typedef&lt;/code&gt; として表現され、いかにもふさわしく &lt;code&gt;type&lt;/code&gt; と命名される。 型生成は通常、複雑な型表現をひとつの型に統合するために使われる。例えば、 &lt;code&gt;boost::filter_iterator_generator&lt;/code&gt; では、次のようになっている:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iterator&lt;/span&gt;, 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; complicated &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;default&lt;/span&gt;,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Reference&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; complicated &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;default&lt;/span&gt;,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Pointer&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; complicated &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;default&lt;/span&gt;,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Category&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; complicated &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;default&lt;/span&gt;,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Distance&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; complicated &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;default&lt;/span&gt;
         &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; filter_iterator_generator {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; iterator_adaptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
        Iterator,filter_iterator_policies&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Predicate,Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;,
        Value,Reference,Pointer,Category,Distance&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; type;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;いまこれは複雑だが、適応するフィルタイテレータを作るのは簡単である。 あなたは普通、ただこう書くだけでよい:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;filter_iterator_generator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;my_predicate,my_base_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#object-generators&#34; name=&#34;object-generators&#34;&gt;オブジェクト生成器(Object Generators)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;オブジェクト生成器&lt;/em&gt; は関数テンプレートであり、唯一の目的は、 引数から新しいオブジェクトを構築することである。 汎用コンストラクタの一種として考えることが出来るだろう。 オブジェクト生成器は、生成される実際の型を表現するのが難しかったり、出来なかったりするときに、 単なるコンストラクタよりも役立つだろう。 そして生成器の結果は変数に格納するのではなく、直接関数に渡すことも出来る。 多くの Boost オブジェクト生成器は接頭辞 &#34;&lt;code&gt;make_&lt;/code&gt;&#34; がつけられている。 これは、&lt;code&gt;std::make_pair(const T&amp;amp;, constU&amp;amp;)&lt;/code&gt; に倣ってのことである。&lt;/p&gt;
&lt;p&gt;たとえば、次のようなものを考えてみる:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; widget {
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; tweak(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);
};
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;widget &lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; widget_ptrs;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;2つの標準のオブジェクト生成器、 &lt;code&gt;std::bind2nd()&lt;/code&gt; と &lt;code&gt;std::mem_fun()&lt;/code&gt; を連鎖することで、全ての装置を簡単につまむことが出来る:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;tweak_all_widgets1&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; arg)
{
   for_each(widget_ptrs.begin(), widget_ptrs.end(),
      bind2nd(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;widget&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;tweak), arg));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;オブジェクト生成器を使わなければ、上の例は次のようになる:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;tweak_all_widgets2&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; arg)
{
   for_each(struct_ptrs.begin(), struct_ptrs.end(),
      std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;binder2nd&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;mem_fun1_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;, widget, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(
          std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;mem_fun1_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;, widget, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;widget&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;tweak), arg));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;表現がより複雑になるにつれて、型指定の冗長性を減らす必要性はどうしても大きくなるのである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/generic_programming.html#policy-classes&#34; name=&#34;policy-classes&#34;&gt;ポリシークラス(Policy Classes)&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ポリシークラスは振る舞いを伝達するために使われるテンプレート引数である。 標準ライブラリからの例は &lt;code&gt;std::allocator&lt;/code&gt; である。これは、メモリ管理の振る舞いを標準の containers に伝える。&lt;/p&gt;
&lt;p&gt;ポリシークラスは Andrei Alexandrescu によって、 &lt;a href=&#34;http://www.cs.ualberta.ca/~hoover/cmput401/XP-Notes/xp-conf/Papers/7_3_Alexandrescu.pdf&#34; target=&#34;_blank&#34;&gt;この文書&lt;/a&gt; の中で詳しく探求されている。彼は次のように書いている:&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;ポリシークラスは几帳面なデザイン選択の実装である。 これらは他のクラスから派生しているか、他のクラスに含まれていて、 構文的に同じインタフェースの下で、異なる戦略を提供する。 ポリシーを使うクラスは、それが使うそれぞれのポリシーに対してひとつのテンプレート引数を持って、 テンプレート化されている。 このためユーザは必要なポリシーを選択することが出来るのである。

ポリシークラスの力は、その能力を自由に組み合わせることから来る。 テンプレートクラスの中のいくつかのポリシークラスを複数の引数と組み合わせることで、 コードの量をそれほど増やすことなく、組み合わせた振る舞いを実現する。
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Andrei のポリシークラスについての記述は、その力を、 粒状性と直交性から引き出されるものとして述べている。 Boost はおそらく、Iterator Adaptors ライブラリの中でこの特徴を弱めている。 このライブラリでは、適用されたイテレータの振る舞い全てをひとつのポリシークラスに伝えている。 しかし、これには前例がある: &lt;code&gt;std::char_traits&lt;/code&gt; はその名前にもかかわらず、&lt;code&gt;std::basic_string&lt;/code&gt; の振る舞いを決定するポリシークラスとして働いているのである。&lt;/p&gt;
&lt;h2&gt;脚注&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[^1]: 型生成器は、 C++ に 「テンプレートの &lt;code&gt;typedef&lt;/code&gt;」 が存在しないことに対する代替手段である。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Revised 14 Mar 2001&lt;/p&gt;
&lt;p&gt;© Copyright David Abrahams 2001. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:k_takahashi@cppll.jp&#34;&gt;Kohske Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>arrayクラス, 固定サイズ配列のSTLコンテナ -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/array/array.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/array/array.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;arrayクラス, 固定サイズ配列のSTLコンテナ&lt;/h1&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.html#introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.html#interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.html#discussion&#34;&gt;議論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.html#code&#34;&gt;コード例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.html#introduction&#34; name=&#34;introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++ 標準ライブラリの一部である C++ 標準テンプレートライブラリ STL は、さまざまな種類のコンテナに対してアルゴリズムを適用するためのフレームワークを提供している。しかしながら、通常の配列は STL コンテナのインターフェイスには備わっていない(STL コンテナのイテレータとしてのインターフェイスは用意されているけれども)。&lt;/p&gt;
&lt;p&gt;通常の配列を置き換えるものとして、STL では &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt;が提供されているが、&lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; は動的配列のセマンティクスを持つので、要素数が変化する可能性を持つデータを管理対象とする。静的なサイズさえあれば充分な場面では、このことはいくぶんかのオーバーヘッドを生じさせることとなる。&lt;/p&gt;
&lt;p&gt;Matthew H. Austern は彼の本、 &lt;em&gt;Generic Programming and the STL&lt;/em&gt; の中で、 &lt;strong&gt;block&lt;/strong&gt; と名づけられた、静的サイズの通常の配列を扱うとても便利なラッパクラスを紹介している。これは通常の配列よりも安全であり、パフォーマンスもひけを取らない。 &lt;em&gt;The C++ Programming Language, 3rd edition&lt;/em&gt; で、Bjarne Stroustrup は &lt;strong&gt;c_array&lt;/strong&gt; という同じようなクラスを紹介しているが、これは私(&lt;a href=&#34;http://www.josuttis.com/&#34; target=&#34;_blank&#34;&gt;Nicolai Josuttis&lt;/a&gt;)が、私の本 &lt;em&gt;The C++ Standard Library - A Tutorial and Reference&lt;/em&gt; の中で &lt;strong&gt;carray&lt;/strong&gt; と呼んでいるものを少々変更して提供したものだ。ここに紹介するのは、これらのアプローチのエッセンスを、&lt;a href=&#34;http://www.boost.org/&#34; target=&#34;_blank&#34;&gt;boost&lt;/a&gt; からのたくさんのフィードバックで味付けしたものである。&lt;/p&gt;
&lt;p&gt;いろいろな名前を考えたすえ、このクラスの名前はシンプルに &lt;strong&gt;array&lt;/strong&gt; と決定した。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.html#interface&#34; name=&#34;interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このクラスは以下のインターフェイスを提供する。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;型:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;value_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素の型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イテレータの型(ランダムアクセス・イテレータ)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定数とされる要素へのイテレータの型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reference&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素の参照の型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const_reference&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定数とされる要素への参照の型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号付のサイズの型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;difference_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号なしの距離(差分)の型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;操作:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;array&amp;lt;type,num&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デフォルトコンストラクタ。&lt;code&gt;num&lt;/code&gt; (要素数)個の&lt;code&gt;type&lt;/code&gt; (型)を要素とする配列を作成する。下のコメントを参照。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;array&amp;lt;type,num&amp;gt;(a)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ&lt;code&gt;a&lt;/code&gt; のすべての要素をコピーする。(&lt;code&gt;a&lt;/code&gt; は同じ &lt;code&gt;type&lt;/code&gt; と &lt;code&gt;num&lt;/code&gt; でなければならない)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代入。すべての要素を代入する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;assign(val)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;すべての要素に &lt;code&gt;val&lt;/code&gt; を代入する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最初の要素へのイテレータを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最後の要素の次の位置へのイテレータを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rbegin()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逆イテレーションでの最初の要素を指す逆イテレータを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rend()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逆イテレーションでの最後の要素のひとつ後ろ(behind)を指す逆イテレータを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator[i]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;インデックス &lt;code&gt;i&lt;/code&gt; の要素を返す(範囲チェックなし)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;at(i)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;インデックス &lt;code&gt;i&lt;/code&gt; の要素を返す(&lt;code&gt;i&lt;/code&gt; が不正な場合は &lt;code&gt;std::range_error&lt;/code&gt; を送出する)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;front()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最初の要素を返す(要素が存在することを呼び出し側で保証しなければならない)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;back()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最後の要素を返す(要素が存在することを呼び出し側で保証しなければならない)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;data()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;生の配列を読み取り専用として返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;size()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;配列が空かどうかを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max_size()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;格納可能な要素数の最大値を返す(&lt;code&gt;size()&lt;/code&gt; と同じ)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;swap(a)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;array a&lt;/code&gt; と要素を交換する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;==, !=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等値性を調べる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;array&lt;/code&gt; の比較演算。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;値:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;定数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static_size&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時の要素数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.html#discussion&#34; name=&#34;discussion&#34;&gt;議論&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;array&lt;/code&gt; クラスは&#34;reversible container&#34;(C++ 標準 Section 23.1, [lib.container.requirements] を参照)の要件のほとんどを満たしているが、完全にではない。&lt;code&gt;array&lt;/code&gt; が reversible な STL コンテナではない理由は以下のとおりである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供されるべきコンストラクタがない&lt;/li&gt;
&lt;li&gt;要素が不確定な初期値を持つ可能性がある(以下を参照)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap()&lt;/code&gt; の計算量が定数ではない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size()&lt;/code&gt; が常に一定で、型の第2テンプレート引数によって決定される。&lt;/li&gt;
&lt;li&gt;アロケータのサポートを提供しないコンテナである。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、&#34;sequence&#34;(C++標準Section 23.1.1, [lib.sequence.reqmts]参照)であるための要件を、以下のものを除いて満たしていない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;front()&lt;/code&gt; と &lt;code&gt;back()&lt;/code&gt; が提供されている。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator[]&lt;/code&gt; と &lt;code&gt;at()&lt;/code&gt; が提供されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンストラクタの点に関しては、重要な設計上のトレードオフを行い、(それによって)&#34;&lt;strong&gt;aggregate&lt;/strong&gt;&#34;( C++ 標準 Section 8.5.1, [dcl.init.aggr] を参照)として &lt;code&gt;array&lt;/code&gt; を実装することができた。つまり、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt; は、ブレースで囲まれ、要素番号の昇順に並べられ、カンマで区切られたコンテナの要素への初期値のリストによって初期化することができる。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::array&amp;lt;int,4&amp;gt; a = { { 1, 2, 3 } };&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;リスト内の初期値の数が足りない場合、残りの要素はデフォルト値のままになる(したがって定義された値を持つ)ことに注意しよう。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;しかしながら、&lt;code&gt;初期値のリストをないままにすると、要素は不確定の初期値をもつことになる。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ユーザー定義のコンストラクタを持たない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt; あるいは &lt;code&gt;protected&lt;/code&gt; な 非 &lt;code&gt;static&lt;/code&gt; データメンバをもたない。&lt;/li&gt;
&lt;li&gt;基底クラスを持たない。&lt;/li&gt;
&lt;li&gt;仮想関数を持たない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現在の実装はこのようなアプローチをとっているが、不確定な初期値を持つ可能性があることは大きな問題点である。そこで、この点に関してこのようにすべきだというあなたの考えを、ぜひフィードバックしてほしい。ここから導かれる &lt;strong&gt;未解決の問題点&lt;/strong&gt; は以下のようなものだ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初期化リストをサポートするべきか、あるいは次のようなものでOKか？&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int data[] = { 1, 2, 3, 4 }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array&amp;lt;int,5&amp;gt; x(data);&lt;/code&gt; あるいは  &lt;code&gt;array&amp;lt;int,data&amp;gt; x;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可搬性のために、初期化リストとして、&#34;&lt;code&gt;{ { ... } }&lt;/code&gt;&#34;のかわりに、&#34;&lt;code&gt;{ ... }&lt;/code&gt;&#34;を使えるようにするべきだろうか？&lt;ul&gt;
&lt;li&gt;規格の 8.5.1 (11) ではこれは許されているようだが、gcc 2.95.2 では警告メッセージを表示する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;初期値の決定と、初期化リストのサポートのための、別の方法があるだろうか？&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red;&#34;&gt;逆イテレータのstuffのための Static_casts はどうするか？&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;span style=&#34;color:red;&#34;&gt;原文は「Static_casts for reverse iterator stuff?」。よくわかりません…&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建設的な&lt;a href=&#34;mailto:solutions@josuttis.com&#34;&gt;フィードバック&lt;/a&gt;はどのようなものでも歓迎する。&lt;strong&gt;注意してほしいのは、boostメーリングリストのすべてのメールを読むだけの時間が、私にはないという点だ。というわけで、確実にフィードバックが私に届くようにするため、このクラスに関するメールについては、私にコピーを送ってほしい。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.html#code&#34; name=&#34;code&#34;&gt;コード例&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下のコードは「このままの形(as is)」で提供され、明示的あるいは暗黙的な保証はない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array.hpp.html&#34;&gt;&lt;strong&gt;array.hpp&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;array&amp;lt;&amp;gt;&lt;/code&gt; の実装ファイル&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array1.cpp.html&#34;&gt;&lt;strong&gt;array1.cpp&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;array&amp;lt;&amp;gt;&lt;/code&gt;を使った簡単な例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array2.cpp.html&#34;&gt;&lt;strong&gt;array2.cpp&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;array&amp;lt;&amp;gt;&lt;/code&gt;を使った別の例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array3.cpp.html&#34;&gt;&lt;strong&gt;array3.cpp&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;array&amp;lt;&amp;gt;&lt;/code&gt;を使った三つ目の例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array4.cpp.html&#34;&gt;&lt;strong&gt;array4.cpp&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;array&amp;lt;&amp;gt;&lt;/code&gt; の &lt;code&gt;array&amp;lt;&amp;gt;&lt;/code&gt; を使った例&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array/array5.cpp.html&#34;&gt;&lt;strong&gt;array5.cpp&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;array&amp;lt;&amp;gt;&lt;/code&gt; の他の操作をテストする例&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ref.hpp -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/bind/ref.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;ref.hpp&lt;/h1&gt;
&lt;p&gt;1.00.0004 (2002-01-27)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/doc/html/ref.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/doc/html/ref.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#files&#34;&gt;ファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#purpose&#34;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#files&#34; name=&#34;files&#34;&gt;ファイル&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ref.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#purpose&#34; name=&#34;purpose&#34;&gt;目的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;boost/ref.hpp ヘッダーでは、クラス テンプレートである &lt;code&gt;boost::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; と、&lt;code&gt;boost::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; のインスタンスを返す二つの関数 &lt;code&gt;boost::ref&lt;/code&gt; と &lt;code&gt;boost::cref&lt;/code&gt;、それに二つの特性クラス &lt;code&gt;boost::is_reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;boost::unwrap_reference&amp;lt;T&amp;gt;&lt;/code&gt; が定義されている。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; の目的は、&lt;code&gt;T&lt;/code&gt; 型のオブジェクトへの参照を格納することにある。主に、値渡しの仮引数をとる関数のテンプレート (アルゴリズム) に参照を「食わせる (feed)」のに使われる。&lt;/p&gt;
&lt;p&gt;この使い方をサポートするため、&lt;code&gt;boost::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; は &lt;code&gt;T &amp;amp;&lt;/code&gt; への暗黙の型変換を提供する。このことにより、関数テンプレートが適合していない参照に対しても大抵はうまく働くようになる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost::reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt; は &lt;code&gt;CopyConstructible&lt;/code&gt;（コピーコンストラクト可能) でかつ &lt;code&gt;Assignable&lt;/code&gt; (代入可能) である (通常の参照は &lt;code&gt;Assignable&lt;/code&gt; (代入可能) ではない)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; の型である場合、&lt;code&gt;boost::ref(x)&lt;/code&gt; という式は &lt;code&gt;boost::reference_wrapper&amp;lt;X&amp;gt;(x)&lt;/code&gt; を返す。同様に、&lt;code&gt;boost::cref(x)&lt;/code&gt; は &lt;code&gt;boost::reference_wrapper&amp;lt;X const&amp;gt;(x)&lt;/code&gt; を返す.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost::is_reference_wrapper&amp;lt;T&amp;gt;::value&lt;/code&gt; という式は、もし &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;reference_wrapper&lt;/code&gt; であるときには &lt;code&gt;true&lt;/code&gt; を返し、それ以外のときには &lt;code&gt;false&lt;/code&gt; を返す。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost::unwrap_reference&amp;lt;T&amp;gt;::type&lt;/code&gt; という型式 (type-expression) は、&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;reference_wrapper&lt;/code&gt; のときには &lt;code&gt;T::type&lt;/code&gt; であり、それ以外のときには &lt;code&gt;T&lt;/code&gt; である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#interface&#34; name=&#34;interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Synopsis&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#reference_wrapper&#34;&gt;class reference_wrapper&lt;/a&gt;;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ref(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; cref(T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#is_reference_wrapper&#34;&gt;is_reference_wrapper&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#unwrap_reference&#34;&gt;unwrap_reference&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#reference_wrapper&#34; name=&#34;reference_wrapper&#34;&gt;reference_wrapper&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;reference_wrapper&lt;/span&gt;
{
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; T type;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;reference_wrapper&lt;/span&gt;(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;

    T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; get() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
    T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h4&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#op_constructor&#34; name=&#34;op_constructor&#34;&gt;&lt;code&gt;explicit reference_wrapper(T &amp;amp; t)&lt;/code&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;作用: &lt;code&gt;t&lt;/code&gt; への参照を格納する &lt;code&gt;reference_wrapper&lt;/code&gt; のオブジェクトを構築する。&lt;/li&gt;
&lt;li&gt;例外: なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#op_t&#34; name=&#34;op_t&#34;&gt;&lt;code&gt;operator T &amp;amp; () const&lt;/code&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;戻り値: 格納した参照。&lt;/li&gt;
&lt;li&gt;例外: なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#get&#34; name=&#34;get&#34;&gt;&lt;code&gt;T &amp;amp; get() const&lt;/code&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;戻り値: 格納した参照。&lt;/li&gt;
&lt;li&gt;例外: なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#get_pointer&#34; name=&#34;get_pointer&#34;&gt;&lt;code&gt;T* get_pointer() const&lt;/code&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;戻り値: 格納したオブジェクトへのポインタ。&lt;/li&gt;
&lt;li&gt;例外: なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#ref&#34; name=&#34;ref&#34;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ref(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値: &lt;code&gt;reference_wrapper&amp;lt;T&amp;gt;(t)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外: なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#cref&#34; name=&#34;cref&#34;&gt;&lt;code&gt;cref&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; cref(T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値: &lt;code&gt;reference_wrapper&amp;lt;T const&amp;gt;(t)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外: なし。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#is_reference_wrapper&#34; name=&#34;is_reference_wrapper&#34;&gt;&lt;code&gt;is_reference_wrapper&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;is_reference_wrapper&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
{
 &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; value &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;i&gt;unspecified&lt;/i&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;reference_wrapper&lt;/code&gt; の特殊化版であれば値は &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#unwrap_reference&#34; name=&#34;unwrap_reference&#34;&gt;unwrap_reference&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unwrap_reference&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
{
 &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;i&gt;unspecified&lt;/i&gt; type;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;reference_wrapper&lt;/code&gt; の特殊化版であれば &lt;code&gt;type&lt;/code&gt; は &lt;code&gt;T::type&lt;/code&gt; と等価。そうでなければ &lt;code&gt;type&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; と等価。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ref&lt;/code&gt; と &lt;code&gt;cref&lt;/code&gt; は元々は Jaakko Järvi 氏作の Boost.Tuple というライブラリの一部であった。それが、一般的に有用であるという理由で Peter Dimov 氏の手によって「&lt;code&gt;boost::&lt;/code&gt; に昇格」した。Douglas Gregor 氏と Dave Abrahams 氏が &lt;code&gt;is_reference_wrapper&lt;/code&gt; と &lt;code&gt;unwrap_reference&lt;/code&gt; を提供した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2001 by Peter Dimov and Multi Media Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:f_kojima@fukuicompu.co.jp&#34;&gt;Fujio Kojima&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.Compatibilty ライブラリ -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/compatibility.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/compatibility.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost.Compatibilty ライブラリ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/compatibility/&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/compatibility/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このライブラリは、boostライブラリが規格に準拠していないプラットフォームでも利用できるようにするための回避手段を提供するものである。我々は、よりいっそう規格に準拠した標準ライブラリが提供され、いつかこのライブラリを削除できる日がくることを望んでいる。&lt;/p&gt;
&lt;h2&gt;C++標準ライブラリのCXXヘッダ(例 &lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt;)が見当たらない場合の回避策&lt;/h2&gt;
&lt;p&gt;Pythonスクリプト generate_cpp_c_headers.py は、いくつかのプラットフォームでは見当たらない C++ の C ヘッダ(例 &lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt;) を生成することができる。このスクリプトによって生成されたヘッダファイルはboost/compatibility/cpp_c_headersディレクトリの中に存在する。このヘッダを使うには、ファイル検索パスにこのディレクトリを追加すればよい。たとえば以下のようにする。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;cxx -I/usr/local/boost/boost/compatibility/cpp_c_headers ...
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;サポートしているプラットフォーム:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compaq Alpha, RedHat 6.2 Linux, Compaq C++ V6.3 (cxx)&lt;/li&gt;
&lt;li&gt;Compaq Alpha, Tru64 Unix V5.0, Compaq C++ V6.2 (cxx)&lt;/li&gt;
&lt;li&gt;Silicon Graphics, IRIX 6.5, MIPSpro コンパイラ: Version 7.3.1.1m (CC)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://www.stlport.org/&#34; target=&#34;_blank&#34;&gt;STLport&lt;/a&gt; や &lt;a href=&#34;http://www-pat.fnal.gov/personal/wb/boost/&#34; target=&#34;_blank&#34;&gt;ISOCXX&lt;/a&gt; のように、Boost.Compatibility を用いるよりもっと強力な代替手段も存在する。しかし、これらの代替手段と比べ、generate_cpp_c_headers.py はたいへん軽量(コメント抜きで100行以下のPythonコード)で、まして大げさでもなく、きわめて簡単に維持できるため、一時的な回避手段としてはより適切である。&lt;/p&gt;
&lt;p&gt;以上は Ralf W. Grosse-Kunstleve によって寄稿されたものである。&lt;/p&gt;
&lt;h2&gt;C++標準ライブラリ&lt;code&gt;&amp;lt;limits&amp;gt;&lt;/code&gt;ヘッダが見当たらない場合の回避手段、boost/limits.hpp&lt;/h2&gt;
&lt;p&gt;Boostライブラリのうちのいくつかは標準ライブラリ&lt;code&gt;&amp;lt;limits&amp;gt;&lt;/code&gt;を必要とする。しかし、このヘッダは規格に準拠していないコンパイラやライブラリがいつでも提供しているとは限らない。boost/limits.hppは、標準ライブラリ&lt;code&gt;&amp;lt;limits&amp;gt;&lt;/code&gt;が利用可能であるならそれを単純にインクルードしているが、そうでないならboost/detail/limits.hppをインクルードしている。boost/config.hppの&lt;code&gt;BOOST_NO_LIMITS&lt;/code&gt;は&lt;code&gt;&amp;lt;limits&amp;gt;&lt;/code&gt;ヘッダが利用可能か決定するために使われる。&lt;/p&gt;
&lt;p&gt;テストプログラム limits_test.cpp も参照せよ。&lt;/p&gt;
&lt;p&gt;以上は Jens Maurer によって寄稿されたものである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;© Copyright Ralf W. Grosse-Kunstleve 2001. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Updated: April 16, 2001&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:samba@pal.tok2.com&#34;&gt;kazu.y&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost Date-Time Library Documentation -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost Date-Time Library Documentation&lt;/h1&gt;
&lt;p&gt;Version 1.00&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/date_time/doc/index.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/date_time/doc/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;概要&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#usage-examples&#34;&gt;Usage Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#domain-concepts&#34;&gt;Domain Concepts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#tests&#34;&gt;Tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#design-and-extensions&#34;&gt;Design and Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#more-info&#34;&gt;More Info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html&#34;&gt;Build-Compiler Information&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日付プログラミング&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorian Date System&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html&#34;&gt;Class date&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html&#34;&gt;Class date_duration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html&#34;&gt;Class date_period&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html&#34;&gt;Date Iterators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html&#34;&gt;Date Generators / Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html&#34;&gt;Class gregorian_calendar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construct-from-clock&#34;&gt;Class day_clock&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;時間プログラミング&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Time System&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html&#34;&gt;Class ptime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html&#34;&gt;Class time_duration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html&#34;&gt;Class time_period&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html&#34;&gt;Time Iterators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html&#34;&gt;UTC / Local Time Adjustments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ジェネリックプログラミングの概念に基づいた日付・時間ライブラリ&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#motivation&#34; name=&#34;motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このライブラリの開発動機は、多くのプロジェクトの多くの日付時間ライブラリで動作すること、また、それらの構築を手助けすることである。 日付時間ライブラリは多くの開発プロジェクトに対して、基礎的な構造を提供する。 しかしそれらの多くは、計算、書式化、変換、その他のいくつかの機能に限界がある。 例えば多くのライブラリは、うるう秒を正しく扱うこと、無限のような概念を提供すること、高分解能の時間資源やネットワーク上の時間資源を利用することが出来ない。 そのうえ、これらのライブラリは、どれも日付や時間の表現形式が厳密である傾向にあるため、プロジェクトやサブプロジェクトのためにカスタマイズすることが出来ない。&lt;/p&gt;
&lt;p&gt;日付や時間に関するプログラミングは、文字列や整数に関するプログラミングと同じくらいシンプルで自然であるべきである。 多くの時間論理を備えたアプリケーションは、演算子と計算能力の頑健な集合により、根本的に単純化することができる。 クラスは日付時間の比較、時間の長さ(length)や期間(duration)の加算、時計からの日付時間の取得、日付時間間隔(interval)に関する自然な動作を提供すべきである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#usage-examples&#34; name=&#34;usage-examples&#34;&gt;Usage Examples&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;次に，グレゴリオ暦システムの使用例を示す。 詳細は「&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;日付プログラミング&lt;/a&gt;」で解説する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;gregorian; 
date &lt;span style=&#34;color: #0000FF&#34;&gt;weekstart&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;2002&lt;/span&gt;,Feb,&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);
date &lt;span style=&#34;color: #0000FF&#34;&gt;weekend&lt;/span&gt;  (&lt;span style=&#34;color: #666666&#34;&gt;2002&lt;/span&gt;,Feb,&lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt;);
date_duration &lt;span style=&#34;color: #0000FF&#34;&gt;fiveDays&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;); 
date d3 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d1 &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; fiveDays;
date today &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; day_clock&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;local_day();
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (d3 &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;=&lt;/span&gt; today) {} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//date comparison operators&lt;/span&gt;

date_period thisWeek(d1,d2);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (thisWeek.contains(today)) {}&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//do something&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//iterate and print the week&lt;/span&gt;
day_iterator itr(weekstart);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (; itr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;=&lt;/span&gt; weekend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;itr) {
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; to_iso_extended_string(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;itr) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;そして &lt;code&gt;posix_time&lt;/code&gt; システムの使用例である。 詳細は「&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;時間プログラミング&lt;/a&gt;」で解説する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;posix_time; 
date &lt;span style=&#34;color: #0000FF&#34;&gt;d&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;2002&lt;/span&gt;,Feb,&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//an arbitrary date&lt;/span&gt;
ptime &lt;span style=&#34;color: #0000FF&#34;&gt;t1&lt;/span&gt;(d, hours(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;nanosec(&lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;));&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//date + time of day offset&lt;/span&gt;
ptime t2 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; t1 &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; minutes(&lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;seconds(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;);
ptime now &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; second_clock&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;local_time(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//use the clock&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//Get the date part out of the time&lt;/span&gt;
date today &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; now.date();
date tommorrow &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; today &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; date_duration(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);
ptime &lt;span style=&#34;color: #0000FF&#34;&gt;tommorrow_start&lt;/span&gt;(tommorrow); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//midnight &lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//starting at current time iterator adds by one hour&lt;/span&gt;
time_iterator &lt;span style=&#34;color: #0000FF&#34;&gt;titr&lt;/span&gt;(now,hours(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)); 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (; titr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; tommorrow_start; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;titr) {
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; to_simple_string(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;titr) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#domain-concepts&#34; name=&#34;domain-concepts&#34;&gt;Domain Concepts&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;日付・時間の分野には専門用語と問題が多い。以下はライブラリ中に見られる概念の簡単な紹介である。&lt;/p&gt;
&lt;p&gt;このライブラリは3つの基本的な時間型をサポートする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Time Point&lt;ul&gt;
&lt;li&gt;時間位置。時刻。連続する時間内での位置を示す&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Time Duration&lt;ul&gt;
&lt;li&gt;時間長。時間連続体においてどの位置にも結びついていない時間の長さ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Time Interval&lt;ul&gt;
&lt;li&gt;時間間隔。時間連続体の特定の位置に結びついた時間長。期間とも&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの時間型にはそれぞれ表現可能な最小の時間間隔(duration)で定義される &lt;strong&gt;分解能&lt;/strong&gt; がある。 &lt;strong&gt;時法系(Time system)&lt;/strong&gt; は、時刻にラベルを付けて計算するための規則はもちろんのこと、これらすべての時間型も提供する。 &lt;strong&gt;暦法系(Calendar system)&lt;/strong&gt; は最大の分解能(1日)を持っている簡素な時法系である。 &lt;strong&gt;グレゴリオ暦&lt;/strong&gt; は今日最も広く使われている暦法系である(ISOシステムは基本的にこれの派生物である)。 しかし、他にも多くの暦法系がある。 &lt;strong&gt;UTC(Coordinated Universal Time;協定標準時)&lt;/strong&gt; は広く使われている民間の時法系である。UTC がうるう秒（これは、必要に応じて適用されるもので、予測可能ではない）の使用によって経度0において地球自転に対して調整される。 たいていの &lt;strong&gt;地域時間システム&lt;/strong&gt; が UTC に基づいているが、地球自転に対して同じように調整されるために、昼時間はどこでも同じである。 さらに、夏の昼時間を長くするためのサマータイム(DST)調整を含む地域時間もある。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;クロックデバイス&lt;/strong&gt; は時法系に関して現在の日付あるいは時刻を供給する(あるハードウェアに結び付けられた)ソフトウェアコンポーネントである。&lt;/p&gt;
&lt;p&gt;ライブラリは日付と時間の計算をサポートする。しかしながら、時間の計算は整数の計算と全く同じというわけにはいかない。 もし、時間計算の正確度(accuracy)が重要ならば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/tradeoffs.html&#34;&gt;Stability, Predictability, and Approximations(安定性、予測性と近似)&lt;/a&gt;を読む必要がある。&lt;/p&gt;
&lt;p&gt;追加資料を以下に示す&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/basic_terms.html&#34;&gt;基本的な専門用語&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html&#34;&gt;計算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/tradeoffs.html&#34;&gt;安定性、予測性と近似&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html&#34;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#tests&#34; name=&#34;tests&#34;&gt;Tests&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ライブラリは、以下のディレクトリで多数のテストを提供している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;libs/date_time/test &lt;/li&gt;
&lt;li&gt;libs/date_time/test/gregorian&lt;/li&gt;
&lt;li&gt;libs/date_time/test/posix_time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらのテストをビルドして実行することで、ライブラリが正しくインストールされ、確実に機能していることを確認できる。 加えて、これらのテストは新しいコンパイラへの移植を容易にする。 最後に、テストは使用例で明示的に記述されない多くの機能の例を提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#design-and-extensions&#34; name=&#34;design-and-extensions&#34;&gt;Design and Extensions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このライブラリの起源の大部分は（今まで）ほとんどの日付時間ライブラリがカスタマイズと拡張を許す方法で構築されないという観察であった。 典型的な例では、カレンダーロジックは直接日付クラスに構築される。 あるいは時計検索機能は直接時間クラスに作り上げられる。 これらのデザイン決定は通常、拡張したりライブラリの振る舞いを変更することを不可能にする。 もっと基本的なレベルにおいては、時間表現あるいはグレゴリオ暦の分解能について通常仮定がある。&lt;/p&gt;
&lt;p&gt;高分解能の時間表現やそれ以外の仮定からの要求を、時間ライブラリの実装が満たすことが出来ないために、結果的に不完全なライブラリを使わざるをえない、というのは、よくあることである。 この種のライブラリの開発は、まったく些細なことではないので、こういう結果は非常に残念なことである。&lt;/p&gt;
&lt;p&gt;（このライブラリの）設計は完璧というには程遠いが、それでも現在の設計は、著者の知るどんな時間ライブラリよりもはるかに柔軟である。 将来のバージョンでは、拡張性のさまざまな面について、さらに文書化されることが期待される。 ライブラリの設計目標についての情報は&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/DesignGoals.html&#34;&gt;ここ&lt;/a&gt;に要約されている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Many people have contributed to the development of this library. In particular Hugo Duncan and Joel de Guzman for help with porting to various compilers. For initial development of concepts and design Corwin Joy and Michael Kenniston deserve special thanks. Also extra thanks to Michael for writing up the theory and tradeoffs part of the documentation. Dave Zumbro for initial inspiration and sage thoughts. Many thanks to boost reviewers and users including: William Seymour, Kjell Elster, Beman Dawes, Gary Powell, Andrew Maclean, William Kempf, Peter Dimov, Chris Little, David Moore, Darin Adler, Gennadiy Rozental, Joachim Achtzehnter, Paul Bristow, Jan Langer, Mark Rodgers, Glen Knowles, Matthew Denman, and George Heintzelman.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#more-info&#34; name=&#34;more-info&#34;&gt;More Info&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;現在、ライブラリの設計はWikiと電子メールによる議論によって発展している。 詳しい情報はこちらへ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?GDTL&#34; target=&#34;_blank&#34;&gt;Boost Wiki GDTL Start Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.crystalclearsoftware.com/libraries/date_time/index.html&#34; target=&#34;_blank&#34;&gt;Full Doxygen Reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Thu Sep 5 07:22:00 MST 2002 by Jeff Garland © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>全体的な設計の目標 -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/DesignGoals.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/DesignGoals.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;全体的な設計の目標&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分類&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;インタフェース&lt;/td&gt;
&lt;td&gt;日付と時間を操作するための具体的なクラスを提供する&lt;/td&gt;
&lt;td&gt;・&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;date_duration&lt;/code&gt;, &lt;code&gt;time_duration&lt;/code&gt;, &lt;code&gt;date_period&lt;/code&gt;, &lt;code&gt;time_period&lt;/code&gt;, ほかにも&lt;br /&gt; 無限数のサポート - 正の無限大, 負の無限大&lt;br /&gt; ・時間と日付の範囲に対するイテレータ&lt;br /&gt; ・日付と時間の実装を可能な限り分離するよう考慮する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;計算&lt;/td&gt;
&lt;td&gt;効率的な時間計算を行うための基盤を提供する&lt;/td&gt;
&lt;td&gt;・日付の間の日数&lt;br /&gt; ・時間の差&lt;br /&gt; ・日付と時間を併せた時間長(durations)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表現の柔軟性&lt;/td&gt;
&lt;td&gt;最大限の再利用性と柔軟性を提供する&lt;/td&gt;
&lt;td&gt;・サイズと分解能を制御するための、traits に基づいた内部表現のカスタマイズ&lt;br /&gt; 異なるエポック(epoch)と分解能の使用が可能 (例:秒とマイクロ秒、2000年から始まる日付と1700年から始まる日付)&lt;br /&gt; ・独特な暦法の内部表現を設定するためのオプション (グレゴリオ暦 + その他)&lt;br /&gt; ・ユリウス通日(Julian Day Number)の使用、および、ユリウス通日とグレゴリオ暦/ユリウス暦との日付変換&lt;br /&gt; ・うるう秒を含む柔軟な調整を考慮する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日付の計算&lt;/td&gt;
&lt;td&gt;日付計算用のツールを提供&lt;/td&gt;
&lt;td&gt;・祝祭日のような複雑な行事予定を計算するための基盤を提供する&lt;br /&gt; ・ある暦法から別の暦法への変換&lt;br /&gt; ・新たな暦法系に拡張するための能力を提供&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;時間の計算&lt;/td&gt;
&lt;td&gt;時間を操作するための具体的なクラスを提供&lt;/td&gt;
&lt;td&gt;・異なった時間帯にまたがる問題を取り扱うための能力を提供&lt;br /&gt; ・昼時間の調整(サマータイム)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;クロックインタフェース&lt;/td&gt;
&lt;td&gt;現在の時刻を取得するクラスを提供&lt;/td&gt;
&lt;td&gt;・ネットワーク、高分解能時間源(time source)へのアクセス&lt;br /&gt; ・クラスに代入するための、現在の日付時間情報を取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O インタフェース&lt;/td&gt;
&lt;td&gt;時間を含む入出力を提供&lt;br /&gt;&lt;/td&gt;
&lt;td&gt;・多言語サポート&lt;br /&gt; ・ISO8601 に準拠した時間面&lt;br /&gt; ・異なるローカル(環境)での振る舞いのためにI/O面を使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 21 15:42:19 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Date-Timeの専門用語 -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/basic_terms.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/basic_terms.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Date-Timeの専門用語&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下は日付・時間分野に関する用語である。&lt;/p&gt;
&lt;p&gt;時間型の分類:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;時間位置(Timepoint)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;時間連続体(time continuum)の中の特定の位置を表す。定規の目盛に似ている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;時間長(Timelength)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;時間連続体中のどの時間位置にも関係しない時間の長さ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;時間間隔(Timeinterval)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;時間連続体中の特定の時間位置に関係する時間の長さ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他の用語:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;正確度(Accuracy)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;誤差の単位, クロックから読み出した時間と真の時間との差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;暦法系(Calendar System)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;日付レベルの分解能で時間位置(time points)にラベルを付ける体系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;クロックデバイス&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;暦法系あるいは時法系に関して現在の日付や時刻を供給する(あるハードウェアに結び付けられた)ソフトウェアコンポーネント。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精密度(Precision)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;クロック間隔の計測単位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分解能(Resolution)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;時法系/暦法系あるいは時間型で表現可能な最小の時間間隔(例: 1秒，一世紀)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安定性(Stability)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;根本的な表現（実装）が特定の（抽象的な）値に関連付いたことを示すクラスの特性は決して変化しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;時法系(Time System)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;日付レベルより高い分解能で時間位置(time points)にラベル付けするための体系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準的な日付・時間用語:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;エポック(Epoch)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;時法系/暦法系の始点となる時間位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;夏時間(DST)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Daylight Savings Time; いくつかの地域で夏期に日照時間を延長するために使われている地域時間の調整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;時間帯(Time zone)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;「地域時間」を提供するために、夏時間(DST)規則と協定標準時(UT)からのオフセットで定義される地球上の地域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;協定標準時(UTC Time)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;Coordinated Universal Time; 経度0 で計測される民間の時法系。 うるう秒を使用することで、地球自転に適応されている。 ズールー時間(Zulu Time)として知られる。 グリニッジ標準時(Greenwich Mean Time)として知られている類似の時法系を置き換えた。 詳細は &lt;a href=&#34;http://aa.usno.navy.mil/faq/docs/UT.html&#34; target=&#34;_blank&#34;&gt;http://aa.usno.navy.mil/faq/docs/UT.html&lt;/a&gt; を参照されたい&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TAI Time&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;世界中の原子時計を使って 0.1 マイクロ秒の分解能で計測される、高精度で単調な時法系(もっと良い用語が必要)。 地球の自転には適応していない。詳細は &lt;a href=&#34;http://www.bipm.fr/enus/5_Scientific/c_time/time_server.html&#34; target=&#34;_blank&#34;&gt;http://www.bipm.fr/enus/5_Scientific/c_time/time_server.html&lt;/a&gt; を参照されたい&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;さらにいくつかの実験的なもの:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;地域時間(Local Time)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;世界の特定の地域で測定される時間&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time Label&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;暦法系あるいは時法系に関して、完全にあるいは部分的に特定の日付時間を明示するタプル。これは年-月-日の表現である。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;時間長の調整(Adjusting Time Length)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;その時々に依存した物理的な時間の長さを表現する時間長(duration)。 例えば、1ヶ月間の時間長(duration)は一般に日数の定数ではない。 その実際の長さは、評価する日付に依存して決定される。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;設計に関する用語:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;生成関数(Generation function)&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;一つ以上のパラメータからなる特定の時間位置(time points), 長さ(length), あるいは間隔(intervals)の集合を生成する関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;訳注: &lt;/p&gt;
&lt;p&gt;時間用語の訳語について、国土地理院の地理情報標準第2版にある&lt;a href=&#34;http://www.gsi.go.jp/GIS/stdind/stdindpdf/jsgi02.pdf&#34; target=&#34;_blank&#34;&gt;時間スキーマ&lt;/a&gt;を参考にしてみました。&lt;/p&gt;
&lt;p&gt;Accuracy と Precision の使い分けは&lt;a href=&#34;http://www.mathworks.com/access/helpdesk/jhelp/toolbox/daq/c1_int15.shtml&#34; target=&#34;_blank&#34;&gt;ここ&lt;/a&gt;を参考にしました。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Date-Time Build-Compiler Information -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/build_info.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Date-Time Build-Compiler Information&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Build-Compiler Information&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compilation-options&#34;&gt;Compilation Options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/compiler-portability-notes&#34;&gt;Compiler/Portability Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#directory-structure&#34;&gt;Directory Structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#required-boost-libraries&#34;&gt;Required Boost Libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#overview&#34; name=&#34;overview&#34;&gt;Overview&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ライブラリ関数のいくつかはライブラリファイルを作成する必要がある。 これらの関数を含むライブラリ( &lt;strong&gt;libboost_date_time&lt;/strong&gt; )を作成するには、buildディレクトリにあるJamfileを使う。&lt;/p&gt;
&lt;p&gt;変数&lt;code&gt;DATE_TIME_INLINE&lt;/code&gt;は、ある特定のコア関数のインライン化を制御する。 デフォルトでこの変数はライブラリのコンパイル時に定義されている。 ライブラリを使っている全てのコンパイル単位でこの定義を含んでいなければ、リンクエラーになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compilation-options&#34; name=&#34;compilation-options&#34;&gt;Compilation Options&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;デフォルトでは &lt;code&gt;posix_time&lt;/code&gt; はナノ秒レベルの精度を提供するために内部で 64bit整数と32bit整数を使う。 選択肢として、一つの 64bit整数でマイクロ秒レベルの精度を提供することもできる。 この代替実装は、ナノ秒精度を必要としない多くのアプリケーションでパフォーマンスの向上と省メモリが期待できる。&lt;/p&gt;
&lt;p&gt;変数&lt;code&gt;BOOST_DATE_TIME_POSIX_TIME_STD_CONFIG&lt;/code&gt;はbuild/Jamfileで定義されており、これらのオプションを選択する。 64bit整数版を使う場合、単にJamfileからこの定義を削除する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compiler-portability-notes&#34; name=&#34;compiler-portability-notes&#34;&gt;Compiler/Portability Notes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost Date-Time libraryは、多くのコンパイラでビルドされテストされた。 しかしながら、いくつかのコンパイラと標準ライブラリで問題がある。 これらの問題のいくつかは回避可能であるが、回避できない問題も残っている。 以下のコンパイラはライブラリの機能を完全にサポートしている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 3.0.3 on Linux&lt;/li&gt;
&lt;li&gt;GCC 3.1 (cygwin)&lt;/li&gt;
&lt;li&gt;MSVC 7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特に、標準ロケールに対するサポートが完全でないと &lt;code&gt;iostream&lt;/code&gt; ベースの入出力サポートが制約される事がある。そういったコンパイラのために、より限定された文字列ベースの入出力を提供している。&lt;/p&gt;
&lt;p&gt;以下のコンパイラ及び標準ライブラリはこの制約を含む&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 2.9x on Linux&lt;/li&gt;
&lt;li&gt;Borland 5.1.1 and 5.6&lt;/li&gt;
&lt;li&gt;MSVC 6 SP5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ComeauやMetroworksといった他のコンパイラでは、ライブラリの初期バージョンでテストに成功している。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#directory-structure&#34; name=&#34;directory-structure&#34;&gt;Directory Structure&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;date_time&lt;/code&gt;のディレクトリ構成はBoostに合わせて変更された。&lt;/p&gt;
&lt;p&gt;ディレクトリ構成は次のようになっている&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ディレクトリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time&lt;/td&gt;
&lt;td&gt;共通ヘッダ及びテンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time/gregoran&lt;/td&gt;
&lt;td&gt;グレゴリオ暦システムのヘッダファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time/posix_time&lt;/td&gt;
&lt;td&gt;Posix Time系のヘッダファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/build&lt;/td&gt;
&lt;td&gt;ビルドファイルと出力ディレクトリ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test&lt;/td&gt;
&lt;td&gt;ジェネリックコードに関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test/gregorian&lt;/td&gt;
&lt;td&gt;グレゴリオ暦に関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/examples/gregorian&lt;/td&gt;
&lt;td&gt;グレゴリオ暦に関する良いコード例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/src/gregorian&lt;/td&gt;
&lt;td&gt;libboost_date_time用のcppファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test/posix_time&lt;/td&gt;
&lt;td&gt;Posix Time系に関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/examples/posix_time&lt;/td&gt;
&lt;td&gt;時間に関する良いコード例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/src/posix_time&lt;/td&gt;
&lt;td&gt;空 (ファイルが一つあるが、ソースコードではない)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#required-boost-libraries&#34; name=&#34;required-boost-libraries&#34;&gt;Required Boost Libraries&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このライブラリは以下のライブラリに依存している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost.tokenizer&lt;/li&gt;
&lt;li&gt;boost.integer(cstdint)&lt;/li&gt;
&lt;li&gt;boost.operators&lt;/li&gt;
&lt;li&gt;boost::lexical_cast&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;よって、最低限これらのライブラリがインストールされている必要がある。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Date-Time Concepts - 計算 -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/calculations.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Date-Time Concepts - 計算&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Calculation Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html#timepoints&#34;&gt;Timepoints&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html#durations&#34;&gt;Durations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html#interval&#34;&gt;Interval&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html#special-cases&#34;&gt;Special Cases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html#timepoints&#34; name=&#34;timepoints&#34;&gt;Timepoints&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このセクションでは，GDTL timepoints で行える基本的な算術規則をいくつか示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Timepoint &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; Duration &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Timepoint
Timepoint &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; Duration &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Timepoint

Duration &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; Timepoint &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Undefined 
Duration &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; Timepoint &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Undefined

Timepoint &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; Timepoint &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Undefined
Timepoint &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; Timepoint &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Duration
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html#durations&#34; name=&#34;durations&#34;&gt;Durations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このセクションでは時間長(time duration)に関する標準的な演算を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Duration &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; Duration  &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Duration
Duration &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; Duration  &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Duration

Duration &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; Integer   &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Duration  
Integer  &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; Duration  &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Duration  

Duration(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; Integer &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Duration(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;) 
Duration(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;Integer   &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Duration(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html#interval&#34; name=&#34;interval&#34;&gt;Intervals&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ここに時間間隔(intervals)によって支援された&#34;演算&#34;がある。 それらは半開区間に基づいている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//These can be defined by either of 2 Timepoints or a Timepoint and Duration&lt;/span&gt;
Timeinterval intersects Timeinterval &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;
Timeinterval intersection Timeinterval &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Timeperiod &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//results undefined if no intersection &lt;/span&gt;
Timeinterval contains  Timepoint    &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;
Timeinterval contains  Timeinterval &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;  
Timeinterval shift Duration         &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; shift start and end by duration amount
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html#special-cases&#34; name=&#34;special-cases&#34;&gt;Special Cases&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般に，非日時値(NADT;Not A Date Time)や無限大といった特別な値は，浮動小数点値のような規則に従うべきである。 戻り値として NADT を返す代わりに，例外を投げるNADTに基づいたシステムを形成することが可能であるべきであることに注意する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Timepoint(NADT) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; Duration &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Timepoint(NADT)
Timepoint(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; Duration &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Timepoint(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;)
Timepoint &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; Duration(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Timepoint(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;)
Timepoint &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; Duration(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;--&amp;gt;&lt;/span&gt; Timepoint(&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;∞&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gregorian::date -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/class_date.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;gregorian::date&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Date Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construction&#34;&gt;Construction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construct-from-string&#34;&gt;Construct from String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construct-from-clock&#34;&gt;Construct from Clock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#operators&#34;&gt;Operators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::gregorian::date&lt;/code&gt; クラスはライブラリユーザーにとって主要なインタフェースである。 一般に、日付クラスは代入可能ではあるが、一度構築されると不変である事が多い。&lt;/p&gt;
&lt;p&gt;日付の生成について別の方法が&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html&#34;&gt;date iterators&lt;/a&gt;と&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html&#34;&gt;date algorithms or generators&lt;/a&gt;に含まれている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construction&#34; name=&#34;construction&#34;&gt;Construction&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date(greg_year year, greg_month month, greg_day day)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付の要素から構築する。year, month, day の範囲が不正な場合、それぞれ &lt;code&gt;std::out_of_range&lt;/code&gt; から派生した &lt;code&gt;bad_year&lt;/code&gt;, &lt;code&gt;bad_day_of_month&lt;/code&gt;, &lt;code&gt;bad_day_month&lt;/code&gt; 例外を投げる。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,10)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date(date d)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d1(d)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date(special_values sv)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;無限大、無効値(not-a-date-time)、最大値、最小値を構築するコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d1(neg_infin);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d2(pos_infin);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d3(not_a_date_time);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d4(max_date);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d5(min_date);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construct-from-string&#34; name=&#34;construct-from-string&#34;&gt;Construction From String&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date from_string(const std::string&amp;amp;)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;年-月-日の順に区切られた文字列から　例:2002-1-25&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::string ds(&#34;2002/1/25&#34;);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d(from_string(ds))&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date from_undelimited_string(const std::string&amp;amp;)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;年-月-日の順のISO形式から　例:20020125&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::string ds(&#34;20020125&#34;);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d(from_string(ds))&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construct-from-clock&#34; name=&#34;construct-from-clock&#34;&gt;Construction From Clock&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;day_clock::local_day()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;計算機に設定された時間帯に準じた地域時間を取得する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(day_clock::local_day())&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;day_clock::universal_day()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;UTC 標準時を取得する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(day_clock::universal_day())&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#accessors&#34; name=&#34;accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;greg_month month() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;月の部分を取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,10); d.month() --&amp;gt; 1;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;greg_day day() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日の部分を取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,10); d.day() --&amp;gt; 10;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;greg_ymd year_month_day() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_ymd&lt;/code&gt; 構造体を返す&lt;br /&gt; 日付の3つの要素全てが必要なときに便利である&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,10);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date::ymd_type ymd = d.year_month_day(); ymd.year --&amp;gt; 2002, ymd.month --&amp;gt; 1, ymd.day --&amp;gt; 10&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;greg_day_of_week day_of_week() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;曜日を返す(例: &lt;code&gt;Sunday&lt;/code&gt;, &lt;code&gt;Monday&lt;/code&gt;, etc.&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,10); d.day() --&amp;gt; Thursday;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool is_infinity() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付が正または負の無限大の時 &lt;code&gt;true&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(pos_infin); d.is_infinity() --&amp;gt; true;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool is_neg_infinity() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付が負の無限大の時 &lt;code&gt;true&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(neg_infin); d.is_neg_infinity() --&amp;gt; true;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool is_pos_infinity() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付が正の無限大の時 &lt;code&gt;true&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(neg_infin); d.is_pos_infinity() --&amp;gt; true;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool is_not_a_date() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付が無効値(not a date)の時 &lt;code&gt;true&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(not_a_date_time); d.is_not_a_date() --&amp;gt; true;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#conversion-to-string&#34; name=&#34;conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_simple_string(date d)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;YYYY-mmm-DD (mmm は月名の3文字短縮形)形式に変換&lt;/td&gt;
&lt;td&gt;2002-Jan-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_iso_string(date d)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;YYYYMMDD 形式に変換&lt;/td&gt;
&lt;td&gt;20020131&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_iso_extended_string(date d)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD 形式に変換&lt;/td&gt;
&lt;td&gt;2002-01-31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#operators&#34; name=&#34;operators&#34;&gt;Operators&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ストリーム出力演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;std::cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator==, operator!=,&lt;/code&gt;&lt;br /&gt; &lt;code&gt;operator&amp;gt;, operator&amp;lt;,&lt;/code&gt;&lt;br /&gt; &lt;code&gt;operator&amp;gt;=, operator&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;サポートする比較演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;d1 == d2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date operator+(date_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;オフセット日数 &lt;code&gt;date_duration&lt;/code&gt; を加えた日付を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd(1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d2 = d + dd;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date operator-(date_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;オフセット日数 &lt;code&gt;date_duration&lt;/code&gt; を差し引いた日付を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd(1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d2 = d - dd;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_duration operator-(date) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つの日付を差し引いた日数(date duration)を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d1(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d2(2002,Jan,2);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd = d2-d1;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gregorian::date_duration -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/class_date_duration.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;gregorian::date_duration&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Date Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#construction&#34;&gt;Construction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#operators&#34;&gt;Operators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::gregorian::date_duration&lt;/code&gt; は，&lt;code&gt;gregorian::date&lt;/code&gt;の演算で使うシンプルな日数を表すクラスである。durationの値は正と負どちらも使用できる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#construction&#34; name=&#34;construction&#34;&gt;Construction&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_duration(long)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日数を生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_duration dd(3); //3 日&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#accessors&#34; name=&#34;accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;long days() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日数を取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_duration dd(3); dd.days() --&amp;gt; 3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool is_negative() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日数が&lt;code&gt;0&lt;/code&gt;より小さいとき&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_duration dd(-1); dd.is_negative() --&amp;gt; true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static date_duration unit()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;duration type の取りうる最小単位を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_duration::unit() --&amp;gt; date_duration(1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html#operators&#34; name=&#34;operators&#34;&gt;Operators&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator==, operator!=,&lt;/code&gt;&lt;br /&gt; &lt;code&gt;operator&amp;gt;, operator&amp;lt;&lt;/code&gt;&lt;br /&gt;&lt;code&gt;operator&amp;gt;=, operator&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;サポートする比較演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dd1 == dd2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_duration operator+(date_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日数を加算する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_duration dd1(3);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd2(5);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd3 = dd1 + dd2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_duration operator-(date_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日数の差を取る&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_duration dd1(3);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd2(5);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd3 = dd1 - dd2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gregorian::date_period -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/class_date_period.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;gregorian::date_period&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Date Period Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#construction&#34;&gt;Construction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#operators&#34;&gt;Operators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::gregorian::date_period&lt;/code&gt; クラスは、二つの日付の範囲(期間)を直接表現する。 プログラムの条件付きの論理を単純化することによって、ある種の計算を単純化する能力を提供する。 例えば、日付が週末あるいは休日のような不規則なスケジュールの中であるかどうか試すのは &lt;code&gt;date_period&lt;/code&gt; のコレクションを使って達成され得る。 これは、&lt;code&gt;date_period&lt;/code&gt; が別の期間(date period)と重複する場合に評価を許可する、あるいは重複している期間を生成する、といったいくつかの方法によって容易になる。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/period_calc.cpp.html&#34;&gt;period calculation example(期間計算の例)&lt;/a&gt; はこの例を提供する。&lt;/p&gt;
&lt;p&gt;無限値と組み合わせて使用される期間(date periods)は、「追って通知があるまで」といった複雑な概念を表現する能力を持っている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#construction&#34; name=&#34;construction&#34;&gt;Construction&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_period(date begin, date last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[begin, last)&lt;/code&gt; で表される期間(period)を生成する。&lt;br /&gt; &lt;code&gt;last &amp;lt;= begin&lt;/code&gt; のときは null となる。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp(date(2002,Jan,10), date_duration(2));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_period(date start, date end)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[begin, begin+len)&lt;/code&gt;で表される期間(period)を生成する。&lt;br /&gt; &lt;code&gt;len &amp;lt;= 0&lt;/code&gt; のときは null となる。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp(date(2002,Jan,10), date_duration(2));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_period(date_period rhs)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp1(dp)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#accessors&#34; name=&#34;accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date begin() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)の初日を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp.begin() --&amp;gt; 2002-Jan-01&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date last() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)の最終日を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp.last() --&amp;gt; 2002-Jan-09&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date end() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)の最終日の翌日を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp.end() --&amp;gt; 2002-Jan-10&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool is_null() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)が正しい形式でないとき&lt;code&gt;true&lt;/code&gt;&lt;br /&gt; 例: &lt;code&gt;end&lt;/code&gt;が&lt;code&gt;start&lt;/code&gt;より小さい&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp(date(2002,Jan,10), date(2002,Jan,1));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp.is_null() --&amp;gt; true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool contains(date) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付が期間(period)の範囲内にあるとき&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp.contains(date(2002,Jan,2)) --&amp;gt; true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool contains(date_period) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period&lt;/code&gt; が期間(period)の範囲内にあるとき&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp1(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_period dp2(date(2002,Jan,2), date(2002,Jan,3));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp1.contains(dp2) --&amp;gt; true&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp2.contains(dp1) --&amp;gt; false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool intersects(date_period) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)が重複するとき&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp1(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_period dp2(date(2002,Jan,2), date(2002,Jan,3));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp2.intersects(dp1) --&amp;gt; true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_period intersection(date_period) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つの期間(period)から重複する期間(period)を計算する。 期間(period)が重複しないときは null が返る&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp1(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_period dp2(date(2002,Jan,2), date(2002,Jan,3));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp2.intersects(dp1) --&amp;gt; dp2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_period merge(date_period) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2つの期間(period)を結合して返す。期間(period)が重複しないときは null が返る&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp1(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_period dp2(date(2002,Jan,9), date(2002,Jan,31));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp2.intersects(dp1) --&amp;gt; 2002-Jan-01/2002-Jan-31&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_period shift(date_duration)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初日と最終日に日数(date_duration)を加算する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date_period dp1(date(2002,Jan,1), date(2002,Jan,10));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dp1.shift(date_duration(1)); --&amp;gt; 2002-Jan-02/2002-Jan-11&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#conversion-to-string&#34; name=&#34;conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_simple_string(date_period dp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;[YYYY-mmm-DD/YYYY-mmm-DD] (mmm は月名の3文字短縮形)形式の文字列に変換&lt;/td&gt;
&lt;td&gt;[2002-Jan-01/2002-Jan-31]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html#operators&#34; name=&#34;operators&#34;&gt;Operators&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator==, operator!=,&lt;/code&gt;&lt;br /&gt; &lt;code&gt;operator&amp;gt;, operator&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;サポートする比較演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp1 == dp2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp1.end()&lt;/code&gt;が&lt;code&gt;dp2.begin()&lt;/code&gt;よりも小さいとき &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp1 &amp;lt; dp2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp1.begin()&lt;/code&gt;が&lt;code&gt;dp2.end()&lt;/code&gt;よりも大きいとき &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp1 &amp;gt; dp2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gregorian::gregorian_calendar -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/class_gregorian_calendar.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;gregorian::gregorian_calendar&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Date Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html#functions&#34;&gt;Functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::gregorian::gregorian_calendar&lt;/code&gt; クラスは、グレゴリオ暦の日付システムを生成するのに必要な機能を実装する。 これは、年-月-日 形式の日付と日付番号表現との相互変換を行う。&lt;/p&gt;
&lt;p&gt;このクラスは、主に &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html&#34;&gt;&lt;code&gt;gregorian::date&lt;/code&gt;&lt;/a&gt; によってアクセスされることを意図しており、ユーザによって直接使用される事はない。 しかしながら、&lt;code&gt;end_of_month_day&lt;/code&gt;機能に役に立つ、有用な機能がある。&lt;/p&gt;
&lt;p&gt;サンプル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/print_month.cpp.html&#34;&gt;print month&lt;/a&gt; で、この例を説明している。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html#functions&#34; name=&#34;functions&#34;&gt;Functions&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static short day_of_week(ymd_type)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;曜日を返す (0==Sunday, 1==Monday, etc)&lt;/td&gt;
&lt;td&gt;参照: &lt;code&gt;gregorian::date day_of_week&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static date_int_type day_number(ymd_type)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ymd_type&lt;/code&gt; を日付番号に変換する。日付番号は、エポック(Epoch)からの通算日数の絶対値である&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static short end_of_month_day(year_type, month_type)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;与えられた年と月から、その月の最終日を決定する&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static ymd_type from_day_number(date_int_type)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付番号を &lt;code&gt;ymd&lt;/code&gt; 構造体に変換する&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static bool is_leap_year(year_type)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定した年がうるう年なら &lt;code&gt;true&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gregorian_calendar::is_leap_year(2000) --&amp;gt; true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>posix_time::ptime Documentation -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/class_ptime.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;posix_time::ptime Documentation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ptime Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#construction&#34;&gt;Construction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#construct-from-string&#34;&gt;Construct from String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#construct-from-clock&#34;&gt;Construct from Clock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#operators&#34;&gt;Operators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::posix_time::ptime&lt;/code&gt; クラスは時間位置(time point)を操作するための主要なインタフェースである。 一般に，&lt;code&gt;ptime&lt;/code&gt; クラスは代入可能ではあるが，一度構築されると不変である事が多い。&lt;/p&gt;
&lt;p&gt;クラス &lt;code&gt;ptime&lt;/code&gt; は，時間位置(time point)の日付部分へのインタフェースである &lt;code&gt;gregorian::date&lt;/code&gt; に依存する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ptime&lt;/code&gt; を生成する別の手法が，&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html&#34;&gt;time iterators&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/posix_time/posix_time.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/posix_time/posix_time_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#construction&#34; name=&#34;construction&#34;&gt;Construction&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime(date,time_duration)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日付とオフセットから構築&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ptime t1(date(2002,Jan,10), time_duration(1,2,3));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2(date(2002,Jan,10), hours(1)+nanosec(5));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime(ptime)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ptime t3(t1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#construct-from-string&#34; name=&#34;construct-from-string&#34;&gt;Construction From String&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime time_from_string(const std::string&amp;amp;)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;区切られた文字列から構築&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::string ts(&#34;2002-01-20 23:59:59.000&#34;);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d(time_from_string(ts));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#construct-from-clock&#34; name=&#34;construct-from-clock&#34;&gt;Construction From Clock&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static ptime second_clock::local_time();&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;計算機の時間帯設定に基づいた地域時間(秒レベル分解能)で初期化&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ptime t(second_clock::local_time());&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static ptime second_clock::universal_time()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;UTC 時間で初期化&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ptime t(second_clock::universal_day());&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#accessors&#34; name=&#34;accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date date() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間の日付部分を取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,10);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t(d, hour(1));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;t.date() --&amp;gt; 2002-Jan-10;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_duration time_of_day() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;その日の時間オフセットを取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,10);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t(d, hour(1));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;t.time_of_day() --&amp;gt; 01:00:00;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#conversion-to-string&#34; name=&#34;conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_iso_string(ptime)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;YYYYMMDDTHHMMSS,fffffffff 形式(T は日付と時間の区切り) に変換&lt;/td&gt;
&lt;td&gt;20020131T100001,123456789&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_iso_extended_string(ptime)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;YYYY-MM-DDTHH:MM:SS,fffffffff 形式(T は日付と時間の区切り) に変換&lt;/td&gt;
&lt;td&gt;2002-01-31T10:00:01,123456789&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html#operators&#34; name=&#34;operators&#34;&gt;Operators&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator==, operator!=,&lt;/code&gt;&lt;br /&gt; &lt;code&gt;operator&amp;gt;, operator&amp;lt;&lt;/code&gt; &lt;br /&gt; &lt;code&gt;operator&amp;gt;=, operator&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;サポートする比較演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t1 == t2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime operator+(date_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;オフセット日数(&lt;code&gt;date_duration&lt;/code&gt;)を加えた &lt;code&gt;ptime&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t(d,minutes(5));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd(1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2 = t + dd;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime operator-(date_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;オフセット日数(&lt;code&gt;date_duration&lt;/code&gt;)を差し引いた &lt;code&gt;ptime&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t(d,minutes(5));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date_duration dd(1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2 = t - dd;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime operator+(time_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間長(&lt;code&gt;time_duration&lt;/code&gt;)を加えた &lt;code&gt;ptime&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t(d,minutes(5));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2 = t + hours(1) + minutes(2);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime operator-(time_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間長(&lt;code&gt;time_duration&lt;/code&gt;)を差し引いた &lt;code&gt;ptime&lt;/code&gt; を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t(d,minutes(5));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2 = t - minutes(2);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_duration operator-(ptime) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;二つの時間の差を取る&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t1(d,minutes(5));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2(d,seconds(5));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_duration t3 = t2 - t1;//negative result&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>posix_time::time_duration -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/class_time_duration.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;posix_time::time_duration&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Time Duration Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#construction&#34;&gt;Construction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#count-based-construction&#34;&gt;Count Based Construction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#construct-from-string&#34;&gt;Construct from String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#operators&#34;&gt;Operators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::posix_time::time_duration&lt;/code&gt; クラスは時間の長さを確実に表現できる基底型である。 時間長(duration)は正あるいは負の値を取り得る。&lt;/p&gt;
&lt;p&gt;以下に示すように、異なった分解能を調整するために基底の &lt;code&gt;time_duration&lt;/code&gt; から継承するいくつかの小さなヘルパークラスがある。 これらのクラスによって、コードを短く、意図をより明確にすることができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/date_time/doc/time_duration_inherit.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;gregorian;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;posix_time;

time_duration td &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; hours(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; seconds(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//01:00:01&lt;/span&gt;
td &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; hours(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; nanosec(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//01:00:00.000000005&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;注意：高分解能(たとえば&lt;code&gt;nanosec&lt;/code&gt;)が存在するかどうかは、依存するインストールライブラリによって異なる。詳細は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html&#34;&gt;Build-Compiler Information&lt;/a&gt;を参照。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/posix_time/posix_time.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/posix_time/posix_time_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#construction&#34; name=&#34;construction&#34;&gt;Construction&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_duration(hours,minutes,seconds,fractional_seconds)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数値から時間長(duration)を生成する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td(1,2,3,9); //1 hr 2 min 3 sec 9 nanoseconds&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#count-based-construction&#34; name=&#34;count-based-construction&#34;&gt;Construction By Count&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hours(long)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間単位で生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td = hours(3);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;minutes(long)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;分単位で生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td = minutes(3);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;seconds(long)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;秒単位で生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td = seconds(3);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;milliseconds(long)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ミリ秒単位で生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td = milliseconds(3);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;microseconds(long)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;マイクロ秒単位で生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td = microseconds(3);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nanoseconds(long)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ナノ秒単位で生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td = nanoseconds(3);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#conversion-to-string&#34; name=&#34;conversion-to-string&#34;&gt;Construction From String&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_duration duration_from_string(const std::string&amp;amp;)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;区切られた文字列から生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::string ts(&#34;23:59:59.000&#34;);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_duraton td(duration_from_string(ts));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#accessors&#34; name=&#34;accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;long hours() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間の部分を取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td(1,2,3); td.hours() --&amp;gt; 1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;long minutes() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正規化された分の部分を取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td(1,2,3); td.minutes() --&amp;gt; 2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;long seconds() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;秒の部分を取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td(1,2,3); td.hours() --&amp;gt; 3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;long fractional_seconds() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;秒の小数部を取得&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td(1,2,3, 1000); td.fractional_seconds() --&amp;gt; 1000&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool is_negative() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間長(duration)が負の時 &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td(-1,0,0); td.is_negative() --&amp;gt; true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_duration invert_sign() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号を反転させた時間長(duration)を新たに生成&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td(-1,0,0); td.invert_sign() --&amp;gt; 01:00:00&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static gdtl::time_resolutions resolution()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration&lt;/code&gt; クラスが表現可能な分解能&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration::resolution() --&amp;gt; nano&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::int64_t ticks()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間長(duration)型の生の数を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td(0,0,0, 1000); td.ticks() --&amp;gt; 1000&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static time_duration unit()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間長(duration)型の扱える最小単位を返す(1ナノ秒)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration::unit() --&amp;gt; time_duration(0,0,0,1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#conversion-to-string&#34; name=&#34;conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_simple_string(time_duration)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HH:MM:SS.fffffffff 形式に変換する(fff...部は、秒の小数部が0でないときのみ含まれる)&lt;/td&gt;
&lt;td&gt;10:00:01.123456789&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_iso_string(time_duration)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HHMMSS,fffffffff 形式に変換する&lt;/td&gt;
&lt;td&gt;100001,123456789&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html#operators&#34; name=&#34;operators&#34;&gt;Operators&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator==, operator!=,&lt;/code&gt;&lt;br /&gt; &lt;code&gt;operator&amp;gt;, operator&amp;lt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;operator&amp;gt;=, operator&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;サポートする比較演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dd1 == dd2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_duration operator+(time_duration) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間長(durations)を加算する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td1(hours(1)+minutes(2));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_duration td2(seconds(10)); time_duration td3 = td1 + td2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_duration operator-(time_duration) const&lt;/code&gt; 時間長(durations)を減算する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_duration td1(hours(1)+nanosec(2));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_duration td2 = td1 - minutes(1);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>posix_time::time_period -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/class_time_period.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;posix_time::time_period&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Time Period Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#construction&#34;&gt;Construction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#operators&#34;&gt;Operators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;クラス &lt;code&gt;boost::posix_time::time_period&lt;/code&gt; は2つの時刻の範囲を直接表現する。 期間(period)は、プログラムの条件付きの論理を単純化することによって、ある種の計算を単純化する能力を提供する。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_periods.cpp.html&#34;&gt;time periods example&lt;/a&gt; は &lt;code&gt;time_period&lt;/code&gt; の使用例を提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/posix_time/posix_time.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/posix_time/posix_time_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#construction&#34; name=&#34;construction&#34;&gt;Construction&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_period(ptime begin, ptime last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[begin, last)&lt;/code&gt; で表される期間(period)を生成する。&lt;br /&gt; &lt;code&gt;last &amp;lt;= begin&lt;/code&gt; のときは null となる。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,01);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t(d, seconds(10)); //10 sec after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_period tp(t, hours(3));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_period(ptime start, ptime end)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[begin, begin+len)&lt;/code&gt; で表される期間(period)を生成する。&lt;br /&gt; &lt;code&gt;len &amp;lt;= 0&lt;/code&gt; のときは null となる。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,01);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t1(d, seconds(10)); //10 sec after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2(d, hours(10)); //10 hours after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_period tp(t1, t2);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_period(time_period rhs)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_period tp1(tp);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#accessors&#34; name=&#34;accessors&#34;&gt;Accessors&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime begin() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)の最初を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,01);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t1(d, seconds(10)); //10 sec after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2(d, hours(10)); //10 hours after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_period tp(t1, t2); tp.begin() --&amp;gt; 2002-Jan-01 00:00:10&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime last() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)の最後を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,01);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t1(d, seconds(10)); //10 sec after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2(d, hours(10)); //10 hours after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_period tp(t1, t2); tp.last() --&amp;gt; 2002-Jan-01 09:59:59.999999999&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ptime end() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)の最後の次を返す&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,01);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t1(d, seconds(10)); //10 sec after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2(d, hours(10)); //10 hours after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_period tp(t1, t2); tp.last() --&amp;gt; 2002-Jan-01 10:00:00&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool is_null() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period) が正しい形式でないとき&lt;code&gt;true&lt;/code&gt;&lt;br /&gt; 例: &lt;code&gt;end&lt;/code&gt;が&lt;code&gt;start&lt;/code&gt;より小さい&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool contains(ptime) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ptime&lt;/code&gt; が期間(period)の範囲内にあるとき &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date d(2002,Jan,01);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t1(d, seconds(10)); //10 sec after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t2(d, hours(10)); //10 hours after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t3(d, hours(2)); //2 hours after midnight&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_period tp(t1, t2); tp.contains(t3) --&amp;gt; true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool contains(time_period) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_period&lt;/code&gt; が期間(period)の範囲内にあるとき &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_period tp1(ptime(d,hours(1)), ptime(d,hours(12)));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_period tp2(ptime(d,hours(2)), ptime(d,hours(4)));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;tp1.contains(tp2) --&amp;gt; true&lt;/code&gt;&lt;br /&gt; &lt;code&gt;tp2.contains(tp1) --&amp;gt; false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool intersects(time_period) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;期間(period)が重複するとき &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_period tp1(ptime(d,hours(1)), ptime(d,hours(12)));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;time_period tp2(ptime(d,hours(2)), ptime(d,hours(4)));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;tp2.intersects(tp1) --&amp;gt; true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_period intersection(time_period) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;二つの期間(period)が重複する範囲を計算する。期間(period)が重複しないときは null が返る&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_period merge(time_period) const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;二つの期間(period)を結合して返す。期間(period)が重複しないときは null が返る&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_period shift(time_duration)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間長(time_duration)を &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; に加算する&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#conversion-to-string&#34; name=&#34;conversion-to-string&#34;&gt;Conversion To String&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::string to_simple_string(time_period dp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;[YYYY-mmm-DD hh:mm:ss.fffffffff/YYYY-mmm-DD hh:mm:ss.fffffffff] 形式の文字列に変換する(mmm は月名の3文字短縮形)&lt;/td&gt;
&lt;td&gt;[2002-Jan-01 01:25:10.000000001/2002-Jan-31 01:25:10.123456789]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html#operators&#34; name=&#34;operators&#34;&gt;Operators&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Syntax&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator==, operator!=,&lt;/code&gt;&lt;br /&gt; &lt;code&gt;operator&amp;gt;, operator&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;サポートする比較演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;tp1 == tp2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;tp1.end()&lt;/code&gt; が &lt;code&gt;tp2.begin()&lt;/code&gt; よりも小さいとき &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;tp1 &amp;lt; tp2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;tp1.begin()&lt;/code&gt; が &lt;code&gt;tp2.end()&lt;/code&gt; よりも大きいとき &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;tp1 &amp;gt; tp2&lt;/code&gt;, etc&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Date Generators / Algorithms -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/date_algorithms.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Date Generators / Algorithms&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Date Generators / Algorithms&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html#class-overview&#34;&gt;Class Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;日付アルゴリズムあるいはジェネレータは、他の日付あるいは日付のスケジュールを生成するためのツールである。 生成関数は、月と日のような日付のある部分で始まり、その後、具体的な日付を生成するために残りの部分を供給される。 これは、プログラマが「2月の最初の日曜日」のような概念を表わし、次に、1つ以上の年を供給された時に日付の具体的なセットを生成することを想定している。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;gregorian; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;date_time&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;nth_kday_of_month&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;date&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; nkday;
nkday &lt;span style=&#34;color: #0000FF&#34;&gt;ldgen&lt;/span&gt;(nkday&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;first, Monday, Sep)); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// US labor day (アメリカ合衆国 労働者の日)&lt;/span&gt;
date labor_day &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ldgen.get_date(&lt;span style=&#34;color: #666666&#34;&gt;2002&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2002年の労働者の日を計算&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/print_holidays.cpp.html&#34;&gt;print holidays example&lt;/a&gt; に詳細な使い方の例を示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/date_generators.hpp&#34; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html#class-overview&#34; name=&#34;class-overview&#34;&gt;Class Overview&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Class&lt;/th&gt;
&lt;th&gt;Construction Parameters&lt;/th&gt;
&lt;th&gt;get_date Parameter&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;first_kday_after&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_day_of_week day_of_week&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date start_day&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2002年1月1日以降の最初の日曜日のといったものを計算する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;first_kday_after fkaf(Monday);&lt;/code&gt;&lt;br /&gt;&lt;code&gt;date d = fkaf.get_date(date(2002,Jan,1));//2002-Jan-07&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;first_kday_before&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_day_of_week day_of_week&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date start_day&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2002年2月1日以前の最初の月曜日といったものを計算する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;first_kday_before fkbf(Monday);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d = fkbf.get_date(date(2002,Feb,1));//2002-Jan-28&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;last_kday_of_month&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_day_of_week day_of_week&lt;/code&gt;&lt;br /&gt; &lt;code&gt;greg_month month&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_year year&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1月最後の月曜日といったものを計算する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;last_kday_of_month lkm(Monday,Jan);&lt;/code&gt;&lt;br /&gt;&lt;code&gt;date d = lkm.get_date(2002);//2002-Jan-28&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;first_kday_of_month&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_day_of_week day_of_week&lt;/code&gt;&lt;br /&gt; &lt;code&gt;greg_month month&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_year year&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1月最初の月曜日といったものを計算する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;first_kday_of_month fkm(Monday,Jan);&lt;/code&gt;&lt;br /&gt;&lt;code&gt;date d = fkm.get_date(2002);//2002-Jan-07&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;partial_date&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_month month&lt;/code&gt;&lt;br /&gt;&lt;code&gt;greg_day day_of_month&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;greg_year year&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;月および日を与えられた日付に、年を適用することにより日付を生成する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;partial_date pd(Jan,1);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;date d = pd.get_date(2002);//2002-Jan-01&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Tue Sep 3 16:02:55 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>gregorian::date iterators -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/date_iterators.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;gregorian::date iterators&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Date Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html#class-overview&#34;&gt;Class Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;日付イテレータは、日単位で反復するための標準的なメカニズムを提供する。 日付イテレータは(STLの)&lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;入力イテレータ&lt;/a&gt;のモデルであり、日付と他の日付生成タスクで集合を代入するために使われる。 例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/print_month.cpp.html&#34;&gt;print month の例&lt;/a&gt;では、1ヶ月の全ての日々を反復し、それらをプリントする。&lt;/p&gt;
&lt;p&gt;ここにあるイテレータは全て &lt;code&gt;boost::gregorian::date_iterator&lt;/code&gt; からの派生である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html#class-overview&#34; name=&#34;class-overview&#34;&gt;Class Overview&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Class&lt;/th&gt;
&lt;th&gt;Construction Parameters&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;全ての日付単位イテレータに共通な基底クラス&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;day_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date start_date, int day_count=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;day_count&lt;/code&gt; 日単位で反復する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;week_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date start_date, int week_offset=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;week_offset&lt;/code&gt; 週単位で反復する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;month_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date start_date, int month_offset=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;month_offset 月単位で反復する。&lt;br /&gt; 月末の取り扱いについては、特別な規則がある。 それは、最初の日が月の最終日であるときは、常にその月の最終日に合わせて調整されるというものである。 日付がその月末を越えている場合(例: 1月31日+1ヶ月)、月の最終日に合わせて調整される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;year_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;date start_date, int year_offset=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;year_offset&lt;/code&gt; 年単位で反復する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Gregorian Date System Documentation -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/gregorian.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Gregorian Date System Documentation&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html#usage-examples&#34;&gt;Usage Examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Temporal Types&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html&#34;&gt;Class date&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html&#34;&gt;Class date_duration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html&#34;&gt;Class date_period&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Other Topics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html&#34;&gt;Date Iterators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html&#34;&gt;Date Generators / Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html&#34;&gt;Class gregorian_calendar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construct-from-clock&#34;&gt;Class day_clock&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;gregorian date system はグレゴリオ暦に基づいた日付プログラミングシステムを提供する。 現在の実装は，1400-Jan-01から10000-Jan-01の範囲の日付をサポートする。 実装された暦は、&#34;予想グレゴリオ暦？(proleptic Gregorian calendar)&#34; で、(グレゴリオ暦が)最初に採用された 1582 年以前に遡る拡張がなされている。&lt;/p&gt;
&lt;p&gt;(訳注: &lt;a href=&#34;http://www.wikipedia.org/wiki/Proleptic_Gregorian_Calendar&#34; target=&#34;_blank&#34;&gt;proleptic Gregorian calendar&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;歴史上の日付を扱うとき，局地的に採用された様々な暦法との調整が必要な事に注意すべきである。 Reingold と Dershowitz による &lt;a href=&#34;http://emr.cs.iit.edu/home/reingold/calendar-book/second-edition/&#34; target=&#34;_blank&#34;&gt;Calendrical Calculations&lt;/a&gt; に詳しい説明がある。 暦法の現在の歴史上の範囲はアルゴリズムによって制限されてはいない。 しかしそれよりもむしろ、時間の正当性を保証するためにテストを書いて実行する。 この暦法系の範囲が将来増加し続けるであろうと思われる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://emr.cs.iit.edu/home/reingold/calendar-book/second-edition/&#34; target=&#34;_blank&#34;&gt;Calendrical Calculations&lt;/a&gt; からの日付情報がグレゴリオ暦の実装の正当性をクロステストするために使われた。&lt;/p&gt;
&lt;p&gt;gregorian system の全ての型は &lt;code&gt;boost::gregorian&lt;/code&gt; 名前空間で見つかる。 ライブラリは入出力に依存しない全てのクラスが収められた便宜的なヘッダ &lt;code&gt;boost/date_time/gregorian/gregorian_types.hpp&lt;/code&gt; をサポートする。&lt;/p&gt;
&lt;p&gt;もう一つのヘッダ &lt;code&gt;boost/date_time/gregorian/gregorian.hpp&lt;/code&gt; は型と入出力コードを含む。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html&#34;&gt;&lt;code&gt;boost::gregorian::date&lt;/code&gt;&lt;/a&gt; クラスはユーザーにとって主要な時間型である。 もし，&#34;4月の第1日曜日&#34;を見つけるといった特別な日付計算プログラムの書き方に興味があるなら、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html&#34;&gt;date generators and algorithms&lt;/a&gt;ページを見ると良い。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html#usage-examples&#34; name=&#34;usage-examples&#34;&gt;Usage Examples&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;コード例&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/days_alive.cpp.html&#34;&gt;Days Alive&lt;/a&gt;&lt;br /&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/days_till_new_year.cpp.html&#34;&gt;Days Till New Year&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;簡単な日数計算。現在の日付を時計から取得&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/dates_as_strings.cpp.html&#34;&gt;Dates as strings&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付と文字列の相互変換、簡単な解析と書式化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/period_calc.cpp.html&#34;&gt;Date Period Calculations&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付が、期間(periods)の集合に含まれるか調べる (例: 休日・週末の判定)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/print_month.cpp.html&#34;&gt;Print a month&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コマンドラインで与えた月の日付を全て出力する小さなユーティリティプログラム。 1999年1月1日が金曜だったか土曜だったか知る必要がある? このプログラムはその方法を示す&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/print_holidays.cpp.html&#34;&gt;Print Holidays&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;抽象的な指定を具体的な日付の集合に変換するために、日付ジェネレータを使う&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Thu Sep 5 07:33:06 MST 2002 by Jeff Garland © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Local Time Adjustment -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/local_time_adjust.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Local Time Adjustment&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Local Time Adjustment&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html#class-overview&#34;&gt;Class Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;時間表現において頻繁にぶつかる問題が、様々な地域時間の間の変換である。 一般に、これは参考時間システム(reference time system)を用いて解決される。 参考時間システムには、典型的に UTC が用いられる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;posix_time&lt;/code&gt; システムは内部で時間調整を行わないので、地域時間および UTC時間の両方を表わすために使用することができる。 しかしながら、ユーザーには変換と時間帯についての知識を処理することが委ねられる。&lt;/p&gt;
&lt;p&gt;このライブラリは UTC から地域時間への変換を処理するための、2つの異なる方法を提示する。 一つ目は、コンピュータの時間帯設定を使う。 これは、ユーザーマシンのための UTC 時刻を変換することに対して、有用な解決法である。 このアプローチは ctime API に依存しており、もし環境設定が間違っていれば、正しくない結果を供給するであろう。 もうひとつのアプローチは、コンピュータの時間帯設定とは無関係に、任意の時間帯から UTC への変換を可能にする。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_utc_conversion.cpp.html&#34;&gt;local utc conversionの例&lt;/a&gt;では、これら両方の手法を示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/gregorian/gregorian_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html#class-overview&#34; name=&#34;class-overview&#34;&gt;Class Overview&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Class&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_time::c_local_adjustor&amp;lt;ptime&amp;gt;::utc_to_local(ptime)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;時間帯の設定および C API に基づいた UTC 時刻から、ローカルマシンの時刻を計算する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;typedef boost::date_time::c_local_adjustor&amp;lt;ptime&amp;gt; local_adj;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t10(date(2002,Jan,1), hours(7));&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptime t11 = local_adj::utc_to_local(t10);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_time::local_adjustor&amp;lt;ptime, utc_offset, dst_rules&amp;gt;::utc_to_local(ptime)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;UTC 時間に基づいた夏時間規則とUTCオフセットから、ローカルマシンの時刻を計算する&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_utc_conversion.cpp.html&#34;&gt;例を参照&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date_time::local_adjustor&amp;lt;ptime, utc_offset, dst_rules&amp;gt;::local_to_utc(ptime)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;夏時間規則とUTCオフセットに基づいて、UTC時刻を計算する&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_utc_conversion.cpp.html&#34;&gt;例を参照&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Posix Time System Documentation -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/posix_time.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Posix Time System Documentation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html#usage-examples&#34;&gt;Usage Examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Temporal Types&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html&#34;&gt;Class ptime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html&#34;&gt;Class time_duration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html&#34;&gt;Class time_period&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Other Topics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html&#34;&gt;Time Iterators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html&#34;&gt;UTC / Local Time Adjustments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ナノ秒分解能および安定した計算特性を備えた、調整されていない時間システムを定義する。 この時間システムは、時間表現における日付部分の実装にグレゴリオ暦を使用する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html#usage-examples&#34; name=&#34;usage-examples&#34;&gt;Usage Examples&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_math.cpp.html&#34;&gt;Time Math&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ptime&lt;/code&gt; と &lt;code&gt;time_durations&lt;/code&gt; を使ったいくつかの単純な計算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/print_hours.cpp.html&#34;&gt;Print Hours&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;time_iterator&lt;/code&gt; を使用してクロックから時刻を取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_utc_conversion.cpp.html&#34;&gt;Local to UTC Conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;地域時間からUTC時間への夏時間規則を含んだ変換について、2つの異なる方法を実証する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_periods.cpp.html&#34;&gt;Time periods&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;期間(time periods)の交差および表示の簡単な例&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>参考文献 -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/references.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下に挙げるのは、日付・時間ドメインに関するリファレンスと情報元である。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#date-references&#34;&gt;Date Calendar References&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#time-reference&#34;&gt;Time References&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#other-cpp-libs&#34;&gt;Other C/C++ Libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#java-libs&#34;&gt;JAVA Date-Time Libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#script-lang-libs&#34;&gt;Scriping Language Libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#related-commerical-fanciful-pages&#34;&gt;関連する商業的かつ想像力に富んだページ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#resolution-precision-accuracy&#34;&gt;分解能, 精度, 正確度&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#date-references&#34; name=&#34;date-references&#34;&gt;Date Calendar References&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ISO 8601 日付・時間の標準 -- &lt;a href=&#34;http://www.cl.cam.ac.uk/~mgk25/iso-time.html&#34; target=&#34;_blank&#34;&gt;Markus Kuhnによるまとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;書籍『&lt;a href=&#34;http://emr.cs.iit.edu/home/reingold/calendar-book/second-edition/&#34; target=&#34;_blank&#34;&gt;Calendrical Calculations&lt;/a&gt;』 著者 Reingold &amp;amp; Dershowitz&lt;/li&gt;
&lt;li&gt;Calendar FAQ by Claus T?dering [&lt;a href=&#34;http://www.pauahtun.org/CalendarFAQ/cal/calendar24.html&#34; target=&#34;_blank&#34;&gt;html&lt;/a&gt;][&lt;a href=&#34;http://www.pauahtun.org/CalendarFAQ/cal/calendar24.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;Calendar zone &lt;a href=&#34;http://www.calendarzone.com/&#34; target=&#34;_blank&#34;&gt;http://www.calendarzone.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/TR/xmlschema-2/#dateTime&#34; target=&#34;_blank&#34;&gt;date timeのXMLスキーマ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Will Lindenの&lt;a href=&#34;http://www.ecben.net/calendar.shtml&#34; target=&#34;_blank&#34;&gt;Calendar Links&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www21.brinkster.com/lonwolve/melt/index.htm&#34; target=&#34;_blank&#34;&gt;XMAS calendar melt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#time-reference&#34; name=&#34;time-reference&#34;&gt;Time References&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Martin Folwerの時間パターン&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aw.com/cseng/titles/0-201-89542-0/apsupp/events2-1.html&#34; target=&#34;_blank&#34;&gt;Recurring Events for Calendars&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Patterns for things that &lt;a href=&#34;http://martinfowler.com/ap2/timeNarrative.html&#34; target=&#34;_blank&#34;&gt;Change with time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;アメリカ国立研究所の標準とテクノロジー &lt;a href=&#34;http://nist.time.gov/exhibits.html&#34; target=&#34;_blank&#34;&gt;Time Exhibits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ntp.org/&#34; target=&#34;_blank&#34;&gt;NTP.org&lt;/a&gt;のネットワーク時間プロトコル&lt;/li&gt;
&lt;li&gt;US Navy &lt;a href=&#34;http://tycho.usno.navy.mil/systime.html&#34; target=&#34;_blank&#34;&gt;Systems of Time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.bipm.fr/enus/5_Scientific/c_time/time_1.html&#34; target=&#34;_blank&#34;&gt;国際原子時(International Atomic Time)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://beta.zyprexia.com/docs/pgsql/user/datatype1130.htm&#34; target=&#34;_blank&#34;&gt;Date-Time type PostgreSQL&lt;/a&gt; ユーザーガイド&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#other-cpp-libs&#34; name=&#34;other-cpp-libs&#34;&gt;Other C/C++ Libraries&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/ref/ctime/index.html&#34; target=&#34;_blank&#34;&gt;ctime C&lt;/a&gt; Standard library reference at cplusplus.com&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cl.cam.ac.uk/~mgk25/c-time/&#34; target=&#34;_blank&#34;&gt;XTime C extension&lt;/a&gt; proposal&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://david.tribble.com/text/c0xcalendar.html#author-info&#34; target=&#34;_blank&#34;&gt;Another C library extension&lt;/a&gt; proposal by David Tribble&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cr.yp.to/libtai.html&#34; target=&#34;_blank&#34;&gt;libTAI&lt;/a&gt; is a C based time library&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.twinsun.com/tz/tz-link.htm&#34; target=&#34;_blank&#34;&gt;Time Zone&lt;/a&gt; Database C library for managing timezones/places&lt;/li&gt;
&lt;li&gt;International Components for Unicode by IBM (open source)&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oss.software.ibm.com/icu/userguide/dateCalendar.html&#34; target=&#34;_blank&#34;&gt;Calendar Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oss.software.ibm.com/icu/userguide/dateTime.html&#34; target=&#34;_blank&#34;&gt;Date Time Services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oss.software.ibm.com/icu/userguide/dateTimezone.html&#34; target=&#34;_blank&#34;&gt;Time Zone Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oss.software.ibm.com/icu/userguide/formatDateTime.html&#34; target=&#34;_blank&#34;&gt;Date-Time Formatting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ringside.arc.nasa.gov/www/toolkits/julian_13/aareadme.html&#34; target=&#34;_blank&#34;&gt;Julian Library in C by Mark Showalter -- NASA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#java-libs&#34; name=&#34;java-libs&#34;&gt;JAVA Date &amp;amp; Time Library Quick Reference&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/products/jdk/1.1/docs/api/java.util.Calendar.html#_top_&#34; target=&#34;_blank&#34;&gt;Calendar class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/products/jdk/1.1/docs/api/java.util.GregorianCalendar.html#_top_&#34; target=&#34;_blank&#34;&gt;Gregorian calendar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/products/jdk/1.1/docs/api/java.util.Date.html&#34; target=&#34;_blank&#34;&gt;Date class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/products/jdk/1.1/docs/api/java.sql.Time.html#_top_&#34; target=&#34;_blank&#34;&gt;sql.time class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/products/jdk/1.1/docs/api/java.text.DateFormatSymbols.html#_top_&#34; target=&#34;_blank&#34;&gt;Date format symbols&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/products/jdk/1.1/docs/api/java.text.DateFormat.html#_top_&#34; target=&#34;_blank&#34;&gt;Date format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/products/jdk/1.1/docs/api/java.text.SimpleDateFormat.html#_top_&#34; target=&#34;_blank&#34;&gt;Simple Date Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://java.sun.com/products/jdk/1.1/docs/api/java.util.SimpleTimeZone.html#_top_&#34; target=&#34;_blank&#34;&gt;Simple Time Zone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#script-lang-libs&#34; name=&#34;script-lang-libs&#34;&gt;Scripting Language Libraries&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A python date library &lt;a href=&#34;http://www.lemburg.com/files/python/mxDateTime.html&#34; target=&#34;_blank&#34;&gt;MX Date Time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perl date-time&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://search.cpan.org/Catalog/Data_and_Data_Type/Date/&#34; target=&#34;_blank&#34;&gt;Date-Time packages at CPAN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://search.cpan.org/doc/TWEGNER/Date-Calc-4.3-bin56Mac/Calc.pm&#34; target=&#34;_blank&#34;&gt;Date::Calc&lt;/a&gt; at CPAN&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://search.cpan.org/doc/MORTY/DateConvert-0.16/Convert.pm&#34; target=&#34;_blank&#34;&gt;Date::Convert&lt;/a&gt; calendar conversions at CPAN&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A PHP library &lt;a href=&#34;http://vlib.activefish.com/docs/vlibDate.html&#34; target=&#34;_blank&#34;&gt;Vlib Date Library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#related-commerical-fanciful-pages&#34; name=&#34;related-commerical-fanciful-pages&#34;&gt;関連する商業的かつ想像力に富んだページ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.leapsecond.com/java/gpsclock.htm&#34; target=&#34;_blank&#34;&gt;Leapsecond.com time&lt;/a&gt; page&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.worldtimeserver.com/&#34; target=&#34;_blank&#34;&gt;World Time Server / TZ database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.longnow.org/10kclock/clock.htm&#34; target=&#34;_blank&#34;&gt;10000 year clock&lt;/a&gt; at Long Now Foundation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.timezonesforpcs.com/&#34; target=&#34;_blank&#34;&gt;Timezones for PCs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html#resolution-precision-accuracy&#34; name=&#34;resolution-precision-accuracy&#34;&gt;Resolution, Precision, and Accuracy&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Definitions with pictures from &lt;a href=&#34;http://metrologyforum.tm.agilent.com/specs.shtml&#34; target=&#34;_blank&#34;&gt;Agilent Technologies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Another set of pictures from &lt;a href=&#34;http://www.teamlabs.com/catalog/performance.asp&#34; target=&#34;_blank&#34;&gt;Team Labs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Definitions from &lt;a href=&#34;http://www.solent.ac.uk/hydrography/notes/errorthe/accuracy.htm&#34; target=&#34;_blank&#34;&gt;Southampton Institute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Definitions from &lt;a href=&#34;http://www.newport.com/Support/Tutorials/OptoMech/om4a.asp&#34; target=&#34;_blank&#34;&gt;Newport Corporation&lt;/a&gt; in the context of instrumentation&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>posix_time::time iterators -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/time_iterators.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;posix_time::time iterators&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Time Iterators&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html#header&#34;&gt;Header&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html#class-overview&#34;&gt;Class Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;時間イテレータは、時間単位で反復するための標準的なメカニズムを提供する。 時間イテレータは(STLの)&lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;入力イテレータ&lt;/a&gt;のモデルであり、時間の集合の代入に用いることができる。 次の例は、15分間隔で反復する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;gregorian;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;posix_time;
date &lt;span style=&#34;color: #0000FF&#34;&gt;d&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;2000&lt;/span&gt;,Jan,&lt;span style=&#34;color: #666666&#34;&gt;20&lt;/span&gt;);
ptime &lt;span style=&#34;color: #0000FF&#34;&gt;start&lt;/span&gt;(d);&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//2000-Jan-20 00:00:00&lt;/span&gt;
time_iterator &lt;span style=&#34;color: #0000FF&#34;&gt;titr&lt;/span&gt;(start,minutes(&lt;span style=&#34;color: #666666&#34;&gt;15&lt;/span&gt;)); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//iterate on 15 minute intervals&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//produces 00:00:00, 00:15:00, 00:30:00, 00:45:00&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (; titr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ptime(d,hour(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)); &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;titr) {
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; to_simple_string(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;titr) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/print_hours.cpp.html&#34;&gt;print hours&lt;/a&gt; の例は、1時間増加させ、その日の残りを繰り返す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html#header&#34; name=&#34;header&#34;&gt;Header&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/posix_time/posix_time.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//全ての型とI/Oを含む&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしくは&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &#34;boost/date_time/posix_time/posix_time_types.hpp&#34; &lt;/span&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//型のみでI/Oは含まない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html#class-overview&#34; name=&#34;class-overview&#34;&gt;Class Overview&lt;/a&gt;&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Class&lt;/th&gt;
&lt;th&gt;Construction Parameters&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ptime start_time, time_duration increment&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定された期間(&lt;code&gt;time_duration&lt;/code&gt;)を増分として反復する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>トレードオフ：安定性、予測性と近似 -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/tradeoffs.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/date_time/tradeoffs.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;トレードオフ：安定性、予測性と近似&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;避けられないトレードオフ&lt;/h2&gt;
&lt;p&gt;このライブラリは、ユーザが必要とするであろうすべてを提供するために最善を尽くす。しかし、どの時間ライブラリにも、できることを制限する固有の制約がある。 特に、ユーザはある特定のアプリケーションに、次の3つの能力の内どの2つが必要かを選ぶ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;壁掛け時計の時刻との厳密な一致&lt;/li&gt;
&lt;li&gt;正確な数学, 例: 時間長の計算&lt;/li&gt;
&lt;li&gt;未来の時間位置(timepoints)を取り扱う能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あるライブラリは、3つすべてを与えると暗黙のうちに約束するかもしれない。しかし、実際にテストしてみれば、同時に2つだけが本当である。 この制限は、どんな特定のライブラリでも設計や実装の欠陥ではない;もっと正確に言えば、それは国際基準によって定義される時法系が非常に異なる結果である。 3つのケースについてそれぞれ見てみよう:&lt;/p&gt;
&lt;p&gt;壁掛け時計の時刻との厳密な一致を望むなら、UTC あるいは地域時間のいずれかを使用しなければならない。 UTC 時刻同士の差を取って時間長(duration)を計算し、秒精度が必要な場合、2つの時間はあまり遠い未来にあってはならない。なぜなら、うるう秒が計算に影響するが、そればたったの約半年前に決定されるものだからである。 地域時間については、立法機関が思うままにDST規則を変えることができ、また(実際に)変えるので、未来の時間長(duration)計算は、いつでも異常になり得る。&lt;/p&gt;
&lt;p&gt;壁掛け時計の未来の時間を扱いたければ、(一般的なケースで)上述と同じ理由のために、正確な時間長(durations)を計算することができないであろう。&lt;/p&gt;
&lt;p&gt;もし未来の時間について正確な計算を必要とするなら、TAI あるいは同等の物を使わなければならないだろう。しかし、TAI から UTC あるいは地域時間への写像はうるう秒に依存すため、壁掛け時計の時間と正確には一致しないであろう。&lt;/p&gt;
&lt;h2&gt;安定性、予測性と近似&lt;/h2&gt;
&lt;p&gt;ここに、何が起こっているのかを説明するのに役立つある基礎理論がある。 時間型が任意の抽象的なデータ型(ADT;Abstract Data Type)のように、それらの値に対する操作と一緒に1セットの値であることを忘れないで欲しい。&lt;/p&gt;
&lt;h3&gt;安定性(Stability)&lt;/h3&gt;
&lt;p&gt;与えられた値に関連付いたビットパターンが時間とともに変化しない場合、型の表現は安定している。 不安定な表現を備えた型は、おそらく誰の役にも立たない。したがって、我々はどんな時間ライブラリにも安定した表現だけを使用するよう要求するだろう。&lt;/p&gt;
&lt;p&gt;特定のオペランドに演算を適用する結果が時間とともに変化しない場合、型に対する演算は安定している。&lt;/p&gt;
&lt;h3&gt;予測性(Predictability)&lt;/h3&gt;
&lt;p&gt;集合は、よく明確(well-defined)であるか不明確(ill-defined)であるか、の 2つのカテゴリーに分類される。 型が集合であるので、型をカバーするためにこれらの定義を拡張することができる。&lt;/p&gt;
&lt;p&gt;任意の型 &lt;code&gt;T&lt;/code&gt; について、値 &lt;code&gt;x&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; のメンバーかどうか決める述語 &lt;code&gt;is_member( x )&lt;/code&gt; があるとする。 この述語は、&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, あるいは &lt;code&gt;dont_know&lt;/code&gt; を返すものとする。&lt;/p&gt;
&lt;p&gt;すべての &lt;code&gt;x&lt;/code&gt; について、&lt;code&gt;is_member( x )&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; か &lt;code&gt;false&lt;/code&gt; のどちらかを返す場合、集合 &lt;code&gt;T&lt;/code&gt; は &lt;strong&gt;明確(well-defined)&lt;/strong&gt; であるという。&lt;/p&gt;
&lt;p&gt;任意の &lt;code&gt;x&lt;/code&gt; について、&lt;code&gt;is_member( x )&lt;/code&gt; が &lt;code&gt;dont_know&lt;/code&gt; を返す場合、集合 &lt;code&gt;T&lt;/code&gt; は &lt;strong&gt;不明確(ill-defined)&lt;/strong&gt; であるという。&lt;/p&gt;
&lt;p&gt;それらは数学で通常使われる規則である。 しかしながら、時間型に特有な特性のために、この考察を洗練し、以下のように第3のカテゴリーを作ることは有用である:&lt;/p&gt;
&lt;p&gt;任意の時間型 &lt;code&gt;T&lt;/code&gt; について、値 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; のメンバーかどうか決める述語 &lt;code&gt;is_member( x, t )&lt;/code&gt; があるとする。 述語が評価されるとき、パラメータ &lt;code&gt;t&lt;/code&gt; は時間に相当する。 &lt;code&gt;xi&lt;/code&gt; それぞれに対して、以下のような時間 &lt;code&gt;ti&lt;/code&gt; と値 &lt;code&gt;v&lt;/code&gt; があるとする:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v = true&lt;/code&gt; あるいは &lt;code&gt;v = false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t &amp;lt; ti&lt;/code&gt; である全ての &lt;code&gt;t&lt;/code&gt; について、&lt;code&gt;is_member( xi, t )&lt;/code&gt; は &lt;code&gt;dont_know&lt;/code&gt; を返す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t &amp;gt;= ti&lt;/code&gt; である全ての &lt;code&gt;t&lt;/code&gt; について、&lt;code&gt;is_member( xi, t )&lt;/code&gt; は &lt;code&gt;v&lt;/code&gt; を返す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;xi&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; のメンバーであるかどうか「見つけ出す」とき、&lt;code&gt;ti&lt;/code&gt; はこのように時間である。今、我々は時間型の3つのカテゴリーを定義することができる:&lt;/p&gt;
&lt;p&gt;全ての &lt;code&gt;xi&lt;/code&gt; について、&lt;code&gt;ti&lt;/code&gt; = 負の無限大 のとき、型 &lt;code&gt;T&lt;/code&gt; は &lt;strong&gt;予測可能&lt;/strong&gt; であるという。&lt;/p&gt;
&lt;p&gt;ある &lt;code&gt;xi&lt;/code&gt; について、&lt;code&gt;ti&lt;/code&gt; = 正の無限大 のとき、型 &lt;code&gt;T&lt;/code&gt; は &lt;strong&gt;不明確(ill-formed)&lt;/strong&gt; であるという。&lt;/p&gt;
&lt;p&gt;それ以外のとき、型 &lt;code&gt;T&lt;/code&gt; は &lt;strong&gt;予測不能&lt;/strong&gt; であるという。 (これは、ある &lt;code&gt;xi&lt;/code&gt; のために &lt;code&gt;ti&lt;/code&gt; が有限であることを意味する)&lt;/p&gt;
&lt;p&gt;不明確(ill-formed)な集合には実用性がほとんど無いので、これ以上は議論しない。 上記について簡単に言えば、予測可能な型は全ての値が事前に分かっているが、予測不能な型ではいくつかの値がある特定の時間になるまで分からない。&lt;/p&gt;
&lt;h3&gt;操作の安定性&lt;/h3&gt;
&lt;p&gt;予測可能な型には2つの重要な特性がある:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;それらの要素から連続する整数への、順序を維持する写像が有る&lt;/li&gt;
&lt;li&gt;それらの値に対する時間長(duration)の演算は安定している&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この実用上の効果は時間長(duration)の計算を単純な整数の減算で実装できるということである。 予測可能な型の例は TAI timepoints およびグレゴリオ暦の日付である。&lt;/p&gt;
&lt;p&gt;予測できない型は正反対の特性を持っている:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;それらの要素から連続する整数への、順序を維持する写像が無い&lt;/li&gt;
&lt;li&gt;それらの値に対する時間長(duration)の演算は安定していない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;予測できない型の例は UTC timepoints および地域時間 timepoints である。&lt;/p&gt;
&lt;p&gt;予測不能な型の中の範囲が予測可能であり得ると示すことによって、これを少し改善することができる。また、完全にその範囲内で実行された演算は安定しているであろう。 例えば、UTC timepoints において 1970-01-01 から現在までの範囲は予測可能である。したがって、その範囲内での時間長(duration)の計算は安定しているであろう。&lt;/p&gt;
&lt;h3&gt;近似(Approximations)&lt;/h3&gt;
&lt;p&gt;UTC と 地域時間のような重要な時間型が実際には予測不能なので、これらの制限は問題である。また、したがって、それらに対する演算は時々不安定である。しかし、実用上の問題として、地域時間で指定される将来の 2つの時間位置(timepoints)の間の時間長(duration)を計算するようなこの種の演算を実行したいことが多々ある。&lt;/p&gt;
&lt;p&gt;このライブラリにできる最善策は、近似値(一般に可能で、大抵の用途で十分である)を提供することである。 もちろん、文書は、答えが近似値(したがって不安定である)であること、そしてエラーがどの位の大きさになり得るのか明示しなくてはならない。 多くの点で、予測不能な集合での計算は浮動小数点数の使用(結果がほぼ正確だろうと期待されるだけ)に似ている。 予測可能な集合での計算は整数の使用と似ており、そして結果が正確であると期待される。&lt;/p&gt;
&lt;p&gt;正確な答えが要求されたり、不安定さを許容できない状況のために、ユーザがそれを明示できなければならない。 そして、ユーザが正確で安定した答えが得られないような計算を要求すれば、ライブラリは例外を投げるべきである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Type-safe &#39;printf-like&#39; format class -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/format/choices.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/format/choices.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Type-safe &#39;printf-like&#39; format class&lt;/h1&gt;
&lt;h2&gt;Choices made&lt;/h2&gt;
&lt;p&gt;&#34;Le pourquoi du comment&#34; ( - &#34;どうしてそうなの？&#34;)&lt;/p&gt;
&lt;h2&gt;The syntax of the format-string&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; は新しいライブラリだ。そのゴールの一つは、 &lt;code&gt;printf&lt;/code&gt; の代替物を提供することにある。つまり、 &lt;code&gt;format&lt;/code&gt; は &lt;code&gt;printf&lt;/code&gt; 用に設計された書式文字列を構文解析することができて、与えられた引数にその書式を適用して &lt;code&gt;printf&lt;/code&gt; と同じ結果を生成できる。 &lt;/p&gt;
&lt;p&gt;この制限の下で、書式文字列の文法には大雑把に３つの選択肢が有り得た :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; とまったく同じ文法を用いる。これは多くの経験のあるユーザに知られているし、 ほとんどすべてのニーズにフィットする。しかし命令の終端を断定するために不可欠な型変換文字は、 C++ ストリームの文脈では、 ストリームの関連する書式化オプションをセットする程度の役にしか立たない(&lt;code&gt;%x&lt;/code&gt; なら hexa をセットする、等...) このお仕着せの型変換文字は、意味付けを変更した上で、省略可能にするのが良いだろう。&lt;/li&gt;
&lt;li&gt;互換性を維持しながら拡張された &lt;code&gt;printf&lt;/code&gt; 文法。まだ &lt;code&gt;printf&lt;/code&gt; の文法として有効でない文字や構造を用いる。例． : &lt;code&gt;&#34;%1%&#34;, &#34;%[1]&#34;, &#34;%|1$d|&#34;&lt;/code&gt;, .. 始端 / 終端マークを用いることで、あらゆる種類の拡張を考慮できるようになる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; 互換のものと平行して、非レガシーモードを提供する。 既存の &lt;code&gt;printf&lt;/code&gt; 文法との互換性という制約を受けずに、他の目的に適すように設計できる。 &lt;ul&gt;
&lt;li&gt;しかし &lt;code&gt;printf&lt;/code&gt; の文法の代替物(既存のものより明確に優れていて、かつパワフルなものになるだろう)の設計は、 &lt;code&gt;format&lt;/code&gt; クラスの構築とはまた別の仕事だ。 そのような文法が設計されたときには、 Boost.Format を二つのライブラリに分割することも考慮すべき だろう : 一方はこの新しい文法と歩調を合わせて開発され、もう一つはレガシーな文法を サポートする (おそらくは高速で、 &lt;code&gt;snprintf&lt;/code&gt; やその同類に勝る安全面での改良が組み込まれたバージョンになるだろう)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完全で、気の利いた、 &lt;code&gt;printf&lt;/code&gt; よりも明確に C++ ストリームに適応した新しい文法が手元にないので、二つ目のアプローチを選択することにした。 Boost.Format は &lt;code&gt;printf&lt;/code&gt; の文法を用い、その文法を拡張することで拡張機能(桁送り、中寄せ)を表現することができる。 &lt;/p&gt;
&lt;p&gt;また、 &lt;code&gt;printf&lt;/code&gt; の文法の弱点を克服するために、これまでのものに替わる互換表記を提供する :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#34;%N%&#34;&lt;/code&gt; より単純な位置指定、型指定無し、オプション無しの表記。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%|spec|&lt;/code&gt; &lt;code&gt;printf&lt;/code&gt; の命令を視覚的により明確な構造に密閉する一手段であり、 同時に &lt;code&gt;printf&lt;/code&gt; の&#39;型変換文字&#39;を省略可能にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;なぜ関数呼び出しではなく演算子で引数を渡すのですか？&lt;/h2&gt;
&lt;p&gt;演算子による方法の不便さ(一部の人にとって)は、混乱させられることがあるということだ。 演算子をオーバーロードし過ぎると人々を真の混乱に陥れるという お決まりの警告だ。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; オブジェクトの仕様は限られた文脈(最も多いのは &lt;code&gt;&#34;cout &amp;lt;&amp;lt; &#34;&lt;/code&gt; の直後)になるだろうってことと、 引数がいかにも書式文字列に続いているように見えることから :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34; %s at %s  with %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; z;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;人々をそれほど混乱させないだろうと期待できる。&lt;/p&gt;
&lt;p&gt;演算子の別の恐怖は優先順位の問題だ。 &lt;code&gt;format(&#34;%s&#34;) % (x+y)&lt;/code&gt; と書かずに &lt;code&gt;format(&#34;%s&#34;) % x+y&lt;/code&gt; を書いた場合どうなるだろう？ &lt;/p&gt;
&lt;p&gt;これだとコンパイル時に問題が起きるので、エラーはすぐに検出されるだろう。&lt;/p&gt;
&lt;p&gt;もちろん、この行は &lt;code&gt;tmp = operator%( format(&#34;%s&#34;), x)&lt;/code&gt; を呼び、それから &lt;code&gt;operator+(tmp, y)&lt;/code&gt; を呼ぶ。 &lt;/p&gt;
&lt;p&gt;暗黙の変換が定義されていない限り &lt;code&gt;tmp&lt;/code&gt; は &lt;code&gt;format&lt;/code&gt; オブジェクトとなるだろう。そのため &lt;code&gt;operator+&lt;/code&gt; の呼び出しは失敗する。 (もちろん、君がそんな演算子を定義した場合は除く)。 だから君は優先順位の間違いはコンパイルの際に知らされると安心して決め込んでいい。&lt;/p&gt;
&lt;p&gt;その一方で、関数アプローチには本物の不便さがある。 多くのテンプレート関数を定義する必要があるんだ。こんな感じに :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T2&lt;/span&gt;,  .., &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;TN&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
string format(string s,  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T1&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x1, .... , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T1&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; xN);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;そして N を 500 まで定義したとしても、 まだ C の &lt;code&gt;printf&lt;/code&gt; にはない上限を設けることになる。 &lt;/p&gt;
&lt;p&gt;それに、 &lt;code&gt;format&lt;/code&gt; はどうにかして &lt;code&gt;printf&lt;/code&gt; をエミュレートできる場合もあるけど、 &lt;code&gt;printf&lt;/code&gt; の完全な等価物には程遠い。根本的に異なる外見を用いる方がベストだ。そして演算子呼び出しを使うのは、その点ではとても成功している！&lt;/p&gt;
&lt;p&gt;いずれにせよ、もし僕らが実際にフォーマルな関数呼び出しテンプレートの仕組みを選択していたら、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; (stream, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;が与えられているクラス &lt;code&gt;T&lt;/code&gt; しか表示することができなかっただろう。 なぜなら、 &lt;code&gt;const&lt;/code&gt; と 非 &lt;code&gt;const&lt;/code&gt; の両方を許容すると組み合わせ爆発が生じるからだ - もし 10 個までの引数で行くにしても、 2^10 個の関数が必要になる。&lt;/p&gt;
&lt;p&gt;(&lt;code&gt;T&amp;amp;&lt;/code&gt; と &lt;code&gt;const T&amp;amp;&lt;/code&gt; のオーバーロードを提供することは C++ 標準の不備の最先端だが、おかげでサポートの保証からは程遠い。しかし現在ではいくつかのコンパイラがそうしたオーバーロードをサポートしている) &lt;/p&gt;
&lt;p&gt;非 &lt;code&gt;const&lt;/code&gt; 版の等価物しか提供しないという悪い設計をすることもできるけど、それはユーザにまた別の根拠の無い制限を押し付けることになる。&lt;/p&gt;
&lt;p&gt;また、マニピュレータのいくつかは関数なので、 &lt;code&gt;const&lt;/code&gt; な参照として渡すことができない。 そのため関数呼び出しアプローチはマニピュレータを上手くサポートしない。&lt;/p&gt;
&lt;p&gt;結論として、コンパイル時に引数の数を知ることができない場合には、専用の二項演算子を用いることが最もシンプルで、ロバストで、かつ制限の少ない引数渡しのメカニズムなんだ。&lt;/p&gt;
&lt;h2&gt;なぜ &lt;code&gt;&#39;with(..)&#39;&lt;/code&gt; のようなメンバ関数でなく &lt;code&gt;operator%&lt;/code&gt; なんですか？？&lt;/h2&gt;
&lt;p&gt;技術的には、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format(fstr) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x1 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x2 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x3;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;は、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format(fstr).with( x1 ).with( x2 ).with( x3 );
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;と同じ構造をしている。後者には優先順位の問題は何も無い。 後者のただ一つの欠点は、演算子を用いるのに比べて、一見してこの行が何をしているのか 把握しづらいということだ。 &lt;code&gt;.with(..)&lt;/code&gt; を呼び出すのは、コードのほかの行でやっていることと同じように見える。 だから、好みの問題だけど、この方がより良いな解決方法だろう。 余計な文字を用いる点と、&lt;code&gt;&#39;with(..)&#39;&lt;/code&gt; を用いたコードの行の全般的に散らかった側面は、僕に真の演算子を選択させるのに十分だった。&lt;/p&gt;
&lt;h2&gt;なぜいつもの &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; でなく &lt;code&gt;operator%&lt;/code&gt; なんですか？？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;なぜなら &lt;code&gt;format&lt;/code&gt; オブジェクトに引数を渡すことは、ストリームに順に変数を送ること同じではないからだ。それに &lt;code&gt;format&lt;/code&gt; オブジェクトはストリームでも、マニピュレータでもない。&lt;/p&gt;
&lt;p&gt;僕らは引数を渡すのに演算子を使う。 &lt;code&gt;format&lt;/code&gt; は、関数が単純に引数を一つずつ取るようにそれを使うだろう。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; オブジェクトはストリームのような振る舞いはしない。君がマニピュレータのように動作する &lt;code&gt;format&lt;/code&gt; オブジェクトを実装しようとしてストリームを返すようにすれば、ユーザはストリームのマニピュレータと完璧に同じものだと信じることになる。そして遅かれ早かれ、そのユーザはこの視点のおかげで欺かれる。&lt;/p&gt;
&lt;p&gt;振る舞いの違いの最も明白な例は、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y ;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// うわぁ、 format は本当はストリームマニピュレータじゃないよ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt; の優先順位は &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; よりも高い。 これは問題のように見える。なぜなら &lt;code&gt;+&lt;/code&gt; や &lt;code&gt;-&lt;/code&gt; は括弧の内側にグループ化しなければならないからだ。一方で &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; にはそんな必要は無い。 しかしもしユーザがこのことを忘れても、誤りはコンパイルの際に捕らえられて、きっと彼は二度と忘れないだろう。&lt;/p&gt;
&lt;p&gt;その一方で、より高い優先順位は &lt;code&gt;format&lt;/code&gt; の振る舞いをとても直観的にしてくれる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;は正確には次のように扱われる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; ( format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; y ) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;だから &lt;code&gt;%&lt;/code&gt; を用いることで、 &lt;code&gt;format&lt;/code&gt; オブジェクトの寿命が周囲のストリームの文脈を妨げることはない。 これはあり得る振る舞いの中で最も単純なものだ。そのためユーザは &lt;code&gt;format&lt;/code&gt; オブジェクトの後でストリームを使いつづけることができる。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 演算子では、この状況では物事はより一層厄介だ。この行 :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  x  &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;は次のように解釈される :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;( ( ( cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) ) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x ) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  y ) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;代替となる実装の中には &amp;lt;&amp;lt; 演算子を選択しているものもあるが、これが働くようにする方法は一つしかない :&lt;/p&gt;
&lt;p&gt;最初の&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;( ostream&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;, format &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;呼び出しは プロクシを返す。プロクシは最終的な出力先 (&lt;code&gt;cout&lt;/code&gt;) と書式文字列の情報をカプセル化している。 &lt;/p&gt;
&lt;p&gt;引数を渡している先が &lt;code&gt;format&lt;/code&gt; なのか、それとも &lt;code&gt;format&lt;/code&gt; の完了後の最終的な出力先なのかは区別できない。これは問題だ。&lt;/p&gt;
&lt;p&gt;僕はいくつか考え得る実装を試してみたけど、どれも完璧には希望に沿っていない。&lt;/p&gt;
&lt;p&gt;例えば : ユーザの誤りを捕らえるために、引数が多く渡されすぎたときに例外を発生するのは筋が通っている。 しかしこの文脈では、余分な引数が最終的な出力先に向けられていることはほとんど間違いない。 ここでいくつかの選択肢がある :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引数が過剰かどうかの検出を諦めて、プロクシのテンプレートメンバ &lt;code&gt;operator&amp;lt;&amp;lt; ( const T&amp;amp;)&lt;/code&gt; が単純にすべての余分な引数を &lt;code&gt;cout&lt;/code&gt; に転送するようにする。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; の引数を特殊なマニピュレータ &lt;code&gt;&#39;endf&#39;&lt;/code&gt; で以下のように閉じるよう、ユーザに要求する。 :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  x  &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endf &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;endf&lt;/code&gt; はプロキシの内部に保持されていた最終的な出力先を返す関数として定義できる。 それで万事解決だ。 &lt;code&gt;endf&lt;/code&gt; の後は、ユーザは再び &lt;code&gt;cout&lt;/code&gt; に向けて &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; を呼んでいる。
    - 中間的な解決方法もある。最も頻繁な使い方は、単にもう一つ多くのマニピュレータ (&lt;code&gt;std::flush&lt;/code&gt; や &lt;code&gt;endl&lt;/code&gt;, ..) を &lt;code&gt;cout&lt;/code&gt; へ出力したい場合だろう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  x  &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; flush ;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;だからその解決方法は &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; をマニピュレータに対してオーバーロードすることだ。 この方法では &lt;code&gt;endf&lt;/code&gt; は不要だが、マニピュレータ以外のものを &lt;code&gt;format&lt;/code&gt; の引数の後に出力する事はできない。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最も完全な解決方法は &lt;code&gt;endf&lt;/code&gt; マニピュレータを使うものだ。 &lt;code&gt;%&lt;/code&gt; 演算子を使う場合、この書式終端関数は不要だ。さらにどの引数が &lt;code&gt;format&lt;/code&gt; オブジェクトの中へと向かい、どれがストリームへ向かうのかがすぐに分かる。
- 美しさの問題 : &lt;code&gt;&#39;%&#39;&lt;/code&gt; は書式文字列の内部で使われているものと同じ文字だ。それぞれの引数を渡すのに同じ文字を使うというのはなかなか良い考えだろう。 &lt;code&gt;&#39;&amp;lt;&amp;lt;&#39;&lt;/code&gt; は２文字、 &lt;code&gt;&#39;%&#39;&lt;/code&gt; は１文字。 &lt;code&gt;&#39;%&#39;&lt;/code&gt; はサイズの面でもより小さい。 見た目の面でも全般的に改善している (何がどうなっているのかが分かる) :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s %s&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;x &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;y &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;z &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;And  avg is&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;avg;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これと次を比較すると :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s %s&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; z &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endf &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;And avg is&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; avg;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&#34;&amp;lt;&amp;lt;&#34;&lt;/code&gt; は、ストリームに渡されているオブジェクトと同じレベルで引数を与えているから、間違いを起こしやすい。
- python も書式化に &lt;code&gt;%&lt;/code&gt; を使っている。だから &#34;聞いたことも無いような&#34; ものじゃないって納得してくれるよね ;-)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;なぜ &lt;code&gt;operator()&lt;/code&gt; や &lt;code&gt;operator[]&lt;/code&gt; ではなく &lt;code&gt;operator%&lt;/code&gt; なんですか？？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; には、関数に引数を送る自然な方法であるというメリットがある。 また、 &lt;code&gt;operator[]&lt;/code&gt; の意味が &lt;code&gt;format&lt;/code&gt; で使うには上手く当てはまると考える人もいる。&lt;/p&gt;
&lt;p&gt;技術的にはこれらは &lt;code&gt;operator%&lt;/code&gt; と同じくらい良い選択だ。しかしすごく醜い。 (好みの問題だ)&lt;/p&gt;
&lt;p&gt;それにそもそも、書式文字列の中の &lt;code&gt;&#34;%&#34;&lt;/code&gt; で参照されている引数を &lt;code&gt;operator%&lt;/code&gt; を使って渡すことは、それらの演算子を使うよりずっと自然に見える。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;July 07, 2001&lt;/p&gt;
&lt;p&gt;© Copyright Samuel Krempp 2001. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>The Boost Format library -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/format/format.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/format/format.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;The Boost Format library&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;boost/format.hpp&amp;gt;&lt;/code&gt; &lt;code&gt;format&lt;/code&gt;クラスは &lt;code&gt;printf&lt;/code&gt; に似た、ユーザ定義型も扱える型安全な書式化処理を提供する。 &lt;/p&gt;
&lt;p&gt;(このライブラリは他の &lt;code&gt;boost&lt;/code&gt; ライブラリに依存しない)&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#synopsis&#34;&gt;概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#how-it-works&#34;&gt;どのように作用するか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#examples&#34;&gt;コード例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#sample-files&#34;&gt;サンプルファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#syntax&#34;&gt;構文&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#printf-format-specifications&#34;&gt;printfフォーマット仕様&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#new-format-specifications&#34;&gt;新たなフォーマット仕様&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#differences-of-behavior-vs-printf&#34;&gt;printfとの振る舞いの違い&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#user-defined-types-output&#34;&gt;ユーザー定義型の出力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#manipulators-and-the-internal-stream-state&#34;&gt;マニピュレータと、内部的なストリーム状態&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#alternatives&#34;&gt;代替手段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#exceptions&#34;&gt;例外&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#extract&#34;&gt;抜粋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#rationale&#34;&gt;設計原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#credits&#34;&gt;クレジット&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#synopsis&#34; name=&#34;synopsis&#34;&gt;概要&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; オブジェクトは書式文字列から構築され、その後 &lt;code&gt;operator%&lt;/code&gt; を繰り返し呼び出されることで引数を与えられる。 &lt;/p&gt;
&lt;p&gt;それぞれの引数は文字列に変換され、書式文字列に従って順に一つの文字列へと結合される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;writing %1%,  x=%2% : %3%-th try&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;toto&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;40.23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; 
     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#34;writing toto,  x=40.230 : 50-th try&#34;と表示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#how-it-works&#34; name=&#34;how-it-works&#34;&gt;どのように作用するか&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1.書式文字列 &lt;code&gt;s&lt;/code&gt; を伴って &lt;code&gt;format(s)&lt;/code&gt; を呼び出すと、あるオブジェクトが構築される。このオブジェクトは、書式文字列を構文解析してすべての命令を探し、次のステップのために内部構造を準備する。
2.そして、すぐに&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt; )
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;のようにするか、あるいは後で、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;);
fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt;; fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;とすることで、フォーマッタに変数を食わせることができる。 &lt;/p&gt;
&lt;p&gt;変数は内部のストリームにダンプされる。ストリームの状態は、与えられた書式文字列の書式化オプション(あれば)によってセットされる。 &lt;code&gt;format&lt;/code&gt; オブジェクトは最後のステップのための結果文字列を保持する。&lt;/p&gt;
&lt;p&gt;3.すべての引数を与えてしまえば、その &lt;code&gt;format&lt;/code&gt; オブジェクトをストリームにダンプしたり、メンバ関数 &lt;code&gt;str()&lt;/code&gt; か名前空間 &lt;code&gt;boost::io&lt;/code&gt; にある &lt;code&gt;str(const format&amp;amp;)&lt;/code&gt; 関数で文字列を取り出すことができる。結果の文字列は、別の引数が与えられて再初期化されるまで、 &lt;code&gt;format&lt;/code&gt; オブジェクトの中にアクセス可能な状態で残る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 先ほど作って引数を与えた fmter の結果を表示:&lt;/span&gt;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter ;  

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 結果の文字列を取り出せる:&lt;/span&gt;
string s  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fmter.str();

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 何度でも:&lt;/span&gt;
s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fmter.str( );

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// すべてのステップを一度に行うこともできる:&lt;/span&gt;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt;; 
string s2 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;str( format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;4.ステップ３の後で &lt;code&gt;format&lt;/code&gt; オブジェクトを再利用し、ステップ２からやり直すこともできる: &lt;code&gt;fmter % 18 % 39;&lt;/code&gt;
新しい変数を同じ書式文字列で書式化する際は、こうすることでステップ１で生じる高価な処理を節約できる。&lt;/p&gt;
&lt;p&gt;結局のところ、 &lt;code&gt;format&lt;/code&gt; クラスは、書式文字列(&lt;code&gt;printf&lt;/code&gt; に似た命令を用いる)を内部のストリームへの操作に翻訳する。そして最終的に、その書式化の結果を文字列として、あるいは直接に出力ストリームへと返す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#examples&#34; name=&#34;examples&#34;&gt;コード例&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;group;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;str;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;並べ替えありの単純な出力:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1% %2% %3% %2% %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;11&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;22&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;333&#34;&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#39;単純な&#39;形式。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;表示はこうなる : &lt;code&gt;&#34;11 22 333 22 11 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POSIX 版 &lt;code&gt;printf&lt;/code&gt; の位置指定命令を用いた、より精細な書式化:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%1$+5d,%2$+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// POSIX版Printf形式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;表示はこうなる : &lt;code&gt;&#34;(x,y) = ( -23, +35) \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;並べ替えのない、古典的な &lt;code&gt;printf&lt;/code&gt; の命令:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;writing %s,  x=%s : %d-th step &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;toto&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;40.23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;表示はこうなる : &lt;code&gt;&#34;writing toto, x=40.23 : 50-th step \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同じことを表現するにもいろいろな方法がある:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%+5d,%+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%|+5|,%|+5|) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;

cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%1$+5d,%2$+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%|1$+5|,%|2$+5|) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;表示はどれも : &lt;code&gt;&#34;(x,y) = ( -23, +35) \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;マニピュレータによる書式文字列の修飾:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1$+5d_ %1$d &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;);

format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter2&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1%_ %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;);
fmter2.modify_item(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, group(showpos, setw(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;)) ); 

cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt; ;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter2 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt; ;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;どちらも同じように表示する : &lt;code&gt;&#34;_ +101_ 101 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引数を伴うマニピュレータ:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1%_ %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; group(showpos, setw(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;), &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;マニピュレータは、 &lt;code&gt;%1%&lt;/code&gt; が現れるたびに適用されるので、出力はこうなる : &lt;code&gt;&#34;_ +101_ +101 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しいフォーマット機能「絶対桁送り(absolute tabulations)」はループの中で使うと便利である。これはあるフィールドを各行の同じ位置に出力する機能で、たとえ直前の引数の幅が大きく変化したとしても、同じ位置に出力することを保証してくれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color: #666666&#34;&gt;=0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; names.size(); &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
    cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1%, %2%, %|40t|%3%&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; names[i] &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; surname[i] &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; tel[i];
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;names&lt;/code&gt; 、 &lt;code&gt;surnames&lt;/code&gt; 、そして &lt;code&gt;tel&lt;/code&gt; などのベクタ(sample_new_features.cpp を参照)は次のように表示される :&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;Marc-Françis Michel, Durand,           +33 (0) 123 456 789
Jean, de Lattre de Tassigny,           +33 (0) 987 654 321
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#sample-files&#34; name=&#34;sample-files&#34;&gt;サンプルファイル&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/example/sample_formats.cpp.html&#34;&gt;sample_formats.cpp&lt;/a&gt; は &lt;code&gt;format&lt;/code&gt; の簡単な使い方をデモする。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/example/sample_new_features.cpp.html&#34;&gt;sample_new_features.cpp&lt;/a&gt; は、単純な位置指定命令、中寄せ、そして「桁送り」など、 &lt;code&gt;printf&lt;/code&gt; の構文に追加された書式化機能のいくつかを説明する。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/example/sample_advanced.cpp.html&#34;&gt;sample_advanced.cpp&lt;/a&gt; は、 &lt;code&gt;format&lt;/code&gt; オブジェクトの 再利用や修飾といった、さらに進んだ機能の使い方をデモする。&lt;/p&gt;
&lt;p&gt;そして &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/example/sample_userType.cpp.html&#34;&gt;sample_userType.cpp&lt;/a&gt; はユーザ定義型に対する &lt;code&gt;format&lt;/code&gt; の振る舞いを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#syntax&#34; name=&#34;syntax&#34;&gt;構文&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format( format&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;string ) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; arg1 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; arg2 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ... &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; argN
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;format-string&lt;/strong&gt; は特殊な命令を含むテキストである。これらの命令は、与えられた引数の書式化結果の文字列によって置換される。 &lt;/p&gt;
&lt;p&gt;C/C++ の世界におけるレガシーな構文は &lt;code&gt;printf&lt;/code&gt; で使われているものである。そのため &lt;code&gt;format&lt;/code&gt; は &lt;code&gt;printf&lt;/code&gt; の書式文字列をそのまま利用でき、同じ結果を生成する。(ほとんどの場合において。詳細は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#differences-of-behavior-vs-printf&#34;&gt;&lt;code&gt;printf&lt;/code&gt;との違い&lt;/a&gt; を見よ) &lt;/p&gt;
&lt;p&gt;この中核となる構文は、新機能を許すだけでなく、 C++ のストリームの文脈に適合するために拡張された。そのため、 &lt;code&gt;format&lt;/code&gt; は書式文字列のさまざまな形式の命令を受け付ける :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;レガシーな &lt;code&gt;printf&lt;/code&gt; の書式文字列 : &lt;code&gt;%spec&lt;/code&gt;　ここで &lt;strong&gt;spec&lt;/strong&gt; は &lt;code&gt;printf&lt;/code&gt; の書式指定子である &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;spec&lt;/strong&gt; は幅、アライメント、数値を書式化する際の基数、その他の特殊なフラグなどの書式化オプションを渡す。 しかし &lt;code&gt;printf&lt;/code&gt; の古典的な型指定フラグは &lt;code&gt;format&lt;/code&gt; ではより弱い意味しか持たない。 &lt;code&gt;format&lt;/code&gt; は内部ストリームと書式化パラメータのどちらかまたは両方に適当なフラグをセットするだけで、対応する引数が指定した型であるかどうかは問わない。 &lt;/li&gt;
&lt;li&gt;例 : &lt;code&gt;2$x&lt;/code&gt; という指定子は、 &lt;code&gt;printf&lt;/code&gt; にとっては「整数である二つ目の引数を16進数で出力する」という意味であるが、 &lt;code&gt;format&lt;/code&gt; においては「二つ目の引数を、ストリームの &lt;code&gt;basefield&lt;/code&gt; フラグを &lt;code&gt;hex&lt;/code&gt; にセットして出力する」という意味でしかない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%|spec|&lt;/code&gt; ここで &lt;strong&gt;spec&lt;/strong&gt; は &lt;code&gt;printf&lt;/code&gt; の書式指定子である。 &lt;ul&gt;
&lt;li&gt;括弧[訳注：米英語では、二つの記号の組み合わせで何かを囲むものはすべてbracket(括弧)と呼び、ここでは縦棒 &lt;code&gt;|&lt;/code&gt; 二つを括弧と呼んでいる]は書式文字列の可読性を改善するが、本来は &lt;strong&gt;spec&lt;/strong&gt; の型変換文字を省略可能にするために導入された。この情報は C++ の変数には不要だが、 &lt;code&gt;printf&lt;/code&gt; の構文をそのまま用いる場合には、書式指定子の終端を決定するために必要だというだけの理由で、常に型変換文字を与える必要がある。 &lt;/li&gt;
&lt;li&gt;例 : &lt;code&gt;&#34;%|-5|&#34;&lt;/code&gt; は 次の変数を幅を 5 、左寄せにフォーマットする。これは &lt;code&gt;printf&lt;/code&gt; の以下の命令と同じものである : &lt;code&gt;&#34;%-5g&#34;&lt;/code&gt;, &lt;code&gt;&#34;%-5f&#34;&lt;/code&gt;, &lt;code&gt;&#34;%-5s&#34;&lt;/code&gt; ..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%N%&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;この単純な位置指定の表記は、 N 番目の引数を書式化オプションなしでフォーマットするよう要求するものである。 &lt;/li&gt;
&lt;li&gt;(これは &lt;code&gt;printf&lt;/code&gt; の位置指定命令(&lt;code&gt;&#34;%N$s&#34;&lt;/code&gt; のような)の短縮形に過ぎないが、ずっと読みやすく、また「型変換指定」文字を用いないですむというご利益がある)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;printf&lt;/code&gt; の標準の書式指定子に加えて、中寄せのような新しい機能が実装されている。詳細は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#new-format-specifications&#34;&gt;new format specification&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#printf-format-specifications&#34; name=&#34;printf-format-specifications&#34;&gt;printfフォーマット仕様&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Boost.Format でサポートされる &lt;code&gt;printf&lt;/code&gt; の書式指定子は、引数の位置指定をサポートしない標準 C の &lt;code&gt;printf&lt;/code&gt; よりも、むしろ Unix98 &lt;a href=&#34;http://www.opengroup.org/onlinepubs/7908799/xsh/fprintf.html&#34; target=&#34;_blank&#34;&gt;Open-group printf&lt;/a&gt; の構文に従っている。 (両者の間では共通のフラグは同じ意味を持つので、誰も頭痛に悩まされることはない) &lt;/p&gt;
&lt;p&gt;なお、一つの書式文字列に位置指定付きの書式指定子(例．&lt;code&gt;%3$+d&lt;/code&gt;)と位置指定なしのもの(例．&lt;code&gt;%+d&lt;/code&gt;)を混ぜて使用するのはエラーである。 
Open-group の仕様では同じ引数を複数回参照すること(例．&lt;code&gt;&#34;%1$d %1$d&#34;&lt;/code&gt;)は未定義動作であるが、 Boost.Format では各引数を何度でも参照できる。ただ一つの制約は、書式文字列に現れる最大の引数の数が P であるとき、必ず P 個の引数を期待することである。(例．&lt;code&gt;&#34;%1$d %10$d&#34;&lt;/code&gt; ならば P == 10) &lt;/p&gt;
&lt;p&gt;引数の数が多すぎても少なすぎても例外が起こる。 (そうでないようにセットされていなければ。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#exceptions&#34;&gt;exceptions&lt;/a&gt; を参照)&lt;/p&gt;
&lt;p&gt;書式指定子 &lt;strong&gt;spec&lt;/strong&gt; は次の形式を持つ : [ &lt;strong&gt;N&lt;/strong&gt;&lt;code&gt;$&lt;/code&gt; ] [ &lt;strong&gt;flags&lt;/strong&gt; ] [ &lt;strong&gt;width&lt;/strong&gt; ] [ . &lt;strong&gt;precision&lt;/strong&gt; ] &lt;strong&gt;type-char&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大括弧で囲われたフィールドは省略可能である。 各フィールドは以下のリストのように説明される :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;code&gt;$&lt;/code&gt; (省略可能なフィールド)は、その書式指定子が N 番目の引数に適用されると指定する。(これは &lt;strong&gt;位置指定書式指定子&lt;/strong&gt; と呼ばれる) &lt;/li&gt;
&lt;li&gt;これが与えられない場合、引数は前から順番に解釈される。(ただし、その後に引数番号付きの書式指定子を与えるのはエラーである)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flags&lt;/strong&gt; は以下の任意のシーケンスである :&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;意味&lt;/th&gt;
&lt;th&gt;内部ストリームへの作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;-&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左寄せ&lt;/td&gt;
&lt;td&gt;N/A (後で文字列に適用される)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;=&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;中寄せ&lt;/td&gt;
&lt;td&gt;N/A (後で文字列に適用される)&lt;br /&gt; &lt;code&gt;printf&lt;/code&gt; には存在しない(追加機能)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;+&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正の数であっても符号を表示する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;showpos&lt;/code&gt; をセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;#&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基数および小数点を表示する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;showbase&lt;/code&gt; と &lt;code&gt;showpoint&lt;/code&gt; をセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;0&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0 で穴埋めする(符号および基数表示の後に挿入) 左寄せでない場合、 &lt;code&gt;setfill(&#39;0&#39;)&lt;/code&gt; を呼び出し &lt;code&gt;internal&lt;/code&gt; をセットする&lt;br /&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#user-defined-types-output&#34;&gt;ユーザ定義型&lt;/a&gt;を扱うためにストリーム変換の後に追加の動作を行う&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39; &#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列が &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; から始まらない場合、変換された文字の前にスペースを挿入&lt;/td&gt;
&lt;td&gt;N/A (後で文字列に適用される) &lt;br /&gt; &lt;code&gt;printf&lt;/code&gt; のものとは挙動が異なる : 内部のアライメントには影響されない&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;width&lt;/strong&gt; は変換の結果文字列に対する最小の幅を指定する。 必要ならば、文字列はアライメントにあわせてパディングされ、文字で埋める。この文字はマニピュレータ経由でストリームにセットされたものか、あるいは書式文字列で指定された文字(例． &lt;code&gt;&#39;0&#39;&lt;/code&gt;, &lt;code&gt;&#39;-&#39;&lt;/code&gt;, ... などのフラグ)である。 &lt;ul&gt;
&lt;li&gt;この幅は変換ストリームにセットされるのではないことに注意してほしい。 ユーザ定義型の出力をサポートする(これはいくつかのメンバに &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; を何度も呼び出すことになりうる)ため、幅の取り扱いはすべての引数オブジェクトのストリーム変換の後に、 &lt;code&gt;format&lt;/code&gt; クラスのコードの中で行われる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;precision&lt;/strong&gt; (小数点の後に続く)はストリームの精度をセットする。&lt;ul&gt;
&lt;li&gt;浮動少数点型の数値を出力する場合、&lt;ul&gt;
&lt;li&gt;固定小数点表示モードまたは指数表示モードでは、小数点より後ろの数字の最大文字数を設定する。&lt;/li&gt;
&lt;li&gt;デフォルトモード(%g のような&#39;ジェネラルモード&#39;)では、全体の数字の最大文字数を設定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;type-char&lt;/strong&gt; が &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;S&lt;/code&gt; の場合は別の意味を持つ : 変換文字列は最初の &lt;strong&gt;precision&lt;/strong&gt; 文字で切り詰められる。 (&lt;strong&gt;width&lt;/strong&gt; によるパディングは、この切り詰めの後で施される。)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;type-char&lt;/strong&gt; 。これは、対象になっている引数が指定した型のいずれかであることを強要しない。その型指定子に関連付けられたフラグをセットするだけである。&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型変換指定文字&lt;/th&gt;
&lt;th&gt;意味&lt;/th&gt;
&lt;th&gt;ストリームへの作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p&lt;/code&gt; または &lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;１６進数で出力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hex&lt;/code&gt; をセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;８進数で出力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;oct&lt;/code&gt; をセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点数の指数表記&lt;/td&gt;
&lt;td&gt;&lt;code&gt;floatfield&lt;/code&gt; ビットを &lt;code&gt;scientific&lt;/code&gt; にセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;f&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点数の固定小数点表記   &lt;code&gt;floatfield&lt;/code&gt; ビットを &lt;code&gt;fixed&lt;/code&gt; にセットする&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一般的な(デフォルトの)浮動小数点表記&lt;/td&gt;
&lt;td&gt;すべての &lt;code&gt;floatfield&lt;/code&gt; ビットを&lt;strong&gt;外す&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt; または &lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;それぞれの小文字と同じように作用。ただし数値の出力に際して大文字を用いる。(指数、１６進数、..)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&#39;x&#39;&lt;/code&gt;, &lt;code&gt;&#39;e&#39;&lt;/code&gt;, または &lt;code&gt;&#39;g&#39;&lt;/code&gt; と同じ作用に&lt;strong&gt;加え&lt;/strong&gt;、 &lt;code&gt;uppercase&lt;/code&gt; をセットする。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; または &lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;１０進数で出力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basefield&lt;/code&gt; ビットを &lt;code&gt;dec&lt;/code&gt; にセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt; または &lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列を出力&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;precision&lt;/strong&gt; 指定子が外され、値は後の&#39;切り詰め&#39;のために内部フィールドへ送られる。 (上記の &lt;strong&gt;precision&lt;/strong&gt; の説明を参照)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt; または &lt;code&gt;C&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;１文字出力&lt;/td&gt;
&lt;td&gt;変換文字列の最初の文字のみが用いられる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字&lt;code&gt;%&lt;/code&gt;を表示&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;&#39;n&#39;&lt;/code&gt; 型指定子は、こうした流れに合わないので、無視される(そして対応する引数も)。 &lt;/p&gt;
&lt;p&gt;また、 &lt;code&gt;printf&lt;/code&gt; の &lt;code&gt;&#39;l&#39;&lt;/code&gt;, &lt;code&gt;&#39;L&#39;&lt;/code&gt;, あるいは &lt;code&gt;&#39;h&#39;&lt;/code&gt; 修飾子(ワイド、ロングおよびショート型を示す)もサポートされている(が、内部ストリームには何の作用もしない)。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#new-format-specifications&#34; name=&#34;new-format-specifications&#34;&gt;新たなフォーマット仕様&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;前述の表で述べたように、中寄せフラグ &lt;code&gt;&#39;=&#39;&lt;/code&gt; が追加された。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%{n&lt;/code&gt;&lt;strong&gt;t&lt;/strong&gt;&lt;code&gt;}&lt;/code&gt; は絶対桁送りを挿入する。ここで n は正の数である。 すなわち &lt;code&gt;format&lt;/code&gt; は、必要であれば、作成済みの文字列の長さが n 文字に届くまで文字で埋め込む。 (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#examples&#34;&gt;examples&lt;/a&gt; を参照)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%{n&lt;/code&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;code&gt;X}&lt;/code&gt; も同様に桁送りを挿入するが、埋め込む文字としてストリームの現在の「埋め込み」文字の代わりに &lt;code&gt;X&lt;/code&gt; を用いる。 (デフォルト状態のストリームではスペースを埋め込む)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#differences-of-behavior-vs-printf&#34; name=&#34;differences-of-behavior-vs-printf&#34;&gt;printfとの振る舞いの違い&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt; という二つの変数(組み込み型で、 C の &lt;code&gt;printf&lt;/code&gt; でサポートされているもの)と書式文字列&lt;code&gt;s&lt;/code&gt;があって、 &lt;code&gt;printf&lt;/code&gt; 関数で以下のように使われるとする :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;printf(s, x1, x2);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ほとんどすべてのケースで、その結果はこの命令と同じものになる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(s) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x1 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x2;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかしいくつかの &lt;code&gt;printf&lt;/code&gt; 書式指定子はストリームの書式化オプションに上手く翻訳されないため、 Boost.Format の &lt;code&gt;printf&lt;/code&gt; エミュレーションには注意すべき僅かな不完全性がある。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; クラスは、 &lt;code&gt;printf&lt;/code&gt; の書式文字列を常に受け付けてほとんど同じ出力を生成するように、どのような場合でもサポートしないオプションを黙って無視する。 &lt;/p&gt;
&lt;p&gt;以下はそうした相違点のすべての一覧である :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;0&#39;&lt;/code&gt; および &lt;code&gt;&#39; &#39;&lt;/code&gt; オプション : &lt;code&gt;printf&lt;/code&gt; は数値以外の変換でこれらのオプションを無視するが、 &lt;code&gt;format&lt;/code&gt; は変数のあらゆる型にそれらを適用する。 (そのためこれらのオプションをユーザ定義型に対して用いることができる。例． &lt;code&gt;Rational&lt;/code&gt; クラスなど)&lt;/li&gt;
&lt;li&gt;汎整数型の引数に対する &lt;strong&gt;precision&lt;/strong&gt; は &lt;code&gt;printf&lt;/code&gt; では特別な意味を持つ : &lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf( &#34;(%5.3d)&#34; , 7 ) ;&lt;/code&gt; は &lt;code&gt;«( 007) »&lt;/code&gt; と出力する。 &lt;/li&gt;
&lt;li&gt;一方で &lt;code&gt;format&lt;/code&gt; は、ストリームと同様に、汎整数型への変換に対する精度パラメータを無視する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; の &lt;code&gt;&#39;&lt;/code&gt; オプション (三桁ごとに数値をグループ化する書式)) は &lt;code&gt;format&lt;/code&gt; では無効である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; では、幅または精度がアスタリスク (&lt;code&gt;*&lt;/code&gt;) にセットされている場合、その値を与えられた引数から読み取る。例． &lt;code&gt;printf(&#34;%1$d:%2$.*3$d:%4$.*3$d\n&#34;, hour, min, precision, sec);&lt;/code&gt; [訳注：この例では、 &lt;code&gt;min&lt;/code&gt; と &lt;code&gt;sec&lt;/code&gt; を表示する際の精度は第三引数 &lt;code&gt;precision&lt;/code&gt; の値が用いられる。 &lt;code&gt;precision=3&lt;/code&gt; なら &lt;code&gt;&#34;%.3d&#34;&lt;/code&gt; だし、 &lt;code&gt;precision=10&lt;/code&gt; なら &lt;code&gt;&#34;%.10d&#34;&lt;/code&gt; になる。] &lt;ul&gt;
&lt;li&gt;このクラスは現在のところ、このメカニズムをサポートしない。そのためこのような精度または幅フィールドは構文解析の時点で黙って無視される。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に、特殊な &lt;code&gt;&#39;n&#39;&lt;/code&gt; 型指定子 (書式化によって出力された文字数を変数に格納するよう &lt;code&gt;printf&lt;/code&gt; に命じるのに用いる) は &lt;code&gt;format&lt;/code&gt; では無効である。&lt;/p&gt;
&lt;p&gt;そのためこの型指定子を含む書式文字列は &lt;code&gt;printf&lt;/code&gt; でも &lt;code&gt;format&lt;/code&gt; でも同じ変換文字列を生成する。 &lt;code&gt;printf&lt;/code&gt; と &lt;code&gt;format&lt;/code&gt; で書式化された文字列に違いは生じない。 &lt;/p&gt;
&lt;p&gt;Boost.Format で書式化された文字数をを得るには以下のようにする :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format &lt;span style=&#34;color: #0000FF&#34;&gt;formatter&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%+5d&#34;&lt;/span&gt;);
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; formatter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x;
&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; formatter.str().size();
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#user-defined-types-output&#34; name=&#34;user-defined-types-output&#34;&gt;ユーザー定義型の出力&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ストリーム状態の修飾に翻訳されたすべてのフラグは、ユーザ定義型にも再帰的に作用する。 ( フラグはアクティブなまま残るので、 ユーザ定義クラスによって呼ばれる各々の &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 演算に対しても、期待するオプションが渡される) &lt;/p&gt;
&lt;p&gt;例．妥当なクラス &lt;code&gt;Rational&lt;/code&gt; なら次のようになる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Rational &lt;span style=&#34;color: #0000FF&#34;&gt;ratio&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;16&lt;/span&gt;,&lt;span style=&#34;color: #666666&#34;&gt;9&lt;/span&gt;);
cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%#x &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;0x10/0x9 \n&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;その他の書式化オプションでは話は異なる。例えば、幅の設定はオブジェクトによって生成される最終出力に適用され、内部の各々の出力には適用されない。これは都合のいい話である :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%-8d&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;16/9    &#34; であって、 &#34;16      /9       &#34; ではない&lt;/span&gt;
cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%=8d&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;  16/9  &#34; であって、 &#34;   16   /    9   &#34; ではない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかし、 &lt;code&gt;0&lt;/code&gt; や &lt;code&gt;&#39; &#39;&lt;/code&gt; オプションにも同様に働くため、不自然なことになってしまう。(意地の悪いことに、 &lt;code&gt;&#39;+&#39;&lt;/code&gt; が &lt;code&gt;showpos&lt;/code&gt; によってストリームの状態へと直接翻訳できるのに対して、 &lt;code&gt;printf&lt;/code&gt; のゼロやスペースに当たるオプションはストリームには存在しない) :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%+08d &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;+00016/9&#34;&lt;/span&gt;
cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;% 08d &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;000 16/9&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#manipulators-and-the-internal-stream-state&#34; name=&#34;manipulators-and-the-internal-stream-state&#34;&gt;マニピュレータと、内部的なストリーム状態&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; の内部ストリームの状態は、引数を出力する直前に保存され、直後に復帰される。そのため、修飾子の影響は後まで引きづられずに、適用される引数にだけ作用する。 &lt;/p&gt;
&lt;p&gt;ストリームのデフォルト状態は標準で述べられているように : 精度 6 、幅 0 、右寄せ、そして１０進数基数である。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; ストリームの内部ストリームの状態は引数と一緒に渡されるマニピュレータによって変えることができる； &lt;code&gt;group&lt;/code&gt; 関数を経由して以下のようにできる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1% %2% %1%&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; group(hex, showbase, &lt;span style=&#34;color: #666666&#34;&gt;40&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#34;0x28 50 0x28\n&#34; と表示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;group&lt;/code&gt; の内側にある N 個の項目を渡すとき、 Boost.Format はマニピュレータに通常の引数とは異なる処理をする必要がある。そのため、 &lt;code&gt;group&lt;/code&gt; の使用には以下の制限がある :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表示されるオブジェクトは &lt;code&gt;group&lt;/code&gt; の最後の項目として渡されなければならない&lt;/li&gt;
&lt;li&gt;先頭の N-1 個の項目はマニピュレータとして扱われるので、出力を生成しても破棄される&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;マニピュレータは、それが現れるごとに、後に続く引数の直前にストリームに渡される。 書式文字列で指定された書式化オプションは、この方法で渡されたストリーム状態修飾子によって上書きされる点に注意して欲しい。 例えば以下のコードで、 &lt;code&gt;hex&lt;/code&gt; マニピュレータは、書式文字列の中で１０進数出力を設定している型指定子 d よりも高い優先度を持つ :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1$d %2% %1%&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; group(hex, showbase, &lt;span style=&#34;color: #666666&#34;&gt;40&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; 
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#34;0x28 50 0x28\n&#34; と表示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#alternatives&#34; name=&#34;alternatives&#34;&gt;代替手段&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;printf&lt;/em&gt; は古典的な代替手段である。型安全でなく、ユーザ定義型に対して拡張可能ではない。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ece.ucdavis.edu/~kenelson/ofrstream.cc&#34; target=&#34;_blank&#34;&gt;ofrstream.cc&lt;/a&gt; Karl Nelson によるデザインはこの &lt;code&gt;format&lt;/code&gt; クラスへのインスピレーションの大きな源となった。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.yahoo.com/group/boost/files/format/&#34; target=&#34;_blank&#34;&gt;format.hpp&lt;/a&gt; Rüiger Loo による。 &lt;code&gt;boost:format&lt;/code&gt; クラスの以前の提案だった。 デザインの簡易さにおいてこのクラスの起源である。最小主義的な &lt;code&gt;&#34;%1 %2&#34;&lt;/code&gt; という構文はこのクラスでも借用している。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.gabi-soft.de/code/gabi-lib.tgz&#34; target=&#34;_blank&#34;&gt;James Kanze&#39;s library&lt;/a&gt; は非常に洗練された &lt;code&gt;format&lt;/code&gt; クラス (&lt;code&gt;srcode/Extended/format&lt;/code&gt;) を持っている。 そのデザインは、実際の変換に内部ストリームを用いる点や引数渡しに演算子を用いる点で、このクラスと共通している。 (しかし彼のクラス &lt;code&gt;ofrstream&lt;/code&gt; は &lt;code&gt;operator%&lt;/code&gt; ではなく &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; を用いている)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.yahoo.com/group/boost/files/format3/&#34; target=&#34;_blank&#34;&gt;Karl Nelson&#39;s library&lt;/a&gt; は、 Boost.Format のデザインのための boost メーリングリストの討論において、別の解決法を示すために用意された。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#Exceptions&#34; name=&#34;exceptions&#34;&gt;例外&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Format は &lt;code&gt;format&lt;/code&gt; オブジェクトの使い方にいくつかのルールを強要する。書式文字列は前述の構文に従わなくてはならず、ユーザは最終的な出力までに正しい個数の引数を供給しなければならない。また &lt;code&gt;modify_item&lt;/code&gt; や &lt;code&gt;bind_arg&lt;/code&gt; を用いるなら、項目や引数のインデックスが範囲外を指してはならない。&lt;/p&gt;
&lt;p&gt;ミスが見過ごされたり放置されたりしないように、 &lt;code&gt;format&lt;/code&gt; はいずれかのルールが満たされていないことを検出すると対応する例外を発生する。&lt;/p&gt;
&lt;p&gt;しかしユーザはこの振る舞いを必要に応じて変えることができる。また、どのエラーの型が発生するかを次の関数を用いて選択できる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;exceptions&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; newexcept); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クエリおよび設定&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; exceptions() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;                  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クエリのみ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ユーザは、以下のアトムを２進演算で結合することで引数 &lt;code&gt;newexcept&lt;/code&gt; を算出できる :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::io::bad_format_string_bit&lt;/code&gt; 書式文字列が適切でなければ例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::too_few_args_bit&lt;/code&gt; すべての引数が渡される前に結果の文字列を尋ねられたとき、例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::too_many_args_bit&lt;/code&gt; 渡された引数の数が多すぎれば例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::out_of_range_bit&lt;/code&gt; &lt;code&gt;modify_item&lt;/code&gt; や項目インデックスを取る他の関数の呼び出し(および引数のインデックス）の際に、ユーザの与えたインデックスが範囲外であれば例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::all_error_bits&lt;/code&gt; すべてのエラーで例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::no_error_bits&lt;/code&gt; いずれのエラーでも例外を発生しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例えば、 Boost.Format が引数の個数をチェックしないようにしたければ、適切な例外設定を施した &lt;code&gt;format&lt;/code&gt; オブジェクトを作る特殊なラッパ関数を定義する :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format my_fmt(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; f_string) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io;
    format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter&lt;/span&gt;(f_string);
    fmter.exceptions( all_error_bits &lt;span style=&#34;color: #666666&#34;&gt;^&lt;/span&gt; ( too_many_args_bit &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; too_few_args_bit )  );
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; fmter;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;すると、必要とされるよりも多くの引数を与えても許される(単に無視される) :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; my_fmt(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34; %1% %2% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;また、すべての引数が与えられる前に結果を問い合わせると、結果の対応する部分は単に空になる&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; my_fmt(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34; _%2%_ _%1%_ &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt; ;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// prints      &#34; __ _1_ \n&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#extract&#34; name=&#34;extract&#34;&gt;抜粋&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;charT&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Traits&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;char_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;basic_format&lt;/span&gt; 
{
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;basic_string&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT, Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;string_t&lt;/span&gt;,
  basic_format(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; charT&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; str);
  basic_format(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; charT&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; str, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;locale &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; loc);
  basic_format(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;string_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; s);
  basic_format(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;string_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; s, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;locale &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; loc);

  &lt;span style=&#34;color: #B00040&#34;&gt;string_t&lt;/span&gt; str() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// pass arguments through those operators :&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;  basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;(T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x);  
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;  basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x);

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// dump buffers to ostream :&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;friend&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;basic_ostream&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT, Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ( std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;basic_ostream&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT, Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; , basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; ); 

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ............  これはただの抜粋である .......&lt;/span&gt;
}; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// basic_format&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;          format;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;wchar_t&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;      wformat;


&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; io {
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// free function for ease of use :&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;charT&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Traits&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;basic_string&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT,Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;  str(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT,Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; f) {
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; f.str();
}
} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//namespace io&lt;/span&gt;


} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// namespace boost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#rationale&#34; name=&#34;rationale&#34;&gt;設計原理&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このクラスのゴールは、より良い、 C++ 用の、型安全かつ型拡張性のある &lt;code&gt;printf&lt;/code&gt; の等価物が、 ストリームとともに用いられるようにすることである。&lt;/p&gt;
&lt;p&gt;正確には、 &lt;code&gt;format&lt;/code&gt; は以下の機能を実現するようデザインされた :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引数の位置指定のサポート(国際化に必要)&lt;/li&gt;
&lt;li&gt;個数無制限の引数を許す。&lt;/li&gt;
&lt;li&gt;書式化命令の見た目を自然にする。&lt;/li&gt;
&lt;li&gt;書式文字列の構文に加えて、引数の出力を修飾するためのマニピュレータをサポー ト。&lt;/li&gt;
&lt;li&gt;あらゆる型の変数を受け付ける。文字列への実際の変換はストリームに任せる。 これは特にユーザ定義型について、書式化オプションの作用が直観的に自然なものとなるよう考慮したものである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; 互換性の提供、型安全で型拡張性のある文脈においてもできるだけ意味をなすようにする。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;デザインの過程で多くの問題に直面し、いくつかの選択をすることになったが、 中には直観的には正しくないものもあった。しかしいずれのケースにも &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/choices.html&#34;&gt;何らかの意味がある&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#credits&#34; name=&#34;credits&#34;&gt;クレジット&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Format の著者は Samuel Krempp である。彼は Rüiger Loos と Karl Nelson の両者の &lt;code&gt;format&lt;/code&gt; クラスのアイディアを利用した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;February 19, 2002&lt;/p&gt;
&lt;p&gt;© Copyright Samuel Krempp 2002. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Header `&lt;boost/function.hpp&gt;` -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/function.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Header &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/doc/html/function.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/doc/html/function.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ヘッダファイル &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt; に含まれるのは、関数オブジェクトのラッパとなるクラステンプレート群である。 Boost.Function の概念はコールバックを一般化したものだ。 Boost.Function は以下の点で関数ポインタと共通の特徴をもっている。 1 つは、何らかの実装によって呼び出される「呼び出しのインタフェース」 (例: 2 つの &lt;code&gt;int&lt;/code&gt; 型引数を取り、 &lt;code&gt;float&lt;/code&gt; を返す関数) を定義していること。もう 1 つは、呼び出される実装をプログラム実行中に変更できる事だ。&lt;/p&gt;
&lt;p&gt;一般に、遅延呼び出しやコールバックを実現するために関数ポインタを使うあらゆる場面で、代わりに Boost.Function を使用できる。そして、それによって呼ばれる側の実装はぐっと自由になる。呼ばれる側にはあらゆる「互換性のある」関数オブジェクト (や関数ポインタ) が指定できる。「互換性がある」とは、 Boost.Function に渡した引数が、対象となる関数オブジェクトの引数に変換できるということだ(訳注：戻り値にも互換性が必要)。&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#compatibility-note&#34;&gt;Compatibility Note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/tutorial.html&#34;&gt;Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html&#34;&gt;Reference manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#function-vs-function-pointers&#34;&gt;Boost.Function vs. Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#portability&#34;&gt;Portability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#design-rationale&#34;&gt;Design rationale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/faq.html&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#compatibility-note&#34; name=&#34;compatibility-note&#34;&gt;Compatibility Note&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function は、インタフェースを小さく、分かりやすくするために、一部が再設計された。昔の Boost.Function にあった、いくつかのめったに (または決して) 使われない機能は推奨されなくなり、近々削除される。以下に推奨されなくなった機能とその理由、それに伴うコードの修正法をリストアップする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::function&lt;/code&gt; クラステンプレートの文法が変更された。以前は&lt;code&gt;boost::function&amp;lt;int, float, double, std::string&amp;gt;&lt;/code&gt;のように書いたが、 &lt;code&gt;boost::function&amp;lt;int (float, double, std::string)&amp;gt;&lt;/code&gt;のような、より自然な書き方になった。戻り値と全ての引数の型が、 1 つの関数型のパラメータに収まる事になったのだ。残りのテンプレートパラメータ (&lt;code&gt;Allocator&lt;/code&gt;など) が、この関数型パラメータの後に続く。
    この変更への対応は、コンパイラに依存する。あなたのコンパイラがテンプレートの部分特殊化版をサポートし、関数型をパース (これは大抵 OK) できるなら、新しい文法を使うようにソースを修正してもいいし (推奨) 、文法が変わっていない&lt;code&gt;functionN&lt;/code&gt; クラスを直接使ってもいい。あなたのコンパイラがテンプレートの部分特殊化版か関数型をサポートしていなければ、&lt;code&gt;functionN&lt;/code&gt;クラスを使う必要がある。&lt;code&gt;functionN&lt;/code&gt;クラスを使うように修正するのは簡単で、クラス名の最後に引数の数を加えるだけだ (例: &lt;code&gt;boost::function&amp;lt;void, int, int&amp;gt;&lt;/code&gt; を &lt;code&gt;boost::function2&amp;lt;void, int, int&amp;gt;&lt;/code&gt; に変更) 。
    &lt;code&gt;boost::function&lt;/code&gt; クラステンプレートの古い文法のサポートはしばらく続くが、いつかは削除される。削除した方がエラーメッセージが分かりやすくなり、リンク互換性が良くなるからだ。&lt;/li&gt;
&lt;li&gt;呼び出しポリシーのテンプレートパラメータ (&lt;code&gt;Policy&lt;/code&gt;) は推奨されておらず、将来削除される。この機能はめったに使われないので、代替となる機能は無い。&lt;/li&gt;
&lt;li&gt;ミックスインのテンプレートパラメータ (&lt;code&gt;Mixin&lt;/code&gt;) は推奨されておらず、将来削除される。この機能はめったに使われないので、代替となる機能は無い。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt; メソッドは推奨されておらず、将来削除される。代わりに代入演算子を使えば良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しい文法に移行し、推奨されない機能を削除するためには、 &lt;code&gt;BOOST_FUNCTION_NO_DEPRECATED&lt;/code&gt; プリプロセサマクロを定義する。このマクロを定義すると、推奨されない全ての機能が使えなくなる。 &lt;code&gt;BOOST_FUNCTION_NO_DEPRECATED&lt;/code&gt; を使ってコンパイルされたプログラムなら、推奨されない機能が削除されても大丈夫だ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#function-vs-function-pointers&#34; name=&#34;function-vs-function-pointers&#34;&gt;Boost.Function vs. Function Pointers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function には関数ポインタに比べていくつかの利点がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Function は、任意の互換性がある関数オブジェクトを格納できる (関数ポインタは全く同じシグネチャを持つ関数しか受け付けない) 。&lt;/li&gt;
&lt;li&gt;Boost.Function は、引数の束縛などの関数オブジェクトを作り出すライブラリと共用できる。&lt;/li&gt;
&lt;li&gt;Boost.Function を使えば、空の関数オブジェクトの呼び出しを、デバッグ時に簡単に検出できる。&lt;/li&gt;
&lt;li&gt;Boost.Function では、それぞれの呼び出しの前後に、ある操作を実行するように指定できる。例えば、同期用の基本命令を関数型の一部にすることができる(訳注：この機能 (呼び出しポリシー) は推奨されておらず、将来削除される)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そしてもちろん、関数ポインタにも Boost.Function に比べていくつかの利点がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数ポインタはサイズが小さい (関数ポインタはポインタ 1 つ、 Boost.Function はポインタ 3 つ) 。&lt;/li&gt;
&lt;li&gt;関数ポインタは高速だ (Boost.Function は関数ポインタを通した呼び出しを 2 回する可能性がある) 。&lt;/li&gt;
&lt;li&gt;関数ポインタは C のライブラリと下位互換性がある。&lt;/li&gt;
&lt;li&gt;エラーメッセージが読みやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上 2 つのリストは Darin Adler のコメントを編集したものである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#performance&#34; name=&#34;performance&#34;&gt;Performance&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Function object wrapper size&lt;/h3&gt;
&lt;p&gt;関数オブジェクトのラッパのサイズは 2 つの関数ポインタと、 1 つの関数ポインタまたはデータのポインタ (の大きい方) のサイズになる。一般的な 32 ビットプラットフォームでは、 1 つのラッパ当たり 12 バイトになる。さらに、対象となる関数オブジェクトがヒープに割り当てられる。&lt;/p&gt;
&lt;h3&gt;Copying efficiency&lt;/h3&gt;
&lt;p&gt;関数オブジェクトのラッパのコピーによって、格納された関数オブジェクトのコピーのためにメモリ割り当てが発生する。デフォルトのアロケータを、もっと速いカスタムアロケータで置換することもできる。また、関数オブジェクトのラッパが、対象となる関数オブジェクトの「参照」を格納するように指定できる (&lt;code&gt;ref&lt;/code&gt;を使用) 。これは関数オブジェクトのコピーが酷く高価な場合に有効だ。&lt;/p&gt;
&lt;h3&gt;Invocation efficiency&lt;/h3&gt;
&lt;p&gt;適切なインライン化を行うコンパイラならば、関数オブジェクトの呼び出しによって、関数ポインタを通した呼び出しが 1 回行われる。非メンバ関数ポインタの呼び出しならば、その関数ポインタの呼び出しに加えて、もう 1 回の呼び出しが行われる (コンパイラがとても強力な関数をまたいだ分析を行うならば別だが) 。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#portability&#34; name=&#34;portability&#34;&gt;Portability&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function は、できるだけ移植性を高めるように、できるだけ多くのコンパイラ (C++ 標準準拠度が低いものも含む) をサポートするように設計されている。以下のコンパイラは &lt;code&gt;boost::function&lt;/code&gt;に含まれる全てのテストケースに合格した。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 2.95.3&lt;/li&gt;
&lt;li&gt;GCC 3.0&lt;/li&gt;
&lt;li&gt;SGI MIPSpro 7.3.0&lt;/li&gt;
&lt;li&gt;Borland C++ 5.5.1&lt;/li&gt;
&lt;li&gt;Comeau C++ 4.2.45.2&lt;/li&gt;
&lt;li&gt;Metrowerks Codewarrior 6.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下のコンパイラでも &lt;code&gt;boost::function&lt;/code&gt;を使えるが、いくつか問題がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft Visual C++ 6.0 (service pack 5): アロケータはサポートされない。 &lt;code&gt;boost::function&lt;/code&gt; クラステンプレートにいくつか問題がある ( &lt;code&gt;boost::functionN&lt;/code&gt; の方は動作するようだ) 。&lt;/li&gt;
&lt;li&gt;Intel C++ 5.0: アロケータはサポートされない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あなたのコンパイラが上のリストになければ、 &lt;code&gt;boost::function&lt;/code&gt; ライブラリを使えるかチェックするための小さなテスト群があるので、これを使える。標準に準拠したコンパイラなら、修正無しでコードをコンパイルできるはずだが、問題が起きたらバグレポートを送ってほしい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#design-rationale&#34; name=&#34;design-rationale&#34;&gt;Design rationale&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Combatting virtual function bloat&lt;/h3&gt;
&lt;p&gt;多くのコンパイラでは、仮想関数の使用によって「コードの膨張」が起きがちである。クラスが仮想関数を持つ場合、オブジェクトの型を分類する補助関数を作る必要がある。私達の経験では、多くの &lt;code&gt;boost::function&lt;/code&gt; オブジェクトが使われると、この補助関数が実行可能ファイルのサイズを大きく膨張させる。&lt;/p&gt;
&lt;p&gt;Boost.Function では、仮想関数の代わりに非メンバ関数を使った、代わりの等価なアプローチをとっている。 Boost.Function オブジェクトが関数オブジェクトを呼び出すためには、本質的に 2 つのポインタを持つ必要がある。所有する関数オブジェクトへの &lt;code&gt;void&lt;/code&gt; ポインタと、関数オブジェクトの「呼び出し役」への &lt;code&gt;void&lt;/code&gt; ポインタ (関数ポインタが代入される) だ。 Boost.Function が提供する、引数と戻り値の変換は、この呼び出し役が実行する。第 3 のポインタは「管理者」と呼ばれる非メンバ関数を指す。これは関数オブジェクトのコピーと破棄を扱う。この方法はタイプセーフだ。なぜなら、関数オブジェクトを実際に扱う関数である呼び出し役と管理者は、関数オブジェクトの型を知らされてインスタンス化されるので、入ってくる &lt;code&gt;void&lt;/code&gt; ポインタ (関数オブジェクトへのポインタ) を、正しい型に安全にキャストできるからだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;たくさんの人がこのライブラリの作成に参加した。 William Kempf 、 Jesse Jones 、 Karl Nelson は、ライブラリのインタフェースと守備範囲を、他のライブラリとは独立したものにする上で大きな助けになってくれた。 John Maddock は公式なレビューをやってくれた。他にもたくさんの人がレビューをして、インタフェース、実装、ドキュメントについて優れたコメントを寄せてくれた。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>boost::function FAQ -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function/faq.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/function/faq.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;boost::function FAQ&lt;/h1&gt;
&lt;h2&gt;Q: &lt;code&gt;void&lt;/code&gt; ポインタを見かけたが、これはタイプセーフなのか？&lt;/h2&gt;
&lt;p&gt;はい。 &lt;code&gt;boost::function&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; ポインタや、戻り値も引数もない関数ポインタを使っているが、タイプセーフだ。関数ポインタや関数オブジェクトを管理/実行する関数の中には、全ての型の情報が書き込まれている。 &lt;code&gt;void&lt;/code&gt; ポインタや &lt;code&gt;void&lt;/code&gt; 関数ポインタが指す本当の型を知らされてインスタンス化されるのは、これらの管理/実行用関数だけなのだ。 &lt;code&gt;void&lt;/code&gt; ポインタと &lt;code&gt;void&lt;/code&gt; 関数ポインタの両方が必要な理由は、オブジェクトへのポインタと &lt;code&gt;void&lt;/code&gt; ポインタは互いに安全にキャストでき、異なる型の関数ポインタ同士も安全にキャストできることだ (ただし、異なる型で関数ポインタを呼び出してはならない) 。&lt;/p&gt;
&lt;h2&gt;Q: なぜ &lt;code&gt;void&lt;/code&gt; の &lt;code&gt;return&lt;/code&gt; の回避手段を取っているのか？ C++ では許されているはずだ！&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt; の &lt;code&gt;return&lt;/code&gt; は C++ 標準で許されている。以下はこれを使ったコードの一部だ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;();
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;() { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; f(); }
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt; の &lt;code&gt;return&lt;/code&gt; を使わない理由の 1 つとして、全てのコンパイラが &lt;code&gt;void&lt;/code&gt; の &lt;code&gt;return&lt;/code&gt; をサポートしているわけではないことが挙げられる。実際には、このちょっとした機能をサポートするコンパイラはごく一部だ。さらに、 &lt;code&gt;void&lt;/code&gt; の &lt;code&gt;return&lt;/code&gt; を使わないことで、 &lt;code&gt;boost::function&lt;/code&gt; はもっと柔軟になった。以下の例を考えてみよう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);

boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; f;
f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; do_something;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この &lt;code&gt;boost::function&lt;/code&gt; の使い方が有効なのは、 &lt;code&gt;void&lt;/code&gt; の &lt;code&gt;return&lt;/code&gt; が使われていないからだ。 &lt;code&gt;void&lt;/code&gt; の &lt;code&gt;return&lt;/code&gt; を使うと、以下のコードと同等の不正なコードをコンパイルしようとすることになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;();
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;() { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; f(); }
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt; の &lt;code&gt;return&lt;/code&gt; を使わないことで、 &lt;code&gt;boost::function&lt;/code&gt; は戻り値を飲み込めるようになる、というのが本質なのだ。このことは、「ぴったり一致しないパラメータを持つ関数や関数オブジェクトを代入/実行できる」こととも一貫している。&lt;/p&gt;
&lt;h2&gt;Q: なぜ (関数を) コピーするのか？&lt;/h2&gt;
&lt;p&gt;2000 年の 11 ～ 12 月に、コピー vs. 参照の論争が長々と繰り広げられた。その結果、コピーの方が予測しやすいセマンティクスになるという結論になった。私はここでその議論を蒸し返すつもりはない。コピーが不適当な場合は、参照カウント式アロケータを使えばよい。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Last modified: Fri Oct 11 05:39:27 EDT 2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.Function Reference Manual -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function/reference.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/function/reference.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost.Function Reference Manual&lt;/h1&gt;
&lt;h2&gt;Header &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt; synopsis&lt;/h2&gt;
&lt;p&gt;以下で、 &lt;code&gt;MAX_ARGS&lt;/code&gt; は実装定義の定数であり、 Boost.Function でサポートされる引数の数の最大値 (少なくとも 10) である。このドキュメント中で参照される &lt;code&gt;MAX_ARGS&lt;/code&gt; 定数は、ライブラリ中で直接的には定義されていない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;function_base&lt;/span&gt;
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; implementation&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;defined safe_bool;
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; empty() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
  };

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// [0, MAX_ARGS] の範囲の全ての N について&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Signature,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg1,
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg2,
           ...
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ArgN,
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy    &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; empty_function_policy, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; empty_function_mixin, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;function_base&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;functionN&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; function_base, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; Mixin
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ResultType result_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#note&#34;&gt;[1]&lt;/a&gt;&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Policy     policy_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Mixin      mixin_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Allocator  allocator_type;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg1 argument_type;        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// N == 1 の場合&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg1 first_argument_type;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// N == 2 の場合&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg2 second_argument_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// N == 2 の場合&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg1 arg1_type;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg2 arg2_type;
             .
             .
             .
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ArgN argN_type;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { arity &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; N };

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 構築&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;functionN&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Mixin&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Mixin());
    functionN(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(F, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Mixin&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Mixin());
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 代入&lt;/span&gt;
    functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(F);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;);
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set(F); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;swap&lt;/span&gt;(functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;clear&lt;/span&gt;();

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// bool 型の文脈&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt; safe_bool() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 呼び出し&lt;/span&gt;
    result_type &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Arg1 a1, Arg2 a2, ..., ArgN aN) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
  };

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ResultType,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg1,
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg2,
           ...
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ArgN,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;,
            functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;);

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// [0, MAX_ARGS] の範囲の全ての N について&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Signature, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 関数型: ResultType (Arg1, Arg2, ..., ArgN)&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy    &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; empty_function_policy, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; empty_function_mixin, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;function_base&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 構築&lt;/span&gt;
    function();
    function(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    function(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(F);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 代入&lt;/span&gt;
    function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(F);
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set(F); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
  };

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Signature, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Signature, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;,
            function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Signature, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#definitions&#34; name=&#34;definitions&#34;&gt;定義&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引数型 &lt;code&gt;Arg1&lt;/code&gt;, &lt;code&gt;Arg2&lt;/code&gt;, ..., &lt;code&gt;ArgN&lt;/code&gt; と戻り値型 &lt;code&gt;ResultType&lt;/code&gt; に対して、該当する以下の関数が適格な時、関数オブジェクト &lt;code&gt;f&lt;/code&gt; は「 互換性がある 」という。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 関数型が void 以外の場合&lt;/span&gt;
ResultType &lt;span style=&#34;color: #0000FF&#34;&gt;foo&lt;/span&gt;(Arg1 arg1, Arg2 arg2, ..., ArgN argN)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; f(arg1, arg2, ..., argN);
}

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 関数型が void の場合&lt;/span&gt;
ResultType &lt;span style=&#34;color: #0000FF&#34;&gt;foo&lt;/span&gt;(Arg1 arg1, Arg2 arg2, ..., ArgN argN)
{
  f(arg1, arg2, ..., argN);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;メンバ関数ポインタには、特別な規定がある。メンバ関数ポインタは関数オブジェクトではないが、 Boost.Function は内部的にメンバ関数ポインタを関数オブジェクトに作り変える。 &lt;code&gt;R (X::*mf)(Arg1, Arg2, ..., ArgN) cv-quals&lt;/code&gt; の形のメンバ関数ポインタは、以下のように関数呼出し演算子をオーバロードした関数オブジェクトに作り変えられる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; P&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
R &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(cv&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;quals P&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x, Arg1 arg1, Arg2 arg2, ..., ArgN argN) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;x).&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;mf(arg1, arg2, ..., argN);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;F&lt;/code&gt; が関数ポインタであるか、 &lt;code&gt;boost::is_stateless&amp;lt;T&amp;gt;&lt;/code&gt; が真の時、 &lt;code&gt;F&lt;/code&gt; 型の関数オブジェクト &lt;code&gt;f&lt;/code&gt; は「 状態を持たない 」という。状態を持たない関数オブジェクトの Boost.Function での構築/コピーは発生せず、例外は起きず、記憶域の割り当ても起きない。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Class &lt;code&gt;function_base&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;クラス &lt;code&gt;function_base&lt;/code&gt; は全ての Boost.Function オブジェクトに共通する基底クラスだ。 &lt;code&gt;function_base&lt;/code&gt; 型のオブジェクトが直接作られることはないだろう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; empty() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値: 関数オブジェクトを格納していれば &lt;code&gt;true&lt;/code&gt; 、そうでなければ &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;例外: 例外を起こさない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Class template &lt;code&gt;functionN&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;クラステンプレート &lt;code&gt;functionN&lt;/code&gt; は実際には、 &lt;code&gt;function0&lt;/code&gt;, &lt;code&gt;function1&lt;/code&gt;, ... と、ある実装定義の最大値まで続く、関連するクラス群である。以下の文では、 &lt;code&gt;N&lt;/code&gt; はパラメータの数、 &lt;code&gt;f&lt;/code&gt; は暗黙のオブジェクトパラメータを表す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;functionN&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Mixin&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Mixin());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用: 与えられたミックスインから &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトを構築する。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;f.empty()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外: &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトの構築で例外が起きない限り、例外を起こさない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;functionN(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事後条件: &lt;code&gt;g&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; が格納する関数オブジェクトのコピーを格納する。 &lt;code&gt;g.empty()&lt;/code&gt; ならば &lt;code&gt;f&lt;/code&gt; も空になる。 &lt;code&gt;f&lt;/code&gt; のミックスインは、 &lt;code&gt;g&lt;/code&gt; のミックスインからコピーされる。&lt;/li&gt;
&lt;li&gt;例外: &lt;code&gt;g&lt;/code&gt; が格納する関数オブジェクトのコピーや &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトの構築で例外が起きない限り、例外を起こさない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(F g, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Mixin&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Mixin());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必須事項: &lt;code&gt;g&lt;/code&gt; は&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#definitions&#34;&gt;互換性がある&lt;/a&gt;関数オブジェクトであること。&lt;/li&gt;
&lt;li&gt;作用: 与えられたミックスインから &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトを構築する。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;g&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; のコピーを格納する。 &lt;code&gt;g&lt;/code&gt; が空ならば、 &lt;code&gt;f.empty()&lt;/code&gt; が真となる。&lt;/li&gt;
&lt;li&gt;例外: &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトの構築で例外が起きず、 &lt;code&gt;g&lt;/code&gt; が状態を持たない関数オブジェクトならば、例外を起こさない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必須事項: &lt;code&gt;g.get()&lt;/code&gt; は&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#definitions&#34;&gt;互換性がある&lt;/a&gt;関数オブジェクトであること。&lt;/li&gt;
&lt;li&gt;作用: 与えられたミックスインから &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトを構築する。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;g.get()&lt;/code&gt; が空でなければ、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; (&lt;code&gt;g.get()&lt;/code&gt;のコピーではない) を格納する。 &lt;code&gt;g.get()&lt;/code&gt; が空ならば、 &lt;code&gt;this-&amp;gt;empty()&lt;/code&gt; が真となる。&lt;/li&gt;
&lt;li&gt;例外: &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトの構築で例外が起きない限り、例外を起こさない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事後条件: &lt;code&gt;g&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; が格納する関数オブジェクトのコピーを格納する。 &lt;code&gt;g.empty()&lt;/code&gt; ならば、 &lt;code&gt;f&lt;/code&gt; も空になる。 &lt;code&gt;f&lt;/code&gt; のミックスインには &lt;code&gt;g&lt;/code&gt; のミックスインが代入される。&lt;/li&gt;
&lt;li&gt;戻り値: &lt;code&gt;*this&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外: &lt;code&gt;g&lt;/code&gt; が&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#definitions&#34;&gt;状態を持たない&lt;/a&gt;関数オブジェクトを格納しているか、 &lt;code&gt;g&lt;/code&gt; が関数オブジェクトへの参照を格納してる場合は、例外を起こさない。ただし、 &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトのコピーで例外が起きた場合を除く。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(F g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必須事項: &lt;code&gt;g&lt;/code&gt; は互換性がある関数オブジェクトであること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;g&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; のコピーを格納する。 &lt;code&gt;g&lt;/code&gt; が空ならば、 &lt;code&gt;f.empty()&lt;/code&gt; が真となる。&lt;/li&gt;
&lt;li&gt;戻り値: &lt;code&gt;*this&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外: &lt;code&gt;g&lt;/code&gt; が状態を持たない関数オブジェクトを格納していれば、例外を起こさない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必須事項: &lt;code&gt;g.get()&lt;/code&gt; が互換性がある関数オブジェクトであること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;g.get()&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g.get()&lt;/code&gt; ( &lt;code&gt;g.get()&lt;/code&gt; のコピーではない) を格納する。 &lt;code&gt;g.get()&lt;/code&gt; が空ならば、 &lt;code&gt;f.empty()&lt;/code&gt; が真となる。&lt;/li&gt;
&lt;li&gt;戻り値: &lt;code&gt;*this&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外: &lt;code&gt;this&lt;/code&gt; が格納していた関数オブジェクトの破棄で例外が起きた場合のみ、例外を起こす。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用: &lt;code&gt;*this = g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意: この関数の使用は推奨されない。この関数は Boost.Function の将来のバージョンで削除される。代わりに代入演算子を使って欲しい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set(F g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用: &lt;code&gt;*this = g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意: この関数の使用は推奨されない。この関数は Boost.Function の将来のバージョンで削除される。代わりに代入演算子を使って欲しい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;swap&lt;/span&gt;(functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用: &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;g&lt;/code&gt; が格納する関数オブジェクトを交換し、 &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;g&lt;/code&gt; のミックスインを交換する。&lt;/li&gt;
&lt;li&gt;例外: 例外は発生しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;clear&lt;/span&gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用: &lt;code&gt;!empty()&lt;/code&gt;ならば、格納する関数オブジェクトを破棄する。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;empty()&lt;/code&gt;が真になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt; safe_bool() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値: &lt;code&gt;!empty()&lt;/code&gt;と等価な&lt;code&gt;safe_bool&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;例外: 例外は発生しない。&lt;/li&gt;
&lt;li&gt;注意: &lt;code&gt;safe_bool&lt;/code&gt; 型は bool 型が予想される場所 (例: &lt;code&gt;if&lt;/code&gt; の条件) に使用できる。しかし、 &lt;code&gt;bool&lt;/code&gt; 型で起きる暗黙の型変換 (例: &lt;code&gt;int&lt;/code&gt;型への変換) は許されない。これによってユーザの間違いの元を減らせることがある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値: &lt;code&gt;this-&amp;gt;empty()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外: 例外は発生しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;result_type &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Arg1 a1, Arg2 a2, ..., ArgN aN) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必須事項: !empty()&lt;/li&gt;
&lt;li&gt;作用: 以下で、 &lt;code&gt;target&lt;/code&gt; は格納された関数オブジェクトである。 &lt;code&gt;target&lt;/code&gt; 変数には &lt;code&gt;const&lt;/code&gt; 修飾子や &lt;code&gt;volatile&lt;/code&gt; 修飾子が付いていない (ので、関数呼出し演算子に &lt;code&gt;const&lt;/code&gt; 修飾子や &lt;code&gt;volatile&lt;/code&gt; 修飾子が付いている必要はない) 。&lt;ol&gt;
&lt;li&gt;&lt;code&gt;policy_type policy;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;policy.precall(this);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target(a1, a2, ..., aN);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;policy.postcall(this);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;戻り値: &lt;code&gt;target&lt;/code&gt; の戻り値。&lt;/li&gt;
&lt;li&gt;注意: 呼び出しポリシーは推奨されなくなり、今後のリリースで削除される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Class template &lt;code&gt;function&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;クラステンプレート &lt;code&gt;function&lt;/code&gt; は、番号付きクラステンプレート &lt;code&gt;function0&lt;/code&gt;, &lt;code&gt;function1&lt;/code&gt;, ... の薄いラッパである。 &lt;code&gt;MAX_ARGS&lt;/code&gt; までの引数を受け付ける。 &lt;code&gt;N&lt;/code&gt; 個の引数を渡されれば、 &lt;code&gt;functionN&lt;/code&gt; (引数 &lt;code&gt;N&lt;/code&gt; 個専用のクラス) から派生する。&lt;/p&gt;
&lt;p&gt;クラステンプレート &lt;code&gt;function&lt;/code&gt; のメンバ関数のセマンティクスは、全て &lt;code&gt;functionN&lt;/code&gt; オブジェクトと同じである。ただし、 &lt;code&gt;function&lt;/code&gt; オブジェクトの正しいコピーコンストラクトやコピーの代入のために、追加のメンバ関数を定義している。&lt;/p&gt;
&lt;h3&gt;Operations&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ResultType,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg1,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg2,
         ...
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ArgN,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; f,
          functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用: &lt;code&gt;f.swap(g);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Signature, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Signature, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; f,
          function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Signature, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用: &lt;code&gt;f.swap(g);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#note&#34; name=&#34;note&#34;&gt;脚注&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[1] : コンパイラが &lt;code&gt;void&lt;/code&gt; 型の &lt;code&gt;return&lt;/code&gt; をサポートしていない場合、 &lt;code&gt;ReturnType&lt;/code&gt; に &lt;code&gt;void&lt;/code&gt; を指定すると、 Boost.Function オブジェクトの &lt;code&gt;result_type&lt;/code&gt; は実装依存になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Last modified: Fri Oct 11 05:40:09 EDT 2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.Function Tutorial -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function/tutorial.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/function/tutorial.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost.Function Tutorial&lt;/h1&gt;
&lt;p&gt;Boost.Function には 2 種類の文法がある。推奨文法と互換文法である。推奨文法は C++ にフィットし、考慮するテンプレートパラメータの数も減り、可読性を高めることが多い。しかし、コンパイラのバグのせいで、推奨文法が使えないコンパイラもある。互換文法は Boost.Function がサポートする全てのコンパイラで使える。どちらの文法を使うかは、下の表を見て決めてほしい。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GNU C++ 2.95.x, 3.0.x, 3.1.x, 3.2&lt;br /&gt; Comeau C++ 4.2.45.2&lt;br /&gt; SGI MIPSpro 7.3.0&lt;br /&gt; Intel C++ 5.0, 6.0&lt;br /&gt; Compaq&#39;s cxx 6.2&lt;/td&gt;
&lt;td&gt;Microsoft Visual C++ 6.0, 7.0&lt;br /&gt; Borland C++ 5.5.1&lt;br /&gt; Sun WorkShop 6 update 2 C++ 5.3&lt;br /&gt; Metrowerks CodeWarrior 8.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;あなたのコンパイラが表になければ、推奨文法を試してみて、結果を Boost MLに報告してほしい。この表を最新に保つためだ。&lt;/p&gt;
&lt;h2&gt;Basic Usage&lt;/h2&gt;
&lt;p&gt;関数オブジェクトのラッパを定義するには、 &lt;code&gt;function&lt;/code&gt; クラステンプレートをインスタンス化するだけだ。テンプレート引数には、戻り値型と引数型を関数型形式で指定する。ある実装定義の最大値 (デフォルトは 10) までなら、引数は何個でもかまわない。以下に、 2 つの &lt;code&gt;int&lt;/code&gt; 型のパラメータを取り、&lt;code&gt;float&lt;/code&gt; 型を返す関数オブジェクトのラッパ f の定義を示す。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;float (int x, int y)&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function2&amp;lt;float, int, int&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトでは、関数オブジェクトのラッパは空である。 &lt;code&gt;f&lt;/code&gt; に代入する関数オブジェクトを作ろう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; int_div { 
  &lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; ((&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)x)&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;y; }; 
};

f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; int_div();
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これで、関数オブジェクト &lt;code&gt;int_div&lt;/code&gt; を呼び出す代わりに &lt;code&gt;f&lt;/code&gt; を使える。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt; には、互換性があれば、どんな関数オブジェクトでも代入できる。 &lt;code&gt;int_div&lt;/code&gt; が 2 つの &lt;code&gt;long&lt;/code&gt; 型の引数をとると宣言されていれば、自動的に暗黙の型変換が適用される。引数型に対する唯一の制限は、コピーコンストラクト可能なことである。だから、参照や配列さえ使える。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;void (int values[], int n, int&amp;amp; sum, float&amp;amp; avg)&amp;gt; sum_avg;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function4&amp;lt;void, int[], int, int&amp;amp;, float&amp;gt; sum_avg;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;do_sum_avg&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; values[], &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; sum, &lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; avg)
{
  sum &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;)
    sum &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; values[i];
  avg &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)sum &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; n;
}

sum_avg &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;do_sum_avg;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;関数オブジェクトを格納していないラッパを呼び出すのは事前条件違反である。ヌルの関数ポインタを呼び出そうとするようなものだ。関数オブジェクトのラッパが空かどうかは &lt;code&gt;empty()&lt;/code&gt; メソッドでチェックできる。もっと簡潔なのは、 &lt;code&gt;bool&lt;/code&gt; 型の文脈でラッパを使う方法だ。ラッパは、空でなければ &lt;code&gt;true&lt;/code&gt; と評価される。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (f)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;f has no target, so it is unsafe to call&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ラッパを空にするには、 &lt;code&gt;clear()&lt;/code&gt; メンバ関数を使う。&lt;/p&gt;
&lt;h2&gt;Free functions&lt;/h2&gt;
&lt;p&gt;非メンバ関数へのポインタは、 &lt;code&gt;const&lt;/code&gt; な関数呼出し演算子を持つ (インスタンスが1つだけ存在する) 関数オブジェクトの一種とみなせる。よって、関数オブジェクトのラッパに直接代入できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;mul_ints&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; ((&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)x) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; y; }
f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;mul_ints;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Microsoft Visual C++ version 6 を使う場合を除けば、本当は &lt;code&gt;&amp;amp;&lt;/code&gt; は不要だ。&lt;/p&gt;
&lt;h2&gt;Member functions&lt;/h2&gt;
&lt;p&gt;多くのシステムで、コールバックは特定のオブジェクトのメンバ関数を呼び出すことが多い。これは「引数の束縛」と呼ばれ、 Boost.Function の守備範囲外である。しかし、 Boost.Function には直接メンバ関数を扱う方法がある。以下のコードのように使う。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X {
  &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; foo(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;int (X*, int)&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function2&amp;lt;int, X*, int&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;foo;

X x;
f(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;引数の束縛をサポートするライブラリはいくつかある。その内 3 つを以下に要約する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;Boost.Bind&lt;/a&gt;。このライブラリを使えば、あらゆる関数オブジェクトの引数を束縛できる。軽くて移植性が高い。&lt;/li&gt;
&lt;li&gt;C++ 標準ライブラリ。 &lt;code&gt;std::bind1st&lt;/code&gt; と &lt;code&gt;std::mem_fun&lt;/code&gt; を一緒に使って、メンバ関数ポインタと (その対象となる) オブジェクトを束縛したものは、 Boost.Function で使える。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X {
  &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; foo(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;X x;
f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind1st(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;foo), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;x);

f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// x.foo(5)を呼び出す&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/lambda.md.nolink&#34;&gt;Boost.Lambda&lt;/a&gt; ライブラリ。このライブラリは、自然な C++ の文法を使って関数オブジェクトを構築する強力な機構を提供する。 Lambda は、コンパイラが C++ 標準にかなり準拠していないと使えない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;References to Functions&lt;/h2&gt;
&lt;p&gt;Boost.Function による関数オブジェクトのコピーが高価 (または不正) な場合がある。そんな場合は、 Boost.Function に実際の関数オブジェクトの「参照」を格納させることができる。&lt;code&gt;ref&lt;/code&gt; や &lt;code&gt;cref&lt;/code&gt; を使うことで、関数オブジェクトの参照のラッパを作成できる。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stateful_type a_function_object;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;f = ref(a_function_object);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f2(f);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;stateful_type a_function_object;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;f = ref(a_function_object);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f2(f);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;こうすれば、 &lt;code&gt;f&lt;/code&gt; も &lt;code&gt;f2&lt;/code&gt; も &lt;code&gt;a_function_object&lt;/code&gt; のコピーを作成しない。さらに、関数オブジェクトの参照を使えば、 Boost.Function は代入、構築時に例外を起こさない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Last modified: Fri Oct 11 05:40:00 EDT 2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>the Boost Graph Library -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;the Boost Graph Library&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/table_of_contents.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/table_of_contents.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/bgl-cover.jpg&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;BGLへの序章&lt;/li&gt;
&lt;li&gt;歴史&lt;/li&gt;
&lt;li&gt;刊行物&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/acknowledgements.html&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;クイック・ツアー&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html&#34;&gt;基本的なグラフ理論の復習&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;チュートリアル&lt;ol&gt;
&lt;li&gt;Property Maps&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;adjacency_list&lt;/code&gt; class&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;例題&lt;ol&gt;
&lt;li&gt;ファイル依存関係の例&lt;/li&gt;
&lt;li&gt;Kevin Bacon の６次数&lt;/li&gt;
&lt;li&gt;Graph Coloring&lt;/li&gt;
&lt;li&gt;Sparse Matrix Ordering&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;BGL 拡張&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/constructing_algorithms.html&#34;&gt;BGLでグラフアルゴリズムを構築する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Converting Existing Graphs to BGL&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Boost Graph インタフェイス&lt;ol&gt;
&lt;li&gt;Graph&lt;/li&gt;
&lt;li&gt;Incidence Graph&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BidirectionalGraph.html&#34;&gt;Bidirectional Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;Adjacency Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vertex List Graph&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;Edge List Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vertex and Edge List Graph&lt;/li&gt;
&lt;li&gt;Mutable Graph&lt;/li&gt;
&lt;li&gt;Property Graph&lt;/li&gt;
&lt;li&gt;Mutable Property Graph&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The Property Map Library （専門的にはグラフ・ライブラリの部分ではないが、ここで使用される頻度が高い）&lt;/li&gt;
&lt;li&gt;ビジタ・コンセプト&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS （幅優先探査） Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS （深さ優先探査） Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;Bellman Ford Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;Event Visitor&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;EventVisitorList アダプタ&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html&#34;&gt;Event Visitor List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html&#34;&gt;&lt;code&gt;dijkstra_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html&#34;&gt;&lt;code&gt;bellman_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;イベント・ビジタ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・クラス&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・アダプタ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;subgraph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filtered_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector as Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Matrix as Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Leda Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Stanford GraphBase&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;イテレータ・アダプタ&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特性クラス&lt;ol&gt;
&lt;li&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bgl_named_params.html&#34;&gt;&lt;code&gt;bgl_named_params&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;核となるアルゴリズム・パターン&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html&#34;&gt;&lt;code&gt;breadth_first_visit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html&#34;&gt;&lt;code&gt;depth_first_visit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undirected_dfs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform_cost_search&lt;/code&gt; (非推奨、代わりに Dijkstra を使うこと)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・アルゴリズム&lt;ol&gt;
&lt;li&gt;最短経路アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html&#34;&gt;&lt;code&gt;dijkstra_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html&#34;&gt;&lt;code&gt;bellman_ford_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html&#34;&gt;&lt;code&gt;dag_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;johnson_all_pairs_shortest_paths&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最小全域木アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;code&gt;kruskal_minimum_spanning_tree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prim_minimum_spanning_tree&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/connected_components.html&#34;&gt;&lt;code&gt;connected_components&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strong_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Incremental Connected Components&lt;ol&gt;
&lt;li&gt;&lt;code&gt;initialize_incremental_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;incremental_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;same_component&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component_index&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最大流アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edmunds_karp_max_flow.html&#34;&gt;&lt;code&gt;edmunds_karp_max_flow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push_relabel_max_flow&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topological_sort&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transitive_closure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/copy_graph.html&#34;&gt;&lt;code&gt;copy_graph&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transpose_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isomorphism&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/cuthill_mckee_ordering.html&#34;&gt;&lt;code&gt;cuthill_mckee_ordering&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sequential_vertex_coloring&lt;/code&gt;(アンドキュメント)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minimum_degree_ordering&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;AT&amp;amp;T Graphviz フォーマット入出力ユーティリティ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;write_graphviz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_graphviz&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;補助コンセプト、補助クラス、補助関数&lt;ol&gt;
&lt;li&gt;&lt;code&gt;property&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BasicMatrix.html&#34;&gt;BasicMatrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;incident&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opposite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;bandwidth&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;ith_bandwidth&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tools for random graphs&lt;ol&gt;
&lt;li&gt;&lt;code&gt;random_vertex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;random_edge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;generate_random_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;randomize_property&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;目標と To-Do 項目&lt;/li&gt;
&lt;li&gt;トラブルシューティング&lt;/li&gt;
&lt;li&gt;既知の問題&lt;/li&gt;
&lt;li&gt;FAQ&lt;/li&gt;
&lt;li&gt;BGL Book Errata&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>AdjacencyGraph -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/AdjacencyGraph.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;AdjacencyGraph&lt;/h1&gt;
&lt;p&gt;AdjacencyGraph コンセプトは、グラフ中の頂点への隣接頂点の効率的なアクセス のためのインターフェースを供給する。これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; コンセプト (出辺の終点が隣接頂点である) と非常に良く似ている。 いくつかの状況では頂点への関心のみがあり、しかし一方、他の状況では辺も同様に重要になるため、両者のコンセプトが供給された。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフのモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;G&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このタグ型は &lt;code&gt;adjacency_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::adjacency_iterator&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;頂点 &lt;code&gt;v&lt;/code&gt; のための隣接イテレータは &lt;code&gt;v&lt;/code&gt; に隣接した頂点へのアクセスを提供する。そのため隣接イテレータの値型はそのグラフの頂点記述子型である。 隣接イテレータは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなければならない。&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;adjacent_vertices(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; に隣接している頂点へのアクセスを提供 するイテレータ範囲を返す。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html#note1&#34;&gt;[1]&lt;/a&gt;&lt;br /&gt; 返却型: &lt;code&gt;std::pair&amp;lt;adjacency_iterator, adjacency_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; 関数は定数時間内に終了するはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graphコンセプト&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdjacencyGraphConcept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
    adjacency_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IncidenceGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(v, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(v, g);
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator,adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor v;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;設計原理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; が同じ (それ以上の) 機能を実際に含んでいるので、AdjacencyGraph コンセプトはいくぶん軽薄である。 &lt;code&gt;adjacent_vertices()&lt;/code&gt; が &lt;code&gt;out_edges()&lt;/code&gt; よりも使用すると便利な状況があるので AdjacencyGraph コンセプトは存在する。 グラフ・クラスを構築しており、隣接イテレータを作成する余分な仕事を行いたくない場合は、恐れを持たないでいただきたい。 出辺イテレータから隣接イテレータを作成するために使用できる&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;と名付けられたアダプタ・クラスがある。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html#note1&#34; name=&#34;note1&#34;&gt;[1]&lt;/a&gt; &lt;strong&gt;multigraph&lt;/strong&gt; (多数の辺が同じ二つの頂点を接続できる) の 場合は、&lt;code&gt;adjacent_vertices()&lt;/code&gt; 関数によって返されたイテレータが各隣接頂点を一度含む範囲にアクセスするかどうか、また &lt;code&gt;out_edges()&lt;/code&gt; 関数 のふるまいと一致し、二度以上隣接した頂点を含むことがある範囲にアクセスすべき かどうかとしての問題が持ち出される。 この決定はグラフ・アルゴリズムの実装と共により多くの経験を考慮して再検討される必要があるかもしれないが、今のところふるまいは &lt;code&gt;out_edges()&lt;/code&gt; のそれと一致すると定義される。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>AdjacencyMatrix -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyMatrix.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/AdjacencyMatrix.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;AdjacencyMatrix&lt;/h1&gt;
&lt;p&gt;AdjacencyMatrix コンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; コンセプトを精製し、始点と終点によって与えられるグラフ中の任意の辺への効率的なアクセスのために必要なものを付け加えている。今のところどの Boost の グラフ・ライブラリ・アルゴリズムもこのコンセプトを使っていない。しかしながらこのコンセプトを必要とするであろう Floyd-Warshall のようなまだ実装されていないアルゴリズムが存在する。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このタグ型は &lt;code&gt;adjacency_matrix_tag&lt;/code&gt; に変換可能でなければならない。&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返却値型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接の辺アクセス&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge(u,v,g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&amp;lt;edge_descriptor, bool&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; の間に辺が存在するかどうかを述べるフラグと、辺が見つかった場合に辺記述子から成るペアを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdjacencyMatrix
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor edge_descriptor;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edge(u, v, g);
  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor u, v;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;, edge_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BFS（幅優先探査）Visitor Concept -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/BFSVisitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;BFS（幅優先探査）Visitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは BFS Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;breadth_first_search()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BFS Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Graph&lt;/code&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点がキューからポップされた時に実行される。これは、頂点 &lt;code&gt;u&lt;/code&gt; の各出力辺に対して &lt;code&gt;examine_edge()&lt;/code&gt; が実行される直前に起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各辺が、探索木を形成する辺の要素になった時に、その辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Non-Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有向グラフでは後退辺と交差辺に対して、無向グラフでは交差辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gray Target&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に灰色に塗られている頂点を終点とする、木でない辺の部分集合に対して実行される。灰色は、頂点が今キューにいることを示す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Black Target&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に黒に塗られている頂点を終点とする、木でない辺の部分集合に対して実行される。黒は、頂点がキューから除去されたことを示す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある頂点の全ての出力辺が探索木に追加され、全ての隣接する頂点が発見された後に、その頂点に対して実行される (ただし、隣接する頂点の出力辺を調査するよりは前に) 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Bellman Ford Visitor Concept -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/BellmanFordVisitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Bellman Ford Visitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html&#34;&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは Bellman Ford Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bellman Ford Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Graph&lt;/code&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ内の各辺に対して &lt;code&gt;num_vertices(g)&lt;/code&gt; 回実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、以下の条件が満たされれば、その辺は緩和される (距離が減らされる) 。この時、このメソッドが実行される。&lt;br /&gt; &lt;code&gt;tie(u,v) = incident(e, g);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;D d_u = get(d, u), d_v = get(d, v);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;W w_e = get(w, e);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;assert(compare(combine(d_u, w_e), d_v));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge_not_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、辺が緩和 (上を参照) されなければ、このメソッドが実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Minimized&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_minimized(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ内の各辺を調査する &lt;code&gt;num_vertices(g)&lt;/code&gt; 回の反復が終わった後に、各辺が最小化されたかをチェックするために最後の反復が行われる。辺が最小化されていれば、この関数が実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Minimized&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge_not_minimized(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺が最小化されていなければ、この関数が呼ばれる。グラフ内に負の閉路が存在する時に、これが起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html&#34;&gt;&lt;code&gt;bellman_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BidirectionalGraph -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BidirectionalGraph.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/BidirectionalGraph.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;BidirectionalGraph&lt;/h1&gt;
&lt;p&gt;BidirectionalGraph コンセプトは、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; を精製し、各頂点の入辺への効率的なアクセスのために必要とされるものを付け加えている。 有向グラフにとって、入辺への効率的なアクセスは一般的により多くの記憶スペースを必要とし、多くのアルゴリズムは入辺へのアクセスを必要としないため、 このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; から分離されている。 無向グラフにとってはこれは問題とならない。というのは &lt;code&gt;in_edges()&lt;/code&gt; 関数 と &lt;code&gt;out_edges()&lt;/code&gt; 関数は同じであり、両方の関数は頂点に隣接した辺を返すからである。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;G&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このタグ型は &lt;code&gt;bidirectional_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::in_edge_iterator&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点 &lt;code&gt;v&lt;/code&gt; のための入辺イテレータは &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する。そのため入辺イテレータの値型はそのグラフの辺記述子型である。 入辺イテレータは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;in_edges(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺 (有向グラフ) または接続辺 (無向グラフ) へのアクセスを提供するイテレータ範囲を返す。 有向グラフと無向グラフの両方にとって、出辺の終点は頂点 &lt;code&gt;v&lt;/code&gt; で あることと、始点が &lt;code&gt;v&lt;/code&gt; に隣接している頂点であることが要求される。&lt;br /&gt; 返却値型: &lt;code&gt;std::pair&amp;lt;in_edge_iterator, in_edge_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;in_degree(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺の数 (有向グラフ) または 接続辺の数 (無向グラフ) を返す。&lt;br /&gt; 返却値型: &lt;code&gt;degree_size_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;degree(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺と出辺を足した数 (有向グラフ) または接続辺の数 (無向グラフ) を返す。&lt;br /&gt; 返却値型: &lt;code&gt;degree_size_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; で &lt;code&gt;Directed=bidirectionalS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; で &lt;code&gt;Directed=undirectedS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;in_edges()&lt;/code&gt; は定数時間であることを必要とする。 &lt;code&gt;in_degree()&lt;/code&gt; 関数と &lt;code&gt;degree()&lt;/code&gt; 関数は入辺の数 (有向グラフ) または接続辺の数 (無向グラフ) による線形時間であるはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BidirectionalGraph_concept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;in_edge_iterator
    in_edge_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IncidenceGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; in_edges(v, g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; in_edges(v, g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor v;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor e;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ColorValue -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/ColorValue.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;ColorValue&lt;/h1&gt;
&lt;p&gt;このコンセプトは色付けを必要とする型として記述されており、グラフ中を探査する時に頂点が訪問済か色でマークするために利用される。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/EqualityComparable.html&#34; target=&#34;_blank&#34;&gt;EqualityComparable&lt;/a&gt; and &lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ColorValue モデルの型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;T&lt;/code&gt; のオブジェクト&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Get Color White&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::white()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;白色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Get Color Gray&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::gray()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;灰色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Get Color Black&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::black()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;黒色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;default_color_type&lt;/code&gt; (boost/graph/properties.hpp の中に記述)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>DFS Visitor Concept -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/DFSVisitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;DFS Visitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは DFS Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;DFS Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、グラフの全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Start Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.start_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;探索の前に 1 度、始点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各辺が、探索木を形成する辺の要素になった時に、その辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Back Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.back_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの後退辺に対して実行される。無向グラフでは、辺 &lt;code&gt;(u,v)&lt;/code&gt; と辺 &lt;code&gt;(v,u)&lt;/code&gt; が同じ辺なので、木の辺か後退辺か曖昧な場合がある。この時は &lt;code&gt;tree_edge()&lt;/code&gt; 関数と &lt;code&gt;back_edge()&lt;/code&gt; 関数が両方とも実行される。この曖昧さを解決する 1 つの方法は、木の辺を記録し、既に木の辺として記録された後退辺を無視することだ。木の辺を記録するためには、 &lt;code&gt;tree_edge&lt;/code&gt; イベントで先行点を記録するのが簡単だ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Forward or Cross Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.forward_or_cross_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの先行辺と交差辺に対して実行される。無向グラフでは、このメソッドは決して呼ばれない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;頂点 &lt;code&gt;u&lt;/code&gt; を根とする DFS 木の全ての頂点に対して &lt;code&gt;finish_vertex&lt;/code&gt; が呼ばれた後に、頂点 &lt;code&gt;u&lt;/code&gt; に対して実行される。頂点 &lt;code&gt;u&lt;/code&gt; が DFS 木の葉であれば、 &lt;code&gt;u&lt;/code&gt; の全ての出力辺が調査された後に、 &lt;code&gt;u&lt;/code&gt; に対して &lt;code&gt;finish_vertex&lt;/code&gt; が呼ばれる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Dijkstra Visitor Concept -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/DijkstraVisitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Dijkstra Visitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html&#34;&gt;&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースと、関連するアルゴリズムを定義する。ユーザはこのインタフェースに一致するクラスを作って、そのクラスのオブジェクトを &lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; に渡すことで、探索中に実行される操作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dijkstra Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;,&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WeightMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初期化される時に、グラフの各頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点がキューからポップされる時に、その頂点に対して実行される。これは頂点 &lt;code&gt;u&lt;/code&gt; の各出力辺に対して &lt;code&gt;examine_edge()&lt;/code&gt; が実行される直前に起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、以下の条件が満たされれば、その辺は緩和される (距離が減らされる) 。この時、このメソッドが実行される。&lt;br /&gt; &lt;code&gt;tie(u,v) = incident(e, g);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;D d_u = get(d, u), d_v = get(d, v);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;W w_e = get(w, e);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;assert(compare(combine(d_u, w_e), d_v));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、辺が緩和 (上を参照) されなければ、このメソッドが実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある頂点の全ての出力辺が探索木に追加され、全ての隣接する頂点が発見された後に、その頂点に対して実行される (ただし、隣接する頂点の出力辺を調査するよりは前に) 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html&#34;&gt;&lt;code&gt;dijkstra_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EdgeListGraph -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/EdgeListGraph.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;EdgeListGraph&lt;/h1&gt;
&lt;p&gt;EdgeListGraph コンセプトは Graph コンセプトを 精製し、グラフ中の全ての辺への効率的なアクセスに必要とされるものを付け加えている。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;EdgeListGraph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;このタグ型は &lt;code&gt;edge_list_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_iterator&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;edges(g)&lt;/code&gt; を経由して得られる辺イテレータは、グラフ中の全ての辺へのアクセスを提供する。辺イテレータの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなけれはならない。辺イテレータの値型はグラフの辺記述子型と同じでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edges_size_type&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;符号なし汎整数型はグラフ中の辺の数を表すのに使われる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返却値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edges(g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&amp;lt;edge_iterator, edge_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の全ての辺へのアクセスを提供するイテレータ範囲を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;num_edges(g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edges_size_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;source(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt; によって表される辺 &lt;code&gt;(u,v)&lt;/code&gt; の &lt;code&gt;u&lt;/code&gt; のための頂点記述子を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt; によって表される辺 &lt;code&gt;(u,v)&lt;/code&gt; の &lt;code&gt;v&lt;/code&gt; のための頂点記述子を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; 関数、&lt;code&gt;source()&lt;/code&gt; 関数、そして &lt;code&gt;target()&lt;/code&gt; 関数は、すべて定数時間内に終了するはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EdgeListGraphConcept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator 
    edge_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; GraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edges(g);
    E &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_edges(g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; source(e, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; target(e, g);
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edges(g);
    E &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_edges(g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; source(e, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; target(e, g);
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator,edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor u, v;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor e;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edges_size_type E;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Edge Mutable Graph -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeMutableGraph.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/EdgeMutableGraph.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Edge Mutable Graph&lt;/h1&gt;
&lt;p&gt;Edge Mutable Graph コンセプトは、辺の追加と削除をサポートするグラフのためのインターフェースを定義する。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;add_edge(u, v, g)&lt;/code&gt; は &lt;code&gt;std::pair&amp;lt;edge_descriptor, bool&amp;gt;&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフ中に挿入することを試み、そして挿入された辺または多重辺、かつ辺が挿入されたかどうかを述べるフラグを返す。この操作はグラフの頂点記述子または頂点イテレータを無効にしないはずである。ただし、辺記述子または辺イテレータを無効にするかもしれない。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; がグラフ中の頂点であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;(u,v)&lt;/code&gt; がグラフの辺集合中にあること。返された辺記述子は &lt;code&gt;u&lt;/code&gt; を始点位置に、&lt;code&gt;v&lt;/code&gt; を終点位置に持つだろう。もしグラフが多重辺を許可しているなら、返されるフラグは常に &lt;code&gt;true&lt;/code&gt; である。もしグラフが多重辺を許可しておらず、辺 &lt;code&gt;(u,v)&lt;/code&gt; がすでにグラフ中にあったら返されるフラグは &lt;code&gt;false&lt;/code&gt; である。もし辺 &lt;code&gt;(u,v)&lt;/code&gt; がグラフ中になかったら返されるフラグは &lt;code&gt;true&lt;/code&gt; である。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから削除する。もしグラフが多重辺を許可しているなら、これは &lt;code&gt;(u,v)&lt;/code&gt; の全ての存在を削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;(u,v)&lt;/code&gt; がグラフの辺集合中にあること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;(u,v)&lt;/code&gt; がもはやグラフの辺集合中にないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;e&lt;/code&gt; をグラフから削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;e&lt;/code&gt; がグラフ中の辺であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;e&lt;/code&gt; はもはや &lt;code&gt;g&lt;/code&gt; のための辺集合中にないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;clear_vertex(u, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 頂点 &lt;code&gt;u&lt;/code&gt; への、そして頂点 &lt;code&gt;u&lt;/code&gt; からの全ての辺をグラフから削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; の有効な頂点記述子であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; 中のどの辺の始点または終点としても現れないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;工事中&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EventVisitor Concept -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/EventVisitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;EventVisitor Concept&lt;/h1&gt;
&lt;p&gt;このコンセプトは単独イベントビジタのインタフェースを定義する。 EventVisitor は適用メンバ関数 (&lt;code&gt;operator()&lt;/code&gt;) を持つ。これは、 EventVisitor 内の &lt;code&gt;event_filter&lt;/code&gt; typedef で指定されるイベントが起きた時に、グラフアルゴリズム内で実行される。 EventVisitor を組み合わせて &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVistorList.html&#34;&gt;EventVistorList&lt;/a&gt; を作成できる。&lt;/p&gt;
&lt;p&gt;以下に、 BGL アルゴリズムによって実行されるイベントのタグのリストを示す。各タグは、アルゴリズムのビジタのメンバ関数と対応している。例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt; の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; には &lt;code&gt;cycle_edge()&lt;/code&gt; というメンバ関数がある。これに対応するタグは &lt;code&gt;on_cycle_edge&lt;/code&gt; だ。 &lt;code&gt;operator()&lt;/code&gt; の第1引数は、イベントタグによって決まる、辺か頂点の記述子でなければならない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_initialize_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_start_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_discover_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_examine_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_tree_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_cycle_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_finish_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_forward_or_cross_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_back_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_relaxed { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_not_relaxed { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_minimized { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_not_minimized { };
} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// namespace boost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;EventVisitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型か &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Event Filter&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V::event_filter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;どのイベントによってビジタが実行されるかを指定するタグ構造体。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Apply Visitor&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis(x, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;オブジェクト &lt;code&gt;x&lt;/code&gt; に対してビジタの操作を実行する。 &lt;code&gt;x&lt;/code&gt; はグラフの辺か頂点の記述子である。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/null_visitor.html&#34;&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html&#34;&gt;EventVisitorList&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EventVisitorList Concept -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/EventVisitorList.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;EventVisitorList Concept&lt;/h1&gt;
&lt;p&gt;EventVisitorList は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; そのものか、 &lt;code&gt;std::pair&lt;/code&gt; で結合された EventVisitor のリストである。各グラフアルゴリズムには、 EventVisitorList を、アルゴリズムに必要な独自のビジタに変換するアダプタが定義されている。 以下に、イベントビジタを &lt;code&gt;std::pair&lt;/code&gt; で結合してリストにする方法の例と、アルゴリズムのビジタアダプタクラスの使い方の例を示す。&lt;/p&gt;
&lt;p&gt;仮に、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;深さ優先探索&lt;/a&gt;で、各頂点の発見／呼び出しの前後関係を、括弧を使った構造で出力したいとする。これを達成するには、 BGL アルゴリズム &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt; と2つのイベントビジタを使えばよい。以下の例の完全なソースコードは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dfs_parenthesis.cpp.html&#34;&gt;examples/dfs_parenthesis.cpp&lt;/a&gt; にある。まず、 2 つのイベントビジタを定義する。使うイベントビジタとして、 DFSVisitor に詳述されたイベントのリストの中から &lt;code&gt;on_discover_vertex&lt;/code&gt; と &lt;code&gt;on_finish_vertex&lt;/code&gt; を選ぶ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; open_paren &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; base_visitor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;open_paren&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; on_discover_vertex event_filter;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Vertex&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Vertex v, Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G) {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v;
  }
};
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; close_paren &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; base_visitor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;close_paren&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; on_finish_vertex event_filter;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Vertex&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Vertex v, Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G) {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;)&#34;&lt;/span&gt;;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次に2つのイベントビジタオブジェクトを作り、 &lt;code&gt;std::make_pair&lt;/code&gt; で作られる &lt;code&gt;std::pair&lt;/code&gt; を使って、この2つから EventVisitorList を作る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次にこのリストを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡したいところだが、 &lt;code&gt;depth_first_search()&lt;/code&gt; が要求しているのは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; であって、 EventVisitorList ではない。そこで EventVisitor のリストを DFSVisitor に変換するアダプタ、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt; を使う。他のビジタアダプタ同様、 &lt;code&gt;dfs_visitor&lt;/code&gt; には &lt;code&gt;make_dfs_visitor()&lt;/code&gt; という作成関数がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;make_dfs_visitor(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren()))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;さあこれで、以下のように、生成されたビジタオブジェクトを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡すことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフオブジェクト G を作る...&lt;/span&gt;

  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;default_color_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; color(num_vertices(G));

  depth_first_search(G, make_dfs_visitor(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren())),
                     color.begin());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;3つ以上のイベントビジタのリストを作りたければ、以下のように &lt;code&gt;std::make_pair&lt;/code&gt; をネストして呼び出せばいい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitor1,
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitor2,
    ...
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitorN&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;, visitorN)...));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>謝辞 -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/acknowledgements.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/acknowledgements.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;謝辞&lt;/h1&gt;
&lt;p&gt;Boost Graph Library の開発において、我々に刺激を与え、励ましてくれた たくさんの人々に感謝したい。&lt;/p&gt;
&lt;p&gt;最も深い感謝を Alexander Stepanov に。彼のジェネリックプログラミングにおける 先駆的仕事と、励ましと、そして BGL に寄贈された彼のアルゴリズムに対して。 Matthew Austern には、 STL の概念を文書化する作業に対して感謝を。 それは BGL における概念を作る基盤となった。 Dietmar Kühl に感謝。彼のジェネリックなグラフアルゴリズムとデザインパターン、 とりわけプロパティマップの抽象化に。&lt;/p&gt;
&lt;p&gt;Dave Abrahams 、 Jens Maurer 、 Beman Dawes 、 Gary Powell 、 Greg Colvin 、 Valentin Bonnard 、 そして Boost の残りのグループは、 BGL インタフェースに有益なアドバイスを与え、 改善のための数多くのことを提案し、 ドキュメントの校正をして、 そしてコードを洗練する際に力を貸してくれた。 公式レビューのマネージメントしくれた Dave Abrahams に特に感謝したい。&lt;/p&gt;
&lt;p&gt;BGL の改良に役立つ質問をしてくれた BGL ユーザの Gordon Woodhull 、 Dave Longhorn 、 Joel Phillips 、そして Edward Luke にも感謝する。&lt;/p&gt;
&lt;p&gt;ドキュメントの編集と校正を担当してくれた Jeffrey Squyres に特別の感謝を。&lt;/p&gt;
&lt;p&gt;Boost Graph Library の当初の作業は、部分的に NSF 助成金 ACI-9982205 および 米国エネルギー省科学局 MICS プログラム (Director, Office of Science, Division of Mathematical, Information, and Computational Sciences of the U.S. Department of Energy) 契約番号 DE-AC03-76SF00098 の支援を受けた。&lt;/p&gt;
&lt;p&gt;また、米エネルギー省科学局が支援する 国立エネルギーリサーチ科学コンピューティングセンター (National Energy Research Scientific Computing Center) の資源も利用させて頂いた。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Adjacency Iterator Adaptor -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/adjacency_iterator.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Adjacency Iterator Adaptor&lt;/h1&gt;
&lt;p&gt;Defined in header &lt;code&gt;boost/graph/adjacency_iterator.hpp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;隣接イテレータ・アダプタは &lt;code&gt;out_edge_iterator&lt;/code&gt; を隣接イテレータに変形する。すなわち、辺の方々を巡回するイテレータを取り、それらの &lt;strong&gt;終点&lt;/strong&gt; の方々を巡回するイテレータを作成する。このアダプタと共に &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenchGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; をモデルとするグラフ型を取り、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;Adjacency Graph&lt;/a&gt; によって要求される能力を付け加えるのは些細なことである。&lt;/p&gt;
&lt;h2&gt;Synopsis&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexDescriptor&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;OutEdgeIter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;adjacency_iterator_generator&lt;/span&gt; {
  &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; iterator_adaptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;...&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; type;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;下記は &lt;code&gt;adjacency_iterator_generator&lt;/code&gt; クラスの使い方の例である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/graph/adjacency_iterator.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;my_graph&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... out_edge_iterator;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... vertex_descriptor;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;adjacency_iterator_generator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;my_graph, vertex_descriptor, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type adjacency_iterator;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Graph&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ型で、それは Incidence Graph をモデルとしなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexDescriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;これは &lt;code&gt;graph_traits&amp;lt;Graph&amp;gt;::vertex_descriptor&lt;/code&gt; と同じ型で なければならない。これがテンプレート・パラメータである理由は、 &lt;code&gt;adjacency_iterator_generator&lt;/code&gt; の主な使用はグラフ・クラスの定義の &lt;strong&gt;内側&lt;/strong&gt; であり、その文脈中でまだ完全に定義されていないグラフ・ クラスの上で &lt;code&gt;graph_traits&lt;/code&gt; を使えないからである。&lt;br /&gt; デフォルト: &lt;code&gt;graph_traits&amp;lt;Graph&amp;gt;::vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;OutEdgeIter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;これは &lt;code&gt;graph_traits&amp;lt;Graph&amp;gt;::out_edge_iterator&lt;/code&gt; と同じ型でなければならない。&lt;br /&gt; デフォルト: &lt;code&gt;graph_traits&amp;lt;Graph&amp;gt;::out_edge_iterator&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;隣接イテレータ・アダプタ (型 &lt;code&gt;adjacency_iterator_generator&amp;lt;...&amp;gt;::type&lt;/code&gt;) は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;Multi-Pass Input Iterator&lt;/a&gt; のモデルである。&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;p&gt;隣接イテレータ型は &lt;code&gt;reference&lt;/code&gt; の型が &lt;code&gt;value_type&lt;/code&gt; と同じで、それから &lt;code&gt;operator*()&lt;/code&gt; が値返しであることを除けば、&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;Random Access Iterator&lt;/a&gt; コンセプトによって要求されるメンバ関数と演算子を実装している。 さらに次のコンストラクタを持つ:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_iterator_generator&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;type(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; OutEdgeIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; it)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Revised 19 Aug 2001&lt;/p&gt;
&lt;p&gt;©Copyright Jeremy Siek 2000. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/adjacency_list.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_list&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed,
               VertexProperties, EdgeProperties,
               GraphProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスは一般化された隣接リストグラフ構造を実装する。 テンプレート・パラメータは要求を最も満たすクラスのバージョンを選べるように多くの形態の選択肢を提供する。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34;&gt;adjacency-list&lt;/a&gt; は基本的に二次元の構造で、ここで最初の次元の各要素は頂点を表し、頂点の各々はその辺リストの一次元構造を含んでいる。 Figure 1 は有向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 1:有向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータは外部の二次元コンテナを表すためにどんな種類のコンテナが使われるかを制御する。 &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータは辺リストを表すためにどんな種類の コンテナが使われるかを制御する。&lt;code&gt;EdgeList&lt;/code&gt; と &lt;code&gt;VertexList&lt;/code&gt; の 選択はグラフ構造の空間計算量を決定するだろう、そして様々なグラフ操作の時間計算量を決定するだろう。可能な選択とトレード・オフは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#choosing-graph-type&#34;&gt;Choosing the Edgelist and VertexList&lt;/a&gt; 中で論じられる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータはグラフが有向か無向か、または 入辺と出辺の両方にアクセスする (これを双方向性と呼ぶ) 有向かを制御する。 双方向性グラフは各辺が出辺リストと入辺リストの両方に現れるため、辺当たり有向グラフの二倍の空間を取る。Figure 2 は無向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 2:無向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの使い方のチュートリアルは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink&#34;&gt;Using &lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/family-tree-eg.cpp.html&#34;&gt;&lt;code&gt;examples/family-tree-eg.cpp&lt;/code&gt;&lt;/a&gt; 中にある例は家族の木 (family tree) をグラフで表現する方法を示す。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各々の頂点の辺リストを表わすために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの頂点リストを表すために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向か、無向か、または双方向の辺アクセス (出辺と入辺の両方にアクセス する) の有向かを選ぶ選択子。選択肢は &lt;code&gt;directedS&lt;/code&gt;、&lt;code&gt;undirectedS&lt;/code&gt;、 そして &lt;code&gt;bidirectionalS&lt;/code&gt; である。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ・オブジェクトのためのプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.md.nolink&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.md.nolink&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Vertex and Edge Properties&lt;/h2&gt;
&lt;p&gt;色、距離、重み、そしてユーザ定義のプロパティのようなプロパティは、プロパティ を用いてグラフの頂点と辺に結びつけることができる。プロパティの値はグラフに よって提供されるプロパティ・マップ経由で読み書きできる。プロパティ・マップ は get(property, g) 関数経由で得られる。プロパティの使い方は 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#adjacency-list-properties&#34;&gt;Internal Properties&lt;/a&gt; 内で述べられている。プロパティ・マップは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.md.nolink&#34;&gt;Property Map Concepts&lt;/a&gt; 内で定義されているインターフェースを実装するオブジェクトである。 &lt;code&gt;adjacency_list&lt;/code&gt; クラスから得られるプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.md.nolink&#34;&gt;Lvalue Property Map&lt;/a&gt; コンセプトのモデルである。もし &lt;code&gt;adjacency_list&lt;/code&gt; が &lt;code&gt;const&lt;/code&gt; なら、 プロパティ・マップは定数である。さもなくばプロパティ・マップは変更可能である。&lt;/p&gt;
&lt;p&gt;もしグラフの &lt;code&gt;VertexList&lt;/code&gt; が &lt;code&gt;vecS&lt;/code&gt; なら、グラフは &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティのためのプロパティ・マップを経由して アクセスされた組み込みの頂点の添え字を持っている。添え字は &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲内に整列し、連続している。頂点が 削除される時、添え字はそれらのプロパティを持ち続けるよう調整される。 これらの添え字を外部のプロパティの記憶領域にアクセスするために使う際には いくらか気をつけなければならない。 頂点の添え字のためのプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;Readable Property Map&lt;/a&gt; のモデルである。&lt;/p&gt;
&lt;h2&gt;Iterator and Descriptor Stability/Invalidation&lt;/h2&gt;
&lt;p&gt;辺の追加や削除によってグラフの構造を変更する時はいくらか注意しなければならない。&lt;code&gt;adjacency_list&lt;/code&gt; の型と操作に依存して、グラフ内を指すイテレータや記述子オブジェクトのいくつかは無効になるかもしれない。 例えば、次のコードは未定義の (悪い) 振る舞いの結果となるだろう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, vecS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=vecS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これでもまだ間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これが問題である理由は &lt;code&gt;remove_vertex()&lt;/code&gt; を呼び出しており、そしてそれが &lt;code&gt;VertexList=vecS&lt;/code&gt; の &lt;code&gt;adjacency_list&lt;/code&gt; とともに使われたとき、グラフのための全てのイテレータと記述子 (例えば &lt;code&gt;vi&lt;/code&gt; や &lt;code&gt;vi_end&lt;/code&gt;) を無効にするために、ループの次の繰り返し中に災難を引き起こす。&lt;/p&gt;
&lt;p&gt;もし異なる種類の &lt;code&gt;adjacency_list&lt;/code&gt; を使い、そして &lt;code&gt;VertexList=listS&lt;/code&gt; ならば、イテレータが削除された実際の頂点を指してなければ &lt;code&gt;remove_vertex&lt;/code&gt; を呼ぶことによってイテレータは無効にならない。次のコードはこれを説明する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, listS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=listS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これは大丈夫である&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;安定性の問題は更に頂点記述子と辺記述子に影響を及ぼす。例えば、最短経路木中の頂点の親 (または先行点) の過程を保持するために頂点記述子の &lt;code&gt;vector&lt;/code&gt; を使ったとしよう (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ)。&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; を呼んで親の &lt;code&gt;vector&lt;/code&gt; を作成し、 それからグラフから頂点を削除する。続いて親の &lt;code&gt;vector&lt;/code&gt; を使おうと試みるが、全ての頂点記述子は無効になっているので、結果は正しくない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(num_vertices(G));
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(num_vertices(G));

dijkstra_shortest_paths(G, s, distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
  predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));

remove_vertex(s, G); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// まずい考えだ！親 vector 中の頂点記述子を無効にする&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 次は間違った結果を生じる&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(tie(vi, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; p[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; is the parent of &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この議論の中でイテレータと記述子の無効化は、操作によって &lt;strong&gt;直接影響を受けない&lt;/strong&gt; イテレータと記述子の無効化に携わっていることに注意しなさい。 例えば、&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の実行は、&lt;code&gt;adjacency_list&lt;/code&gt; の種類に関係なく、いつも &lt;code&gt;(u,v)&lt;/code&gt; のためのどの辺記述子も、また&lt;code&gt;(u,v)&lt;/code&gt; を指すどの辺記述子も無効にするだろう。 このイテレータと記述子の無効化の議論中で、他の辺 (&lt;code&gt;(u,v)&lt;/code&gt; ではない) を指す辺記述子とイテレータにおける &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の影響にのみ携わっている。&lt;/p&gt;
&lt;p&gt;一般的に頂点記述子と辺記述子を安定に (決して無効にならない) したければ、 &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; と &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;listS&lt;/code&gt; または &lt;code&gt;setS&lt;/code&gt; を使いなさい。もし記述子とイテレータの安定性に気をもまないけれどもメモリの 消費量とグラフの巡回速度をより心配するなら、&lt;code&gt;VertexList&lt;/code&gt; かつ／または &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;vecS&lt;/code&gt; を使いなさい。&lt;/p&gt;
&lt;p&gt;下記の表はどの操作が記述子とイテレータを無効にする原因となるかを要約する。 表中で、&lt;code&gt;EL&lt;/code&gt; は &lt;code&gt;EdgeList&lt;/code&gt; の省略形で &lt;code&gt;VL&lt;/code&gt; は &lt;code&gt;VertexList&lt;/code&gt; を意味する。 &lt;strong&gt;Adj Iter (隣接イテレータ)&lt;/strong&gt; カテゴリは &lt;code&gt;out_edge_iterator&lt;/code&gt;、&lt;code&gt;in_edge_iterator&lt;/code&gt;、そして &lt;code&gt;adjacency_iterator&lt;/code&gt; 型を含む。記述子とイテレータの無効化の より詳しい説明は各操作のドキュメント中で示されている。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;頂点記述子&lt;/th&gt;
&lt;th&gt;辺記述子&lt;/th&gt;
&lt;th&gt;頂点イテレータ&lt;/th&gt;
&lt;th&gt;辺イテレータ&lt;/th&gt;
&lt;th&gt;隣接イテレータ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_out_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_in_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table: 記述子とイテレータの無効化の要約&lt;/p&gt;
&lt;h2&gt;Associated Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;adjacency_list_traits&amp;lt;EdgeList, VertexList, Directed&amp;gt;::vertex_descriptor
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた頂点記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた辺記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;VertexList=vecS&lt;/code&gt; なら &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;EdgeList=vecS&lt;/code&gt; なら &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;adjacency_iterator&lt;/code&gt; は &lt;code&gt;out_edge_iterator&lt;/code&gt; と同じイテレータ・ コンセプトをモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフが有向 (&lt;code&gt;directed_tag&lt;/code&gt;) か、無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) かについての情報を提供する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これはグラフのクラスが多重辺 (同じ始点と終点を持つ辺) の挿入を許可するかどうかを述べる。二つのタグは &lt;code&gt;allow_parallel_edge_tag&lt;/code&gt; と &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;code&gt;setS&lt;/code&gt; と &lt;code&gt;hash_setS&lt;/code&gt; の亜種は多重辺を許可しない一方で他の型は多重辺を許可する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点に接続する辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点プロパティまたは辺プロパティのためのプロパティ・マップの型。 具体的なプロパティは &lt;code&gt;Property&lt;/code&gt; テンプレート引数で指定され、グラフのための &lt;code&gt;VertexProperties&lt;/code&gt; もしくは &lt;code&gt;EdgeProperties&lt;/code&gt; で指定されたプロパティのどちらか一つと一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Property&lt;/code&gt; タグで指定されたグラフのプロパティのためのプロパティの値型。&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;デフォルト・コンストラクタ。0 個の頂点と0 個の辺からなる空のグラフ・ オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コピー・コンストラクタ。辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーである新しいグラフを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;代入演算子。&lt;code&gt;this&lt;/code&gt; に 辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーを入れる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(vertices_size_type n, 
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と 0 個の辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;template &amp;lt;class EdgeIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               vertices_size_type n, 
               edges_size_type m = 0, 
               const GraphProperty&amp;amp; p = GraphProperty())&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;
`n` 個の頂点と、範囲 `[first, last)` で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 `EdgeIterator` は [`InputIterator`](http://www.sgi.com/tech/stl/InputIterator.html) のモデルでなければならない。`EdgeIterator` の値型は `std::pair` でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは `[0, n)` の範囲内に整列していなければならない。


***
```cpp
template &amp;lt;class EdgeIterator, class EdgePropertyIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               EdgePropertyIterator ep_iter,
               vertices_size_type n,
               vertices_size_type m = 0,
               const GraphProperty&amp;amp; p = GraphProperty())
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と、範囲 &lt;code&gt;[first, last)&lt;/code&gt; で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; と &lt;code&gt;EdgePropertyIterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;code&gt;EdgeIterator&lt;/code&gt; の値型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは &lt;code&gt;[0, n)&lt;/code&gt; の範囲内に整列していなければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperties&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear()
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから全ての辺と頂点を削除する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; のグラフの頂点、辺、そしてプロパティと、グラフ&lt;code&gt;x&lt;/code&gt;の頂点、辺、そしてプロパティを交換する。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;h3&gt;Structure Access&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; の出辺へのアクセスを提供するイテレータ範囲を返す。もしグラフが無向グラフなら、このイテレータ範囲は 頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。 有向グラフと無向グラフの両方で、出辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; に隣接する頂点の場合は &lt;code&gt;source(e, g) == u&lt;/code&gt; かつ &lt;code&gt;target(e, g) == v&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
in_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する イテレータ範囲を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに &lt;code&gt;bidirectionalS&lt;/code&gt; が指定されている場合にのみ利用できる。 入辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; に隣接している何らかの頂点 &lt;code&gt;u&lt;/code&gt; に対して、グラフが有向であろうと無向であろうと、&lt;code&gt;target(e, g) == v&lt;/code&gt; かつ &lt;code&gt;source(e, g) == u&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; を出て行く辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
in_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; に入ってくる辺の数を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに&lt;code&gt;bidirectionalS&lt;/code&gt;が指定されている場合にのみ利用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type
num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type
num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点リスト中の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; と頂点 &lt;code&gt;v&lt;/code&gt; を結ぶ辺を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge_range(vertex_descriptor u, vertex_descriptor v,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; への全ての多重辺のための範囲を与える出辺イテレータのペアを返す。この関数は &lt;code&gt;adjacency_list&lt;/code&gt; 用の &lt;code&gt;EdgeList&lt;/code&gt; が終点に従って出辺をソートし、かつ多重辺を考慮するコンテナである時にのみ動作する。&lt;code&gt;multisetS&lt;/code&gt; 選択子はそのようなコンテナを選択する。&lt;/p&gt;
&lt;h3&gt;Structure Modification&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフに辺 &lt;code&gt;(u,v)&lt;/code&gt; を付け加え、新しい辺のための辺記述子を返す。 多重辺を許可しないグラフにとっては、もし辺がすでにグラフ中にあるなら、二重には付け加えられず、&lt;code&gt;bool&lt;/code&gt; フラグは &lt;code&gt;false&lt;/code&gt; になるだろう。同様に、もし &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; が 同じ頂点のための記述子 (ループを作っている) であり、かつグラフが無向グラフならば、辺は付け加えられずフラグは &lt;code&gt;false&lt;/code&gt; になるだろう。 フラグが &lt;code&gt;false&lt;/code&gt; の時は、返された辺記述子は既に存在している辺を指す。&lt;/p&gt;
&lt;p&gt;出辺リスト中の新しい辺の配置は一般に不定である。もっとも出辺リストの順序付けは &lt;code&gt;EdgeList&lt;/code&gt; の選択を通じて成し遂げられるが。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;VertexList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; でありかつ頂点記述子 &lt;code&gt;u&lt;/code&gt; または &lt;code&gt;v&lt;/code&gt; (それは整数である) がグラフ中の現在の頂点の数より大きな値を持っているなら、頂点の数が &lt;code&gt;std::max(u,v) + 1&lt;/code&gt; に なるようにグラフが拡大される。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; であれば、この操作によって頂点 &lt;code&gt;u&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; も無効になるだろう。 これはもし &lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;push(container, x)&lt;/code&gt; が呼び出されたときにそのイテレータを無効にするようなユーザ定義のコンテナ (章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#custom-storage&#34;&gt;Customizing the Adjacency List Storage&lt;/a&gt; を見なさい) であれば同様にあてはまる。 もしグラフが同様に双方向であれば、&lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;in_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりに グラフが無向グラフならば &lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりにグラフが有向グラフならば、 &lt;code&gt;add_edge()&lt;/code&gt; は同様にどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフに付け加え、&lt;code&gt;p&lt;/code&gt; を辺の内部のプロパティの記憶領域の値として添える。さらなる詳細のために前の &lt;code&gt;add_edge()&lt;/code&gt; 非メンバ関数も見なさい。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから取り除く。&lt;/p&gt;
&lt;p&gt;この操作は辺 &lt;code&gt;(u,v)&lt;/code&gt; を指すどの発行済みの辺記述子もイテレータも無効となる原因になる。加えて、もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; ならば無向と双方向のグラフの場合この操作は頂点 &lt;code&gt;u&lt;/code&gt; とまた頂点 &lt;code&gt;v&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; をグラフから取り除く。これは多重グラフの場合 &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数とは違う。この &lt;code&gt;remove_edge(e, g)&lt;/code&gt; 関数は一つの辺だけを取り除くのに対して &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数は全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を取り除く。&lt;/p&gt;
&lt;p&gt;この操作は記述子 &lt;code&gt;e&lt;/code&gt; が指す同じ辺のためのどの発行済みの辺記述子も イテレータも無効にする。加えて、この操作は &lt;code&gt;target(e, g)&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはグラフのためのどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(out_edge_iterator iter, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;remove_edge(*iter, g)&lt;/code&gt; と同じ効果を持つ。違いはこの関数は有向グラフの場合定数の時間計算量を持つのに対し、&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は O(E/V) の時間計算量を持つ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_out_edge_if(vertex_descriptor u, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                        adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;u&lt;/code&gt; の出辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_in_edge_if(vertex_descriptor v, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                       adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;v&lt;/code&gt; の入辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向と双方向の &lt;code&gt;adjacency_list&lt;/code&gt; グラフに利用できるが、有向グラフには利用できない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge_if(&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての辺を取り除く。すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点をグラフに付け加え、新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
           adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;指定されたプロパティを持つ頂点をグラフに付け加える。新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; への、そして &lt;code&gt;u&lt;/code&gt; からの全ての辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点または終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_out_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての出辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点として 持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出す時のそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向グラフには適用できない (代わりに &lt;code&gt;clear_vertex()&lt;/code&gt; を使いなさい)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_in_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての入辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は双方向グラフにのみ適用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; をグラフの頂点集合から取り除く。頂点が削除されるとき、 頂点 &lt;code&gt;u&lt;/code&gt; への、また頂点 &lt;code&gt;u&lt;/code&gt; への辺は存在しないものと仮定する。 これを確実にする一つの手段はあらかじめ &lt;code&gt;clear_vertex()&lt;/code&gt; を呼ぶことである。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータが &lt;code&gt;vecS&lt;/code&gt; なら、グラフのための全ての頂点記述子、辺記述子、そしてイテレータ はこの操作によって無効にされる。各頂点のための組み込みの &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティは操作の後もなお頂点の添え字が連続した範囲 &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; に配列しているように番号が付け直される。 もし組み込みの頂点の添え字に基づく外部のプロパティの記憶領域を使って いるなら、外部の記憶領域は調整される必要があるだろう。 他の選択は組み込みの頂点の添え字を使用せずに独自の頂点の添え字プロパティを付け加えるためにプロパティを代わりに使うことである。 もしたびたび &lt;code&gt;remove_vertex()&lt;/code&gt; 関数を使用する必要があるなら、 &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータには &lt;code&gt;listS&lt;/code&gt; 選択子が非常によい選択である。&lt;/p&gt;
&lt;h3&gt;Property Map Accessors&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PropertyTag&lt;/code&gt; で指定される頂点プロパティのためのプロパティ・マップ・ オブジェクトを返す。&lt;code&gt;PropertyTag&lt;/code&gt; はグラフの &lt;code&gt;VertexProperty&lt;/code&gt; テンプレート引数中に指定されたプロパティの一つに一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; が頂点記述子か辺記述子のどちらか一方である場合、これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を &lt;code&gt;value&lt;/code&gt; にする。&lt;code&gt;x&lt;/code&gt; は頂点記述子か辺記述子のどちらか一方である。&lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_list, PropertyTag&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; と互換でなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.md.nolink&#34;&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_traits.md.nolink&#34;&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list_traits -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/adjacency_list_traits.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_list_traits&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは &lt;code&gt;adjacency_list&lt;/code&gt; クラスに結びついた型のいくつかをアクセスする代替方法を提供する。このクラスの主な理由は値が頂点記述子または辺記述子であるグラフ・プロパティを時々作成したいと思うからである。もしこのために &lt;code&gt;graph_traits&lt;/code&gt; を使おうと試みるならば、相互に再帰的な型の問題にぶつかるだろう。この問題を避けるために &lt;code&gt;adjacency_list_traits&lt;/code&gt; クラスが提供され、それはユーザにグラフのためのプロパティ型を提供する 要求をすることなしにユーザが頂点記述子型または辺記述型にアクセスできるようにする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;EdgeList&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexList&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Directed&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; adjacency_list_traits {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... vertex_descriptor;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... edge_descriptor;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... directed_category;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... edge_parallel_category;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺コンテナの実装のための選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;頂点コンテナの実装のための選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向であるか無向であるかの選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;Assignable&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Type Requirements&lt;/h2&gt;
&lt;p&gt;工事中&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ中の頂点を識別するのに使われるオブジェクトのための型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edge_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ中の辺を識別するのに使われるオブジェクトのための型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;directed_category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;これはグラフが無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) であるか有向 (&lt;code&gt;directed_tag&lt;/code&gt;) であるかを述べる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edge_parallel_category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;これはグラフが多重辺の挿入を許可する (&lt;code&gt;allow_parallel_edge_tag&lt;/code&gt;) か、または自動的に多重辺を取り除く (&lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt;) かを述べる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bandwidth -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/bandwidth.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;bandwidth&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; VertexIndexMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, VertexIndexMap index_map)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;無向グラフの 帯域幅 (bandwidth) は二つの隣接頂点の間の最大距離 で、頂点が構成単位間隔に置かれた線上で測定された距離である。別の言い方を すると、 もし無向グラフの頂点 &lt;code&gt;G=(V,E)&lt;/code&gt; に各々 &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;|V| - 1&lt;/code&gt; までの &lt;code&gt;index[v]&lt;/code&gt; によって与えられる添え字が割り当てられているなら、&lt;code&gt;G&lt;/code&gt; の帯域幅は以下である：&lt;/p&gt;
&lt;p&gt;B(G) = max { |index[u] - index[v]|  | (u,v) in E }&lt;/p&gt;
&lt;h2&gt;Defined in&lt;/h2&gt;
&lt;p&gt;boost/graph/bandwidth.hpp&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;ith_bandwidth&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt; (&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
ith_bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor i,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; VertexIndexMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
ith_bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor i,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
      VertexIndexMap index)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの &lt;code&gt;i&lt;/code&gt; 番目の帯域幅 (i-th bandwidth) は、 &lt;code&gt;i&lt;/code&gt; 番目の頂点とその隣接のいずれかとの間の最大距離である。&lt;/p&gt;
&lt;p&gt;B&lt;sub&gt;i&lt;/sub&gt;(G) = max { |index[i] - index[j]|  | (i,j) in E }&lt;/p&gt;
&lt;p&gt;それで帯域幅 B(G) は &lt;code&gt;i&lt;/code&gt; 番目の帯域幅 B&lt;sub&gt;i&lt;/sub&gt;(G) の最大値として表すことができる。&lt;/p&gt;
&lt;p&gt;B(G) = max { B&lt;sub&gt;i&lt;/sub&gt;(G)   | i=0...|V|-1 }&lt;/p&gt;
&lt;h2&gt;Defined in&lt;/h2&gt;
&lt;p&gt;boost/graph/bandwidth.hpp &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bellman_ford_shortest_paths -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/bellman_ford_shortest_paths.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;bellman_ford_shortest_paths&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Size&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; bellman_ford_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, Size N, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Size&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;WeightMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredecessorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistanceMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;BinaryFunction&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;BinaryPredicate&lt;/a&gt;&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; bellman_ford_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, Size N, 
  WeightMap weight, PredecessorMap pred, DistanceMap distance, 
  &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;BinaryFunction&lt;/a&gt; combine, &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;BinaryPredicate&lt;/a&gt; compare, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; v)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Bellman-Ford アルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#bellman58&#34;&gt;4&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford62:_flows&#34;&gt;11&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#lawler76:_comb_opt&#34;&gt;20&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;8&lt;/a&gt;] は、正と負の両方の辺の重みを持つグラフの単一始点の最短経路問題を解く。最短経路問題の定義のために、 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-paths-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。 もし正の辺の重みを持つ最短経路問題を解く必要があるだけなら、Dijkstra の アルゴリズムがより効率的な代替手段を提供する。もし全ての辺の重みが 1 に等しいなら幅優先探索がより一層効率的な代替手段を提供する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; 関数を呼ぶ前に、ユーザは始点に 0 の 距離を割り当て、他の全ての頂点に無限大の距離を割り当てなければならない。 Bellman-Ford アルゴリズムはグラフ中の全ての辺を通してループし、各辺に リラックス操作 (減らす操作) を適用することによって進められる。下記の擬似コード中で、 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;u&lt;/code&gt; の隣接頂点で、&lt;code&gt;w&lt;/code&gt; は辺にそれらの重みをマップし、 &lt;code&gt;d&lt;/code&gt; は今の所見られる各辺への最短経路の長さを記録する距離マップである。&lt;code&gt;p&lt;/code&gt; は各辺の親を記録する先行点マップで、それは結局最短経路木中で親となるであろう。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;RELAX(u, v, w, d, p)
  if (w(u,v) + d[u] &amp;lt; d[v]) 
    d[v] := w(u,v) + d[u]      辺をリラックスする (減らす) (u,v)
    p[v] := u
  else
    ...                        辺 (u,v) は リラックスされていない (減らされていない)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;アルゴリズムはグラフ中に負の閉路が存在しないならば、各辺への距離が可能な限り最小に減らされた事が保証された後にこのループを &lt;code&gt;|V|&lt;/code&gt; 回 繰り返す。もし負の閉路が存在するならば、グラフ中に適当に最小化されない 辺が存在する事になるだろう。つまり、&lt;code&gt;w(u,v) + d[u] &amp;lt; d[v]&lt;/code&gt; であるような 辺 &lt;code&gt;(u,v)&lt;/code&gt; が存在することになるだろう。 アルゴリズムは全ての辺が最小化されたかどうか最後に一回調べるためにグラフ中の辺をループし、もしよければ &lt;code&gt;true&lt;/code&gt; を返し、そうでなければ &lt;code&gt;false&lt;/code&gt; を返す。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;BELLMAN-FORD(G)
  for each vertex u in V        頂点 u の初期化
    d[u] := infinity
    p[u] := u
  end for
  for i := 1 to |V|-1
    for each edge (u,v) in E    辺 (u,v) の調査
      RELAX(u, v, w, d, p)
    end for
  end for
  for each edge (u,v) in E
    if (w(u,v) + d[u] &amp;lt; d[v])
      return (false, , )        辺 (u,v) は最小化されていない
    else
      ...                       辺 (u,v) は最小化されている
  end for
  return (true, p, d)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。 ユーザが &lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・マップを提供するならばグラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう (もし関数が &lt;code&gt;true&lt;/code&gt; を返すなら)。 二番目の選択は最短経路木を &lt;code&gt;predecessor_map()&lt;/code&gt; に記録することである。 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点 であるか、または始点からは到達不能な頂点である場合を除く)。 これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間、アクションを取れる独自のビジタをそこに提供することができる。&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;EdgeListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;Edge List Graph&lt;/a&gt; のモデルの有向グラフまたは無向グラフでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;Size N&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の頂点の数。型 &lt;code&gt;Size&lt;/code&gt; は汎整数型でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重み　(そして「長さ」もしくは「コスト」として知られる)。 &lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。このプロパティ・マップのキー型はグラフの辺記述子でなければならない。重みマップの値型は距離マップの値型を伴った Addable でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。 アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN/OUT: &lt;code&gt;distance_map(DistanceMap d)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。プロパティ・マップのキー型は グラフの頂点記述子型でなければならず、距離マップの値型は &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;Less Than Comparable&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_distance, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BellmanFordVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビジタ・オブジェクトで、その型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;Bellman-Ford Visitor&lt;/a&gt; のモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bellman_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(BinaryFunction combine)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数オブジェクトはリラックス (減少) 段階中で、加算の役割を置き換える。 第一引数の型は距離マップの値型に一致していなければならず、第二引数の型は重みマップの値型に一致していなければならない。 結果型は距離マップの値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト:&lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(BinaryPredicate compare)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数オブジェクトはリラックス (減少) 段階中で、距離を比較する less-than (&lt;code&gt;&amp;lt;&lt;/code&gt;) 演算子の役割を置き換える。引数の型は距離マップの値型に一致していなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間複雑性は O(V E) である。&lt;/p&gt;
&lt;h2&gt;Visitor Event Points&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、グラフ中の各辺において &lt;code&gt;|V|&lt;/code&gt; 回呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は終点のための距離ラベルが減じられた時に呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった 辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし終点のための距離ラベルが減じられなかった時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_minimized(e, g)&lt;/code&gt; は、アルゴリズムの第二段階の間、各辺が最小化されたかどうかの検査の間に呼び出される。もし辺が最小化されていればこの関数が呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_minimized(e, g)&lt;/code&gt; もまた、アルゴリズムの第二段階の間、各辺が最小化されたかどうかの検査の間に呼び出される。もし辺が最小化されていなければ、この関数が呼び出される。これはグラフ中に負の閉路が存在する時に起こる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;Bellman-Ford のアルゴリズムを用いた例が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bellman-example.cpp.html&#34;&gt;examples/bellman-example.cpp&lt;/a&gt; 中にある。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われず ビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたは リファレンスによってこの状態をビジタに保持させる事を望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bellman_visitor&lt;EventVisitorList&gt; -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/bellman_visitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;bellman_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/bellman_ford_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.me&#34;&gt;BellmanFordVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが EventVisitorList の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bellman_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_bellman_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; に適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.me&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bfs_visitor&lt;EventVisitorList&gt; -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/bfs_visitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;bfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;以下は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs.cpp.html&#34;&gt;examples/bfs.cpp&lt;/a&gt; からの抜粋である。ここでは 3 つのイベントビジタを結合して BFS ビジタを作っている。関数 &lt;code&gt;boost::record_distances&lt;/code&gt; 、 &lt;code&gt;boost::record_predecessors&lt;/code&gt; 、 &lt;code&gt;copy_graph&lt;/code&gt; は全て、イベントビジタを作る関数だ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Construct graph G and obtain the source vertex s ...&lt;/span&gt;

boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;breadth_first_search(G, s, 
 boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_bfs_visitor(
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;record_distances(d, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_tree_edge()),
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;record_predecessors(p.begin(), 
                                            boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_tree_edge()),
                 copy_graph(G_copy, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_examine_edge())))) );
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリスト。&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/null_visitor.html&#34;&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが EventVisitorList の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_bfs_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを BFS ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bgl_named_params&lt;Param, Type, Rest&gt; -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bgl_named_params.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/bgl_named_params.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;bgl_named_params&amp;lt;Param, Type, Rest&amp;gt;&lt;/h1&gt;
&lt;p&gt;多くの Boost.Graph アルゴリズムは長いパラメータ列を持ち、その多くはデフォルト値を持つ。これがいくつかの問題を起こす。 1つは、 C++ がテンプレート関数のデフォルト値を扱う仕組みを持っていないことだ。しかし、異なる数のパラメータを持つ複数のバージョンのアルゴリズムを作り、各バージョンが一部のパラメータにデフォルト値を与えることで、この問題は克服される。これは Boost.Graph の以前のバージョンで使われていたアプローチだ。しかし、この解決法はまだ、いくつかの理由で不十分だ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータのデフォルト値は特定の順序でしか使えない。デフォルト値の順序がユーザの状況に合わなければ、ユーザは全てのパラメータを与えるという手段をとらなければならない。&lt;/li&gt;
&lt;li&gt;パラメータ列が長いので、順序を忘れやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;より良い解決法を与えるのが &lt;code&gt;bgl_named_params&lt;/code&gt; だ。このクラスを使えば、パラメータを任意の順序で与えることができ、パラメータ名によって引数をパラメータに適合できる。&lt;/p&gt;
&lt;p&gt;以下のコードで、名前付きパラメータのテクニックを使って &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; を呼び出す例を示す。各引数は、引数がどのパラメータに与えられるのかを示す名前を持つ関数に渡される。それぞれの名前付きパラメータは、カンマではなくピリオドで区切られる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), 
     boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;weight_map(weight).
     distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
     predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;引数が正しいパラメータ関数に適合される限り、引数が与えられる順序はどうでも良い。これは、上のコードと等価な &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; の呼び出しである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), 
   boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
   distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
   weight_map(weight));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;一般に、ユーザは &lt;code&gt;bgl_named_params&lt;/code&gt; クラスを直接使う必要はない。 &lt;code&gt;boost::weight_map&lt;/code&gt; のような &lt;code&gt;bgl_named_params&lt;/code&gt; のインスタンスを作る関数があるからだ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>breadth_first_search -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/breadth_first_search.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;breadth_first_search&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は有向グラフまたは無向グラフの幅優先巡回(breadth-first traversal) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#moore59&#34;&gt;[49]&lt;/a&gt; を行う。幅優先巡回は、始点から遠方に離れた頂点を訪れる前に近い頂点を訪れる。 この文脈中で「距離」とは始点からの最短経路中の辺の数として定義される。 &lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は始点から全ての到達可能な頂点への最短経路を計算するのに使用でき、結果として最短経路の距離が得られる。 BFS に関連した更なる定義は章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34;&gt;Breadth-First Search&lt;/a&gt; を見よ。&lt;/p&gt;
&lt;p&gt;BFS は巡回を実装するのに二つのデータ構造を使っている: 各頂点のカラー・マーカーとキューである。白色の頂点は未発見で、一方灰色の頂点は発見されたけれども未発見の隣接頂点を持つ。黒色の頂点は発見されており、他の黒色もしくは灰色の頂点にのみ隣接している。アルゴリズムは頂点 &lt;code&gt;u&lt;/code&gt; をキューから取り除き、 各出辺 &lt;code&gt;(u,v)&lt;/code&gt; を調べながら進められる。もし隣接頂点 &lt;code&gt;v&lt;/code&gt; がまだ 未発見ならば、灰色に色づけしてキューに置く。すべての出辺を調べた後、頂点 &lt;code&gt;u&lt;/code&gt; を黒色に色づけして手順を繰り返す。BFS アルゴリズムの疑似コードを下に示す。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;BFS(G, s)
  for each vertex u in V[G]      頂点uの初期化
    color[u] := WHITE 
    d[u] := infinity 
    p[u] := u 
  end for
  color[s] := GRAY 
  d[s] := 0 
  ENQUEUE(Q, s)                  頂点sの発見
  while (Q != Ø) 
    u := DEQUEUE(Q)              頂点uの調査
    for each vertex v in Adj[u]  辺(u,v)の調査
      if (color[v] = WHITE)      辺(u,v)は木の辺
        color[v] := GRAY 
        d[v] := d[u] + 1  
        p[v] := u  
        ENQUEUE(Q, v)            頂点vの発見
      else                       (u,v)は木でない辺
        if (color[v] = GRAY) 
          ...                    (u,v)は灰色の終点を持つ
        else
          ...                    (u,v)は黒色の終点を持つ
    end for
    color[u] := BLACK            頂点uの終了
  end while
  return (d, p)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は一定のイベント・ポイントと呼ばれる、 ユーザ定義のアクションで拡張することができる。アクションはビジタ・オブジェクトの形で提供されなければならない。すなわち、型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; の要求を満たしているオブジェクトである。上の擬似コード内で、イベント・ポイントは右側のラベルである。さらに各イベント・ポイントの記述を以下に示した。デフォルトでは &lt;code&gt;breadth_first_search()&lt;/code&gt; 関数はどんなアクションも実行しない。距離や先行点の記録さえも。しかしながらこれらは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; のイベント・ビジタを用いて容易に追加できる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; コンセプトで指定されたイベント・ポイントで呼び出されるビジタ・オブジェクト。 ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 アルゴリズムは開始時に全ての頂点の色を白色に初期化するため、ユーザは &lt;code&gt;breadth_first_search()&lt;/code&gt; を呼ぶ前にカラー・マップを初期化する必要はない。もし複合的な幅優先探索をグラフ上で行う必要があるなら (例えばいくつかの切断された成分があるなら) &lt;code&gt;breadth_first_visit()&lt;/code&gt; 関数を使って独自の初期化を行うこと。
    &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならなく、そのキー型はグラフの頂点記述子型でなければならなく、カラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;code&gt;iterator_property_map&lt;/code&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。 このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。 &lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;buffer(Buffer&amp;amp; Q)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点が発見される順序を決定するために使用されるキュー。もしFIFOキューが使われると、 巡回は通常の BFS 順序付けに従う。他の型のキューも使用できるが、巡回順序は異なる。例えば Dijkstra のアルゴリズムは優先度付きキューを用いて実装することができる。&lt;code&gt;Buffer&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt; のモデルでなければならない。&lt;code&gt;buffer&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; はグラフの &lt;code&gt;vertex_descriptor&lt;/code&gt; 型でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;boost::queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E + V) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(v, g)&lt;/code&gt; は、探索の開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、各頂点においてそれがキューから削除される時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、頂点が キューから削除された後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に加えて 辺が木の辺の場合に呼び出される。辺 &lt;code&gt;e&lt;/code&gt; の終点はこの時に発見される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、アルゴリズムが初めて頂点 &lt;code&gt;u&lt;/code&gt; を通った時に呼び出される。始点に近い全ての頂点が発見されており、始点から遠方に離れた頂点はまだ発見されていない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に加えて辺が tree edge でない場合に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が灰色に色づけされている場合に呼び出される。灰色は頂点が現在 キュー中にある印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が黒色に色づけされている場合に呼び出される。黒色は頂点がもはやキュー中にはない印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、 &lt;code&gt;u&lt;/code&gt; の全ての出辺が調べられ、全ての隣接頂点が発見された後で呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs-example.cpp.html&#34;&gt;examples/bfs-example.cpp&lt;/a&gt; 中にある例は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34;&gt;Figure 6&lt;/a&gt; のグラフにおいて BGL 幅優先探索アルゴリズムを用いて実演している。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs-example2.cpp.html&#34;&gt;examples/bfs-example2.cpp&lt;/a&gt; のファイルは同じ例を含むが、使われている &lt;code&gt;adacency_list&lt;/code&gt; クラスは &lt;code&gt;VertexList&lt;/code&gt; を持っており、&lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;listS&lt;/code&gt; に置かれている。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>breadth_first_visit -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/breadth_first_visit.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;breadth_first_visit&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_visit(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_visit
  (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; vis, ColorMap color)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数はカラー・マーカーがアルゴリズム中で初期化されないことを除けば、基本的に &lt;code&gt;breadth_first_search()&lt;/code&gt; と同じである。 ユーザはアルゴリズムを呼ぶ前に全ての頂点の色が白色であることを確かめる責任がある。この違いでグラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; である代わりに &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; であることのみが要求される。 さらにこの違いはカラー・プロパティ・マップ中のより多くの柔軟性を考慮に入れている。例えば頂点上の部分的な関数を実装するだけのマップを使うことができる。そしてそれは探索がグラフのごく一部にしか及ばない場合、より良い空間効率であることができる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; コンセプトで指定されたイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならなく、そのキー型はグラフの頂点記述子型でなければならなく、カラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_color, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;buffer(Buffer&amp;amp; Q)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点が発見される順序を決定するために使用されるキュー。 もしFIFO キューが使われると、巡回は通常の BFS 順序付けに従う。 他の型のキューも使用できるが、巡回順序は異なる。 例えば Dijkstra のアルゴリズムは優先度付きキューを用いて実装することができる。 &lt;code&gt;Buffer&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt; のモデルでなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;boost::queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(v, g)&lt;/code&gt; は、探索の開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、各頂点においてそれがキューから削除される時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、 頂点がキューから削除された後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt;に加えて辺が木の辺の場合に呼び出される。辺 &lt;code&gt;e&lt;/code&gt; の終点はこの時に発見される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、アルゴリズムが初めて頂点 &lt;code&gt;u&lt;/code&gt; に通った時に呼び出される。始点に近い全ての頂点が発見されており、始点から遠方に離れた頂点はまだ発見されていない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に 加えて辺が木の辺でない場合に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が灰色に色づけされている場合に呼び出される。 灰色は頂点が現在キュー中にある印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が黒色に色づけされている場合に呼び出される。 黒色は頂点がもはやキュー中にはない印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、 &lt;code&gt;u&lt;/code&gt; の全ての出辺が調べられ、全ての隣接頂点が発見された後で呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>connected_components -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/connected_components.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/connected_components.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;connected_components&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ComponentMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ComponentMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
connected_components(VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, ComponentMap comp,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この関数の名前なしパラメータバージョンは存在しない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;connected_components()&lt;/code&gt; 関数は、無向グラフの連結成分を DFS に基づく方法を用いて計算する。無向グラフの連結成分はすべての互いに到達可能な頂点の集合である。もしグラフが増大する間、連結成分を保持する必要があるなら、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.html&#34;&gt;&lt;code&gt;incremental_components()&lt;/code&gt;&lt;/a&gt; 関数の素集合に基づく方法の方が速い。「静的な」グラフには この DFS に基づく方法の方が速い &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;[8]&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;このアルゴリズムの出力は成分プロパティ・マップ &lt;code&gt;comp&lt;/code&gt; に記録され、そしてそれは各頂点に割り当てられた成分番号を与える数を含んでいる。 全成分数が関数の返却値である。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/connected_components.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const Graph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; かつ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;ComponentMap c&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このアルゴリズムはグラフ中にある連結成分数を計算し、各成分に整数のラベルを割り当てる。このアルゴリズムはそれから成分プロパティ・マップ中の成分番号を記録することによってグラフ中の各頂点がどの成分に属しているかを登録する。&lt;code&gt;ComponentMap&lt;/code&gt; 型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/[WritablePropertyMap.html&#34;&gt;Writable Property Map&lt;/a&gt; のモデルでなければならない。値型は汎整数型であるべきで、できればグラフの &lt;code&gt;vertices_size_type&lt;/code&gt; に等しい方が望ましい。キー型はグラフの頂点記述子型でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付き引数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフの進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; 型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。 このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。 &lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。 グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;連結成分のアルゴリズムの時間計算量もまた O(V + E) である。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/strong_components.html&#34;&gt;&lt;code&gt;strong_components()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.html&#34;&gt;&lt;code&gt;incremental_components()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;ファイル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/connected_components.cpp.html&#34;&gt;examples/connected_components.cpp&lt;/a&gt; は無向グラフの連結成分を計算する例を含む。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BGLでグラフアルゴリズムを構築する -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/constructing_algorithms.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/constructing_algorithms.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;BGLでグラフアルゴリズムを構築する&lt;/h1&gt;
&lt;p&gt;BGLの主な目標は、精密なグラフ・クラスを提供することにあるのではなく、また再利用可能なグラフ・アルゴリズムの広範囲にわたる集合を提供することにあるのでもない (それらは目標であるにもかかわらず)。BGLの主な目標は、他者に再利用可能なグラフのアルゴリズムを書くよう奨励することである。再利用可能とは最大限に再利用可能であることを意味する。ジェネリックプログラミングはアルゴリズムを最大限に再利用可能にする手法であり、この章でジェネリックプログラミングをいかにグラフ・アルゴリズムを構築するのに応用するかについて論ずるつもりである。&lt;/p&gt;
&lt;p&gt;ジェネリックプログラミングの過程を説明するために、グラフの着色アルゴリズムの構築を歩み抜けてみようと思う。グラフの着色問題 (またはもっと具体的に頂点着色問題) はグラフ &lt;code&gt;G&lt;/code&gt; 中の各頂点を、同じ色で彩られた隣接した二つの頂点がないように、そして最小の色数が使われるようにすることである。一般的に、グラフの着色問題はNP完全問題で、それゆえ適度な量の時間で最適解を見つけるのは不可能である。しかしながら、最小に近い着色を見つけるために発見的手法を使う多くのアルゴリズムが存在する。&lt;/p&gt;
&lt;p&gt;ここで示す今問題にするアルゴリズムは疎なヤコビ行列とヘッセン行列の消去法 [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#curtis74:_jacob&#34;&gt;9&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman84:_estim_jacob&#34;&gt;7&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman85:_algor&#34;&gt;6&lt;/a&gt;] 中で用いられている 線形時間の SEQ サブルーチンに基づいている。このアルゴリズムはグラフ中の全ての頂点を入力された順序によって定義される順番に従って訪れる。各頂点において、アルゴリズムは隣接頂点の色を印付け、それから現時点の頂点の色のために最小のまだ印付けられていない色を選ぶ。もし全ての色がすでに印付けられていたら、新しい色が作成される。色の印番号が現在の頂点番号に等しいなら、色は印付けられているとみなされる。これは各頂点のために印を置き直さねばならない厄介ごとから守る。このアルゴリズムの有効性は入力された頂点の順番に大きく依存する。最大先頭 (largest-first) 順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#welsch67&#34;&gt;[31]&lt;/a&gt;、 最小後尾 (smallest-last) 順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#matula72:_graph_theory_computing&#34;&gt;[29]&lt;/a&gt;、そして接続次数 (incidence degree) による順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#brelaz79:_new&#34;&gt;[32]&lt;/a&gt; を含むいくつかの順序付けアルゴリズムが存在し、そしてそれらはこの着色アルゴリズムの有効性を改善する。&lt;/p&gt;
&lt;p&gt;汎用グラフ・アルゴリズムを構築する際にする最初の決定は、どのグラフ操作がアルゴリズムの実装のために必要か決定すること、そしてその操作にどのグラフ・コンセプトを結びつけるか決定することである。このアルゴリズム中で頂点の色を初期化するために全ての頂点を通して巡回する必要があるだろう。さらに隣接頂点もアクセスする必要がある。それゆえ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; コンセプトを選択するつもりである。というのは、これらの操作を含む最小の概念であるからである。グラフの型はこのアルゴリズムのためにテンプレート関数中で引数が決められるだろう。グラフの型を BGL &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; のような特定のグラフ・クラスには限定しない。なぜかというとこれはアルゴリズムの再利用可能性を著しく制限するだろうからである (今まで書かれたほとんどのアルゴリズムはそうであるが)。グラフの型を &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; をモデルとする型にぜひ限定しよう。これはアルゴリズム中のそれらのグラフ操作の使用によって、その上 &lt;code&gt;function_requires()&lt;/code&gt; とともにコンセプト・チェックとして付け加えられた明示的な要求として強いられる (コンセプト・チェックについてのさらなる詳細のために章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;Concept Checking&lt;/a&gt; を見なさい)。&lt;/p&gt;
&lt;p&gt;次に、このプログラム中でどの頂点プロパティまたは辺プロパティが使われるであろうかについて考える必要がある。この場合、唯一のプロパティは頂点の色である。頂点の色へのアクセスを指定する最も融通のきく方法はプロパティ・マップのインターフェースを使うことである。これはアルゴリズムの使用者にどのようにプロパティを格納したいかを決定する能力を与える。色の読み書き両方が必要であろうから、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;ReadWritePropertyMap&lt;/a&gt; としての要求を指定する。カラー・マップの &lt;code&gt;key_type&lt;/code&gt; はグラフからの &lt;code&gt;vertex_descriptor&lt;/code&gt; でなければならず、&lt;code&gt;value_type&lt;/code&gt; は 整数の種類でなければならない。さらに &lt;code&gt;order&lt;/code&gt; 引数のためのインターフェースをプロパティ・マップとして指定する。この場合 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;ReadablePropertyMap&lt;/a&gt; である。順序付けのために、&lt;code&gt;key_type&lt;/code&gt; は整数のオフセットで、 &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;vertex_descriptor&lt;/code&gt; である。再びコンセプト・チェックとともにこれらの要求を適用する。このアルゴリズムの返却値はグラフを着色するのに必要な色の数で、従って関数の返却値型はグラフの &lt;code&gt;vertices_size_type&lt;/code&gt; である。次のコードはテンプレート関数としてのグラフのアルゴリズムのためのインターフェース、コンセプト・チェック、そしていくつかの &lt;code&gt;typedef&lt;/code&gt; を示す。実装は容易であり、上述で論ぜられていない唯一の段階は色の初期化段階で、そしてそこで全ての頂点の色を「着色されてない」状態にする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Order&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Color&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
  sequential_vertex_color_ting(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
    Order order, Color color)
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; GraphTraits;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertex_descriptor vertex_descriptor;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertices_size_type size_type;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Color&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type ColorType;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Order&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type OrderType;

    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; VertexListGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ReadWritePropertyMapConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Color, vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IntegerConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ColorType&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; size_type, ReadablePropertyMapConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Order&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; same_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;OrderType, vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type req_same;

    size_type max_color &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; size_type V &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_vertices(G);
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;size_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
      mark(V, numeric_limits_max(max_color));

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertex_iterator v, vend;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(v, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); v &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;v)
      color[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;v] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; V &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// which means &#34;not colored&#34;&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; V; i&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;) {
      vertex_descriptor current &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; order[i];

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 隣接頂点の全ての色を印付ける&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;adjacency_iterator ai, aend;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(ai, aend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(current, G); ai &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; aend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ai)
        mark[color[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ai]] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i; 

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 隣接頂点によって使われていない最小の色を見つける&lt;/span&gt;
      size_type smallest_color &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; (smallest_color &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; max_color &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mark[smallest_color] &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; i) 
        &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;smallest_color;

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// もし全ての色を使い切ったら、色の数を増やす&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (smallest_color &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; max_color)
        &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;max_color;

      color[current] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; smallest_color;
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; max_color;
  }
} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// namespace boost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_graph -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/copy_graph.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/copy_graph.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;copy_graph&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; copy_graph(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G_copy,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数はグラフ &lt;code&gt;G&lt;/code&gt; から &lt;code&gt;G_copy&lt;/code&gt; へとすべての頂点と辺をコピーする。また、頂点と辺のプロパティも、 &lt;code&gt;vertex_all&lt;/code&gt; と &lt;code&gt;edge_all&lt;/code&gt; プロパティマップを用いるか、あるいはユーザが与えたコピー関数を用いてコピーする。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/copy.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; G&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向または無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; モデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;MutableGraph&amp;amp; G_copy&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフのコピー結果。 グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;Mutable Graph&lt;/a&gt; モデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_copy(VertexCopier vc)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは オリジナルのグラフの頂点のプロパティをコピーの対応する頂点にコピーする &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;vertex_copier&amp;lt;VertexListGraph, MutableGraph&amp;gt;&lt;/code&gt; これはグラフからプロパティマップにアクセスするためにプロパティタグ &lt;code&gt;vertex_all&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;edge_copy(EdgeCopier ec)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは オリジナルのグラフの辺のプロパティをコピーの対応する辺にコピーする &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;edge_copier&amp;lt;VertexListGraph, MutableGraph&amp;gt;&lt;/code&gt; これはグラフからプロパティマップにアクセスするためにプロパティタグ &lt;code&gt;edge_all&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点添え字マップの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; モデルでなければならず、また &lt;code&gt;G&lt;/code&gt; の頂点デスクリプタを &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;num_vertices(G)&lt;/code&gt; までの整数にマップしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, G)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;orig_to_copy(Orig2CopyMap c)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはオリジナルのグラフの頂点をコピーの頂点にマップする。&lt;/li&gt;
&lt;li&gt;デフォルト: 出力グラフの頂点デスクリプタ型のサイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から 作られる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、 添え字マップのために &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(V + E) 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cuthill_mckee_ordering -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/cuthill_mckee_ordering.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/cuthill_mckee_ordering.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;cuthill_mckee_ordering&lt;/h1&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;構成要素&lt;/th&gt;
&lt;th&gt;値&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;グラフ&lt;/td&gt;
&lt;td&gt;無向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;プロパティ&lt;/td&gt;
&lt;td&gt;色、次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;計算量&lt;/td&gt;
&lt;td&gt;`time: O(log(m)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;IncidenceGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;OutputIterator&lt;/span&gt;,
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DegreeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; 
cuthill_mckee_ordering(IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
                       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
                       OutputIterator inverse_permutation, 
                       ColorMap color, DegreeMap degree)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;OutputIterator&lt;/span&gt;, 
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DegreeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; 
cuthill_mckee_ordering(VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, OutputIterator inverse_permutation, 
                       ColorMap color, DegreeMap degree)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Cuthill-Mckee(と逆Cuthill-Mckee)順序アルゴリズム[&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george81:__sparse_pos_def&#34;&gt;14&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#cuthill69:reducing_bandwith&#34;&gt;43&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#liu75:anal_cm_rcm&#34;&gt;44&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george71:fem&#34;&gt;45&lt;/a&gt;]の目的は、各頂点に割り当てられている添え字を再順序付けすることによって、グラフの&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;帯域幅&lt;/a&gt;を減らすことである。Cuthill-Mckee の順序付けアルゴリズムは、 i 番目の帯域幅の局所最小化によって動作する。頂点は基本的に幅優先探索順に割り当てられる。ただし各段階において、隣接頂点がキュー中に次数の昇順で並べられることを除く。&lt;/p&gt;
&lt;p&gt;このアルゴリズムのバージョン (1) がユーザに「始点」を選ばせるのに対し、 バージョン (2) は疑似周辺ペアの発見的手法を用いて良好な始点を見つける。「始点」の選択は順序付けの品質上、重要な影響を持つ傾向がある。&lt;/p&gt;
&lt;p&gt;このアルゴリズムの出力は、新しい順序付けになっている頂点である。使用した出力イテレータの種類に依存して、Cuthill-Mckee の順序付け、または逆 Cuthill-Mckee の順序付けのどちらか一方を得られる。例えば、出力を &lt;code&gt;vector&lt;/code&gt; のリバース・イテレータを用いて &lt;code&gt;vector&lt;/code&gt; に格納すれば、逆 Cuthill-Mckee 順序付けを得る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; inv_perm(num_vertices(G));
cuthill_mckee_ordering(G, inv_perm.rbegin());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;どちらの方法でも、出力を &lt;code&gt;vector&lt;/code&gt; に格納することは、新しい順序付けから古い順序付けへの順列を与える。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;inv_perm[new_index[u]] &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; u
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;多くの場合、ほしい順列は逆の順列、つまり古い添え字から新しい添え字への順列である。これは次の方法で簡単に計算され得る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; inv_perm.size(); &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
  perm[old_index[inv_perm[i]]] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;バージョン (1) 用:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vertex_descriptor s&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OutputIterator inverse_permutation&lt;/code&gt;  (OUT) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しい頂点の順序付け。頂点は新しい順序で &lt;a href=&#34;http://www.sgi.com/tech/stl/OutputIterator.html&#34; target=&#34;_blank&#34;&gt;output iterator&lt;/a&gt; に書かれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ColorMap color_map&lt;/code&gt;  (WORK) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部的にアルゴリズムの進行過程を保持するために使われる (同じ頂点を二回訪れるのを回避するために)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DegreeMap degree_map&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点を次数にマップしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バージョン (2) 用&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OutputIterator inverse_permutation&lt;/code&gt;  (OUT) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しい頂点の順序付け。頂点は新しい順序で出力イテレータに書かれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ColorMap color_map&lt;/code&gt;  (WORK) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部的にアルゴリズムの進行過程を保持するために使われる (同じ頂点を二回訪れるのを回避するために)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DegreeMap degree_map&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点を次数にマップしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/cuthill_mckee_ordering.cpp.html&#34;&gt;examples/cuthill_mckee_ordering.cpp&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;bandwidth&lt;/code&gt;&lt;/a&gt;、それと boost/graph/properties.hpp 中の &lt;code&gt;degree_property_map&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dag_shortest_paths -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/dag_shortest_paths.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;dag_shortest_paths&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Param&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Tag&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Rest&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dag_shortest_paths(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Param,Tag,Rest&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DijkstraVisitor&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistanceMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;WeightMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredecessorMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Compare&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Combine&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistInf&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistZero&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dag_shortest_paths(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   DistanceMap distance, WeightMap weight, ColorMap color,
   PredecessorMap pred, DijkstraVisitor vis, 
   Compare compare, Combine combine, DistInf inf, DistZero zero)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズム &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;[8]&lt;/a&gt; は 重み付きの非循環有向グラフ (DAG) の単一始点の最短経路問題を解く。 このアルゴリズムは DAG にとって、Dijkstra や Bellman-Ford アルゴリズムより 一層効率的である。全ての辺の重みが 1 に等しい時はこのアルゴリズムの代わりに幅優先探索を使いなさい。最短経路問題の定義のために、最短経路問題のいくつかの背景についての章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-path-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dag_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。&lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・マップを提供するならばグラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう。さらに最短経路木を先行点マップ (predecessor map) に記録する事ができる。その場合 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点であるかまたは始点からは到達不能な頂点である場合を除く)。これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間アクションをとれる独自のビジタを提供することができる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dag_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムが適用されるグラフオブジェクト。&lt;code&gt;VertexListGraph&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。全ての距離はこの頂点から計算され、最短経路木はこの頂点を根とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重みまたは「長さ」。&lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。グラフの辺記述子型は重みマップのキー型として使用できる必要がある。マップの値型は距離マップの値型を伴った Addable でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。これは辺がリラックスされた (減らされた) 時、ヒープ・データ構造を効率よく更新するのに必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;distance_map(DistanceMap d_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点 &lt;code&gt;s&lt;/code&gt; から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。最短経路の重みは、最短経路に沿った辺の重みの和である。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。グラフの頂点記述子型は距離マップのキー型として使用できる必要がある。距離マップの値型は &lt;code&gt;combine&lt;/code&gt; 関数 オブジェクトと単位要素のための &lt;code&gt;zero&lt;/code&gt; オブジェクトから作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; の要素型である。さらに距離の値型は &lt;code&gt;compare&lt;/code&gt; 関数オブジェクトによって供給される &lt;a href=&#34;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&#34; target=&#34;_blank&#34;&gt;StrictWeakOrdering&lt;/a&gt; の順序付けを持っていなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;WeightMap&lt;/code&gt; の値型の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(CompareFunction cmp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数はどの頂点が始点により近いか決定するために距離を比較するのに使われる。 &lt;code&gt;CompareFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Predicate&lt;/a&gt; のモデルでなければならず、&lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致する引数型を持たなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(CombineFunction cmb)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数は道の距離を計算するために、距離を結合するのに使われる。 &lt;code&gt;CombineFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; のモデルでなければならない。二項関数の第一引数の型は &lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならず、第二引数の型は &lt;code&gt;WeightMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならない。結果型は距離の値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_inf(D inf)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inf&lt;/code&gt; オブジェクトは &lt;code&gt;D&lt;/code&gt; オブジェクトのどの値よりも最も大きくなければならない。すなわち、&lt;code&gt;d != inf&lt;/code&gt; の場合どれでも &lt;code&gt;compare(d, inf) == true&lt;/code&gt; でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::numeric_limits&amp;lt;D&amp;gt;::max()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_zero(D zero)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zero&lt;/code&gt; の値は距離の値と &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトによって作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; のための単一要素でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;D()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap c_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点に印をつけるためにアルゴリズムの実行の間使われる。頂点は白色から始めて、それがキュー中に挿入された時に灰色になる。それからそれがキューから取り除かれた時に黒色になる。アルゴリズムの終了時に、始点から到達可能な頂点は黒色に色づけされている。その他の全ての頂点は白色のままである。&lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。頂点記述子はマップのキー型として使用できる必要があり、マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; のモデルでなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;visitor(DijkstraVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズム内の一定のイベント・ポイントの間に起こしたいアクションを指定するのに使いなさい。&lt;code&gt;DijkstraVisitor&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt; コンセプトのモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dijkstra_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(V + E) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt; は、アルゴリズムの開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた時に呼び出される。この時点で &lt;code&gt;(p[u],u)&lt;/code&gt; は最短経路木の辺であることがわかるので、 &lt;code&gt;d[u] = delta(s,u) = d[p[u]] + w(p[u],u)&lt;/code&gt; である。さらに調査された頂点の距離は単調増加 &lt;code&gt;d[u1] &amp;lt;= d[u2] &amp;lt;= d[un]&lt;/code&gt; である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、頂点の各出辺において、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は、辺 &lt;code&gt;(u,v)&lt;/code&gt; において、 もし &lt;code&gt;d[u] + w(u,v) &amp;lt; d[v]&lt;/code&gt; であるなら呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(v, g)&lt;/code&gt; は、頂点 &lt;code&gt;v&lt;/code&gt; において、 &lt;code&gt;(u,v)&lt;/code&gt; が調査されて &lt;code&gt;v&lt;/code&gt; が白色である時に呼び出される。頂点が発見されていれば灰色に色づけされており、各到達可能な頂点はきっかり一度発見されるからである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし辺がリラックスされない (上を見よ) なら呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、頂点の出辺が全て調査された後に呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dag_shortest_paths.cpp.html&#34;&gt;examples/dag_shortest_paths.cpp&lt;/a&gt; を見よ。これはこのアルゴリズムの使用例である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われず ビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>depth_first_search -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/depth_first_search.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;depth_first_search&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;class&lt;/span&gt; P, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; vis, ColorMap color)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; vis, ColorMap color, 
                        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor start)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;depth_first_search()&lt;/code&gt; 関数は、有向グラフ中の頂点の深さ優先巡回(depth-first traversal)を行う。可能な時は、深さ優先巡回は次に訪れるために現在の頂点の隣接頂点を選ぶ。もし全ての隣接頂点がすでに発見されているならば、もしくは隣接頂点が存在しないならば、アルゴリズムは未発見の隣接を持つ前の頂点へとバックトラックする。一旦全ての到達可能な頂点が訪問されたら、アルゴリズムは残っている未発見の頂点のどれかを選び出し、巡回を続ける。このアルゴリズムは全ての頂点が訪問された時に終了する。深さ優先探索はグラフ中の辺を分類するのと、頂点を順序づけるのに役立つ。章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;Depth-First Search&lt;/a&gt; は DFS の様々な特性を記述し、適当に例をあげている。&lt;/p&gt;
&lt;p&gt;BFS に似て、頂点が発見された過程を保持するためにカラー・マーカーが使われる。白色はまだ発見されていない頂点を印づけ、灰色は発見されたけれどもまだ未発見の隣接している頂点を持つ頂点を印づける。黒い頂点はどの白い頂点にも隣接していない発見された頂点である。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;depth_first_search()&lt;/code&gt; 関数は、アルゴリズムの内部で一定のイベント・ポイントにおいて、ユーザ定義のアクションを呼び出す。これは一般的な DFS アルゴリズムが使用できる多くの状況に適用させるための機構を提供する。下の疑似コード中で、 DFS のためのイベント・ポイントは三角形と右側のラベルで示されている。ユーザ定義のアクションはビジタ・オブジェクトの形で提供されなければならない。すなわち、型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; の要求を満たしているオブジェクトである。擬似コード中では、先行点を計算するアルゴリズムを &lt;code&gt;p&lt;/code&gt;、発見時間を &lt;code&gt;d&lt;/code&gt;、そして終了時間を &lt;code&gt;t&lt;/code&gt; と表す。デフォルトでは、&lt;code&gt;depth_first_search()&lt;/code&gt; 関数はこれらのプロパティを計算しない。しかしながら、これを実行するのに使える &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; のような、あらかじめ定義されたビジタが存在する。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;DFS(G)
  for each vertex u in V 
    color[u] := WHITE              頂点 u の初期化
    p[u] = u 
  end for
  time := 0
  if there is a starting vertex s
    call DFS-VISIT(G, s)           頂点 s の開始
  for each vertex u in V 
    if color[u] = WHITE
      call DFS-VISIT(G, u)         頂点 u の開始
  end for
  return (p,d_time,f_time) 

DFS-VISIT(G, u) 
  color[u] := GRAY                 頂点 u の発見
  d_time[u] := time := time + 1 
  for each v in Adj[u]             辺 (u,v) の調査
    if (color[v] = WHITE)
      p[v] = u                     (u,v) は木の辺
      call DFS-VISIT(G, v)
    else if (color[v] = GRAY) 
      ...                          (u,v) は後退辺
    else if (color[v] = BLACK) 
      ...                          (u,v) は交差辺または前方辺
  end for
  color[u] := BLACK                頂点 u の終了
  f_time[u] := time := time + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IN: &lt;code&gt;Graph&amp;amp; g&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;有向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(DFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; コンセプトで指定されるイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;root_vertex(typename graph_traits&amp;lt;VertexListGraph&amp;gt;::vertex_descriptor start)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは深さ優先探索が開始されるべき頂点を指定する。型は与えられたグラフの頂点記述子型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;*vertices(g).first&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E + V) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt; は、グラフの探索の開始前にグラフの各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.start_vertex(s, g)&lt;/code&gt; は、探索の開始前に始点において一度呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、初めて頂点に通った時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、それが発見された後に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、各辺において、それが探索木を構成する辺のメンバになった時に呼び出される。もし先行点の記録を望むなら、このイベント・ポイントで行いなさい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.back_edge(e, g)&lt;/code&gt; は、グラフ中の後退辺において呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.forward_or_cross_edge(e, g)&lt;/code&gt; は、グラフ中の前方辺または交差辺において呼び出される。無向グラフ中ではこのメソッドは決して呼ばれない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、出辺の全てが探索木に追加され、全ての隣接頂点が発見された (ただし、それらの出辺が調査される前に) 後の頂点において呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dfs-example.cpp.html&#34;&gt;examples/dfs-example.cpp&lt;/a&gt; 中の例は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;Figure 1&lt;/a&gt; にあるグラフへ適用された DFS を示す。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html&#34;&gt;&lt;code&gt;depth_first_visit&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/undirected_dfs.html&#34;&gt;&lt;code&gt;undirected_dfs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>depth_first_visit -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/depth_first_visit.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;depth_first_visit&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_visit(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; vis, ColorMap color)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph/doc/graph_theory_review.html#dfs-algorithm&#34;&gt;depth-firstパターン&lt;/a&gt; を使って、始点 &lt;code&gt;s&lt;/code&gt; と同じ連結成分中にある全ての頂点を訪れる。時々単独で有用ではあるが、この関数の主な目的は &lt;code&gt;depth_first_search()&lt;/code&gt; の実装のためにある。&lt;/p&gt;
&lt;p&gt;ユーザによって提供される &lt;code&gt;DFSVisitor&lt;/code&gt; はアルゴリズムの内側の各イベント・ポイントで行われるアクションを決定する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ColorMap&lt;/code&gt; は訪れられた頂点の過程を保持するためにアルゴリズムによって使われる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN &lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;DFSVisitor visitor&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; コンセプトで指定されるイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;ColorMap color&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E) である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたは リファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dfs_visitor&lt;EventVisitorList&gt; -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/dfs_visitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;dfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;例は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた EventVisitor のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは DFSVisitor に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが &lt;code&gt;EventVisitorList&lt;/code&gt; の中の EventVisitor にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_dfs_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを DFS ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dijkstra_shortest_paths -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/dijkstra_shortest_paths.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;dijkstra_shortest_paths&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; P, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
dijkstra_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前なしパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; PredecessorMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistanceMap,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; WeightMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; IndexMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Compare&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Combine&lt;/a&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistInf, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistZero&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dijkstra_shortest_paths
  (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   PredecessorMap predecessor, DistanceMap distance, WeightMap weight, 
   IndexMap index_map,
   &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Compare&lt;/a&gt; compare, &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Combine&lt;/a&gt; combine, DistInf inf, DistZero zero,
   &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; vis)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#dijkstra59&#34;&gt;10&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;8&lt;/a&gt;] は、全ての辺の重みが負でない場合の、重みづけされた有向グラフまたは無向グラフの単一始点の最短経路問題を解く。いくつかの辺の重みが負である場合は Bellman-Ford のアルゴリズムを使いなさい。全ての辺の重みが 1 に等しい時は Dijkstra のアルゴリズムの代わりに幅優先探索を使いなさい。最短経路問題の定義のために、最短経路問題のいくつかの背景 についての章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-path-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。&lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・ マップを提供するならば、グラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう。さらに最短経路木を先行点マップ (predecessor map) に記録することができる。その場合 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点であるかまたは始点からは到達不能な頂点である場合を除く)。 これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間アクションを取れる独自のビジタを提供することができる。&lt;/p&gt;
&lt;p&gt;Dijkstra のアルゴリズムは最短経路を知っている頂点集合 &lt;code&gt;S&lt;/code&gt; を反復的に「育てる」ことによって、始点から他の頂点への全ての最短経路を発見する。アルゴリズムの各段階で、&lt;code&gt;S&lt;/code&gt; に追加される次の頂点は優先度付きキューによって決定される。キューは、距離ラベルによって優先された &lt;code&gt;V - S&lt;/code&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt; 中に頂点を含む。そして距離ラベルとはいまの所見られる各頂点への最短経路の長さである。それから優先度付きキューの先頭にある頂点 &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;S&lt;/code&gt; に加えられ、その各先行辺はリラックス (距離が減らされる) される。つまり、もし &lt;code&gt;u&lt;/code&gt; への距離に出辺 &lt;code&gt;(u,v)&lt;/code&gt; の重みを加えた結果が &lt;code&gt;v&lt;/code&gt; の 距離ラベルより小さいなら、頂点 &lt;code&gt;v&lt;/code&gt; の評価された距離は減らされる。 それからアルゴリズムは元に戻り、優先度付きキューの先頭の次の頂点の処理をする。優先度付きキューが空になった時にアルゴリズムは終了する。&lt;/p&gt;
&lt;p&gt;アルゴリズムは各頂点がどの集合中にあるかの過程を保持するためにカラー・マーカー (白色、灰色、そして黒色) を使う。黒色に色づけされた頂点は &lt;code&gt;S&lt;/code&gt; 中にある。 白色または灰色に色づけされた頂点は &lt;code&gt;V-S&lt;/code&gt; 中にある。白色の頂点はまだ発見されていず、灰色の頂点は優先度付きキュー中にある。デフォルトでは、グラフ中の各頂点のためのカラー・マーカーを格納するための配列を割り当てる。&lt;code&gt;color_map()&lt;/code&gt; パラメータによって独自の記憶域と色へのアクセスを提供することができる。&lt;/p&gt;
&lt;p&gt;下記の擬似コードは Dijkstra の単一始点の最短経路アルゴリズムである。 &lt;code&gt;w&lt;/code&gt; は辺の重み、&lt;code&gt;d&lt;/code&gt; は距離ラベル、そして &lt;code&gt;p&lt;/code&gt; は最短経路木を符号化するのに使われる各頂点の先行点である。&lt;code&gt;Q&lt;/code&gt; は減少キー操作 (DECREASE-KEY operation) を備える優先度付きキューである。ビジタのイベント・ポイントは右側のラベルによって示されている。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;DIJKSTRA(G, s, w)
  for each vertex u in V           頂点 u の初期化
    d[u] := infinity 
    p[u] := u 
    color[u] := WHITE
  end for
  color[s] := GRAY 
  d[s] := 0 
  INSERT(Q, s)                     頂点 s の発見
  while (Q != Ø)
    u := EXTRACT-MIN(Q)            頂点 u の調査
    S := S U { u }
    for each vertex v in Adj[u]    辺 (u,v) の調査
      if (w(u,v) + d[u] &amp;lt; d[v])
        d[v] := w(u,v) + d[u]      辺 (u,v) はリラックスされた (減らされた)
        p[v] := u 
        if (color[v] = WHITE) 
          color[v] := GRAY
          INSERT(Q, v)             頂点 v の発見
        else if (color[v] = GRAY)
          DECREASE-KEY(Q, v)
      else
        ...                        辺 (u,v) はリラックスされない (減らされない)
    end for
    color[u] := BLACK              頂点 u の終了
  end while
  return (d, p)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dijkstra_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムが適用されるグラフオブジェクト。&lt;code&gt;VertexListGraph&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。全ての距離はこの頂点から計算される。そして最短経路木はこの頂点を根とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重みまたは「長さ」。重みは全て非負でなければならず、辺の一つが負であればアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/exception.html#negative_edge&#34;&gt;&lt;code&gt;negative_edge&lt;/code&gt;&lt;/a&gt; 例外を投げる。&lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。グラフの辺記述子型は重みマップのキー型として使用できる必要がある。このマップの値型は距離マップの値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。これは辺がリラックスされた (減らされた) 時、ヒープ・データ構造を効率よく更新するのに必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;distance_map(DistanceMap d_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点 &lt;code&gt;s&lt;/code&gt; から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。最短経路の重みは、最短経路に沿った辺の重みの和である。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。グラフの頂点記述子型は距離マップのキー型として使用できる必要がある。距離マップの値型は &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトと単位要素のための &lt;code&gt;zero&lt;/code&gt; オブジェクトから作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; の要素型である。さらに距離の値型は &lt;code&gt;compare&lt;/code&gt; 関数オブジェクトによって提供される &lt;a href=&#34;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&#34; target=&#34;_blank&#34;&gt;StrictWeakOrdering&lt;/a&gt; の順序付けを持っていなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;WeightMap&lt;/code&gt; の値型の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(CompareFunction cmp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数はどの頂点が始点により近いか決定するために距離を比較するのに使われる。&lt;code&gt;CompareFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Predicate&lt;/a&gt; のモデルでなければならず、&lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・ マップの値型に一致する引数型を持たなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(CombineFunction cmb)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数は道の距離を計算するために、距離を結合するのに使われる。 &lt;code&gt;CombineFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; のモデルでなければならない。二項関数の第一引数の型は &lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならず、 第二引数の型は &lt;code&gt;WeightMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならない。結果型は距離の値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_inf(D inf)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inf&lt;/code&gt; オブジェクトは &lt;code&gt;D&lt;/code&gt; オブジェクトのどの値よりも最も大きく なければならない。すなわち、&lt;code&gt;d != inf&lt;/code&gt; の場合どれでも &lt;code&gt;compare(d, inf) == true&lt;/code&gt; でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::numeric_limits&amp;lt;D&amp;gt;::max()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_zero(D zero)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zero&lt;/code&gt; の値は距離の値と &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトによって 作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; のための単一要素でなければならない。&lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;D()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap c_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点に印をつけるためにアルゴリズムの実行の間使われる。頂点は白色から始めて、それがキュー中に挿入された時に灰色になる。それからそれがキューから取り除かれた時に黒色になる。アルゴリズムの終了時に、始点から到達可能な頂点は黒色に色づけされている。その他の全ての頂点は白色のままである。&lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。頂点記述子はマップのキー型として使用できる必要があり、マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;visitor(DijkstraVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズム内の一定のイベント・ポイントの間に起こしたいアクションを指定するのに使いなさい。&lt;code&gt;DijkstraVisitor&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt; コンセプトのモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_2&#34;&gt;[2]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dijkstra_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O((V + E) log V) か、もし全ての頂点が始点から到達可能ならちょうど O(E log V) になる。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt; は、アルゴリズムの開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、頂点が優先度付きキューから取り除かれ、集合 &lt;code&gt;S&lt;/code&gt; に加えられた時に呼び出される。この時点で &lt;code&gt;(p[u],u)&lt;/code&gt; は最短経路木の辺であることが分かるので &lt;code&gt;d[u] = delta(s,u) = d[p[u]] + w(p[u],u)&lt;/code&gt; である。さらに、調査された頂点の距離は単調増加 &lt;code&gt;d[u1] &amp;lt;= d[u2] &amp;lt;= d[un]&lt;/code&gt; である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、頂点の各出辺において、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は、辺 &lt;code&gt;(u,v)&lt;/code&gt; において、もし &lt;code&gt;d[u] + w(u,v) &amp;lt; d[v]&lt;/code&gt; であるなら呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(v, g)&lt;/code&gt; は、頂点 &lt;code&gt;v&lt;/code&gt; において、&lt;code&gt;(u,v)&lt;/code&gt; が調査されて &lt;code&gt;v&lt;/code&gt; が白色である時に呼び出される。頂点が発見されていれば灰色に色づけされており、各到達可能な頂点はきっかり一度発見されるからである。これは頂点が優先度付きキューに挿入される時にも言える。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし辺がリラックスされない (上を見よ) なら呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、頂点の出辺が全て調査された後に呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ。これは Dijkstra のアルゴリズムの使用例である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ここで使われているアルゴリズムは全ての &lt;code&gt;V - S&lt;/code&gt; 頂点を一度に優先度付きキュー中に置かないことによって、わずかなスペースを節約している。その代わり、発見された &lt;code&gt;V - S&lt;/code&gt; 中のこれらの頂点だけであり、それゆえ無限より少ない距離を持っている。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_2&#34; name=&#34;note_2&#34;&gt;[2]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dijkstra_visitor&lt;EventVisitorList&gt; -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/dijkstra_visitor.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;dijkstra_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;以下は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dave.cpp.html&#34;&gt;examples/dave.cpp&lt;/a&gt; からの抜粋である。ここでは Dijkstra のアルゴリズムで計算された最短経路木のコピーを作るために、 &lt;code&gt;copy_graph&lt;/code&gt; という単独イベントビジタを使っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;dijkstra_shortest_paths
  (G, vertex(a, G), 
   distance_map(make_iterator_property_map(distance.begin(), vertex_id, distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;])).
   predecessor_map(make_iterator_property_map(parent.begin(), vertex_id, parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;])).
   visitor(make_dijkstra_visitor(copy_graph(G_copy, on_examine_edge()))));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた EventVisitor のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dijkstra_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが &lt;code&gt;EventVisitorList&lt;/code&gt; の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dijkstra_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_dijkstra_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを Dijkstra ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。 &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>distance_recorder&lt;DistanceMap, EventTag&gt; -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/distance_recorder.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;distance_recorder&amp;lt;DistanceMap, EventTag&amp;gt;&lt;/h1&gt;
&lt;p&gt;これは、グラフ探索中に、ある始点から各頂点までの距離を (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.html&#34;&gt;property map&lt;/a&gt; を使って) 記録する &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; である。辺 &lt;code&gt;e = (u,v)&lt;/code&gt; に対して実行されると、 &lt;code&gt;v&lt;/code&gt; への距離は &lt;code&gt;u&lt;/code&gt; への距離より大きくなる。 &lt;code&gt;distance_recorder&lt;/code&gt; は &lt;code&gt;on_tree_edge&lt;/code&gt; や &lt;code&gt;on_relax_edge&lt;/code&gt; イベントでよく使われる。頂点イベントには使用できない。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt; などのアルゴリズム別のアダプタでラップすることで、 &lt;code&gt;distance_recorder&lt;/code&gt; を グラフアルゴリズムで使えるようになる。また、&lt;code&gt;std::pair&lt;/code&gt; を使って他のイベントビジタと結合して、 EventVisitorList を作れる。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;例は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/visitors.hpp&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;キーの型と値の型がグラフの頂点記述子型である &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/WritablePropertyMap.html&#34;&gt;WritablePropertyMap&lt;/a&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html#translate_note_1&#34;&gt;[訳注1]&lt;/a&gt;。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventTag&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフアルゴリズム中、いつ &lt;code&gt;distance_recorder&lt;/code&gt; が呼び出されるかを指定するタグ。 &lt;code&gt;EventTag&lt;/code&gt; は辺イベントでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;distance_recorder::event_filter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータ &lt;code&gt;EventTag&lt;/code&gt; と同じ型。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;distance_recorder(DistanceMap pa);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;距離プロパティマップ &lt;code&gt;pa&lt;/code&gt; を使って &lt;code&gt;distance_recorder&lt;/code&gt; オブジェクトを構築する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Edge, class Graph&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void operator()(Edge e, const Graph&amp;amp; g);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺 &lt;code&gt;e = (u,v)&lt;/code&gt; を渡されると、 &lt;code&gt;u&lt;/code&gt; への距離に 1 を足したものを &lt;code&gt;v&lt;/code&gt; への距離として記録する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class DistanceMap, class Tag&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;distance_recorder&amp;lt;DistanceMap, Tag&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;record_distances(DistanceMap pa, Tag);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;distance_recorder&lt;/code&gt; を作る便利な方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2&gt;訳注&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html#translate_note_1&#34; name=&#34;translate_note_1&#34;&gt;[訳注1]&lt;/a&gt; 値の型は整数である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>edge_list&lt;EdgeIterator, ValueType, DiffType&gt; -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/edge_list.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;edge_list&amp;lt;EdgeIterator, ValueType, DiffType&amp;gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; クラスは辺イテレータのペアを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; をモデルとするクラスに変えるアダプタである。辺イテレータの &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;std::pair&lt;/code&gt; (もしくは少なくとも &lt;code&gt;first&lt;/code&gt; メンバと &lt;code&gt;second&lt;/code&gt; メンバを持っている) でなければならない。ペアの &lt;code&gt;first_type&lt;/code&gt; と &lt;code&gt;second_type&lt;/code&gt; は同じでなければならず、それらはグラフの &lt;code&gt;vertex_descriptor&lt;/code&gt; のために使われるだろう。 &lt;code&gt;ValueType&lt;/code&gt; と &lt;code&gt;DiffType&lt;/code&gt; のテンプレート・パラメータは、コンパイラが部分特殊化版をサポートしていない時にのみ必要である。そうでなければデフォルトは正しい型になる。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;Bellman-Ford の最短経路アルゴリズムを &lt;code&gt;edge_list&lt;/code&gt; に適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { u, v, x, y, z, N };
&lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; name[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;u&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;v&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;y&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;z&#39;&lt;/span&gt; };

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; E;
E edges[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { E(u,y), E(u,x), E(u,v),
              E(v,u),
              E(x,y), E(x,v),
              E(y,v), E(y,z),
              E(z,u), E(z,x) };

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; weight[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt; };

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; Graph;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(edges, edges &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;sizeof&lt;/span&gt;(edges) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;sizeof&lt;/span&gt;(E));

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(N, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;short&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;max());
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(N,&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;);

distance[z] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
parent[z] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; z;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), weight,
                                            distance.begin(),
                                            parent.begin());
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (r)  
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; N; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name[i] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; distance[i]
              &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name[parent[i]] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;negative cycle&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力は最短経路木中の根と各頂点の親からの距離になる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;u: 2 v
v: 4 x
x: 7 z
y: -2 u
z: 0 z
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/edge_list.hpp&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;value_type&lt;/code&gt; が頂点記述子のペアである &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;InputIterator&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ValueType&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt;。&lt;br /&gt; デフォルト: &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::value_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DiffType&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt; の &lt;code&gt;difference_type&lt;/code&gt;。&lt;br /&gt; デフォルト: &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::difference_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; に結びつけられた頂点記述子のための型。これは &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::value_type::first_type&lt;/code&gt; と同じ型であるだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; に結びつけられた辺記述子のための型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータのための型。&lt;code&gt;edge_iterator&lt;/code&gt; のイテレータの種類は &lt;code&gt;EdgeIterator&lt;/code&gt; のそれと同じであるだろう。&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edge_list(EdgeIterator first, EdgeIterator last) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;範囲 &lt;code&gt;[first,last)&lt;/code&gt; で与えられる辺リストで指定された &lt;code&gt;n&lt;/code&gt; 個の頂点と辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>edmunds_karp_max_flow -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/edmunds_karp_max_flow.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/edmunds_karp_max_flow.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;edmunds_karp_max_flow&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; detail&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;edge_capacity_value&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
edmunds_karp_max_flow(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor src,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor sink,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;CapacityEdgeMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ResidualCapacityEdgeMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ReverseEdgeMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredEdgeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;CapacityEdgeMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
edmunds_karp_max_flow(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor src,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor sink,
   CapacityEdgeMap cap, ResidualCapacityEdgeMap res, ReverseEdgeMap rev, 
   ColorMap color, PredEdgeMap pred)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edmunds_karp_max_flow()&lt;/code&gt; 関数はネットワークの最大流を計算する。最大流の記述のために章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#network-flow-algorithms&#34;&gt;Network Flow Algorithms&lt;/a&gt; を見なさい。計算された最大流が関数の返却値になるだろう。関数はさらに &lt;code&gt;E&lt;/code&gt; 中の全ての &lt;code&gt;(u,v)&lt;/code&gt; のために流量 &lt;code&gt;f(u,v)&lt;/code&gt; を計算する。そしてそれは、残差容量 &lt;code&gt;r(u,v) = c(u,v) - f(u,v)&lt;/code&gt; の形で返される。&lt;/p&gt;
&lt;p&gt;このアルゴリズムのために、入力グラフとプロパティ・マップのパラメータにいくつかの特別な必要条件がある。最初に、ネットワークを表す有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; は、 &lt;code&gt;E&lt;/code&gt; 中の各辺のための逆辺 (reverse edge) を含むために増やされなければならない。換言すれば、入力グラフは &lt;code&gt;G&lt;sub&gt;in&lt;/sub&gt; = (V,{E U ET})&lt;/code&gt; であるべきである。&lt;code&gt;ReverseEdgeMap&lt;/code&gt; 引数 &lt;code&gt;rev&lt;/code&gt; は元のグラフ中の各辺をその逆辺にマップしなければならない。すなわち &lt;code&gt;E&lt;/code&gt; 中の全ての &lt;code&gt;(u,v)&lt;/code&gt; に対して &lt;code&gt;(u,v) -&amp;gt; (v,u)&lt;/code&gt; である。&lt;code&gt;CapacityEdgeMap&lt;/code&gt; 引数 &lt;code&gt;cap&lt;/code&gt; は &lt;code&gt;E&lt;/code&gt; 中の各辺を正の数にマップしなければならず、&lt;code&gt;E&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; 中の各辺は &lt;code&gt;0&lt;/code&gt; にされなければならない。&lt;/p&gt;
&lt;p&gt;このアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#edmonds72:_improvements_netflow&#34;&gt;Edmonds and Karp&lt;/a&gt; に負っている。もっとも &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ahuja93:_network_flows&#34;&gt;Network Flows&lt;/a&gt; に述べられている「ラベリング・アルゴリズム」と呼ばれる亜種を使っているが。&lt;/p&gt;
&lt;p&gt;このアルゴリズムは、最大流問題を実装するための大変単純で容易な解答である。しかしながら、このアルゴリズムが &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/push_relabel_max_flow.html&#34;&gt;&lt;code&gt;push_relabel_max_flow()&lt;/code&gt;&lt;/a&gt; アルゴリズムほどには良くないいくつかの理由がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非整数の容量の場合、時間計算量は最疎グラフを除く全てのグラフにとって push-relabel アルゴリズムの O(V&lt;sup&gt;2&lt;/sup&gt;E&lt;sup&gt;1/2&lt;/sup&gt;) より悪い O(V E&lt;sup&gt;2&lt;/sup&gt;) である。&lt;/li&gt;
&lt;li&gt;整数の容量の場合、もし容量の範囲 &lt;code&gt;U&lt;/code&gt; が大変大きいならば、アルゴリズムに長い時間がかかるだろう。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/edmunds_karp_max_flow.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; のモデルでなければならない。グラフ中の各辺 &lt;code&gt;(u,v)&lt;/code&gt; のために、逆辺 &lt;code&gt;(v,u)&lt;/code&gt; もまたグラフ中になければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor src&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流れのネットワーク・グラフのためのソース頂点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor sink&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流れのネットワーク・グラフのためのシンク頂点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;capacity_map(CapacityEdgeMap cap)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;辺容量プロパティ・マップ。型は定数 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_capacity, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;residual_capacity_map(ResidualCapacityEdgeMap res)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは辺をその残差容量にマップする。型は変更可能の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_residual_capacity, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;reverse_edge_map(ReverseEdgeMap rev)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を逆辺 &lt;code&gt;(v,u)&lt;/code&gt; にマップする辺プロパティ・ マップ。マップは定数 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_reverse, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;幅優先探索の段階の間、進行過程を保持するためにアルゴリズムによって使われる。アルゴリズムの終了時に、白色の頂点は最小カット集合を定義する。マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの頂点記述子型であるべきで、値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;predecessor_map(PredEdgeMap pred)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;増大した道を格納するためにアルゴリズムによって使われる。マップは変更可能の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; でなければならない。キー型はグラフの頂点記述子型であるべきで、値型は グラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の 辺記述子の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフの各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において唯一の整数にマップしなさい。このプロパティ・マップはカラー・マップまたは先行点マップのためにデフォルトが使われた時にのみ必要である。頂点添え字マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの頂点記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は、通常の場合には O(V E&lt;sup&gt;2&lt;/sup&gt;) で、もしくは容量値が 定数 &lt;code&gt;U&lt;/code&gt; で範囲づけられた整数であるならば O(V E U) である。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/edmunds-karp-eg.cpp.html&#34;&gt;examples/edmunds-karp-eg.cpp&lt;/a&gt; 中のプログラムは最大流問題の例 (辺容量を伴うグラフ) を DIMACS 形式で書かれた ファイルから読み、最大流を計算する。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/push_relabel_max_flow.html&#34;&gt;&lt;code&gt;push_relabel_max_flow()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>基本的なグラフ理論の復習 -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/graph/graph_theory_review.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;基本的なグラフ理論の復習&lt;/h1&gt;
&lt;p&gt;この章は、基本的なグラフ理論を思い出させることを意図している。読者があらかじめグラフアルゴリズムの知識があるのなら、始めるにあたりこの章は十分であろう。もし読者がグラフアルゴリズムの知識がないのならば、 Cormen, Leiserson, Rivestの&lt;a href=&#34;http://www.toc.lcs.mit.edu/~clr/&#34; target=&#34;_blank&#34;&gt;Introduction to Algorithms&lt;/a&gt; のようなもっと詳しいものを薦める。&lt;/p&gt;
&lt;h2&gt;グラフ抽象&lt;/h2&gt;
&lt;p&gt;グラフは、多くの種類の問題を解くのに有効な数学的抽象化である。基本的には、グラフは頂点と辺から構成され、辺は二つの頂点を結ぶ。もっと正確には、グラフ(graph)とは組&lt;code&gt;(V,E)&lt;/code&gt;で表され、&lt;code&gt;V&lt;/code&gt;は有限集合で、&lt;code&gt;E&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の２項関係である。&lt;code&gt;V&lt;/code&gt;は &lt;strong&gt;頂点集合(vertex set)&lt;/strong&gt; と呼ばれ、その要素を &lt;strong&gt;頂点(vertex)&lt;/strong&gt; と呼ぶ。&lt;code&gt;E&lt;/code&gt;は辺の集合で、 &lt;strong&gt;辺(edge)&lt;/strong&gt; とは&lt;code&gt;(u,v)&lt;/code&gt;の組で&lt;code&gt;u&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の要素である。 &lt;strong&gt;有向グラフ(directed graph)&lt;/strong&gt; においては、辺は順序付けられた組で、 &lt;strong&gt;始点(source)&lt;/strong&gt; を &lt;strong&gt;終点(target)&lt;/strong&gt; へと接続する。無向グラフ(undirected graph)においては、辺は順序付けされていない組で、２つの頂点を両方向につなぐ。つまり、無向グラフでは &lt;code&gt;(u,v)&lt;/code&gt;と&lt;code&gt;(v,u)&lt;/code&gt;は同じ辺の２通りの書き方である。&lt;/p&gt;
&lt;p&gt;グラフのこの定義は、いくつかの点であいまいである。辺や頂点が何を表現するかが述べられていない。グラフの例としては、連絡道路やハイパーリンク付きのウェブページなどを挙げることができる。これらの詳細がグラフの定義からは除外されているのは、大きな理由がある。それらの詳細はグラフの &lt;strong&gt;抽象化&lt;/strong&gt; の中では必要な部分ではない。詳細を定義から除外することで再利用可能な理論を構築でき、そのことは多くの異なった種類の問題を解く際に役に立つのである。&lt;/p&gt;
&lt;p&gt;定義にもどろう。グラフは頂点と辺の集合である。実際の様子を見せるため、頂点に文字のラベルがついたグラフを考え、辺を単純に文字の組としよう。ここで、有向グラフの例を次のように書くことができる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y } 
E = { (b,y), (b,y), (y,v), (z,a), (x,x), (b,x), (x,v), (a,z) } 
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このグラフを図示すると 図1 のようになる。辺 &lt;code&gt;(x,x)&lt;/code&gt; は &lt;strong&gt;輪(self-loop)&lt;/strong&gt; と呼ばれる。&lt;code&gt;(b,y)&lt;/code&gt;と &lt;code&gt;(b,y)&lt;/code&gt;は &lt;strong&gt;平行辺(parallel edges)&lt;/strong&gt; であり、これは &lt;strong&gt;マルチグラフ(multigraph)&lt;/strong&gt; でのみ許される(ただし、通常は有向グラフでも無向グラフでも許されない)。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/digraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図1: 有向グラフの例&lt;/p&gt;
&lt;p&gt;次に似たようなグラフを示すが、今度は無向グラフである。これは図2に図示する。無向グラフでは輪は許されない。上記のグラフ(から平行辺&lt;code&gt;(b,y)&lt;/code&gt;を除いたもの)の &lt;strong&gt;無向版(undirected version)&lt;/strong&gt; である。それはつまり、同じ頂点をもち、同じ辺から方向を除いたものを持つことを意味し、&lt;code&gt;(a,z)&lt;/code&gt;と&lt;code&gt;(z,a)&lt;/code&gt;という２つの辺は一つの辺に退化する。また、逆を考えることもできる。無向グラフの &lt;strong&gt;有向版(directed version)&lt;/strong&gt; は、すべての辺をそれぞれの方向を向く２つの辺で置き換えることで得られる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y }
E = { (b,y), (y,v), (z,a), (b,x), (x,v) }
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undigraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図2: 無向グラフの例&lt;/p&gt;
&lt;p&gt;ここでさらにグラフの用語を定義する。辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるとき、頂点&lt;code&gt;v&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;について &lt;strong&gt;隣接している(adjacent)&lt;/strong&gt; と言う。有向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は 頂点&lt;code&gt;u&lt;/code&gt;の &lt;strong&gt;出辺(out-edge)&lt;/strong&gt; であり、頂点&lt;code&gt;v&lt;/code&gt;の &lt;strong&gt;入辺(in-edge)&lt;/strong&gt; である。無向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を &lt;strong&gt;接合している(incident on)&lt;/strong&gt; という。&lt;/p&gt;
&lt;p&gt;図1で、頂点&lt;code&gt;y&lt;/code&gt;は頂点&lt;code&gt;b&lt;/code&gt;に対して隣接している (ただし&lt;code&gt;b&lt;/code&gt;は&lt;code&gt;y&lt;/code&gt;に対して隣接していない)。辺&lt;code&gt;(b,y)&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;の出辺であり、&lt;code&gt;y&lt;/code&gt;の入辺である。図2で、&lt;code&gt;y&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;に隣接していて、また逆も同様である。辺&lt;code&gt;(y,b)&lt;/code&gt;は頂点&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;を接合している。&lt;/p&gt;
&lt;p&gt;有向グラフにおいて、ある頂点の出辺の数は &lt;strong&gt;出次数(out-degree)&lt;/strong&gt; と呼ばれ、入辺の数は &lt;strong&gt;入次数(in-degree)&lt;/strong&gt; と呼ばれる。無向グラフにおいて、ある頂点に対して接合している辺の数は &lt;strong&gt;次数(degree)&lt;/strong&gt; と呼ばれる。図1で、頂点&lt;code&gt;b&lt;/code&gt;の出次数は3であり、入次数は0である。図2では単純に頂点&lt;code&gt;b&lt;/code&gt;の次数は2である。&lt;/p&gt;
&lt;p&gt;グラフの &lt;strong&gt;路(path)&lt;/strong&gt; とは辺の列で、それぞれの辺の終点が次の辺の始点であるものである。頂点&lt;code&gt;u&lt;/code&gt;から始まり頂点&lt;code&gt;v&lt;/code&gt;で終わる路があれば、頂点&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;から &lt;strong&gt;到達可能(reachable)&lt;/strong&gt; であるという。路が &lt;strong&gt;単純(simple)&lt;/strong&gt; であるとは、辺の列の中でどの頂点も繰り返し現れないことである。路&lt;code&gt;&amp;lt;(b,x), (x,v)&amp;gt;&lt;/code&gt;は単純であるが、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は単純ではない。また、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は最初の頂点と最後の頂点が一致するので、 &lt;strong&gt;サイクル(cycle)&lt;/strong&gt; と呼ばれる。サイクルのないグラフは &lt;strong&gt;アサイクリック(acyclic)&lt;/strong&gt; と呼ばれる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平面的グラフ(planar graph)&lt;/strong&gt; とは、すべての辺が交差しないように平面上に描けるグラフのことである。そのように描かれたものは &lt;strong&gt;平面グラフ(plane graph)&lt;/strong&gt; と呼ばれる。平面グラフの &lt;strong&gt;面(face)&lt;/strong&gt; とは、辺に囲まれた連結成分のことである。平面的グラフの重要な特性は、面、辺、頂点の数がオイラーの定理：&lt;code&gt;|F| - |E| + |V| = 2&lt;/code&gt;によって関係付けられることである。このことは、平面的グラフは最大でもO(|V|)個の辺しか持たないことを意味する。&lt;/p&gt;
&lt;h2&gt;グラフデータ構造&lt;/h2&gt;
&lt;p&gt;データ構造を考えるときに最初に考えるべきグラフの属性は、&lt;strong&gt;まばらさ(sparsity)&lt;/strong&gt; である。まばらさとは、頂点に対する相対的な辺の数である。&lt;code&gt;E&lt;/code&gt;が&lt;code&gt;V²&lt;/code&gt;に近いグラフは &lt;strong&gt;密(dense)&lt;/strong&gt; であると呼ばれ、&lt;code&gt;E = alpha V&lt;/code&gt;で&lt;code&gt;alpha&lt;/code&gt;が&lt;code&gt;V&lt;/code&gt;より十分に小さい場合は、まばらな(sparse)グラフと呼ばれる。密なグラフについては、通常、 &lt;strong&gt;隣接行列表現(adjacency-matrix representation)&lt;/strong&gt; が最良の選択であり、一方まばらなグラフについては &lt;strong&gt;隣接リスト表現(adjacency-list representation)&lt;/strong&gt; が最良である。また、まばらなグラフについては &lt;strong&gt;辺リスト表現(edge-list representation)&lt;/strong&gt; も適切な状況下では記憶効率面でよい選択である。&lt;/p&gt;
&lt;h3&gt;隣接行列表現&lt;/h3&gt;
&lt;p&gt;グラフの隣接行列表現はV x Vの２次元配列である。 行列a&lt;sub&gt;uv&lt;/sub&gt;の要素は、辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるかどうかを示すブーリアン値である。図3に図1(から&lt;code&gt;(b,y)&lt;/code&gt;を引いたもの)の隣接行列表現を表す。保存に必要な領域はO(V²)である。任意の辺について、アクセス、追加、除去にかかる時間はO(1)である。 頂点の追加や除去は、再割り当てとすべてのグラフのコピーが必要になり、手順数はO(V²)になる。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;クラスは、隣接行列表現によってBGLグラフインターフェースを実装する。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_matrix.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図3: 隣接行列によるグラフの表現&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34; name=&#34;adjacency-list-representation&#34;&gt;隣接リスト表現&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;グラフの隣接リスト表現では、すべての頂点に対して出辺の列を保存する。まばらなグラフでは、こうすることでメモリ領域を節約でき、必要な領域はO(V + E)だけになる。さらに、すべての頂点の出辺にはより効果的にアクセスできる。辺の挿入のコストはO(1)で、任意の辺へのアクセスはO(alpha)である。ここで、alphaは行列のまばらさ(グラフ中のすべての頂点についての出辺の数の最大値)である。図4は図1のグラフの隣接リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;は隣接リスト表現の実装である。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図4: 隣接リストによるグラフ表現&lt;/p&gt;
&lt;h3&gt;辺リスト表現&lt;/h3&gt;
&lt;p&gt;グラフの辺リスト表現は、単純に辺の列であり、辺は頂点のIDの組で表される。必要なメモリはO(E)だけである。辺挿入のコストはO(1)であり、特定の辺のアクセスするのはO(E)(あまり効果的でない)である。図5は図1のグラフの辺リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;アダプタクラスは、辺リスト表現の実装を作るのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/edge_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図5: 辺リストによるグラフの表現&lt;/p&gt;
&lt;h2&gt;グラフアルゴリズム&lt;/h2&gt;
&lt;h3&gt;グラフ探索アルゴリズム&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;木辺(tree edge)&lt;/strong&gt; とは、グラフ探索アルゴリズムをグラフに適用することによって作られた探索木(またはフォレスト)の辺ことである。辺&lt;code&gt;(u,v)&lt;/code&gt;は木辺であるのは、辺&lt;code&gt;(u,v)&lt;/code&gt;の探索(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;ビジタ&lt;/a&gt;の&lt;code&gt;explore()&lt;/code&gt;メソッドにあたる)をしているときに&lt;code&gt;v&lt;/code&gt;が最初に見つかるときである。&lt;strong&gt;後退辺(back edge)&lt;/strong&gt;とは、探索木上で頂点を先祖につなぐ辺である。したがって、辺&lt;code&gt;(u,v)&lt;/code&gt;では&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;の先祖である。輪は後退辺とみなされる。&lt;strong&gt;先行辺(forward edge)&lt;/strong&gt;は木辺ではない辺&lt;code&gt;(u,v)&lt;/code&gt;で、探索木上&lt;code&gt;u&lt;/code&gt;を子孫&lt;code&gt;v&lt;/code&gt;へとつなぐ。&lt;strong&gt;交差辺(cross edge)&lt;/strong&gt;とは、以上の３つのカテゴリに含まれない辺のことである。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34; name=&#34;bfs-algorithm&#34;&gt;幅優先探索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;幅優先探索(Breadth-First Search, BFS)とは、グラフに対して横断的であり、特定の原点から到達可能な頂点をすべて探索する。また横断する順番については、頂点のすべての近傍を探索してから近傍の近傍の探索へと進む。幅優先探索について考えるには、例えば水溜りに石を落としたときに波が放射状に広がるように拡散すると思えばよい。同じ「波」の中の頂点は原点から同じ距離にある。頂点は最初にアルゴリズムによって遭遇するときに&lt;strong&gt;発見される(discovered)&lt;/strong&gt;と言う。頂点は、その近傍がすべて探索されたときに&lt;strong&gt;完了した(finished)&lt;/strong&gt;と言われる。これらをわかりやすくする例がある。グラフを図6に示し、そのBFSにおける発見と完了の順番をその下に示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/bfs_example.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図6: 広さ優先探索がグラフに広がる様子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順番: s r w v t x u y &lt;/li&gt;
&lt;li&gt;完了の順番: s r w v t x u y&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt;から開始して、最初は&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;(&lt;code&gt;s&lt;/code&gt;の近傍)にたどり着く。&lt;code&gt;s&lt;/code&gt;の両方の希望に到達してから、&lt;code&gt;r&lt;/code&gt;の近傍(頂点&lt;code&gt;v&lt;/code&gt;)に到達し、&lt;code&gt;w&lt;/code&gt;の近傍&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;に到達する (&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;の順序は意味を持たない)。最後に&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の近傍、&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;に到達する。&lt;/p&gt;
&lt;p&gt;今グラフ上のどこにいるか、次にどこの頂点に行くかをアルゴリズムが把握するために、BFSは頂点に色を塗る。塗る色を置く場所は、グラフの中でもよいし、アルゴリズムに引数として渡すこともできる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34; name=&#34;dfs-algorithm&#34;&gt;深さ優先探索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;深さ優先探査(Depth-First Search, DFS) は、グラフ中の全頂点を探査する。このアルゴリズムでは、常にグラフ中の「深い」部分を、次に探査すべき辺として選択していく。これは、到達した頂点が未訪問の隣接頂点を持たなくなるまで次の未訪問な隣接頂点を選択していき、端に到達すれば前の頂点へと戻り、その頂点から任意の未探査な辺へと探査を継続していくことである。深さ優先探査は、出発する頂点から到達可能な全ての頂点を訪問した後に、残りの未訪問な頂点のうちから１頂点を選択して探査を継続していく。このプロセスは、深度優先の森からともに深度優先の木という集合を形成する。深さ優先探索は、グラフ中の辺を３つのカテゴリーに分類する：木辺、後退辺、先行辺か交差辺(どちらにも明確に分類しない)。与えられたグラフから多くの有効な深度優先の森が典型的に存在し、それゆえ辺を分類するには様々な(かつ等しく有効な)方法がある。&lt;/p&gt;
&lt;p&gt;深さ優先探査の興味深い特性は、各頂点の発見時と完了時の間において、括弧（入れ子）構造を形成するということである。頂点が発見される場合、私たちが開いた括弧を使用すれば、頂点が探査終了される場合には閉じた括弧が使用され、その結果、括弧により適切に入れ子にされた集合ができあがる。図7は、探査された順番にラベル付けされた辺による無向グラフに適応された DFS （深さ優先探査）である。図の下に、探査を開始した順序と探査を終了した順序を示し、それらから導かれる括弧構造を示す。DFS （深さ優先探査）は、２つが接続されたコンポーネント・アルゴリズム、トポロジカル・ソート、などを含む他のグラフ・アルゴリズムによって使用される核となるアルゴリズムである。これは循環を検知するために利用できる（ファイル依存関係の例における&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/file_dependency_example.html#cycles&#34;&gt;循環依存 （Cylic Dependencies）&lt;/a&gt; の節を見よ）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/dfs.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 7: 無向グラフにおける深度優先探査&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順序: a b e d c f g h i&lt;/li&gt;
&lt;li&gt;完了の順序: d f c e b a&lt;/li&gt;
&lt;li&gt;括弧構造: (a (b (e (d d) (c (f f) c) e) b) a) (g (h (i i) h) g)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#minimum-spanning-tree&#34; name=&#34;minimum-spanning-tree&#34;&gt;最小全域木問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最小全域木問題は、以下のように定義される：グラフ &lt;code&gt;E&lt;/code&gt; 中の全頂点を接続する循環のサブセット &lt;code&gt;T&lt;/code&gt; を接続の全コストが最小となるように選択することである。全コストは下記により与えられる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(T) = T における辺 (u,v) におけるコスト w(u,v) の合計、 w(u,v) は辺 (u,v) のコスト
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T&lt;/code&gt; は&lt;strong&gt;全域木(spanning tree)&lt;/strong&gt;と呼ばれる.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-paths-algorithms&#34; name=&#34;shortest-paths-algorithms&#34;&gt;最短経路問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;グラフ理論における古典的問題のひとつは、グラフ中の２頂点間を結ぶ最短経路を見つけることである。形式的に経路はグラフ &lt;code&gt;G = (V, E)&lt;/code&gt; 中の頂点のシーケンス &lt;code&gt;&amp;lt;v0,v1,...,vk&amp;gt;&lt;/code&gt; で表される（辺 &lt;code&gt;(vi,vi+1) for i=0,1,...,k-1&lt;/code&gt; は 辺の集合 &lt;code&gt;E&lt;/code&gt; ）。シーケンスにおいて各頂点は次の頂点へ接続される。最短経路問題において、各辺は重みを数値として与えられている。それゆえ、&lt;strong&gt;経路の重み(weight of a path)&lt;/strong&gt;について記す&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(p) = i=1..k of w(vi-1,vi) の合計
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; に至る&lt;strong&gt;最短経路の重み(shortest path weight)&lt;/strong&gt;は&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;delta (u,v) = min { w(p) : u --&amp;gt; v } もし 頂点 u から v に至る経路が存在すれば
delta (u,v) = 無限(infinity ) そうでなければ（ u から v に至る経路がなければ）
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;最短経路は、重みの合計が最小となる経路といえる。&lt;/p&gt;
&lt;p&gt;最短経路問題には、いくつかの変形された問題がある。ここでは単一ペアの問題を定義した、しかし、さらに単一出所問題(グラフ中の1つの頂点から各頂点ごとまでの最短のパス)があり、等価な単一目的地問題、全ペア問題、などである。単一出所の問題を解決するアルゴリズムより漸近的に速い、単一ペアの問題を解決するアルゴリズムは存在しない。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短経路木(shortest-paths tree)&lt;/strong&gt;は、グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; 中のある頂点を原点とした有向サブグラフである。&lt;code&gt;V&#39;&lt;/code&gt; を &lt;code&gt;V&lt;/code&gt; のサブセット、&lt;code&gt;E&#39;&lt;/code&gt; を &lt;code&gt;E&lt;/code&gt; のサブセットとし、 &lt;code&gt;V&#39;&lt;/code&gt; は&lt;code&gt;G&#39;&lt;/code&gt; から到達可能な頂点の集合、&lt;code&gt;G&#39;&lt;/code&gt; は原点から連なる経路木を成すものとすれば、&lt;code&gt;V&#39;&lt;/code&gt; 中の全ての頂点 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;G&#39;&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; から唯一の経路を持つ。再帰的に、単一頂点アルゴリズムによる結果は最短経路木である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#network-flow-algorithms&#34; name=&#34;network-flow-algorithms&#34;&gt;ネットワークフロー問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ネットワークの流れは&lt;strong&gt;送信(source)&lt;/strong&gt;頂点 &lt;code&gt;s&lt;/code&gt; から&lt;strong&gt;受信(sink)&lt;/strong&gt;頂点&lt;code&gt;t&lt;/code&gt;へと向かう有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; である。各辺は数値による、&lt;strong&gt;容量(capacity)&lt;/strong&gt;関数 &lt;code&gt;c&lt;/code&gt; 、および、&lt;strong&gt;流れ(flow)&lt;/strong&gt;関数 &lt;code&gt;f&lt;/code&gt; を持つ。流れ関数は次の３条件を満たしていなければならない：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;f(u,v) &amp;lt;= c(u,v) for all (u,v) in V x V (容量制限) 
f(u,v) = - f(v,u) for all (u,v) in V x V (流れ対称性)
sumv in V f(u,v) = 0 for all u in V - {s,t} (流れ保存則)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;ネットワークにおける&lt;strong&gt;流れ(flow)&lt;/strong&gt;は、受信頂点 &lt;code&gt;t&lt;/code&gt; に流れ込む集合の流れである（それは、送信頂点 &lt;code&gt;s&lt;/code&gt; から流れ出るネットの流れに等価である）。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;|f| = sumu in V f(u,t) = sumv in V f(s,v)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;辺における&lt;strong&gt;余剰容量(residual capacity)&lt;/strong&gt;を &lt;code&gt;r(u,v) = c(u,v) – f(u,v)&lt;/code&gt; とする。 &lt;code&gt;r(u,v) &amp;gt; 0&lt;/code&gt; を満たす辺は余剰辺 &lt;code&gt;E&lt;sub&gt;f&lt;/sub&gt;&lt;/code&gt; であり、それは余剰グラフ &lt;code&gt;G&lt;sub&gt;f&lt;/sub&gt; = (V, E&lt;sub&gt;f&lt;/sub&gt;)&lt;/code&gt; を成す。 &lt;code&gt;r(u,v) = 0&lt;/code&gt; を満たす辺は&lt;strong&gt;飽和(saturated)&lt;/strong&gt;している。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大流問題(maximum flow problem)&lt;/strong&gt;は、最大に可能な流量値 &lt;code&gt;|f|&lt;/code&gt; を決定することであり、そのときのグラフ中における各辺に対する流量値を決定することである。&lt;/p&gt;
&lt;p&gt;ネットワークの流れを 図 8 に示す。 &lt;code&gt;A&lt;/code&gt; は送信頂点で、&lt;code&gt;H&lt;/code&gt; は受信頂点。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/max-flow.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 8: 最大流ネットワーク。各辺は（流れ/容量）のラベルで示している。&lt;/p&gt;
&lt;p&gt;最大流ネットワーク問題を解決するには長い歴史があり、最初のアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford56:_maxim&#34;&gt;Ford と Fulkerson&lt;/a&gt;による。現在に至る最良のアルゴリズムである push-relabel アルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goldberg85:_new_max_flow_algor&#34;&gt;Goldberg&lt;/a&gt; によるもので、これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#karzanov74:_deter&#34;&gt;Karzanov&lt;/a&gt; による &lt;strong&gt;preflow&lt;/strong&gt; introduced という概念を元に成り立っている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 KATO Kimikazu, &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Assignable -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/utility/Assignable.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Assignable&lt;/h1&gt;
&lt;h2&gt;説明&lt;/h2&gt;
&lt;p&gt;その型のオブジェクトから、その型の他のオブジェクトに代入が可能である場合、その型はAssignableである。&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;はAssignableモデルの型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト、もしくは可能であれば&lt;code&gt;const T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義&lt;/h2&gt;
&lt;h2&gt;妥当な式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値の型&lt;/th&gt;
&lt;th&gt;意味論&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;代入&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t = u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.lsc.nd.edu/~jsiek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Copy Constructible -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/utility/CopyConstructible.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;Copy Constructible&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;説明&lt;/h2&gt;
&lt;p&gt;オブジェクトのコピーが可能である場合、その型はCopy Constructibleである。&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;はCopy Constructibleモデルの型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;const T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義&lt;/h2&gt;
&lt;h2&gt;妥当な式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値の型&lt;/th&gt;
&lt;th&gt;意味論&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T(t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T(t)&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T(u)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;T(u)&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;デストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t.~T()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;アドレス演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;のアドレスを意味する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;アドレス演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;のアドレスを意味する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; CopyConstructibleConcept
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints() {
    T a(b);            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require copy constructor&lt;/span&gt;
    T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ptr &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;a;       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require address of operator&lt;/span&gt;
    const_constraints(a);
    ignore_unused_variable_warning(ptr);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; const_constraints(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; a) {
    T c(a);            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require const copy constructor&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ptr &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;a; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require const address of operator&lt;/span&gt;
    ignore_unused_variable_warning(c);
    ignore_unused_variable_warning(ptr);
  }
  T b;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;Default Constructible&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.lsc.nd.edu/~jsiek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>MultiPassInputIterator -- [...](...)という記法で書かれたメールアドレスに、mailto:を追加(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html"/>
      <id>9b6fb3c6c483fa0c2c0cb646a2e3f0a68d07ae10:archive/boost_docs/libs/utility/MultiPassInputIterator.md</id>
      <updated>2015-01-19 20:10:27 +0900</updated>
      
        <content type="html">&lt;h1&gt;MultiPassInputIterator&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/MultiPassInputIterator.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/utility/MultiPassInputIterator.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このコンセプトは&lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;Input Iterator&lt;/a&gt;を精製し、範囲を複数のパスで通るようイテレータを使用してもよいという要件を追加しており、&lt;code&gt;it1 == it2&lt;/code&gt;かつ&lt;code&gt;++it1 == ++it2&lt;/code&gt;のとき、&lt;code&gt;it1&lt;/code&gt;は間接参照可能である。このMulti-Pass Input Iteratorは、&lt;a href=&#34;http://www.sgi.com/tech/stl/ForwardIterator.hmtl&#34; target=&#34;_blank&#34;&gt;Forward Iterator&lt;/a&gt;によく似ている。唯一の違いは、&lt;a href=&#34;http://www.sgi.com/tech/stl/ForwardIterator.hmtl&#34; target=&#34;_blank&#34;&gt;Forward Iterator&lt;/a&gt;の&lt;code&gt;reference&lt;/code&gt;型が&lt;code&gt;value_type&amp;amp;&lt;/code&gt;であることを要求するのに対し、MultiPassInputIteratorは&lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;Input Iterator&lt;/a&gt;のように&lt;code&gt;reference&lt;/code&gt;が&lt;code&gt;value_type&lt;/code&gt;に変換できるということである。&lt;/p&gt;
&lt;h2&gt;設計ノート&lt;/h2&gt;
&lt;p&gt;Valentin Bonnardからのコメント：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;私は、Multi-Pass Input Iteratorの導入は、正しい解決ではないと考える。これと同様に、Multi-Pass Bidirectional IteratorやMulti-Pass Random Access Iteratorを定義したいと思うだろうか？私は思わない、確実に。これは問題を混乱させるだけだ。この問題は、既存のイテレータ階層に含まれている移動性(movavility)と変更性(modifiability)と左辺値らしさを混ぜ合わせたものであり、これらは明確に独立している。

Forward、Bidirectional、Random Accessは移動性に関しての用語であり、それ以外の意味に使用すべきではない。イテレータが不変(immutable)か変更可能(mutable)かは、完全に直交する。左辺値のイテレータもまた、不変性(immutability)は直交する。これらのクリーンなコンセプトでは、Multi-Pass Input Iteratorは素直にForward Iteratorと呼べる。

他の変換は以下のようになる：

std::Forward Iterator -&amp;gt; ForwardIterator &amp;amp; Lvalue Iterator

std::Bidirectionnal Iterator -&amp;gt; Bidirectionnal Iterator &amp;amp; Lvalue Iterator

std::Random Access Iterator -&amp;gt; Random Access Iterator &amp;amp; Lvalue Iterator

私のForward Iteratorで許可しておらず、std::Forward Iteratorでは許可されている唯一の操作は「&amp;amp;*it」である。私は、「&amp;amp;*」はジェネリックコードではほとんど必要ないと考える。
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Jeremy Siekからの返信：&lt;/p&gt;
&lt;p&gt;Valentinの分析は正しい。もちろん、ここには後方互換性の問題がある。現在のSTLの実装は、古いForward Iteratorの定義に基いている。これに対するアクションの正しい道筋は、標準C++のForward Iteratorやその他の定義を変更することである。そうすれば、我々はMulti-Pass Input Iteratorをなくすことができる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Other Classses -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/document/boostserialization/other-classses.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:document/boostserialization/other-classses.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Other Classses&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/boostserialization/other-classses/extended_type_info.html&#34;&gt;&lt;code&gt;extended_type_info&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/boostserialization/other-classses/void_cast.html&#34;&gt;&lt;code&gt;void_cast&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utf8_codecvt_facet&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_STRONG_TYPEDEF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state_saver&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dataflow Iterators&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smart_cast&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_STATIC_WARNING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/boostserialization/other-classses/singleton.html&#34;&gt;&lt;code&gt;singleton&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Export Key -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/document/boostserialization/reference/serializableconcept/class-serialization-traits/export-key.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:document/boostserialization/reference/serializableconcept/class-serialization-traits/export-key.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Export Key&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;仮想基底クラスのポインタを経由して派生クラスをシリアライズするとき、問題が2つ発生します。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;派生クラスのコードは、明示的に参照されないかもしれません。そのようなコードは、インスタンス化できません。この問題には、クラスTを定義(実装)するファイルで、&lt;code&gt;BOOST_CLASS_EXPORT_IMPLEMENT(T)&lt;/code&gt;を実行することで対処します。これにより、派生クラス&lt;code&gt;T&lt;/code&gt;のためのコードが明示的にインスタンス化されることが確実になります。&lt;/li&gt;
&lt;li&gt;オブジェクトがロードされるとき実行されるコードを選択するのに用いることができるある種の識別子である必要が あります。標準C++は、クラスのためのユニークな文字列を返す&lt;code&gt;typeid()&lt;/code&gt;を実装します。これは、以下の理由により、目的を完全に満たすとはいえません。    - 文字列がプラットフォームをまたいで同じであるという保証がありません。これでは、ポータブルなアーカイブをサポートできません。&lt;ul&gt;
&lt;li&gt;いろんなソースコードから、(当該クラスの定義された)コードモジュールを利用する際に、クラスはそれぞれ異なる名前空間で包まないといけないかもしれません。&lt;/li&gt;
&lt;li&gt;同じ名前を持っているが内容は異なるクラスが、利用する側のコードでローカルに定義されているかもしれません。&lt;/li&gt;
&lt;li&gt;シリアライズのためにライブラリが同じと考えるべき、異なる名前があるかもしれません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;よってserializationライブラリでは、そのクラスが宣言されるヘッダファイルで&lt;code&gt;BOOST_CLASS_EXPORT_KEY2(my_class, &#34;my_class_external_identifier&#34;)&lt;/code&gt;を記述することで対処します。多くのアプリケーションで、&lt;code&gt;BOOST_CLASS_EXPORT_KEY(my_class)&lt;/code&gt;として定義されるショートカットが利用できます。これは、クラス名を外部識別し文字列として使うのに最適です。
1つだけのモジュールからなるプログラム、すなわちDLLを利用しないプログラムは、&lt;code&gt;BOOST_CLASS_EXPORT(my_class)&lt;/code&gt;または、&lt;code&gt;BOOST_CLASS_EXPORT_GUID(my_class, &#34;my_class_external_identifier&#34;)&lt;/code&gt;を宣言ヘッダまたは定義で指定できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記2つのマクロは、実装に展開されます。(GUIDはグローバルユニーク識別子のことを示します）&lt;/p&gt;
&lt;p&gt;(このマニュアルの別の場所(&lt;a href=&#34;http://boostjp.github.io/document/boostserialization/reference/special-considerations/exporting-class-serialization.html&#34;&gt;ExportingClassSerialization&lt;/a&gt;)で、派生クラスのシリアライズについて詳細に説明します。)&lt;/p&gt;
&lt;p&gt;ライブラリは以下の場合に例外を投げます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exportされていない明示的に参照されないタイプの場合&lt;/li&gt;
&lt;li&gt;複数のモジュールまたはDLLでシリアライズのための同じタイプがインスタンス化された場合&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.46.0 リリースノート -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/document/version/1_46_0.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:document/version/1_46_0.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost 1.46.0 リリースノート&lt;/h1&gt;
&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/news/version_1_46_0&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/news/version_1_46_0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interval Container Library。interval setとmap、および interval に関連づけられた値の集約。作者：Joachim Faulhaber。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#array&#34;&gt;Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#asio&#34;&gt;Asio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#bind&#34;&gt;Bind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#concept-check&#34;&gt;Concept Check&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#filesystem&#34;&gt;Filesystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#fusion&#34;&gt;Fusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#hash&#34;&gt;Hash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#iterator&#34;&gt;Iterator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#math&#34;&gt;Math&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#optional&#34;&gt;Optional&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#pool&#34;&gt;Pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#program-options&#34;&gt;Program Options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#proto&#34;&gt;Proto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#signals&#34;&gt;Signals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#spirit&#34;&gt;Spirit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#tokenizer&#34;&gt;Tokenizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#unordered&#34;&gt;Unordered&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#wave&#34;&gt;Wave&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ツール&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#boostbook&#34;&gt;Boostbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#inspect&#34;&gt;Inspect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#array&#34; name=&#34;array&#34;&gt;Array&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cbegin&lt;/code&gt;/&lt;code&gt;cend&lt;/code&gt;のサポートを追加(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4761&#34; target=&#34;_blank&#34;&gt;#4761&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Sunコンパイラでの問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4757&#34; target=&#34;_blank&#34;&gt;#4757&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#asio&#34; name=&#34;asio&#34;&gt;Asio&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ip::address_v4::broadcast()&lt;/code&gt; を64ビット環境で使用する場合に生じる整数オーバーフローの問題を修正。&lt;/li&gt;
&lt;li&gt;プログラムがしばらく動作したあとに、 &lt;code&gt;deadline_timer&lt;/code&gt; ハンドラーの期限内の呼び出しを阻む、古い Linux カーネル上の問題を修正( &lt;code&gt;timerfd&lt;/code&gt; サポートなしで &lt;code&gt;epoll&lt;/code&gt; が使われるところ) (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5045&#34; target=&#34;_blank&#34;&gt;#5045&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#bind&#34; name=&#34;bind&#34;&gt;Bind&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make_adaptable&lt;/code&gt;のドキュメントを記載(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4532&#34; target=&#34;_blank&#34;&gt;#4532&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#concept-check&#34; name=&#34;concept-check&#34;&gt;Concept Check&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自己代入による警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4918&#34; target=&#34;_blank&#34;&gt;#4918&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#filesystem&#34; name=&#34;filesystem&#34;&gt;Filesystem&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;デフォルトのライブラリバージョンをv3にした。&lt;/li&gt;
&lt;li&gt;IBM vacpp: コンパイラのバグによる&lt;code&gt;iterator_facade&lt;/code&gt;のworkaroundに対応(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4912&#34; target=&#34;_blank&#34;&gt;#4912&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;検証し、ドキュメント化された &lt;code&gt;&amp;lt;boost/config/user.hpp&amp;gt;&lt;/code&gt; は、&lt;code&gt;BOOST_FILESYSTEM_VERSION&lt;/code&gt; の規定のために使用される(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4891&#34; target=&#34;_blank&#34;&gt;#4891&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Cスタイルの &lt;code&gt;assert&lt;/code&gt; を &lt;code&gt;BOOST_ASSERT&lt;/code&gt; で置き換えた。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_path()&lt;/code&gt; の非推奨を取りやめた。代わりに、スレッド安全性と cwd のための代替手段を注記するようにした。 &lt;code&gt;unique_path()&lt;/code&gt; は非推奨にするにはあまりに便利すぎる！&lt;/li&gt;
&lt;li&gt;GCC のいくつかの警告を解消。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_THROW_EXCEPTION&lt;/code&gt; を使用するよう、 v2 コードを修正。&lt;/li&gt;
&lt;li&gt;Windows: 非symlink reparseポイントを正確に報告するよう &lt;code&gt;status()&lt;/code&gt; を修正。&lt;/li&gt;
&lt;li&gt;directory symlink に再帰の制御を許可するために、 &lt;code&gt;recursive_directory_iterator&lt;/code&gt; に &lt;code&gt;symlink_option&lt;/code&gt; を追加。&lt;ul&gt;
&lt;li&gt;※注： directory symlink はデフォルトでは再帰できない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;リファレンスドキュメントをクリーンナップした：リンク切れ、インクルード漏れ、記載されていない関数の追加。&lt;/li&gt;
&lt;li&gt;雑なコードをクリーンナップ。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#fusion&#34; name=&#34;fusion&#34;&gt;Fusion&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt; のコピーコンストラクタを、異なる環境でも同じ順序でシーケンスメンバをコピーするよう修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2823&#34; target=&#34;_blank&#34;&gt;#2823&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#graph&#34; name=&#34;graph&#34;&gt;Graph&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++ 7.1 で Graphviz 出力が動作するよう修正。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assert&lt;/code&gt; を &lt;code&gt;BOOST_ASSERT&lt;/code&gt; に置き換え。&lt;/li&gt;
&lt;li&gt;使用する Boost.Filesystem のバージョンを v3 に変更。&lt;/li&gt;
&lt;li&gt;(&lt;code&gt;graph_traits&lt;/code&gt; 等を用いて) アダプトされたユーザー定義グラフを、&lt;code&gt;reverse_graph&lt;/code&gt; アダプタとともに使用する際の問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1021&#34; target=&#34;_blank&#34;&gt;#1021&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GraphML を使用する場合はビルドが必要であることをドキュメントに記載(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4556&#34; target=&#34;_blank&#34;&gt;#4556&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r_c_shortest_path&lt;/code&gt; のオーバーロードのうち一本の経路を要求するバージョンについて経路が見つからなかった場合にクラッシュする問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4631&#34; target=&#34;_blank&#34;&gt;#4631&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;BGL ヘッダファイルと &lt;code&gt;boost/range/irange.hpp&lt;/code&gt; で名前衝突が発生する問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4642&#34; target=&#34;_blank&#34;&gt;#4642&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;カスタム &lt;code&gt;property_map&lt;/code&gt; が &lt;code&gt;astar_search&lt;/code&gt; で動作しない問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4715&#34; target=&#34;_blank&#34;&gt;#4715&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dijkstra_shortest_path&lt;/code&gt; （ダイクストラ法）のドキュメント中で、最小スパニングツリーでないものを最小スパニングツリーとして記述していた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4731&#34; target=&#34;_blank&#34;&gt;#4731&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prim_minimum_spanning_tree&lt;/code&gt; （プリムの最小全域木）のドキュメント中で &lt;code&gt;distance_map&lt;/code&gt; に関する記述が間違っていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4737&#34; target=&#34;_blank&#34;&gt;#4737&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subgraph.hpp&lt;/code&gt; の &lt;code&gt;remove_edge_if&lt;/code&gt; と &lt;code&gt;clear_vertex&lt;/code&gt; が(遅いが正しいコードなのに) &#34;wrong&#34; とコメントで記述されていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4753&#34; target=&#34;_blank&#34;&gt;#4753&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;generate_random_graph&lt;/code&gt; の結果が指定通りの辺数にならない場合がある問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4758&#34; target=&#34;_blank&#34;&gt;#4758&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy_component&lt;/code&gt; が正しく動作しない場合がある問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4793&#34; target=&#34;_blank&#34;&gt;#4793&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GraphML の parser が &lt;code&gt;edge&lt;/code&gt; の省略可能なプロパティ &lt;code&gt;id&lt;/code&gt; を必須としていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4843&#34; target=&#34;_blank&#34;&gt;#4843&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;ドキュメントのスペルミスを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4851&#34; target=&#34;_blank&#34;&gt;#4851&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Dijkstra アルゴリズムの計算量の記述が誤っていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4852&#34; target=&#34;_blank&#34;&gt;#4852&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clustering_coefficient&lt;/code&gt; が &lt;code&gt;graph_traits&lt;/code&gt; を使っていなかった問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4887&#34; target=&#34;_blank&#34;&gt;#4887&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filtered_graph&lt;/code&gt; でグラフに対するプロパティの扱いが抜けていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4914&#34; target=&#34;_blank&#34;&gt;#4914&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;部分グラフに対してループ辺を追加した場合に二重に追加される問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4966&#34; target=&#34;_blank&#34;&gt;#4966&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Trac 上に無い種々の問題の修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#hash&#34; name=&#34;hash&#34;&gt;Hash&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::type_index&lt;/code&gt;をサポート&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wconversion&lt;/code&gt;警告を回避&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#iterator&#34; name=&#34;iterator&#34;&gt;Iterator&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;implicit_cast&lt;/code&gt; での問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3645&#34; target=&#34;_blank&#34;&gt;#3645&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function_input_iterator&lt;/code&gt; を追加(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2893&#34; target=&#34;_blank&#34;&gt;#2893&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transform_iterator&lt;/code&gt; は &lt;code&gt;function_object_result&lt;/code&gt; という独自の result type を使うのではなくて &lt;code&gt;boost::result_of&lt;/code&gt; を使うように修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1427&#34; target=&#34;_blank&#34;&gt;#1427&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#math&#34; name=&#34;math&#34;&gt;Math&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Wald分布(Wald distribution)、 逆ガウス分布(Inverse Gaussian distribution)、幾何分布(geometric distributions)を追加。&lt;/li&gt;
&lt;li&gt;configurationマクロの情報を追加。&lt;/li&gt;
&lt;li&gt;real-numered 型のために &lt;code&gt;mpreal&lt;/code&gt; のサポートを追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#msm&#34; name=&#34;msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Back-end チュートリアルに、&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/msm/doc/HTML/ch03s05.html#backend-compile-time-analysis&#34; target=&#34;_blank&#34;&gt;コンパイル時状態マシン解析(Compile-time state machine analysis)&lt;/a&gt;の節を追加。&lt;/li&gt;
&lt;li&gt;Back-end チュートリアルに、 &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/msm/doc/HTML/ch03s05.html#backend-boost-parameter&#34; target=&#34;_blank&#34;&gt;Boost.Parameter によるポリシー定義(Policy definition with Boost.Parameter)&lt;/a&gt;の節を追加。&lt;/li&gt;
&lt;li&gt;Back-end チュートリアルに、&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/msm/doc/HTML/ch03s05.html#backend-queues&#34; target=&#34;_blank&#34;&gt;メッセージキューのカスタマイズ(Customizing the message queues)&lt;/a&gt;の節を追加。
イベント、もしくは遅延されたイベントのキューのコンテナを提供することが可能になった。 Boost.CircularBuffer による効率的な実装。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;msm::back::state_machine&amp;lt;&amp;gt;::is_flag_active&lt;/code&gt; メソッドの &lt;code&gt;const&lt;/code&gt; 版を用意した。&lt;/li&gt;
&lt;li&gt;Back-end チュートリアルに、&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/msm/doc/HTML/ch03s05.html#backend-enqueueing&#34; target=&#34;_blank&#34;&gt;遅延処理のためのイベントキューイング(Enqueueing events for later processing)&lt;/a&gt;の節を追加。&lt;/li&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;deferred eventsがVC++8.0で動かなかった問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4926&#34; target=&#34;_blank&#34;&gt;#4926&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Defer functorでスタックオーバーフローしていた問題を修正。&lt;/li&gt;
&lt;li&gt;initial stateで、匿名サブマシンの遷移が動作していなかった問題を修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#optional&#34; name=&#34;optional&#34;&gt;Optional&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;コンパイラのバグでテストが失敗する可能性があるということをテスト結果に記述(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2294&#34; target=&#34;_blank&#34;&gt;#2294&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#pool&#34; name=&#34;pool&#34;&gt;Pool&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;poolに&lt;code&gt;max_size&lt;/code&gt;をセット可能になった(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2696&#34; target=&#34;_blank&#34;&gt;#2696&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/pool/pool.hpp&lt;/code&gt; &lt;code&gt;static_cast&lt;/code&gt;のかわりに&lt;code&gt;reinterpret_cast&lt;/code&gt;が使われている問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2941&#34; target=&#34;_blank&#34;&gt;#2941&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::pool_allocator&lt;/code&gt; &lt;code&gt;vector&lt;/code&gt;の&lt;code&gt;vector&lt;/code&gt;でも動作するように修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/386&#34; target=&#34;_blank&#34;&gt;#386&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Microsoftのメモリリーク検出機能との互換性を確立した(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4346&#34; target=&#34;_blank&#34;&gt;#4346&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#program-options&#34; name=&#34;program-options&#34;&gt;Program Options&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ドキュメントのサンプルのエラーを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3992&#34; target=&#34;_blank&#34;&gt;#3992&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4858&#34; target=&#34;_blank&#34;&gt;#4858&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argv&lt;/code&gt; に &lt;code&gt;const&lt;/code&gt; を付けるように修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3909&#34; target=&#34;_blank&#34;&gt;#3909&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#proto&#34; name=&#34;proto&#34;&gt;Proto&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;※破壊的変更： &lt;code&gt;&amp;lt;boost/proto/core.hpp&amp;gt;&lt;/code&gt; で定義されていた &lt;code&gt;functional::pop_front&lt;/code&gt; と &lt;code&gt;functional::reverse&lt;/code&gt; を &lt;code&gt;&amp;lt;boost/proto/functional&amp;gt;&lt;/code&gt; に移動。&lt;/li&gt;
&lt;li&gt;多くのFusionアルゴリズムのラッパー(&lt;code&gt;fusion::at&lt;/code&gt;等)と、標準ユーティリティライクな &lt;code&gt;make_pair&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt; を 新たな `&amp;lt;boost/proto/functional&amp;gt;&amp;gt; ディレクトリに追加。&lt;/li&gt;
&lt;li&gt;文法から個別に変換を指定するのを許可。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proto::matches&lt;/code&gt; は、ドメイン固有式(domain-specific expression)を保存するラッパー。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proto::and_&lt;/code&gt; 内での &lt;code&gt;operator,&lt;/code&gt; の ADL 問題を修正。&lt;/li&gt;
&lt;li&gt;複数ドメインの式における文法チェックのハンドリングを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4675&#34; target=&#34;_blank&#34;&gt;#4675&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proto::display_expr&lt;/code&gt; で &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; が曖昧になっていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4910&#34; target=&#34;_blank&#34;&gt;#4910&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Proto expression で &lt;code&gt;fusion::is_sequence&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返すよう修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5006&#34; target=&#34;_blank&#34;&gt;#5006&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GCC で &lt;code&gt;-Wundef&lt;/code&gt; オプションを使用したときに &lt;code&gt;&amp;lt;boost/proto/fusion.hpp&amp;gt;&lt;/code&gt; で警告が出ていたのを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5075&#34; target=&#34;_blank&#34;&gt;#5075&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#signals&#34; name=&#34;signals&#34;&gt;Signals&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;gcc で警告が出ないようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4365&#34; target=&#34;_blank&#34;&gt;#4365&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#spirit&#34; name=&#34;spirit&#34;&gt;Spirit&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Spirit V2.4.2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spirit.Qi および Spirit.Karma のドキュメントに、キーワードインデックスを追加。&lt;/li&gt;
&lt;li&gt;コンテナに対して属性値を追加する場合に呼ばれる新たなカスタマイゼーションポイントとして &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/advanced/customize/assign_to/assign_to_container_from_value.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;traits::assign_to_container_from_value&lt;/code&gt;&lt;/a&gt; を追加。&lt;/li&gt;
&lt;li&gt;「&lt;code&gt;lit(foo)&lt;/code&gt;」か「&lt;code&gt;foo&lt;/code&gt;」かを区別することを可能にするために、 &lt;code&gt;sprit::lit&lt;/code&gt; を実装するために使われていた &lt;code&gt;proto::lit&lt;/code&gt; を独立したバージョンに置き換えた。この変更によってセマンティクスは全く変更されないはずであり、既存コードも破壊されないはずである。&lt;/li&gt;
&lt;li&gt;コンテナ属性型として代入可能にするために、 Spirit.Qi に &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/qi/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as&amp;lt;T&amp;gt;[]&lt;/code&gt;&lt;/a&gt; ディレクティブを追加(また、 &lt;code&gt;string&lt;/code&gt; の特殊化バージョンである &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/qi/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as_string&lt;/code&gt;&lt;/a&gt; および &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/qi/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as_wstring&lt;/code&gt;&lt;/a&gt; を追加)。&lt;/li&gt;
&lt;li&gt;出力生成中にコンテナ属性型として処理可能にするために、 Spirit.Karma に &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as&amp;lt;T&amp;gt;[]&lt;/code&gt;&lt;/a&gt; ディレクティブを追加(また、 &lt;code&gt;string&lt;/code&gt; の特殊化バージョンである &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as_string&lt;/code&gt;&lt;/a&gt; および &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as_wstring&lt;/code&gt;&lt;/a&gt; を追加)。&lt;/li&gt;
&lt;li&gt;Spirit.Qi において、 &lt;code&gt;lit()&lt;/code&gt; を数値に対しても使用できるようにした。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/qi/reference/string/symbols.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;symbols&amp;lt;Ch, T&amp;gt;&lt;/code&gt;&lt;/a&gt; パーサーで、明示的な名前をエラーハンドリングとデバッギングに使用できるようにした。これは新メンバ関数 &lt;code&gt;sym.name(...)&lt;/code&gt; を使用することで設定できる。パッチを送ってくれた teajay に感謝する。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/string/symbols.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;symbols&amp;lt;Attrib, T&amp;gt;&lt;/code&gt;&lt;/a&gt; ジェネレータで、明示的な名前をエラーハンドリングとデバッギングに使用できるようにした。これは新メンバ関数 &lt;code&gt;sym.name(...)&lt;/code&gt; を使用することで設定できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Qi もしくは Karma のバグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spirit.Qi シーケンスでコンテナ属性を扱う際の問題を解決した。先頭要素に対して適切に解析された属性がシーケンスの後ろの方の値によって上書きされてしまっていた。&lt;/li&gt;
&lt;li&gt;Spirit.Karma の &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/string.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;string(s)&lt;/code&gt;&lt;/a&gt; ジェネレータを修正。 &lt;code&gt;s&lt;/code&gt; が属性のプレフィックスだけとマッチした場合でも成功していた。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Spirit.Lex の変更内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;qi::tokenid()&lt;/code&gt; プリミティブパーサーで、与えられた token id に基づいた任意の lexer token とマッチすることを可能にした。&lt;/li&gt;
&lt;li&gt;デフォルト &lt;code&gt;lexertl::token&amp;lt;&amp;gt;&lt;/code&gt; 定義のためのテンプレートパラメータを追加： token id の型。この型はデフォルトで &lt;code&gt;std::size_t&lt;/code&gt; となる。 id 型として使用されるあらゆる型は、(明示的に) &lt;code&gt;std::size_t&lt;/code&gt; に変換可能でなければならない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lex::char_()&lt;/code&gt; および &lt;code&gt;lex::string()&lt;/code&gt; に基づいたトークン定義に、 &lt;code&gt;lexer&lt;/code&gt; のセマンティックアクションを付加できるようにした。&lt;/li&gt;
&lt;li&gt;あるトークンとマッチした後、 &lt;code&gt;lexer&lt;/code&gt; が自動的に切り替わるように &lt;code&gt;lexer&lt;/code&gt; 状態を指定することを可能にした。この理由のために、トークン定義構文を拡張した：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; lexer &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; lex&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
{
    lexer()
    {
        int_ &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;[1-9][0-9]*&#34;&lt;/span&gt;;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt;self(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;INITIAL&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;TARGETSTATE&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; int_;
     }
     lex&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;token_def&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; int_;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この例の &lt;code&gt;lexer&lt;/code&gt; は &lt;code&gt;int_&lt;/code&gt; にマッチし、 &#34;TARGETSTATE&#34; 状態に切り替わる。第2引数が指定されない場合は、(これまで通り)前の状態のままである。&lt;/li&gt;
&lt;li&gt;パーサープリミティブ &lt;code&gt;qi::tokens&lt;/code&gt; および &lt;code&gt;qi::tokenid&lt;/code&gt; を引数なしで使用できるようにした。その場合、あらゆるトークンにマッチする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lex::lit()&lt;/code&gt; を削除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Spirit.Lexのバグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;すべての &lt;code&gt;lexer&lt;/code&gt; 状態にただちにトークンを割り当てるために、 &lt;code&gt;Lexer&lt;/code&gt; を与える問題を解決した。これは現在、状態の名前として &lt;code&gt;&#34;*&#34;&lt;/code&gt; を使用することで可能となる。たとえば、以下は全ての &lt;code&gt;lexer&lt;/code&gt; 状態にトークン &lt;code&gt;int_&lt;/code&gt; を加えるだろう：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; lexer &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; lex&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
{
      lexer()
      {
          int_ &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;[1-9][0-9]*&#34;&lt;/span&gt;;
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt;self(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;*&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; int_;
      }
      lex&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;token_def&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; int_;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;注：すべての &lt;code&gt;lexer&lt;/code&gt; 状態が &lt;code&gt;lexer&lt;/code&gt; オブジェクトに導入されたあと、 &lt;code&gt;self(&#34;*&#34;) = ...&lt;/code&gt; が実行されなければならない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lexer&lt;/code&gt; 先読みを修正。先読み操作は現在、その引数として使用される &lt;code&gt;token_def&lt;/code&gt; インスタンスが使用した &lt;code&gt;lexer&lt;/code&gt; 状態を使用して評価される。&lt;/li&gt;
&lt;li&gt;multi_pass iterator の中で間違ったトークンがユーザーに返される問題を解決した。これは &lt;code&gt;lexer&lt;/code&gt; 状態変更を実行し、トークンマッチを失敗させるためにセマンティックアクションの中で &lt;code&gt;pass_fail&lt;/code&gt; を使用していた &lt;code&gt;lexer&lt;/code&gt; とともの起こるかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;既知の問題&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数リテラル(&lt;code&gt;int_(10)&lt;/code&gt;のような)は、失敗に関して入力を消費する。これは代替演算子に関する問題に結びつくかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#tokenizer&#34; name=&#34;tokenizer&#34;&gt;Tokenizer&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isspace&lt;/code&gt;/&lt;code&gt;ispunct&lt;/code&gt; が間違ったキャラクタ型で呼ばれていたのを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4791&#34; target=&#34;_blank&#34;&gt;#4791&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#unordered&#34; name=&#34;unordered&#34;&gt;Unordered&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;value type での &lt;code&gt;operator&amp;amp;&lt;/code&gt; の使用を回避。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wconversion&lt;/code&gt; での警告を回避。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#wave&#34; name=&#34;wave&#34;&gt;Wave&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;V2.2.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++0xでキーワードとされる語をRe2C lexerに追加。&lt;/li&gt;
&lt;li&gt;コマンドラインオプション &lt;code&gt;--c++0x&lt;/code&gt; を追加。このオプションを付けると、C++0xでキーワードされる語と、それらのC++0xトークンへの変換が有効になる。&lt;/li&gt;
&lt;li&gt;全ライブラリをBoost.Filesystem V3と協調動作するように適合 (デフォルトで有効)。&lt;/li&gt;
&lt;li&gt;拡張文字・文字列リテラルのサポートと、それに関するテストケースを追加 (テストアプリケーションへのC++0xサポートの追加が要求される)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--c++0x&lt;/code&gt; modeに仕様に沿った定義済みマクロの追加。現在&lt;code&gt;__cplusplus&lt;/code&gt;は&lt;code&gt;201101L&lt;/code&gt;と定義されているが、言語仕様が決定する際に変更されるかもしれない。&lt;/li&gt;
&lt;li&gt;オブジェクト形式マクロがカッコと隣接していて、&lt;code&gt;expanding_object_like_macro()&lt;/code&gt;フック関数によってマクロ展開が抑制されるとき、カッコが消えてしまう問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pragma option(preserve)&lt;/code&gt;のバグを修正 (以前の値が&lt;code&gt;preserve=2&lt;/code&gt;だった場合、&lt;code&gt;perserve=1&lt;/code&gt;がセットされないバグ)。&lt;/li&gt;
&lt;li&gt;waveコマンドの&lt;code&gt;--preserve&lt;/code&gt;オプションのinteger argumentの解釈を少し変更:&lt;ul&gt;
&lt;li&gt;0: 空白文字は全て処理する&lt;/li&gt;
&lt;li&gt;1: 行頭の空白文字だけそのままにする&lt;/li&gt;
&lt;li&gt;2: 行頭とコメントの空白文字だけそのままにする&lt;/li&gt;
&lt;li&gt;3: 全ての行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#pragma wave option(preserve)&lt;/code&gt; は次の引数をサポートする: [0|1|2|3|push|pop]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#boostbook&#34; name=&#34;boostbook&#34;&gt;Boostbook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ルート要素に対する属性のより良いサポート(&lt;code&gt;lang&lt;/code&gt;を含む)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#inspect&#34; name=&#34;inspect&#34;&gt;Inspect&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boostのヘッダで、Cの&lt;code&gt;assert&lt;/code&gt;マクロが使われていないかをチェック&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#quickbook&#34; name=&#34;quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ドキュメント情報中での &lt;code&gt;lang&lt;/code&gt; 属性のサポートを追加&lt;/li&gt;
&lt;li&gt;アンカーを改善&lt;/li&gt;
&lt;li&gt;条件節での &lt;code&gt;import&lt;/code&gt;、&lt;code&gt;include&lt;/code&gt; 、 &lt;code&gt;xinclude&lt;/code&gt; のサポート&lt;/li&gt;
&lt;li&gt;Filesystem v3を使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主要テストコンパイラ：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: 3.4.6, 4.2.4, 4.3.4, 4.4.3, 4.4.5, 4.5.2,&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.3.4, 4.4.3, 4.5.0, 4.5.2&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1&lt;/li&gt;
&lt;li&gt;Clang: 2.8&lt;/li&gt;
&lt;li&gt;Pathscale: 3.2.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: 4.0.1, 4.2.1, 4.4&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.4.&lt;/li&gt;
&lt;li&gt;Intel: 11.1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++: 7.1, 8.0, 9.0 and 10.0.&lt;/li&gt;
&lt;li&gt;GCC, mingw: 4.4.0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FreeBSD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: 4.2.1, 64 bit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加のテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: 3.4.6, 4.2.4, 4.3.4, 4.3.5, 4.4.3, 4.4.5, 4.5.0, 4.5.2&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.3.4, 4.4.3, 4.5.0, 4.5.2&lt;/li&gt;
&lt;li&gt;pgCC [/ 10.1,] 11.1&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1&lt;/li&gt;
&lt;li&gt;PathScale: 3.2, 4.0&lt;/li&gt;
&lt;li&gt;Visual Age C++ 10.1&lt;/li&gt;
&lt;li&gt;Clang from subversion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intel C++ Compiler: 10.1, 11.0, 11.1&lt;/li&gt;
&lt;li&gt;GCC: 4.0.1, 4.2.1, 4.4.4&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.4.4&lt;/li&gt;
&lt;li&gt;Clang from subversion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++: 7.1, 8.0, 9.0, 10.0&lt;/li&gt;
&lt;li&gt;Visual C++ with STLport: 9.0&lt;/li&gt;
&lt;li&gt;Visual C++, Windows Mobile 5, with STLport: 9.0&lt;/li&gt;
&lt;li&gt;GCC, mingw: 4.4.0, 4.5.1, 4.6.0&lt;/li&gt;
&lt;li&gt;GCC, mingw, C++0x mode: 4.5.1&lt;/li&gt;
&lt;li&gt;Borland: 6.1.3 (2009), 6.2.1 (2010)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AIX:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FreeBSD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 4.2.1, 64 bit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solaris:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sun C++: 5.10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, melpon, zakkas783, yak_ex&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.47.0 リリースノート -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/document/version/1_47_0.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:document/version/1_47_0.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost 1.47.0 リリースノート&lt;/h1&gt;
&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_47_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_47_0.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Chrono&lt;ul&gt;
&lt;li&gt;有用な時間ユーティリティ。&lt;/li&gt;
&lt;li&gt;作者：Vicente J. Botet Escribá&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Geometry&lt;ul&gt;
&lt;li&gt;幾何学ライブラリ。&lt;/li&gt;
&lt;li&gt;作者：Barend Gehrels, Bruno Lalande and Mateusz Loskot&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phoenix&lt;ul&gt;
&lt;li&gt;呼び出し側での小さな無名関数の定義と、より多くのもの。&lt;/li&gt;
&lt;li&gt;作者：Joel de Guzman, Dan Marsden and Thomas Heller&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ratio&lt;ul&gt;
&lt;li&gt;コンパイル時有理数ライブラリ。&lt;/li&gt;
&lt;li&gt;作者：Vicente J. Botet Escribá&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#accumulators&#34;&gt;Accumulators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#asio&#34;&gt;Asio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#config&#34;&gt;Config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#datetime&#34;&gt;DateTime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#dynamic-bitset&#34;&gt;Dynamic Bitset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#function&#34;&gt;Function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#foreach&#34;&gt;Foreach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#function-types&#34;&gt;Function Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#iostreams&#34;&gt;Iostreams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#iterator&#34;&gt;Iterator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#lexical-cast&#34;&gt;Lexical Cast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#logic&#34;&gt;Logic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#math&#34;&gt;Math&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#multi-index&#34;&gt;MultiIndex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#random&#34;&gt;Random&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#proto&#34;&gt;Proto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#range&#34;&gt;Range&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#spirit&#34;&gt;Spirit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#tokenizer&#34;&gt;Tokenizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#utility&#34;&gt;Utility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#uuid&#34;&gt;Uuid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#wave&#34;&gt;Wave&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ツール&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#boostbook&#34;&gt;BoostBook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#accumulators&#34; name=&#34;accumulators&#34;&gt;Accumulators&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新たな統計アキュムレータを追加 : &lt;code&gt;sum_kahan&lt;/code&gt;, &lt;code&gt;sum_of_weights_kahan&lt;/code&gt;, &lt;code&gt;sum_of_variates_kahan&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#asio&#34; name=&#34;asio&#34;&gt;Asio&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;シグナルハンドリング。&lt;code&gt;signal_set&lt;/code&gt;クラスを追加。&lt;/li&gt;
&lt;li&gt;非同期プログラムのデバッグ支援。&lt;code&gt;BOOST_ASIO_ENABLE_HANDLER_TRACKING&lt;/code&gt;をdefineすることで利用可能。&lt;/li&gt;
&lt;li&gt;ソケット&lt;code&gt;iostream&lt;/code&gt;に対するタイムアウト。&lt;code&gt;ip::tcp::iostream&lt;/code&gt;で&lt;code&gt;expires_at()&lt;/code&gt;もしくは&lt;code&gt;expires_from_now()&lt;/code&gt;を使用する。&lt;/li&gt;
&lt;li&gt;ソケット&lt;code&gt;iostream&lt;/code&gt;に&lt;code&gt;error()&lt;/code&gt;メンバ関数を追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;basic_deadline_timer::cancel_one()&lt;/code&gt;を追加。この関数は、タイマーに対する待機ハンドラを解除するのに使用できる。ハンドラはFIFO順に解除される。&lt;/li&gt;
&lt;li&gt;完了条件の&lt;code&gt;transfer_exactly()&lt;/code&gt;関数を追加。これは、バッファの合計サイズ(またはバッファのシーケンス)が大きい場合でも、指定されたバイト数を送受信するのに使用することができる。&lt;/li&gt;
&lt;li&gt;接続操作の合成。&lt;code&gt;connect()&lt;/code&gt;, &lt;code&gt;async_connect()&lt;/code&gt;フリー関数の追加。これらの操作は、ソケットが正常に接続されるまで、リスト内の各エンドポイントを試みる。IPv4とIPv6の両方で動作するTCPクライアントを作成するために便利。&lt;/li&gt;
&lt;li&gt;個々のバッファに加え、バッファシーケンスを動作するように&lt;code&gt;buffer_size()&lt;/code&gt;関数を拡張。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buffer_copy()&lt;/code&gt;関数を追加。個々のバッファと、バッファシーケンスの間で生のバイトデータをコピーするのに使用できる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read_at()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;write_at()&lt;/code&gt;のno throw版オーバーロードを追加。&lt;/li&gt;
&lt;li&gt;終了ハンドラが必要な型要件を満たさない場合のよりフレンドリーなコンパイルエラーを追加。C++0xの&lt;code&gt;static_assert&lt;/code&gt;が利用可能な環境で自動的にONになる(g++やVC10以降など)。&lt;code&gt;BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS&lt;/code&gt;をdefineすることでこのモードを無効にできる。&lt;/li&gt;
&lt;li&gt;SSL実装の書き直し。新たな実装は、高速コンパイル、パフォーマンスの大幅向上、カスタムメモリアロケートとハンドラの呼び出しをサポートする。証明書検証コールバックなどの新たなAPI関数が含まれていて、エラー報告機能の強化がある。新たな実装は、ほとんどの場合に古いソースに互換性がある。ただし、必要に応じて&lt;code&gt;BOOST_ASIO_ENABLE_OLD_SSL&lt;/code&gt;を定義することで以前の実装を使用する可能性がある(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3702&#34; target=&#34;_blank&#34;&gt;#3702&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3958&#34; target=&#34;_blank&#34;&gt;#3958&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;AsioのSSL機能を使うために、あなたのプログラムにひとつのソースファイル&lt;code&gt;boost/asio/ssl/impl/src.hpp&lt;/code&gt;を含める、というように、分割コンパイルサポートを変更した。&lt;/li&gt;
&lt;li&gt;SSL v2を明示的に無効化できるようにSSL実装を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5453&#34; target=&#34;_blank&#34;&gt;#5453&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_loopback()&lt;/code&gt;, &lt;code&gt;is_unspecified()&lt;/code&gt;, &lt;code&gt;is_multicast()&lt;/code&gt;関数を、&lt;code&gt;ip::address&lt;/code&gt;, &lt;code&gt;ip::address_v4&lt;/code&gt;, &lt;code&gt;ip::address_v6&lt;/code&gt;の全てで使用できるよう修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3939&#34; target=&#34;_blank&#34;&gt;#3939&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;ソケットやdescriptorでノンブロッキングの振る舞いを管理するための&lt;code&gt;non_blocking()&lt;/code&gt;関数を追加。&lt;code&gt;non_blocking_io&lt;/code&gt;という名前の&lt;code&gt;io_control&lt;/code&gt;コマンドは、この新たな関数によって非推奨(deprecated)となる。&lt;/li&gt;
&lt;li&gt;ソケットやdescriptorでノンブロッキングモードの基礎的なものをを管理するための、&lt;code&gt;native_non_blocking()&lt;/code&gt;関数を追加。この関数は、ソケットオブジェクトのユーザーに透過的な方法での非同期操作として、任意のノンブロッキングシステムコールのカプセル化を許可するものである。この関数は、ソケットやdescriptorの同期操作の挙動に影響を及ぼす。&lt;/li&gt;
&lt;li&gt;socket acceptorのための&lt;code&gt;io_control()&lt;/code&gt;メンバ関数を追加(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3297&#34; target=&#34;_blank&#34;&gt;#3297&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;posix descriptorに&lt;code&gt;release()&lt;/code&gt;メンバ関数を追加。この関数は、ネイティブなdescriptorの所有権を解放する(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3900&#34; target=&#34;_blank&#34;&gt;#3900&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;sequenced packet sockets(&lt;code&gt;SOCK_SEQPACKET&lt;/code&gt;)のサポートを追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;io_service&lt;/code&gt;が停止しているかどうかを判定するための&lt;code&gt;io_service::stopped()&lt;/code&gt;関数を追加(&lt;code&gt;reset()&lt;/code&gt;呼び出しは、&lt;code&gt;run()&lt;/code&gt;, &lt;code&gt;run_one()&lt;/code&gt;, &lt;code&gt;poll()&lt;/code&gt;, &lt;code&gt;poll_one()&lt;/code&gt;呼び出しの前に必要になる)。&lt;/li&gt;
&lt;li&gt;C++0x標準ライブラリとの整合性のために、&lt;code&gt;native_type&lt;/code&gt; typedefを非推奨とし、&lt;code&gt;native_handle_type&lt;/code&gt;を推奨とした。また、&lt;code&gt;native()&lt;/code&gt;メンバ関数を非推奨とし、&lt;code&gt;native_handle()&lt;/code&gt;メンバ関数を推奨とした。&lt;/li&gt;
&lt;li&gt;C++0xのmoveに対応。ソケット、シリアルポート、posix descriptor、Windowsハンドルのムーブコンストラクト、ムーブ代入に対応。&lt;/li&gt;
&lt;li&gt;(C++0xのmoveなどにより)ハンドラ関数オブジェクトのコピーを減らした。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt;システムコールのサポートを追加。&lt;code&gt;fork()&lt;/code&gt;を使用するプログラムは、&lt;code&gt;io_service.notify_fork()&lt;/code&gt;を適切なタイミングで呼び出す必要がある。この機能の2つのサンプルを追加した(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3238&#34; target=&#34;_blank&#34;&gt;#3238&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4162&#34; target=&#34;_blank&#34;&gt;#4162&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close()&lt;/code&gt;システムコールによって報告されたエラーのクリーンアップ。ほとんどのオペレーティングシステムは、&lt;code&gt;EWOULDBLOCK&lt;/code&gt;によって&lt;code&gt;close()&lt;/code&gt;が失敗するが、それはブロッキングモードを設定して呼び出しを再起動していない場合に起こる。その他のエラーの場合には、descriptorは閉じられると想定する(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3307&#34; target=&#34;_blank&#34;&gt;#3307&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;asio::buffer()&lt;/code&gt;関数に、&lt;code&gt;std::array&lt;/code&gt;のオーバーロードを追加。&lt;/li&gt;
&lt;li&gt;その実装がBoostと同等以上である場合に、C++0x標準ライブラリの&lt;code&gt;array&lt;/code&gt;, &lt;code&gt;shared_ptr&lt;/code&gt;, &lt;code&gt;weak_ptr&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;を使用するよう内部実装を修正。&lt;/li&gt;
&lt;li&gt;C++0x可変引数テンプレートが利用可能である場合に、Boost.Preprocessorによるオーバーロードの代わりにそちらの実装を使用するようにした。&lt;/li&gt;
&lt;li&gt;例外の&lt;code&gt;what()&lt;/code&gt;メンバ関数で返されるメッセージに、関数名を含めるようにした。&lt;/li&gt;
&lt;li&gt;MinGWでの未初期化変数警告を修正。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutdown_service()&lt;/code&gt;メンバ関数を&lt;code&gt;private&lt;/code&gt;にした。&lt;/li&gt;
&lt;li&gt;ソケットオプション関数のテストを追加。&lt;/li&gt;
&lt;li&gt;Boost.Asioの例でBoost.Threadを使用しないようにした。&lt;/li&gt;
&lt;li&gt;IPv4とIPv6のための、OSが提供するマクロへの依存をやめた(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3741&#34; target=&#34;_blank&#34;&gt;#3741&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip::basic_endpoint&amp;lt;&amp;gt;&lt;/code&gt;(と同じく&lt;code&gt;ip::tcp::endpointとip::udp::endpoint&lt;/code&gt;も)のサイズを小さくした。&lt;/li&gt;
&lt;li&gt;任意のソケットやdescriptorが、&lt;code&gt;dup()&lt;/code&gt;を持っている場合に&lt;code&gt;assign()&lt;/code&gt;を使用するようリアクターのバックエンドを変更し、リアクターの明示的な要件から削除(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4971&#34; target=&#34;_blank&#34;&gt;#4971&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;非推奨だったメンバ関数&lt;code&gt;io_service()&lt;/code&gt;を削除した。&lt;code&gt;get_io_service()&lt;/code&gt;を使用するべきである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip::tcp&lt;/code&gt;, &lt;code&gt;ip::udp&lt;/code&gt;, &lt;code&gt;ip::icmp&lt;/code&gt;クラスから、非推奨だったtypedefである&lt;code&gt;resolver_query&lt;/code&gt;, &lt;code&gt;resolver_iterator&lt;/code&gt;を削除した。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buffers_iterator&amp;lt;&amp;gt;&lt;/code&gt;と&lt;code&gt;ip::basic_resolver_iterator&lt;/code&gt;の&lt;code&gt;value_type&lt;/code&gt;を非&lt;code&gt;const&lt;/code&gt; &lt;code&gt;byte&lt;/code&gt;型に修正。&lt;/li&gt;
&lt;li&gt;g++の-Wshadowコンパイルオプションによる警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3905&#34; target=&#34;_blank&#34;&gt;#3905&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;一部の環境でのコンパイラ警告を抑制するために、&lt;code&gt;FIONBIO&lt;/code&gt;定数を&lt;code&gt;int&lt;/code&gt;に明示的にキャストするようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5128&#34; target=&#34;_blank&#34;&gt;#5128&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;acceptorの例で、エラーを許容するように修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5124&#34; target=&#34;_blank&#34;&gt;#5124&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tick_count_timer&lt;/code&gt;の例での間違いを修正。&lt;code&gt;signed&lt;/code&gt;な&lt;code&gt;duration&lt;/code&gt;を作るようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5418&#34; target=&#34;_blank&#34;&gt;#5418&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#config&#34; name=&#34;config&#34;&gt;Config&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;マクロの名称変更(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1988&#34; target=&#34;_blank&#34;&gt;#1988&lt;/a&gt;)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BOOST_NO_THREADEX&lt;/code&gt; -&amp;gt; &lt;code&gt;BOOST_HAS_THREADEX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_NO_GETSYSTEMTIMEASFILETIME&lt;/code&gt; -&amp;gt; &lt;code&gt;BOOST_HAS_GETSYSTEMTIMEASFILETIME&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#datetime&#34; name=&#34;datetime&#34;&gt;DateTime&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;サンプルの間違いを修正。typoなど(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4920&#34; target=&#34;_blank&#34;&gt;#4920&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;ドキュメントにあるサンプルの変数名、関数名などの間違いを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3651&#34; target=&#34;_blank&#34;&gt;#3651&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;サンプルの間違いを修正。&lt;code&gt;end_of_month_day()&lt;/code&gt; -&amp;gt; &lt;code&gt;end_of_month()&lt;/code&gt;(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4845&#34; target=&#34;_blank&#34;&gt;#4845&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;OpenVMSの64ビットプラットフォームサポートを追加(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4475&#34; target=&#34;_blank&#34;&gt;#4475&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GCC 4.3での&lt;code&gt;time_facet&lt;/code&gt;の警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4952&#34; target=&#34;_blank&#34;&gt;#4952&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time_serialize&lt;/code&gt;で、依存名に対して&lt;code&gt;typename&lt;/code&gt;が付いていなかったのを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5345&#34; target=&#34;_blank&#34;&gt;#5345&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;clangでの、二重カッコによる警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5250&#34; target=&#34;_blank&#34;&gt;#5250&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;valgrindプラットフォームでの警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4798&#34; target=&#34;_blank&#34;&gt;#4798&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;オーストラリアでの、夏時間の開始と終了が間違っていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4754&#34; target=&#34;_blank&#34;&gt;#4754&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Australia/Euclaのタイムゾーンデータベースが間違っていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4411&#34; target=&#34;_blank&#34;&gt;#4411&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;SCCキーワードのエスケープに関するバグ修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5126&#34; target=&#34;_blank&#34;&gt;#5126&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;タイムゾーンデータベースの、ファイルからの読み込みをサポート(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2475&#34; target=&#34;_blank&#34;&gt;#2475&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;グローバルロケールを使用した場合に、&lt;code&gt;ymd_formatter&lt;/code&gt;で年が&lt;code&gt;2,008&lt;/code&gt;のようにフォーマットされる問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1674&#34; target=&#34;_blank&#34;&gt;#1674&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#dynamic-bitset&#34; name=&#34;dynamic-bitset&#34;&gt;Dynamic Bitset&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GCCで&lt;code&gt;-Wshadow&lt;/code&gt;コンパイラオプションを付けた際に出る警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5439&#34; target=&#34;_blank&#34;&gt;#5439&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#function&#34; name=&#34;function&#34;&gt;Function&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GCCで&lt;code&gt;-Wold-style-cast&lt;/code&gt;コンパイラオプションを付けた際に出る警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3410&#34; target=&#34;_blank&#34;&gt;#3410&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;MSVCでの未使用変数警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3618&#34; target=&#34;_blank&#34;&gt;#3618&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Visual Age C++の古いバージョンのためのworkaroundに、新しいバージョン(&lt;code&gt;__IBMCPP__ &amp;gt;= 800&lt;/code&gt;)が適用されないよう修正。新しいバージョンでは、&lt;code&gt;boost::function&lt;/code&gt;の引数が11個以上使用できる(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3912&#34; target=&#34;_blank&#34;&gt;#3912&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;VC10で、&lt;code&gt;function&lt;/code&gt;内部で&lt;code&gt;boost::mem_fn&lt;/code&gt;が呼ばれるべきところを、ADLによって&lt;code&gt;std::mem_fn&lt;/code&gt;が探索されコンパイルエラーになっていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4073&#34; target=&#34;_blank&#34;&gt;#4073&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::function&lt;/code&gt;に、関数の参照を持たせるために&lt;code&gt;boost::ref&lt;/code&gt;でラップして渡すとコンパイルエラーになる問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4325&#34; target=&#34;_blank&#34;&gt;#4325&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::function&lt;/code&gt;内部の&lt;code&gt;stored_vtable&lt;/code&gt;が非&lt;code&gt;const&lt;/code&gt;のために書き込み可能メモリに配置されてしまう問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4717&#34; target=&#34;_blank&#34;&gt;#4717&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;関数呼び出し演算子で、&lt;code&gt;inline&lt;/code&gt;キーワードの書く場所を間違えていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4765&#34; target=&#34;_blank&#34;&gt;#4765&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#foreach&#34; name=&#34;foreach&#34;&gt;Foreach&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++0xムーブセマンティクスに対応。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#function-types&#34; name=&#34;function-types&#34;&gt;Function Types&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;デフォルトビルドにおいてプリプロセス済みの &lt;code&gt;function_types&lt;/code&gt; ヘッダを作成しようとし、waveの実行ファイルが要求される問題をデフォルトビルド対象外とすることで修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1653&#34; target=&#34;_blank&#34;&gt;#1653&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function_types&lt;/code&gt;/&lt;code&gt;components&lt;/code&gt; のtypoを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3162&#34; target=&#34;_blank&#34;&gt;#3162&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#graph&#34; name=&#34;graph&#34;&gt;Graph&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;非推奨な関数であった&lt;code&gt;kolmogorov_max_flow&lt;/code&gt;を削除した。以降は&lt;code&gt;boykov_kolmogorov_max_flow&lt;/code&gt;を使う。&lt;/li&gt;
&lt;li&gt;Boost.Type_Traitsに同等の機能があるため&lt;code&gt;&amp;lt;boost/graph/detail/is_same.hpp&amp;gt;&lt;/code&gt;ヘッダを削除した&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#iostreams&#34; name=&#34;iostreams&#34;&gt;Iostreams&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Filesystem V3の&lt;code&gt;path&lt;/code&gt;をサポート(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4485&#34; target=&#34;_blank&#34;&gt;#4485&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chain&lt;/code&gt;でのメモリリークを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4922&#34; target=&#34;_blank&#34;&gt;#4492&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#iterator&#34; name=&#34;iterator&#34;&gt;Iterator&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function_input_iterator&lt;/code&gt;追加 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2893&#34; target=&#34;_blank&#34;&gt;#2893&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;&lt;code&gt;transform_iterator&lt;/code&gt;の戻り型の推論に&lt;code&gt;boost::result_of&lt;/code&gt;を使うよう修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1427&#34; target=&#34;_blank&#34;&gt;#1427&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zip_iterator&lt;/code&gt;が&lt;code&gt;BidirectionalInputIterator&lt;/code&gt;を&lt;code&gt;zip&lt;/code&gt;できない問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1517&#34; target=&#34;_blank&#34;&gt;#1517&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/iterator.hpp&lt;/code&gt;のコメントのtypoを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3434&#34; target=&#34;_blank&#34;&gt;#3434&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Lexical Cast&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Source&lt;/code&gt;と&lt;code&gt;Target&lt;/code&gt;型の特殊化を追加し、パフォーマンスとメモリ効率を改善した&lt;ul&gt;
&lt;li&gt;&lt;code&gt;signed char&lt;/code&gt;と&lt;code&gt;unsigned char&lt;/code&gt;の特殊化 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5564&#34; target=&#34;_blank&#34;&gt;#5564&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;整数型 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5417&#34; target=&#34;_blank&#34;&gt;#5417&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Source&lt;/code&gt;と&lt;code&gt;Target&lt;/code&gt;が同じ型の場合 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4397&#34; target=&#34;_blank&#34;&gt;#4397&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Source&lt;/code&gt;から&lt;code&gt;Target&lt;/code&gt;を直接コンストラクト可能な場合 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5350&#34; target=&#34;_blank&#34;&gt;#5350&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;整数型のグルーピングが0の場合 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5576&#34; target=&#34;_blank&#34;&gt;#5576&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ドキュメント更新&lt;ul&gt;
&lt;li&gt;パフォーマンスセクションの追加 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5576&#34; target=&#34;_blank&#34;&gt;#5576&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;FAQに&lt;code&gt;lexical_cast&amp;lt;unsigned int&amp;gt;(&#34;-1&#34;)&lt;/code&gt;が例外を送出する件について追加 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5494&#34; target=&#34;_blank&#34;&gt;#5494&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#logic&#34; name=&#34;logic&#34;&gt;Logic&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logic/tribool&lt;/code&gt;のGCC Shadow errorを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3093&#34; target=&#34;_blank&#34;&gt;#3093&lt;/a&gt;)   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_TRIBOOL_THIRD_STATE&lt;/code&gt;の未使用変数警告を抑制 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3600&#34; target=&#34;_blank&#34;&gt;#3600&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#math&#34; name=&#34;math&#34;&gt;Math&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;nonfinite facetを容易に追加するために、&lt;code&gt;changesign&lt;/code&gt;関数を&lt;code&gt;sign.hpp&lt;/code&gt;に追加した&lt;/li&gt;
&lt;li&gt;Johan Rade氏によるnonfinite facetと、そのテスト、C99形式の無限大と&lt;code&gt;NaN&lt;/code&gt;での利用例、およびドキュメントの追加&lt;/li&gt;
&lt;li&gt;Johan Rade氏による&lt;code&gt;changesign&lt;/code&gt;のテストとドキュメントの追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#msm&#34; name=&#34;msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バックエンドに&lt;code&gt;stop()&lt;/code&gt;メソッドを追加&lt;/li&gt;
&lt;li&gt;Boost.Phoenix ファンクタのeUML表現を部分的にサポートした&lt;/li&gt;
&lt;li&gt;ステートスイッチングが発生した際に選択する可能性を考慮&lt;/li&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;Trac &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5117&#34; target=&#34;_blank&#34;&gt;#5117&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5253&#34; target=&#34;_blank&#34;&gt;#5253&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5533&#34; target=&#34;_blank&#34;&gt;#5533&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5573&#34; target=&#34;_blank&#34;&gt;#5573&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;gccで未使用変数の警告がでる問題を修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;favor_compile_time&lt;/code&gt; バックエンドポリシーをさらに統合した&lt;/li&gt;
&lt;li&gt;ステート構築とeUMLのバグを修正&lt;/li&gt;
&lt;li&gt;eUML イヴェントとステートマクロの誤りを修正&lt;/li&gt;
&lt;li&gt;直接入力のステートの&lt;code&gt;on_entry&lt;/code&gt;アクションに間違ったイヴェントタイプが渡される問題を修正&lt;/li&gt;
&lt;li&gt;コードサンプルを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#multi-index&#34; name=&#34;multi-index&#34;&gt;MultiIndex&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Refに関連する&lt;code&gt;composite_key_compare&lt;/code&gt;のADL問題を修正した&lt;/li&gt;
&lt;li&gt;メンテナンス上の修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#random&#34; name=&#34;random&#34;&gt;Random&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;新たな標準(C++0x)に同期&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多くの分布を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chi_squared_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;negative_binomial_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fisher_f_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;student_t_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weibull_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extreme_value_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discrete_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;piecewise_constant_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;piecewise_liear_distribution&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;名称変更：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;uniform_int&lt;/code&gt; → &lt;code&gt;uniform_int_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform_real&lt;/code&gt; → &lt;code&gt;uniform_real_distribution&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全ての分布クラスに以下のメンバを追加：&lt;code&gt;param_type&lt;/code&gt;, &lt;code&gt;param&lt;/code&gt;, ストリーム演算子, 比較演算子, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分布クラスを、&lt;code&gt;variate_generator&lt;/code&gt;を通さずに直接ジェネレータを使用できるようにした。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geometric_distribution&lt;/code&gt;と&lt;code&gt;lognormal_distribution&lt;/code&gt;のパラメータの意味を変えた。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gamma_distribution&lt;/code&gt;に第2パラメータを追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;seed_seq&lt;/code&gt;を追加し、対応するコンストラクタと&lt;code&gt;seed&lt;/code&gt;オーバーロードジェネレータを追加。- &lt;code&gt;generate_canonical&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;エンジンテンプレートの名称変更。たとえば、&lt;code&gt;mersenne_twister&lt;/code&gt;は&lt;code&gt;mersenne_twister_engine&lt;/code&gt;となる。&lt;/li&gt;
&lt;li&gt;新たなエンジンアダプタ&lt;code&gt;independent_bits_engine&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;新たな事前定義&lt;code&gt;typedef&lt;/code&gt;を追加：&lt;code&gt;mt19937_64&lt;/code&gt;, &lt;code&gt;ranlux[24|48][_base]&lt;/code&gt;, &lt;code&gt;knuth_b&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;シードアルゴリズムを更新。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discard&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;全ての定義済みエンジンで、符合あり型の代わりに符号なし型を使用するようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全てのケースで剰余演算が実装されていなかったので、&lt;code&gt;linear_congruential_engine&lt;/code&gt;が&lt;code&gt;assert&lt;/code&gt;する可能性があった。&lt;code&gt;shuffle_output&lt;/code&gt;は整数オーバーフローを起こす可能性があったため、今は&lt;code&gt;shuffle_order_engine&lt;/code&gt;を呼ぶようにした。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform_small_int&lt;/code&gt;は現在、ドキュメント通りに動作する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;その他変更&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binomial_distribution&lt;/code&gt;と&lt;code&gt;poisson_distribution&lt;/code&gt;のための新たな効率的なアルゴリズム。&lt;/li&gt;
&lt;li&gt;全ての機能を&lt;code&gt;boost::random&lt;/code&gt;名前空間に移動。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;下位互換性の問題&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;シードアルゴリズムが変更した。これは標準との互換性のために避けられなかった。既存のいくつかのアルゴリズムに矛盾があったことは言うまでもない。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;によるシード：&lt;code&gt;lagged_fibonacci&lt;/code&gt;と&lt;code&gt;subtract_with_carry&lt;/code&gt;(つまり&lt;code&gt;ranlux&lt;/code&gt;)を除くほとんどのジェネレータを変更する必要がある。&lt;/li&gt;
&lt;li&gt;別のジェネレータとジェネレータのシード：これは全てのジェネレータモデル&lt;code&gt;SeedSeq&lt;/code&gt;を作ることで有効になっている。したがって、非Boost.RandomジェネレータでBoost.Randomジェネレータのシードを使用した場合、それはコンパイルに成功しない。アルゴリズムが変更されたため、このシード処理のメソッドを使用したコードが異なる値を生成する。&lt;/li&gt;
&lt;li&gt;イテレータの組からシードを生成する：全てではないがいくつかの場所で、暗黙的に要素が32ビット整数であることを仮定する。この要件を追加し、それに応じてアルゴリズムを更新した。ジェネレータの&lt;code&gt;value_type&lt;/code&gt;が32ビット以上の場合には、動作を変更する必要がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;名称変更&lt;ul&gt;
&lt;li&gt;クラス名が変更されたものには、古い名前によるラッパーを用意した。また、名前空間が移動された全てのもののために、&lt;code&gt;boost&lt;/code&gt;名前空間での&lt;code&gt;using&lt;/code&gt;宣言を行うようにした。&lt;/li&gt;
&lt;li&gt;分布クラスのいくつかのアクセッサ名が変更された。古いものと新しいもの両方を使用できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geometric_distribution&lt;/code&gt;と&lt;code&gt;lognormal_distribution&lt;/code&gt;：実行時に異なる動作をするようになった。これまでの動作をする&lt;code&gt;boost::geometric_distribution&lt;/code&gt;と&lt;code&gt;boost::lognormal_distribution&lt;/code&gt;、新たな動作をする&lt;code&gt;boost::random::geometric_distribution&lt;/code&gt;と&lt;code&gt;boost::random::lognormal_distribution&lt;/code&gt;を提供する。&lt;/li&gt;
&lt;li&gt;ストリーミング：&lt;code&gt;gamma_distribution&lt;/code&gt;は新たなパラメータを持っているため、古いバージョンでストリーム演算子を使用して出力されたテキストを新しいバージョンで読み込むことはできない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;variate_generator&lt;/code&gt;は現在、単なるラッパーである。ジェネレータの結果が分布の結果型と一致することを期待しているコードは動作しなくなる。これはBoost.Randomが提供する分布の問題ではない。&lt;/li&gt;
&lt;li&gt;戻り値の型：いくつかのジェネレータの&lt;code&gt;result_type&lt;/code&gt;を変更した。標準に合わせて、いくつかの符号あり型は符号なし型に変更された。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;has_fixed_range&lt;/code&gt;：これは常に&lt;code&gt;false&lt;/code&gt;を返し、非常に有用ではあるが過度に複雑だった。最初に&lt;code&gt;has_fixed_range&lt;/code&gt;をチェックせずに&lt;code&gt;const_min&lt;/code&gt;, &lt;code&gt;const_max&lt;/code&gt;を使用していたのがはじめから間違いだった。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#proto&#34; name=&#34;proto&#34;&gt;Proto&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;コンパイルタイム改善のためにプリプロセス済みのマクロ(Pre-preprocessed)を用意した&lt;/li&gt;
&lt;li&gt;デフォルトのプリプロセッサ制限を引き上げた&lt;ul&gt;
&lt;li&gt;式の引数の数(&lt;code&gt;BOOST_PROTO_MAX_ARITY&lt;/code&gt;)を5から10に増やした&lt;/li&gt;
&lt;li&gt;関数呼び出しの引数の数(&lt;code&gt;BOOST_PROTO_MAX_FUNCTION_CALL_ARITY&lt;/code&gt;)を5から10に増やした&lt;/li&gt;
&lt;li&gt;論理演算子の引数の数(&lt;code&gt;BOOST_PROTO_MAX_LOGICAL_ARITY&lt;/code&gt;)を8から10に増やした&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不要な&lt;code&gt;proto::expr&lt;/code&gt;のインスタンス化を避けるために&lt;code&gt;proto::basic_expr&lt;/code&gt;をさらに統合した&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#range&#34; name=&#34;range&#34;&gt;Range&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;破壊的変更&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;irange&lt;/code&gt;で、&lt;code&gt;step&lt;/code&gt;が2以上のときの終端の計算が間違っていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5544&#34; target=&#34;_blank&#34;&gt;#5544&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#spirit&#34; name=&#34;spirit&#34;&gt;Spirit&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Spirit V2.5&lt;/p&gt;
&lt;p&gt;Boost 1.47.0でリリースされるBoost.Phoenix V3に対応した。&lt;/p&gt;
&lt;p&gt;これによってユーザーコードに影響を与えることはない。&lt;/p&gt;
&lt;p&gt;Boost.Phoenix V3を有効にするには、Spiritのヘッダをインクルードする前に以下のプリプロセッサ定数を定義する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#define BOOST_SPIRIT_USE_PHOENIX_V3 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Qi or Karmaの新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ジェネリックで、階層的で、抽象構文木を表すことができる動的なデータ構造であるutreeを追加。これはSpirit.QiとSpirit.Karmaに統合される。これはほぼすべての構文を解析の属性として渡すことができる。同時に、その属性を使用して出力を生成できる。&lt;/li&gt;
&lt;li&gt;新たなマクロ&lt;code&gt;BOOST_SPIRIT_TERMINAL_NAME&lt;/code&gt;は、2つのパラメータをとる(ターミナルの名前と型)。ターミナルの名前のみを引数にとる&lt;code&gt;BOOST_SPIRIT_TERMINAL&lt;/code&gt;マクロもあり、これは「ターミナル名 + &lt;code&gt;_type&lt;/code&gt;」という型名を生成する。&lt;code&gt;int_&lt;/code&gt;のような名前の場合には&lt;code&gt;int__type&lt;/code&gt;のような、C++言語でシステムに予約されているダブルアンダーバーを含む型が生成されるので注意。&lt;/li&gt;
&lt;li&gt;数値パーサーで2..10と16の基数を許可。&lt;/li&gt;
&lt;li&gt;プレースホルダー &lt;code&gt;_val&lt;/code&gt; が、トップレベルセマンティックルールの右辺で使用できるようになった。以下がその例である：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
BOOST_TEST(test_attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;456&#34;&lt;/span&gt;, int_[_val &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; _1], i) &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;456&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この場合、&lt;code&gt;parse()&lt;/code&gt; または &lt;code&gt;phrase_parse()&lt;/code&gt; 関数に渡された属性の値 &lt;code&gt;_val&lt;/code&gt; を指す。これはSpirit.Karmaでも同様に可能となる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;123&lt;/span&gt;;
BOOST_TEST(test(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123&#34;&lt;/span&gt;, int_[_1 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; _val], i));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この変更により&lt;code&gt;_val&lt;/code&gt;プレースホルダーがどこでも使えるようになり、セマンティックアクションのルールが統一される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spirit.Karmaに、2..36基数のunsigned numericジェネレータのサポートを追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Qi or Karmaのバグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int_(10)&lt;/code&gt;のような整数リテラルのパース失敗時に入力を消費してしまう問題を修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mmap_file_iterator&lt;/code&gt;の初期化に失敗する問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5246&#34; target=&#34;_blank&#34;&gt;#5246&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;karma::real_policies&lt;/code&gt;で&lt;code&gt;const&lt;/code&gt;浮動小数点数を使用する際の&lt;code&gt;const&lt;/code&gt; correctness問題を修正。パッチとテストを送付してくれたJeroen Habraken(a.k.a VeXocide)に感謝する。&lt;/li&gt;
&lt;li&gt;Spirit.Qi &lt;code&gt;attr(attrib)&lt;/code&gt;パーサー, Spirit.Qi &lt;code&gt;symbols&amp;lt;&amp;gt;&lt;/code&gt;パーサー, Spirit.Karma &lt;code&gt;symbols&amp;lt;&amp;gt;&lt;/code&gt;ジェネレータでのコンテナ属性のプロパティハンドルを修正。これはBoost V1.46.1で壊れていた(この問題を報告してくれたAaron Graham, Joerg Beckerに感謝する)。&lt;/li&gt;
&lt;li&gt;streamパーサーコンポーネントが成功したときに、もとになる入力ストリームのイテレータを正しく調整するようstream パーサーを修正。Stackoverflowで問題を報告してくれたBrian O’Kennedyに感謝する。&lt;/li&gt;
&lt;li&gt;アダプトされたADTを使用するときにKarma数値ジェネレータが失敗する問題を修正(問題を報告してくれたColin Rundelに感謝する)。
破壊的変更&lt;/li&gt;
&lt;li&gt;Spirit.Qi &lt;code&gt;repeat&lt;/code&gt;ディレクティブが失敗した場合に値を残し、その属性のコミット／ロールバックのセマンティクスを実装した。同様のコンポーネントが矛盾している動作を削除した。この機能に依存する既存のコードは破壊される。コードを修正する方法は、Spirit.Qi &lt;code&gt;hold&lt;/code&gt; ディレクティブを参照。&lt;/li&gt;
&lt;li&gt;コンパイル時間を大きく低下させていた定義済みターミナルのインスタンス化を防ぐために、&lt;code&gt;BOOST_SPIRIT_NO_PREDEFINED_TERMINALS&lt;/code&gt;プリプロセッサマクロを追加した。&lt;code&gt;BOOST_SPIRIT_NO_PREDEFINED_TERMINALS&lt;/code&gt; が定義されている場合は、ユーザーは必要なターミナルをインスタンス化する。したがって、&lt;code&gt;using qi::uint_&lt;/code&gt;の代わりに&lt;code&gt;qi::uint_type uint_&lt;/code&gt;のように書く。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Lexの新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lex::char_&lt;/code&gt;と&lt;code&gt;lex::string&lt;/code&gt;を使用して、トークンの定義を作成中にトークンの&lt;code&gt;id&lt;/code&gt;を指定することを可能にした。両方のプリミティブはこの定義から生成されたトークンの要求されたトークンIDとして解釈され、2番目のパラメータを受け付けるようになった。&lt;/li&gt;
&lt;li&gt;新たなトークン型&lt;code&gt;lex::lexertl::position_token&amp;lt;&amp;gt;&lt;/code&gt;を追加。これは本質的には、既存の&lt;code&gt;lex::lexertl::token&amp;lt;&amp;gt;&lt;/code&gt;によるプラグイン互換である。基になる入力シーケンスとして、&lt;code&gt;iterator_range&lt;/code&gt;を指すイテレータのペアを格納する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Lexのバグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アクションに添付されたトークン定義のすべての状態(状態名 &lt;code&gt;&#34;*&#34;&lt;/code&gt; を使用する)を関連付けて問題を修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Making Stuff Work&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性がコンテナの場合(&lt;code&gt;traits::is_container&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;を返す属性)に、古いカスタマイズポイント&lt;code&gt;traits::extract_from&lt;/code&gt;の代わりに呼び出される、Spirit.Karmaカスタマイズポイント&lt;code&gt;traits::extract_from_container&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hold_any&lt;/code&gt;型がテンプレート引数をとるようにした：&lt;code&gt;basic_hold_any&amp;lt;Char&amp;gt;&lt;/code&gt;。&lt;code&gt;Char&lt;/code&gt;は、ストリーム演算子(&lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;と&lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;)で使用される。&lt;code&gt;hold_any&lt;/code&gt;は、&lt;code&gt;typedef basic_hold_any&amp;lt;char&amp;gt; hold_any&lt;/code&gt;と定義される。&lt;/li&gt;
&lt;li&gt;セマンティックアクションで属性の互換性がサポートされた。これは破壊的な変更だが、&lt;code&gt;#define BOOST_SPIRIT_ACTIONS_ALLOW_ATTR_COMPAT&lt;/code&gt;で新しい動作を定義する必要がある。規定ではこれまでの動作である。&lt;/li&gt;
&lt;li&gt;属性互換性の選択肢をサポート。&lt;/li&gt;
&lt;li&gt;シーケンス&amp;amp;コンテナコンポーネント(list, Kleene, Plus, repeat)のコンテナ属性のための属性ハンドリングが書き直された。これによって多くの場合に予測可能な動作をするようになった。Thomas Taylor, Richard Crossley, Semen, Adalberto Casteloそして問題を報告し、支援してくれた方々に感謝する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#tokenizer&#34; name=&#34;tokenizer&#34;&gt;Tokenizer&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio で&lt;code&gt;/W4&lt;/code&gt;にてビルドすると、warning C4127(条件文が定数)がでる問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4649&#34; target=&#34;_blank&#34;&gt;#4699&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#utility&#34; name=&#34;utility&#34;&gt;Utility&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio 2010でwarning number 4284がなくなったことによるwarningの抑制(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4432&#34; target=&#34;_blank&#34;&gt;#4432&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#uuid&#34; name=&#34;uuid&#34;&gt;Uuid&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;例外を無効にした場合に&lt;code&gt;string_generator.hpp&lt;/code&gt;がコンパイルエラーになる問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5570&#34; target=&#34;_blank&#34;&gt;#5570&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;VC8での暗黙の型変換警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4601&#34; target=&#34;_blank&#34;&gt;#4601&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GHSコンパイラ(Green Hills Compiler)でこのライブラリが動作するようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4991&#34; target=&#34;_blank&#34;&gt;#4991&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;論理演算子周りの警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5145&#34; target=&#34;_blank&#34;&gt;#5145&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;uuidのテストに、まだリリースされていない&lt;code&gt;lightweight_test_ex.hpp&lt;/code&gt;を使用していたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5235&#34; target=&#34;_blank&#34;&gt;#5235&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#wave&#34; name=&#34;wave&#34;&gt;Wave&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;V2.3.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma wave option()&lt;/code&gt; のプリプロセス後、連続した文字列リテラルを一つにまとめるようにした。&lt;/li&gt;
&lt;li&gt;空白文字のハンドリングを修正し、そのテストを追加 (&lt;code&gt;t_9_020.cpp&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;新しいプリプロセスフック &lt;code&gt;locate_include_file&lt;/code&gt; を追加。インクルードするファイルの決定方法をカスタマイズできる。&lt;/li&gt;
&lt;li&gt;Wave コマンドに新しいオプション &lt;code&gt;--noexpand&lt;/code&gt;/&lt;code&gt;-N&lt;/code&gt; を追加。指定した名前のマクロ（オブジェクト形式でも関数形式でもOK）の展開を抑制できる。このオプションは、出力結果中のマクロ全部が実行されないだけでなく、Wave自身からもその存在が消されるので、よく考えて使うべきである。もし展開を抑制されたマクロがあとでどこかの &lt;code&gt;#ifdef&lt;/code&gt; に影響がある場合、予期しない結果を引き起こす可能性がある。&lt;/li&gt;
&lt;li&gt;Wave コマンドの対話モードで、定義された全マクロをコマンドラインに出すのを修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5554&#34; target=&#34;_blank&#34;&gt;#5554&lt;/a&gt; の修正 (wave slex parser が &lt;code&gt;eol&lt;/code&gt; の前に &lt;code&gt;eof&lt;/code&gt; を見つけると最終行を処理しない問題)。&lt;/li&gt;
&lt;li&gt;コンパイル時のオプション設定に、&lt;code&gt;BOOST_WAVE_WCHAR_T_SIGNEDNESS&lt;/code&gt; を追加。これには &lt;code&gt;BOOST_WAVE_WCHAR_T_AUTOSELECT&lt;/code&gt;, &lt;code&gt;BOOST_WAVE_WCHAR_T_FORCE_SIGNED&lt;/code&gt;, または &lt;code&gt;BOOST_WAVE_WCHAR_T_FORCE_UNSIGNED&lt;/code&gt; を指定できる。デフォルトは auto select.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#pragma&lt;/code&gt; のオプション (output) を付けて実行した Wave コマンドがすぐに終了した場合、上書きせずに追記してしまう問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5569&#34; target=&#34;_blank&#34;&gt;#5569&lt;/a&gt; を修正 (slex の CONTLINE が LF で改行するファイルでしか動かない)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#boostbook&#34; name=&#34;boostbook&#34;&gt;BoostBook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;doxygenタグをハンドル : &lt;code&gt;\see&lt;/code&gt;, &lt;code&gt;tparam&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; (クラスのみ)&lt;/li&gt;
&lt;li&gt;クラスと関数のメモをサポート&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#quickbook&#34; name=&#34;quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;見出しの一貫性あるID生成&lt;/li&gt;
&lt;li&gt;WindowsでのUnicodeサポートを改善&lt;/li&gt;
&lt;li&gt;移植性のないWindowsのパスで警告を出力するようにした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[br]&lt;/code&gt;の非推奨を取りやめ&lt;/li&gt;
&lt;li&gt;copyright属性で、日付の範囲と、カンマ区切りされた節をサポート&lt;/li&gt;
&lt;li&gt;簡単なマークアップ(例えば&lt;strong&gt;bold&lt;/strong&gt;)のために、区切り文字のチェック機能を改善&lt;/li&gt;
&lt;li&gt;コードスニペット内でのコメントをそのまま使用するようにした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__FILENAME__&lt;/code&gt;マクロが相対パスを生成するようにした&lt;/li&gt;
&lt;li&gt;コード内でエスケープによる強調表示を許可&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要テストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LLVM Clang 2.8&lt;/li&gt;
&lt;li&gt;GCC: 3.4.6, 4.2.4, 4.3.4, 4.3.5, 4.4.1, 4.4.3, 4.4.5, 4.5.1, 4.5.2, 4.6.0, 4.6.1&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.3.4, 4.4.3, 4.5.2&lt;/li&gt;
&lt;li&gt;Intel 12.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apple Clang 2.1&lt;/li&gt;
&lt;li&gt;Intel 11.1&lt;/li&gt;
&lt;li&gt;GCC: 4.2.1, 4.4.4&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.4.4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++ 7.1, 9.0, 10.0&lt;/li&gt;
&lt;li&gt;GCC, mingw: 4.4.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FreeBSD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 4.2.1, 64 bit&lt;/li&gt;
&lt;li&gt;QNX:- QCC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加のテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clang from subversion, with GNU libstdc++.&lt;/li&gt;
&lt;li&gt;LLVM Clang 2.8&lt;/li&gt;
&lt;li&gt;GCC: 3.4.6, 4.2.4, 4.3.4, 4.3.5, 4.4.3, 4.4.5, 4.5.1, 4.5.2, 4.6.0, 4.6.1&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.3.4, 4.4.3, 4.5.2&lt;/li&gt;
&lt;li&gt;pgCC: 11.2&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1, 12.0&lt;/li&gt;
&lt;li&gt;PathScale: 3.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clang from subversion, with GNU libstdc++.&lt;/li&gt;
&lt;li&gt;Intel 11.1&lt;/li&gt;
&lt;li&gt;GCC: 4.4.4&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.4.4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++ 7.1, 9.0, 10.0&lt;/li&gt;
&lt;li&gt;Visual C++ with STLport: 9.0&lt;/li&gt;
&lt;li&gt;Visual C++, Windows Mobile 5, with STLport: 9.0&lt;/li&gt;
&lt;li&gt;GCC, mingw: 4.5.2&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode, mingw: 4.5.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AIX:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, zakkas783, digitalghost, yak_ex&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.勉強会 #13 仙台 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/study_meeting/study13.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:study_meeting/study13.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost.勉強会 #13 仙台&lt;/h1&gt;
&lt;h2&gt;開催日時&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2013/10/19(土) 10:30～&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;開催場所&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;宮城県仙台市内 戦災復興記念館 第2会議室&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;募集ページ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://partake.in/events/6d6339e0-95df-4275-ba00-5e5344cb84f3#&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 @仙台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://partake.in/events/e16749f6-bb06-45bf-8f15-09a0b2b82506#&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 @仙台 懇親会&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;主催&amp;amp;スタッフ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;主催者： 橋本達明(&lt;a href=&#34;https://twitter.com/chichimotsu&#34; target=&#34;_blank&#34;&gt;@chichimotsu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;タイムテーブル&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;時間&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;担当者&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10:00&lt;/td&gt;
&lt;td&gt;勉強会スタート&lt;/td&gt;
&lt;td&gt;@chichimotsu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10:00-10:15&lt;/td&gt;
&lt;td&gt;趣旨説明・タイムテーブル確認&lt;/td&gt;
&lt;td&gt;@chichimotsu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10:20-11:05&lt;/td&gt;
&lt;td&gt;Boost.Asioを使おう&lt;/td&gt;
&lt;td&gt;@chichimotsu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11:10-11:55&lt;/td&gt;
&lt;td&gt;Boost.Randomで乱数を学ぼう&lt;/td&gt;
&lt;td&gt;@cpp_akira&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12:00-13:00&lt;/td&gt;
&lt;td&gt;昼休憩&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13:00-13:45&lt;/td&gt;
&lt;td&gt;boost::multiprecisionに勝負を挑んだのち，オリジナル三角形分割手法の実装&lt;/td&gt;
&lt;td&gt;@oniprog&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13:50-14:35&lt;/td&gt;
&lt;td&gt;boost::signals2とboost::anyで作ったiPhoneアプリ『ういろう』&lt;/td&gt;
&lt;td&gt;@5mingame2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14:35-14:50&lt;/td&gt;
&lt;td&gt;休憩&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14:50-15:35&lt;/td&gt;
&lt;td&gt;並列アルゴリズムライブラリThrustについて&lt;/td&gt;
&lt;td&gt;@krustf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15:40-16:35&lt;/td&gt;
&lt;td&gt;Wandbox を支える技術&lt;/td&gt;
&lt;td&gt;@melponn&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16:40-16:55&lt;/td&gt;
&lt;td&gt;アプリ紹介&lt;/td&gt;
&lt;td&gt;@about_hiroppy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17:00-17:15&lt;/td&gt;
&lt;td&gt;鳥小屋を支える技術＆問題点&lt;/td&gt;
&lt;td&gt;@yutopp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16:30&lt;/td&gt;
&lt;td&gt;閉会&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブ配信&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ustream.tv/channel/boost-%E5%8B%89%E5%BC%B7%E4%BC%9A-13-%E4%BB%99%E5%8F%B0&#34; target=&#34;_blank&#34;&gt;http://www.ustream.tv/channel/boost-勉強会-13-仙台&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Twitterハッシュタグ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://twitter.com/search?q=%23boostjp&#34; target=&#34;_blank&#34;&gt;#boostjp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;発表内容&lt;/h2&gt;
&lt;h3&gt;Boost.Asioを使おう&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：橋本達明&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter： &lt;a href=&#34;https://twitter.com/chichimotsu&#34; target=&#34;_blank&#34;&gt;https://twitter.com/chichimotsu&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://www.slideshare.net/chichimotsu/asio&#34; target=&#34;_blank&#34;&gt;http://www.slideshare.net/chichimotsu/asio&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ:  &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIWlEtclpncjVSSFU/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 637MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Boost.Randomで乱数を学ぼう&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：高橋晶&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;サイト： &lt;a href=&#34;https://sites.google.com/site/faithandbrave/about&#34; target=&#34;_blank&#34;&gt;https://sites.google.com/site/faithandbrave/about&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：[&lt;a href=&#34;http://www.slideshare.net/faithandbrave/leanning-random-using-boost-random&#34; target=&#34;_blank&#34;&gt;slideshare&lt;/a&gt;][&lt;a href=&#34;https://dl.dropboxusercontent.com/u/1682460/presentation/boost_random/boost_random.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt;][&lt;a href=&#34;https://dl.dropboxusercontent.com/u/1682460/presentation/boost_random/boost_random.key&#34; target=&#34;_blank&#34;&gt;key&lt;/a&gt;]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ: &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIdmhSVEJHMkJHUlU/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4 動画 607MB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;アフターケア：&lt;a href=&#34;http://d.hatena.ne.jp/faith_and_brave/20131021/1382340838&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 仙台 - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;boost::multiprecisionに勝負を挑んだのち，オリジナル三角形分割手法の実装&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：oniprog&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twiter: &lt;a href=&#34;https://twitter.com/oniprog&#34; target=&#34;_blank&#34;&gt;https://twitter.com/oniprog&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://ohkuma.mydns.jp/homepage/tech/boost/boost_presen/Ohkuma_boost2.pdf&#34; target=&#34;_blank&#34;&gt;http://ohkuma.mydns.jp/homepage/tech/boost/boost_presen/Ohkuma_boost2.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ: &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKISlNhdElDX3NhaU0/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 393MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;boost::signals2とboost::anyで作ったiPhoneアプリ『ういろう』&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：西山信行&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/5mingame2&#34; target=&#34;_blank&#34;&gt;https://twitter.com/5mingame2&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：[&lt;a href=&#34;http://www.slideshare.net/5mingame2/iphoneboost&#34; target=&#34;_blank&#34;&gt;slideshare&lt;/a&gt;][&lt;a href=&#34;https://www.dropbox.com/s/96g3h8pvqjsmlji/iPhone%E3%82%A2%E3%83%97%E3%83%AA%E3%80%8E%E3%81%86%E3%81%84%E3%82%8D%E3%81%86%E3%80%8F%E3%81%A8boost.pptx&#34; target=&#34;_blank&#34;&gt;pptx&lt;/a&gt;]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ:&lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKId0Q3d3d2aWFmQ0U/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 478MB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;アフターケア：&lt;a href=&#34;http://blog.livedoor.jp/tek_nishi/archives/8109245.html&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 仙台 で発表してきた - でらうま倶楽部&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並列アルゴリズムライブラリThrustについて&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者： krustf&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/krustf&#34; target=&#34;_blank&#34;&gt;https://twitter.com/krustf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://www.slideshare.net/krustf/thrust-27354206&#34; target=&#34;_blank&#34;&gt;http://www.slideshare.net/krustf/thrust-27354206&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ: &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIQ2pnR0w3TDZEcTQ/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 364MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Wandbox を支える技術&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：melpon&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/melponn&#34; target=&#34;_blank&#34;&gt;https://twitter.com/melponn&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://melpon.org/pub/wandbox&#34; target=&#34;_blank&#34;&gt;http://melpon.org/pub/wandbox&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ: &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIUjE3aWpIRGhTRjQ/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 784MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アプリ紹介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：about_hiroppy&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/about_hiroppy&#34; target=&#34;_blank&#34;&gt;https://twitter.com/about_hiroppy&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;メモアプリLabelial&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://about-hiroppy.com/Labelial/index.html&#34; target=&#34;_blank&#34;&gt;http://about-hiroppy.com/Labelial/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ:  &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIbVMxNnE2TkEyMVE/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 156MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;鳥小屋を支える技術＆問題点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：yutopp&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/yutopp&#34; target=&#34;_blank&#34;&gt;https://twitter.com/yutopp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://www.slideshare.net/yutopp/boost-13&#34; target=&#34;_blank&#34;&gt;http://www.slideshare.net/yutopp/boost-13&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ:  &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKISkxQZW8xWC1TVnM/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 210MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連リンク&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/faith_and_brave/20131021/1382340838&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 仙台 - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.livedoor.jp/tek_nishi/archives/8109245.html&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 仙台 で発表してきた - でらうま倶楽部&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://togetter.com/li/579014&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 ＠仙台 - togetter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンパイラ間の差を吸収する -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/tips/config.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:tips/config.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンパイラ間の差を吸収する&lt;/h1&gt;
&lt;p&gt;ここでは、コンパイラ間の差を吸収するための方法を挙げる。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#support-cpp11&#34;&gt;コンパイラが、あるC++11の機能をサポートしているかどうかでコードを変更する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#deduced-typename&#34;&gt;コンパイラによって、テンプレート中の &lt;code&gt;hoge&amp;lt;T&amp;gt;::type x;&lt;/code&gt; や &lt;code&gt;fuga.f();&lt;/code&gt; がコンパイルエラーになったりならなかったりする問題を回避する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#nested-template&#34;&gt;メンバ関数テンプレートの呼び出しでコンパイルエラーになる問題を回避する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#support-cpp11&#34; name=&#34;support-cpp11&#34;&gt;コンパイラが、あるC++11の機能をサポートしているかどうかでコードを変更する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下は可変長テンプレート引数をサポートしているコンパイラならそれを使い、そうでなければ Boost.Preprocessor などでエミュレートする例&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/config.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#if defined BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/repetition/enum_params.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/repetition/enum_binary_params.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/facilities/intercept.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 他色々&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  if !defined MAX_PARAM_LIMIT&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#    define MAX_PARAM_LIMIT 10&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  endif&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#endif&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#if !defined BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ...T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T ...x) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// fの定義&lt;/span&gt;
}

&lt;span style=&#34;color: #BC7A00&#34;&gt;#else&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// fの定義（長くなるので省略）&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost/config.hpp&lt;/code&gt; をインクルードすると、コンパイラやバージョンに応じて &lt;code&gt;BOOST_NO_&lt;/code&gt;&lt;em&gt;FEATURE_NAME&lt;/em&gt; が定義される。定義されているマクロ名に対応した機能は、そのコンパイラでは使えない。&lt;/p&gt;
&lt;p&gt;以下はそのマクロ一覧である。C++11の新機能については各々で調べたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;マクロ名&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ALIGNAS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の&lt;code&gt;alignas&lt;/code&gt;キーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ALLOCATOR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11バージョンの&lt;code&gt;std::allocator&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ATOMIC_SP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11のスマートポインタがアトミック操作をサポートしているか&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_ARRAY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/array.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CHRONO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/chrono.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CODECVT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/codecvt.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CONDITION_VARIABLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/condition_variable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;condition_variable&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FORWARD_LIST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/forward_list.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FUNCTIONAL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11バージョンと互換のある&lt;a href=&#34;http://cpprefjp.github.io/reference/functional.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FUTURE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/future.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;future&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_INITIALIZER_LIST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/initializer_list.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;initializer_list&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ。 変数の初期化を &lt;code&gt;{1, 2, 3}&lt;/code&gt; のような記述で行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_MUTEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/mutex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;mutex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_RANDOM&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/random.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_RATIO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/ratio.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_REGEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/regex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_SYSTEM_ERROR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/system_error.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_THREAD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/thread.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;thread&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TUPLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/tuple.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;tuple&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TYPEINDEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/typeindex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;typeindex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TYPE_TRAITS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/type_traits.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_UNORDERED_MAP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/unordered_map.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_UNORDERED_SET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/unordered_set.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_INLINE_NAMESPACES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;inline namespace&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_SMART_PTR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11のスマートポインタ、&lt;code&gt;shared_ptr&lt;/code&gt;と&lt;code&gt;unique_ptr&lt;/code&gt;を提供しているか&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_AUTO_DECLARATIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto&lt;/code&gt; による変数の型の自動決定&lt;br /&gt; &lt;code&gt;// x の型は初期化式 expr から自動的に決定する&lt;/code&gt;&lt;br /&gt; &lt;code&gt;auto x = expr;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto&lt;/code&gt; での宣言で、一度に複数の変数を宣言する&lt;br /&gt; &lt;code&gt;auto x = expr1, y = expr2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CHAR16_T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;組み込み型 &lt;code&gt;char16_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CHAR32_T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;組み込み型 &lt;code&gt;char32_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_TEMPLATE_ALIASES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;template&lt;/code&gt; による別名宣言。&lt;br /&gt; &lt;code&gt;template&amp;lt;typename T&amp;gt; using my_vector = std::vector&amp;lt;T, my_allocator&amp;lt;T&amp;gt; &amp;gt;;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;my_vector&amp;lt;T&amp;gt; v;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CONSTEXPR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に計算して定数に畳み込むことが可能なことを示す修飾子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DECLTYPE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boost.Typeof のように式から型を取得する&lt;br /&gt; &lt;code&gt;// x は expr1 の型として宣言され、&lt;/code&gt;&lt;br /&gt; &lt;code&gt;// expr2 で初期化される&lt;/code&gt;&lt;br /&gt;&lt;code&gt;decltype(expr1) x = expr2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DECLTYPE_N3276&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;N3276仕様の&lt;code&gt;decltype&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DEFAULTED_FUNCTIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ、コピー代入演算子、デストラクタをデフォルト実装で宣言する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DELETED_FUNCTIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の &lt;code&gt;delete&lt;/code&gt; 宣言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型変換演算子に対する &lt;code&gt;explicit&lt;/code&gt; 宣言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_EXTERN_TEMPLATE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートのインスタンス化をその翻訳単位では行わないようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数テンプレートのテンプレートパラメータにデフォルト引数を指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_LAMBDAS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ローカルクラスをテンプレートパラメータに指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_LONG_LONG&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(unsigned) long long&lt;/code&gt; 型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_NOEXCEPT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;noexcept&lt;/code&gt;キーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_NULLPTR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ヌルポインタを示すキーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_RANGE_BASED_FOR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲&lt;code&gt;for&lt;/code&gt;文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`BOOST_NO_CXX11_RAW_LITERALS&lt;/td&gt;
&lt;td&gt;文字列リテラルの新しい表記法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_RVALUE_REFERENCES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右辺値参照型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_SCOPED_ENUMS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スコープ付きの列挙型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_STATIC_ASSERT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条件式によってコンパイルエラーにするための &lt;code&gt;static_assert&lt;/code&gt; 文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_STD_UNORDERD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unordered_set&lt;/code&gt;, &lt;code&gt;unordered_multiset&lt;/code&gt;, &lt;code&gt;unordered_map&lt;/code&gt;, &lt;code&gt;unordered_multimap&lt;/code&gt; の4つのコンテナクラステンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_TRAILING_RESULT_TYPES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値型を後置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_UNICODE_LITERALS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unicode 文字・文字列リテラル(&lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタの呼び出しを初期化子リストと同じ構文で記述する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_USER_DEFINED_LITERALS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ユーザー定義リテラル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変引数テンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_VARIADIC_MACROS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変引数マクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#deduced-typename&#34; name=&#34;deduced-typename&#34;&gt;コンパイラによって、テンプレート中の &lt;code&gt;hoge&amp;lt;T&amp;gt;::type x;&lt;/code&gt; や &lt;code&gt;fuga.f();&lt;/code&gt; がコンパイルエラーになったりならなかったりする問題を回避する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; hoge {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; type;
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T x) {
    T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;type x; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a)&lt;/span&gt;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g() {
    hoge x;
    f(x); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この部分をコンパイルしようとすると (a) でコンパイルエラーが起きる&lt;/span&gt;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;関数テンプレートもしくはクラステンプレート内で、上の &lt;code&gt;f&lt;/code&gt; のように内部でテンプレートパラメータの内部で宣言された型名を利用する場合、(a) の箇所では、&lt;code&gt;T::type&lt;/code&gt; が型名であることを示す必要がある。具体的には &lt;code&gt;typename&lt;/code&gt; キーワードを使って、 &lt;code&gt;typename T::type x;&lt;/code&gt; のように記述する。しかし古いコンパイラなどでは、&lt;code&gt;typename&lt;/code&gt; を付けずとも空気を読んで &lt;code&gt;T::type&lt;/code&gt; が型であると判断することで、&lt;code&gt;typename&lt;/code&gt; キーワードそのものをサポートしていない場合がある。次のように記述することで、この問題は回避可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f() {
    BOOST_DEDUCED_TYPENAME T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;type x;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BOOST_DEDUCED_TYPENAME&lt;/code&gt; マクロは、普通 &lt;code&gt;typename&lt;/code&gt; になるが、かかる位置での &lt;code&gt;typename&lt;/code&gt; をサポートしていないコンパイラでは空に展開される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#nested-template&#34; name=&#34;nested-template&#34;&gt;メンバ関数テンプレートの呼び出しでコンパイルエラーになる問題を回避する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上記の &lt;code&gt;typename&lt;/code&gt; と似たような問題で、次のようなコードがコンパイラによって通ったり通らなかったりする：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; hoge {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f() {}
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; fuga {};
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a)&lt;/span&gt;
    T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b)&lt;/span&gt;
}

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; h() {
    hoge x;
    g(x); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この関数呼び出しをコンパイルしようとすると (a) や (b) の箇所でコンパイルエラーが起きる&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;(a) は &lt;code&gt;int&lt;/code&gt; で実体化したメンバ関数テンプレートの呼び出しとは認識されず、(b) もメンバクラステンプレートを &lt;code&gt;int&lt;/code&gt; で実体化した型の変数の宣言とは見なされない。次のように記述する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a’)&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b’)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;(a’) では &lt;code&gt;f&lt;/code&gt; の前に &lt;code&gt;template&lt;/code&gt; キーワードを付けて、&lt;code&gt;f&lt;/code&gt; がテンプレートであることを明記している。(b’) も同様に &lt;code&gt;fuga&lt;/code&gt; がテンプレートであると示しているが、同時に &lt;code&gt;T::template fuga&amp;lt;int&amp;gt;&lt;/code&gt; が型であることも示すために &lt;code&gt;typename&lt;/code&gt; も付けている。しかし上の &lt;code&gt;typename&lt;/code&gt; の問題と同様に、この &lt;code&gt;template&lt;/code&gt; キーワードの使い方をサポートしないコンパイラが存在する。これについては &lt;code&gt;BOOST_NESTED_TEMPLATE&lt;/code&gt; マクロを使うことで解決する。次のように使う：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.BOOST_NESTED_TEMPLATE f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a&#39;)&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;BOOST_NESTED_TEMPLATE fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b&#39;)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この &lt;code&gt;template&lt;/code&gt; キーワードの使い方をサポートするコンパイラでは &lt;code&gt;template&lt;/code&gt; と展開され、そうでないコンパイラでは空に展開される。&lt;/p&gt;
&lt;p&gt;documented boost version is 1.51.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>構文解析 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/tips/parser.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:tips/parser.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;構文解析&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;本稿は記述途中です。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/index.html&#34; target=&#34;_blank&#34;&gt;Boost Spirit&lt;/a&gt; ライブラリ、特にその中の &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi.html&#34; target=&#34;_blank&#34;&gt;Qi&lt;/a&gt; を用いることにより構文解析器を作成することが可能である。&lt;/p&gt;
&lt;p&gt;文法、アクションを記述したファイルを元に C/C++ ソースを生成する yacc や bison といった伝統的なパーサジェネレータとは異なり、Spirit Qi では C++ 内で文法、アクションの記述を完結させることができる。また、対象とする文法も文脈自由文法のような伝統的なクラスではなく解析表現文法(PEG: Parsing Expression Grammar)である(一般に解析表現文法は自然言語の解析には適しておらずコンピュータ言語の解析に適している)。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#api&#34;&gt;1 API&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#check-all-consume&#34;&gt;1.1 入力を全て消費したかを確認する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#skip&#34;&gt;1.2 空白等を読み飛ばす&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#get-parsed-result&#34;&gt;1.3 解析された値を受け取る&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2 ルール&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#primitive&#34;&gt;2.1 プリミティブ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#directive&#34;&gt;2.2 ディレクティブ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#operator&#34;&gt;2.3 演算子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#semantic-action&#34;&gt;2.4 セマンティックアクション&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#nonterminal&#34;&gt;2.5 非終端記号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-reference&#34;&gt;3 逆引き&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-skip&#34;&gt;3.1 空白等を読み飛ばしたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-find&#34;&gt;3.2 特定の文字列で終了する部分まで読み出したい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-default-value&#34;&gt;3.3 デフォルト値を与えたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-check-condition&#34;&gt;3.4 条件によって構文解析を途中で失敗させたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-as-string&#34;&gt;3.5 ある範囲全体の結果を文字列として得たい&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#api&#34; name=&#34;api&#34;&gt;API&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;構文解析の実施は &lt;code&gt;parse()&lt;/code&gt; 関数、あるいは &lt;code&gt;phrase_parse()&lt;/code&gt; 関数を呼び出すことによって行う。&lt;code&gt;parse()&lt;/code&gt; 関数と &lt;code&gt;phrase_parse()&lt;/code&gt; 関数の違いは、&lt;code&gt;phrase_parse()&lt;/code&gt; が空白等の読み飛ばし(後述する&lt;code&gt;Skipper&lt;/code&gt;)を行う一方、&lt;code&gt;parse()&lt;/code&gt; 関数は読み飛ばしを行わない点である。&lt;code&gt;phrase_parse()&lt;/code&gt; については&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#skip&#34;&gt;空白等を読み飛ばす&lt;/a&gt;を参照。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; spirit { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi {
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Expr&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; parse(
        Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; first
      , Iterator last
      , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Expr&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; expr);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Expr
      , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Attr1, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Attr2, ..., &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; AttrN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; parse(
        Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; first
      , Iterator last
      , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Expr&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; expr
      , Attr1&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attr1, Attr2&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attr2, ..., AttrN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attrN);
}}}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parse()&lt;/code&gt;関数の引数・戻り値は、以下を意味する：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;引数・戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;td&gt;解析が成功したかどうか。&lt;br /&gt;入力が余っている場合でも解析が完了した場合は &lt;code&gt;true&lt;/code&gt; を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;first&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非 &lt;code&gt;const&lt;/code&gt; 参照で受け、かつ、値が変更されるため &lt;code&gt;s.begin()&lt;/code&gt; 等は直接渡せない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;last&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;終端のイテレータ。参照ではなく値であるため、&lt;code&gt;s.end()&lt;/code&gt;の戻り値を直接渡せる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ルール(文法部分) 後述　この場合は1つの整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;attrN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取った値の格納先&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123 456&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(
    first,
    last,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK が出力される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#check-all-consume&#34; name=&#34;check-all-consume&#34;&gt;1.1 入力を全て消費したかを確認する&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parse()&lt;/code&gt; 関数、&lt;code&gt;phrase_parse()&lt;/code&gt; 関数の第1引数であるイテレータへの参照は、解析中に更新されていく。そのため構文解析中に入力が全て消費されたか確認したい場合は、第2引数に渡した値と比較すれば良い。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123 456&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(
    first,
    last,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; first &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; last) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK は出力されない&lt;/span&gt;

s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123&#34;&lt;/span&gt;; first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(); last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(first, last, qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; first &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; last) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK が出力される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#skip&#34; name=&#34;skip&#34;&gt;1.2 空白等を読み飛ばす&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前述の通り &lt;code&gt;phrase_parse()&lt;/code&gt; 関数を用いる。関数呼び出しの際にどのような内容を読み飛ばすかを第4引数にルールの形で指定する(&lt;code&gt;Skipper&lt;/code&gt; と呼ばれる)。非終端記号（後述）を使用している場合は、その非終端記号の型に &lt;code&gt;Skipper&lt;/code&gt; の型を指定してやる必要があることに注意（FAQ）。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; spirit { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi {

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Expr, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Skipper&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; phrase_parse(
        Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; first
      , Iterator last
      , Expr &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; expr
      , Skipper &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; skipper
      , BOOST_SCOPED_ENUM(skip_flag) post_skip &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; skip_flag&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;postskip);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Expr, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Skipper
      , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Attr1, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Attr2, ..., &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; AttrN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; phrase_parse(
        Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; first
      , Iterator last
      , Expr &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; expr
      , Skipper &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; skipper
      , Attr1&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attr1, Attr2&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attr2, ..., AttrN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attrN);

}}}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;引数・戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;td&gt;解析が成功したかどうか。&lt;br /&gt;入力が余っている場合でも解析が完了した場合は &lt;code&gt;true&lt;/code&gt; を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;first&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非 &lt;code&gt;const&lt;/code&gt; 参照で受け、かつ、値が変更されるため &lt;code&gt;s.begin()&lt;/code&gt; 等は直接渡せない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;last&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;終端のイテレータ。参照ではなく値であるため、&lt;code&gt;s.end()&lt;/code&gt;の戻り値を直接渡せる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ルール(文法部分) 後述　この場合は1つの整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;skipper&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み飛ばす条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;attrN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取った値の格納先&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;   123&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phrase_parse(
    first,
    last,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Skipper この場合は任意の空白&lt;/span&gt;
              &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 勝手に繰り返し呼び出されるので繰り返し分を明示的に指定する必要はない&lt;/span&gt;
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK が出力される&lt;/span&gt;

first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin();
success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(first, last, qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 最初の空白で失敗するため OK は出力されない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#get-parsed-result&#34; name=&#34;get-parsed-result&#34;&gt;1.3 解析された値を受け取る&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parse()&lt;/code&gt; 関数、&lt;code&gt;phrase_parse()&lt;/code&gt; 関数のいずれも追加で読み取った値を受け取る変数を渡すことができる。複数の値を読み取る場合は複数の変数を渡すことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123 456&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n1, n2;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phrase_parse(
    first,
    last,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_ &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2つの整数&lt;/span&gt;
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space,
    n1, n2                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 読み取った値の格納先&lt;/span&gt;
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK: 123, 456 が出力される&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; n1 &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;, &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; n2 &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#rule&#34; name=&#34;rule&#34;&gt;2 ルール&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ルールはプリミティブ、ディレクティブ、演算子を組み合わせることによって表現される。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#primitive&#34; name=&#34;primitive&#34;&gt;2.1 プリミティブ&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字を読むプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/char.html&#34; target=&#34;_blank&#34;&gt;Character Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;数値を読むプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/numeric.html&#34; target=&#34;_blank&#34;&gt;Numeric Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;文字列を読むプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/string.html&#34; target=&#34;_blank&#34;&gt;String Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;バイナリ値を読むプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/binary.html&#34; target=&#34;_blank&#34;&gt;Binary Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;補助的なプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/auxiliary.html&#34; target=&#34;_blank&#34;&gt;Auxiliary Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;※後で適当に丸めて翻訳して入れる&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#directive&#34; name=&#34;directive&#34;&gt;2.2 ディレクティブ&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ディレクティブのリストは &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/directive.html&#34; target=&#34;_blank&#34;&gt;Parser Directives&lt;/a&gt; を参照。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;※後で翻訳して入れる&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#operator&#34; name=&#34;operator&#34;&gt;2.3 演算子&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;演算子のリストは &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/operator.html&#34; target=&#34;_blank&#34;&gt;Parser Operators&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;属性（読み取る値）の型については &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/compound_attribute_rules.html&#34; target=&#34;_blank&#34;&gt;Compound Attribute Rules&lt;/a&gt; を参照。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;※後で翻訳して入れる&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#semantic-action&#34; name=&#34;semantic-action&#34;&gt;セマンティックアクション&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#nonterminal&#34; name=&#34;nonterminal&#34;&gt;非終端記号&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rule&lt;/code&gt;型を用いることで、ルールに名前をつけることができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Iterator の型以外は省略可能で、順序も自由&lt;/span&gt;
qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 解析対象の Iterator の型 ※しばしば template 引数&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;),             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 属性の型 ※関数型として指定し戻り値の型が読み取る値 ※省略可能&lt;/span&gt;
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;locals&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;,       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ローカル変数の型 ※省略可能&lt;/span&gt;
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space_type         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Skipper の型 ※省略可能　Skipper を使いたい時には忘れず指定すること&lt;/span&gt;
                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ※指定しなくともコンパイルできてしまうが望み通りの挙動とならない&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; int_pair;
int_pair &lt;span style=&#34;color: #666666&#34;&gt;%=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_[qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_a &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_1] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_(qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_a); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 同じ数字の2回の繰り返し&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int_pair の任意の回数の繰り返し&lt;/span&gt;
qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;), qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; int_pairs &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;int_pair;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;また複数の &lt;code&gt;rule&lt;/code&gt; の固まりを &lt;code&gt;grammar&lt;/code&gt; としてまとめることもできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; mygrammar &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;grammar&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iterator, A1, A2, A3&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// start_rule の template 引数と一致すること&lt;/span&gt;
{
    mygrammar() &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; mygrammar&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;base_type(start_rule, name)
    {
        start_rule &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;/* */&lt;/span&gt;;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;/* 他の rule の定義 */&lt;/span&gt;
    }
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iterator, A1, A2, A3&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; start_rule;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;/* 他の rule の宣言 */&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-reference&#34; name=&#34;reverse-reference&#34;&gt;3 逆引き&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-skip&#34; name=&#34;reverse-skip&#34;&gt;3.1 空白等を読み飛ばしたい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;phrase_parse()&lt;/code&gt; と &lt;code&gt;Skipper&lt;/code&gt; を使う。&lt;code&gt;rule&lt;/code&gt;型 や &lt;code&gt;grammar&lt;/code&gt;型 を使う場合は &lt;code&gt;Skipper&lt;/code&gt; の型を指定する必要があることに注意すること。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;   123&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();

qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(), &lt;span style=&#34;color:#ff0000&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space_type&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; rule &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Skipper の型指定&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff0000&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phrase_parse&lt;/span&gt;( &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// phrase_parse() を使用&lt;/span&gt;
    first,
    last,
    rule,
    &lt;span style=&#34;color:#ff0000&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Skipper この場合は任意の空白&lt;/span&gt;
              &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 勝手に繰り返し呼び出されるので繰り返し分を明示的に指定する必要はない&lt;/span&gt;
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK が出力される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-find&#34; name=&#34;reverse-find&#34;&gt;3.2 特定の文字列で終了する部分まで読み出したい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;文字列 &lt;code&gt;&#34;end&#34;&lt;/code&gt; までの任意の文字列(&lt;code&gt;&#34;end&#34;&lt;/code&gt; を含まない)を読み出したい場合は以下のようなルールを用いれば良い。読み飛ばしたい場合は &lt;code&gt;qi::omit&lt;/code&gt; ディレクティブを使えばよい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;char_ &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;end&#34;&lt;/span&gt;)) &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;end&#34;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-default-value&#34; name=&#34;reverse-default-value&#34;&gt;3.3 デフォルト値を与えたい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;例えば文字列 &lt;code&gt;&#34;value:&#34;&lt;/code&gt; に続いて数値がある場合はその数値を、ない場合はデフォルト値 &lt;code&gt;42&lt;/code&gt; を返したい場合は以下のように &lt;code&gt;qi::attr&lt;/code&gt; を使用すればよい。省略された場合にさらに数値が続く場合は省略されているか否かが判別できずにうまくいかない（場合が多い）ので注意。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;value:&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; (qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_ &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;attr&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;42&lt;/span&gt;) )
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-check-condition&#34; name=&#34;reverse-check-condition&#34;&gt;3.4 条件によって構文解析を途中で失敗させたい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通常は何もせず常に成功するプリミティブ &lt;code&gt;qi::eps&lt;/code&gt; （※特定のタイミングでセマンティックアクションを実行させたい場合等に使う）に遅延評価される引数を与えることで実現できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; phx &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phoenix;
&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 読み出した整数が 42 以外の時だけ成功する&lt;/span&gt;
qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; rule &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_[phx&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ref(n) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_1] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;eps&lt;/span&gt;(phx&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ref(n) &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;42&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-as-string&#34; name=&#34;reverse-as-string&#34;&gt;3.5 ある範囲全体の結果を文字列として得たい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;例えば改行で終端される空白区切りの文字列を得たい場合、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;char_(&lt;span style=&#34;color: #BA2121&#34;&gt;&#39; &#39;&lt;/span&gt;)) &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit_(&lt;span style=&#34;color: #BA2121&#34;&gt;&#39;\n&#39;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;をルールとすると空白を除いた文字列が得られることになるが場合によっては空白を含む文字列全体を得たい場合があるかもしれない。あるいは、単純に構成すると文字列のリスト(&lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt;)が属性の型となってしまうが欲しいのはリストではなく文字列である場合もあるだろう。こうした場合、&lt;code&gt;qi::raw&lt;/code&gt; ディレクティブを使うのが簡単である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;a b c&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string value;

&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(
    first,
    last,
    &lt;span style=&#34;color:#ff0000&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;raw&lt;/span&gt;[(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#39; &#39;&lt;/span&gt;))] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#39;\n&#39;&lt;/span&gt;),
    value
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; value &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// a b c が出力される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>優先順位を付けて並べ替える -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/tips/priority_sort.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:tips/priority_sort.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;優先順位を付けて並べ替える&lt;/h1&gt;
&lt;p&gt;ここでは、優先順位を付きのオブジェクト比較と、それによる並べ替えの方法を示す。優先順位付きの比較とは、Windowsのエクスプローラで言うところの「ファイル種別順に並べて、同じファイル種別のものはファイル名順に並べる」というようなものである。
このような比較方法は、一覧画面のようなものを作る場合に必要となる。&lt;/p&gt;
&lt;p&gt;優先順位付きの比較には、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/&#34; target=&#34;_blank&#34;&gt;Boost Fusion Library&lt;/a&gt;が提供するタプル型を使用する。タプルとは、異なる複数の型からなるシーケンスである。&lt;a href=&#34;http://cpprefjp.github.io/reference/utility/pair.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/a&gt;が2つの異なる型のオブジェクトを格納するのに対して、タプルは任意個のオブジェクトを格納できる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/&#34; target=&#34;_blank&#34;&gt;Boost.Fusion&lt;/a&gt;が提供するタプルは比較演算子を持っており、それがちょうど前述した「ファイル種別順に並べて、同じファイル種別のものはファイル名順に並べる」という意味論での比較を行う。&lt;/p&gt;
&lt;p&gt;クラスのメンバ変数をタプルに変換することにより、優先順位付きの比較が可能となる。&lt;/p&gt;
&lt;p&gt;以下がその例である：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;algorithm&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/fusion/include/comparison.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/fusion/include/&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; File {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string type;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string name;

    File(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; type, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; name)
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; type(type), name(name) {}
};

&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; a, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; b)
{
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ファイル種別、ファイル名の順番で優先順位を付けて比較&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; fusion &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;fusion;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; fusion&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;(a.type, a.name) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; fusion&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;(b.type, b.name);
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; main()
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;File&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; files &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;text&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;b.txt&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;application&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;b.exe&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;application&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;a.exe&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;text&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;a.txt&#34;&lt;/span&gt;}
    };

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 並べ替え&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;sort(files.begin(), files.end());

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; file &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; files) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; file.type &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;, &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; file.name &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;application, a.exe
application, b.exe
text, a.txt
text, b.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;ファイルが、ファイル種別順に並んだ上で、種別が同じファイルは名前で並べ替えられていることがわかるだろう。&lt;/p&gt;
&lt;p&gt;このプログラムでは、&lt;code&gt;File&lt;/code&gt;クラスの&lt;code&gt;operator&amp;lt;()&lt;/code&gt;演算子において「ファイル種別でどちらが小さいかを比較し、同じであればファイル名がどちらが小さいかを比較する」という優先順位付き比較を行なっている。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/container/generation/functions/vector_tie.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::fusion::vector_tie()&lt;/code&gt;&lt;/a&gt;関数は、引数として受け取った変数への参照から、参照のタプル型を構築する。ここでは、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/container/vector.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::fusion::vector&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;const std::string&amp;amp;, const std::string&amp;amp;&amp;gt;&lt;/code&gt;という型のタプルオブジェクトを構築する。&lt;/p&gt;
&lt;p&gt;Boost.Fusionが提供するタプル型に対する比較演算子は、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/sequence/operator/comparison.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;boost/fusion/include/comparison.hpp&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダで定義されている。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参照：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/algorithm/lexicographical_compare.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::lexicographical_compare()&lt;/code&gt; - cpprefjp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>