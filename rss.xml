<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-01-17T00:14:49.225674</updated>
  <id>9e95dd68-f441-4b59-b2c2-5519430cb8de</id>

  
    <entry>
      <title>adjacency_list -- adjacency_list : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html"/>
      <id>07c4d5d2b03fce8ffaf0569589780e1b19b76328:archive/boost_docs/libs/graph/adjacency_list.md</id>
      <updated>2015-01-17 00:14:36 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_list&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed,
               VertexProperties, EdgeProperties,
               GraphProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスは一般化された隣接リストグラフ構造を実装する。 テンプレート・パラメータは要求を最も満たすクラスのバージョンを選べるように多くの形態の選択肢を提供する。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34;&gt;adjacency-list&lt;/a&gt; は基本的に二次元の構造で、ここで最初の次元の各要素は頂点を表し、頂点の各々はその辺リストの一次元構造を含んでいる。 Figure 1 は有向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 1:有向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータは外部の二次元コンテナを表すためにどんな種類のコンテナが使われるかを制御する。 &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータは辺リストを表すためにどんな種類の コンテナが使われるかを制御する。&lt;code&gt;EdgeList&lt;/code&gt; と &lt;code&gt;VertexList&lt;/code&gt; の 選択はグラフ構造の空間計算量を決定するだろう、そして様々なグラフ操作の時間計算量を決定するだろう。可能な選択とトレード・オフは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#choosing-graph-type&#34;&gt;Choosing the Edgelist and VertexList&lt;/a&gt; 中で論じられる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータはグラフが有向か無向か、または 入辺と出辺の両方にアクセスする (これを双方向性と呼ぶ) 有向かを制御する。 双方向性グラフは各辺が出辺リストと入辺リストの両方に現れるため、辺当たり有向グラフの二倍の空間を取る。Figure 2 は無向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 2:無向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの使い方のチュートリアルは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink&#34;&gt;Using &lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/family-tree-eg.cpp.html&#34;&gt;&lt;code&gt;examples/family-tree-eg.cpp&lt;/code&gt;&lt;/a&gt; 中にある例は家族の木 (family tree) をグラフで表現する方法を示す。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各々の頂点の辺リストを表わすために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの頂点リストを表すために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向か、無向か、または双方向の辺アクセス (出辺と入辺の両方にアクセス する) の有向かを選ぶ選択子。選択肢は &lt;code&gt;directedS&lt;/code&gt;、&lt;code&gt;undirectedS&lt;/code&gt;、 そして &lt;code&gt;bidirectionalS&lt;/code&gt; である。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ・オブジェクトのためのプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.html&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.html&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Vertex and Edge Properties&lt;/h2&gt;
&lt;p&gt;色、距離、重み、そしてユーザ定義のプロパティのようなプロパティは、プロパティ を用いてグラフの頂点と辺に結びつけることができる。プロパティの値はグラフに よって提供されるプロパティ・マップ経由で読み書きできる。プロパティ・マップ は get(property, g) 関数経由で得られる。プロパティの使い方は 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#adjacency-list-properties&#34;&gt;Internal Properties&lt;/a&gt; 内で述べられている。プロパティ・マップは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.html&#34;&gt;Property Map Concepts&lt;/a&gt; 内で定義されているインターフェースを実装するオブジェクトである。 &lt;code&gt;adjacency_list&lt;/code&gt; クラスから得られるプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; コンセプトのモデルである。もし &lt;code&gt;adjacency_list&lt;/code&gt; が &lt;code&gt;const&lt;/code&gt; なら、 プロパティ・マップは定数である。さもなくばプロパティ・マップは変更可能である。&lt;/p&gt;
&lt;p&gt;もしグラフの &lt;code&gt;VertexList&lt;/code&gt; が &lt;code&gt;vecS&lt;/code&gt; なら、グラフは &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティのためのプロパティ・マップを経由して アクセスされた組み込みの頂点の添え字を持っている。添え字は &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲内に整列し、連続している。頂点が 削除される時、添え字はそれらのプロパティを持ち続けるよう調整される。 これらの添え字を外部のプロパティの記憶領域にアクセスするために使う際には いくらか気をつけなければならない。 頂点の添え字のためのプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルである。&lt;/p&gt;
&lt;h2&gt;Iterator and Descriptor Stability/Invalidation&lt;/h2&gt;
&lt;p&gt;辺の追加や削除によってグラフの構造を変更する時はいくらか注意しなければならない。&lt;code&gt;adjacency_list&lt;/code&gt; の型と操作に依存して、グラフ内を指すイテレータや記述子オブジェクトのいくつかは無効になるかもしれない。 例えば、次のコードは未定義の (悪い) 振る舞いの結果となるだろう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, vecS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=vecS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これでもまだ間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これが問題である理由は &lt;code&gt;remove_vertex()&lt;/code&gt; を呼び出しており、そしてそれが &lt;code&gt;VertexList=vecS&lt;/code&gt; の &lt;code&gt;adjacency_list&lt;/code&gt; とともに使われたとき、グラフのための全てのイテレータと記述子 (例えば &lt;code&gt;vi&lt;/code&gt; や &lt;code&gt;vi_end&lt;/code&gt;) を無効にするために、ループの次の繰り返し中に災難を引き起こす。&lt;/p&gt;
&lt;p&gt;もし異なる種類の &lt;code&gt;adjacency_list&lt;/code&gt; を使い、そして &lt;code&gt;VertexList=listS&lt;/code&gt; ならば、イテレータが削除された実際の頂点を指してなければ &lt;code&gt;remove_vertex&lt;/code&gt; を呼ぶことによってイテレータは無効にならない。次のコードはこれを説明する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, listS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=listS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これは大丈夫である&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;安定性の問題は更に頂点記述子と辺記述子に影響を及ぼす。例えば、最短経路木中の頂点の親 (または先行点) の過程を保持するために頂点記述子の &lt;code&gt;vector&lt;/code&gt; を使ったとしよう (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ)。&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; を呼んで親の &lt;code&gt;vector&lt;/code&gt; を作成し、 それからグラフから頂点を削除する。続いて親の &lt;code&gt;vector&lt;/code&gt; を使おうと試みるが、全ての頂点記述子は無効になっているので、結果は正しくない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(num_vertices(G));
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(num_vertices(G));

dijkstra_shortest_paths(G, s, distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
  predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));

remove_vertex(s, G); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// まずい考えだ！親 vector 中の頂点記述子を無効にする&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 次は間違った結果を生じる&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(tie(vi, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; p[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; is the parent of &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この議論の中でイテレータと記述子の無効化は、操作によって &lt;strong&gt;直接影響を受けない&lt;/strong&gt; イテレータと記述子の無効化に携わっていることに注意しなさい。 例えば、&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の実行は、&lt;code&gt;adjacency_list&lt;/code&gt; の種類に関係なく、いつも &lt;code&gt;(u,v)&lt;/code&gt; のためのどの辺記述子も、また&lt;code&gt;(u,v)&lt;/code&gt; を指すどの辺記述子も無効にするだろう。 このイテレータと記述子の無効化の議論中で、他の辺 (&lt;code&gt;(u,v)&lt;/code&gt; ではない) を指す辺記述子とイテレータにおける &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の影響にのみ携わっている。&lt;/p&gt;
&lt;p&gt;一般的に頂点記述子と辺記述子を安定に (決して無効にならない) したければ、 &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; と &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;listS&lt;/code&gt; または &lt;code&gt;setS&lt;/code&gt; を使いなさい。もし記述子とイテレータの安定性に気をもまないけれどもメモリの 消費量とグラフの巡回速度をより心配するなら、&lt;code&gt;VertexList&lt;/code&gt; かつ／または &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;vecS&lt;/code&gt; を使いなさい。&lt;/p&gt;
&lt;p&gt;下記の表はどの操作が記述子とイテレータを無効にする原因となるかを要約する。 表中で、&lt;code&gt;EL&lt;/code&gt; は &lt;code&gt;EdgeList&lt;/code&gt; の省略形で &lt;code&gt;VL&lt;/code&gt; は &lt;code&gt;VertexList&lt;/code&gt; を意味する。 &lt;strong&gt;Adj Iter (隣接イテレータ)&lt;/strong&gt; カテゴリは &lt;code&gt;out_edge_iterator&lt;/code&gt;、&lt;code&gt;in_edge_iterator&lt;/code&gt;、そして &lt;code&gt;adjacency_iterator&lt;/code&gt; 型を含む。記述子とイテレータの無効化の より詳しい説明は各操作のドキュメント中で示されている。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;頂点記述子&lt;/th&gt;
&lt;th&gt;辺記述子&lt;/th&gt;
&lt;th&gt;頂点イテレータ&lt;/th&gt;
&lt;th&gt;辺イテレータ&lt;/th&gt;
&lt;th&gt;隣接イテレータ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_out_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_in_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table: 記述子とイテレータの無効化の要約&lt;/p&gt;
&lt;h2&gt;Associated Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;adjacency_list_traits&amp;lt;EdgeList, VertexList, Directed&amp;gt;::vertex_descriptor
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた頂点記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた辺記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;VertexList=vecS&lt;/code&gt; なら &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;EdgeList=vecS&lt;/code&gt; なら &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;adjacency_iterator&lt;/code&gt; は &lt;code&gt;out_edge_iterator&lt;/code&gt; と同じイテレータ・ コンセプトをモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフが有向 (&lt;code&gt;directed_tag&lt;/code&gt;) か、無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) かについての情報を提供する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これはグラフのクラスが多重辺 (同じ始点と終点を持つ辺) の挿入を許可するかどうかを述べる。二つのタグは &lt;code&gt;allow_parallel_edge_tag&lt;/code&gt; と &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;code&gt;setS&lt;/code&gt; と &lt;code&gt;hash_setS&lt;/code&gt; の亜種は多重辺を許可しない一方で他の型は多重辺を許可する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点に接続する辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点プロパティまたは辺プロパティのためのプロパティ・マップの型。 具体的なプロパティは &lt;code&gt;Property&lt;/code&gt; テンプレート引数で指定され、グラフのための &lt;code&gt;VertexProperties&lt;/code&gt; もしくは &lt;code&gt;EdgeProperties&lt;/code&gt; で指定されたプロパティのどちらか一つと一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Property&lt;/code&gt; タグで指定されたグラフのプロパティのためのプロパティの値型。&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;デフォルト・コンストラクタ。0 個の頂点と0 個の辺からなる空のグラフ・ オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コピー・コンストラクタ。辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーである新しいグラフを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;代入演算子。&lt;code&gt;this&lt;/code&gt; に 辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーを入れる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(vertices_size_type n, 
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と 0 個の辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;template &amp;lt;class EdgeIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               vertices_size_type n, 
               edges_size_type m = 0, 
               const GraphProperty&amp;amp; p = GraphProperty())&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;
`n` 個の頂点と、範囲 `[first, last)` で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 `EdgeIterator` は [`InputIterator`](http://www.sgi.com/tech/stl/InputIterator.html) のモデルでなければならない。`EdgeIterator` の値型は `std::pair` でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは `[0, n)` の範囲内に整列していなければならない。


***
```cpp
template &amp;lt;class EdgeIterator, class EdgePropertyIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               EdgePropertyIterator ep_iter,
               vertices_size_type n,
               vertices_size_type m = 0,
               const GraphProperty&amp;amp; p = GraphProperty())
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と、範囲 &lt;code&gt;[first, last)&lt;/code&gt; で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; と &lt;code&gt;EdgePropertyIterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;code&gt;EdgeIterator&lt;/code&gt; の値型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは &lt;code&gt;[0, n)&lt;/code&gt; の範囲内に整列していなければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperties&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear()
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから全ての辺と頂点を削除する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; のグラフの頂点、辺、そしてプロパティと、グラフ&lt;code&gt;x&lt;/code&gt;の頂点、辺、そしてプロパティを交換する。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;h3&gt;Structure Access&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; の出辺へのアクセスを提供するイテレータ範囲を返す。もしグラフが無向グラフなら、このイテレータ範囲は 頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。 有向グラフと無向グラフの両方で、出辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; に隣接する頂点の場合は &lt;code&gt;source(e, g) == u&lt;/code&gt; かつ &lt;code&gt;target(e, g) == v&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
in_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する イテレータ範囲を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに &lt;code&gt;bidirectionalS&lt;/code&gt; が指定されている場合にのみ利用できる。 入辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; に隣接している何らかの頂点 &lt;code&gt;u&lt;/code&gt; に対して、グラフが有向であろうと無向であろうと、&lt;code&gt;target(e, g) == v&lt;/code&gt; かつ &lt;code&gt;source(e, g) == u&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; を出て行く辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
in_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; に入ってくる辺の数を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに&lt;code&gt;bidirectionalS&lt;/code&gt;が指定されている場合にのみ利用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type
num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type
num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点リスト中の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; と頂点 &lt;code&gt;v&lt;/code&gt; を結ぶ辺を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge_range(vertex_descriptor u, vertex_descriptor v,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; への全ての多重辺のための範囲を与える出辺イテレータのペアを返す。この関数は &lt;code&gt;adjacency_list&lt;/code&gt; 用の &lt;code&gt;EdgeList&lt;/code&gt; が終点に従って出辺をソートし、かつ多重辺を考慮するコンテナである時にのみ動作する。&lt;code&gt;multisetS&lt;/code&gt; 選択子はそのようなコンテナを選択する。&lt;/p&gt;
&lt;h3&gt;Structure Modification&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフに辺 &lt;code&gt;(u,v)&lt;/code&gt; を付け加え、新しい辺のための辺記述子を返す。 多重辺を許可しないグラフにとっては、もし辺がすでにグラフ中にあるなら、二重には付け加えられず、&lt;code&gt;bool&lt;/code&gt; フラグは &lt;code&gt;false&lt;/code&gt; になるだろう。同様に、もし &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; が 同じ頂点のための記述子 (ループを作っている) であり、かつグラフが無向グラフならば、辺は付け加えられずフラグは &lt;code&gt;false&lt;/code&gt; になるだろう。 フラグが &lt;code&gt;false&lt;/code&gt; の時は、返された辺記述子は既に存在している辺を指す。&lt;/p&gt;
&lt;p&gt;出辺リスト中の新しい辺の配置は一般に不定である。もっとも出辺リストの順序付けは &lt;code&gt;EdgeList&lt;/code&gt; の選択を通じて成し遂げられるが。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;VertexList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; でありかつ頂点記述子 &lt;code&gt;u&lt;/code&gt; または &lt;code&gt;v&lt;/code&gt; (それは整数である) がグラフ中の現在の頂点の数より大きな値を持っているなら、頂点の数が &lt;code&gt;std::max(u,v) + 1&lt;/code&gt; に なるようにグラフが拡大される。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; であれば、この操作によって頂点 &lt;code&gt;u&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; も無効になるだろう。 これはもし &lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;push(container, x)&lt;/code&gt; が呼び出されたときにそのイテレータを無効にするようなユーザ定義のコンテナ (章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#custom-storage&#34;&gt;Customizing the Adjacency List Storage&lt;/a&gt; を見なさい) であれば同様にあてはまる。 もしグラフが同様に双方向であれば、&lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;in_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりに グラフが無向グラフならば &lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりにグラフが有向グラフならば、 &lt;code&gt;add_edge()&lt;/code&gt; は同様にどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフに付け加え、&lt;code&gt;p&lt;/code&gt; を辺の内部のプロパティの記憶領域の値として添える。さらなる詳細のために前の &lt;code&gt;add_edge()&lt;/code&gt; 非メンバ関数も見なさい。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから取り除く。&lt;/p&gt;
&lt;p&gt;この操作は辺 &lt;code&gt;(u,v)&lt;/code&gt; を指すどの発行済みの辺記述子もイテレータも無効となる原因になる。加えて、もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; ならば無向と双方向のグラフの場合この操作は頂点 &lt;code&gt;u&lt;/code&gt; とまた頂点 &lt;code&gt;v&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; をグラフから取り除く。これは多重グラフの場合 &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数とは違う。この &lt;code&gt;remove_edge(e, g)&lt;/code&gt; 関数は一つの辺だけを取り除くのに対して &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数は全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を取り除く。&lt;/p&gt;
&lt;p&gt;この操作は記述子 &lt;code&gt;e&lt;/code&gt; が指す同じ辺のためのどの発行済みの辺記述子も イテレータも無効にする。加えて、この操作は &lt;code&gt;target(e, g)&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはグラフのためのどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(out_edge_iterator iter, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;remove_edge(*iter, g)&lt;/code&gt; と同じ効果を持つ。違いはこの関数は有向グラフの場合定数の時間計算量を持つのに対し、&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は O(E/V) の時間計算量を持つ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_out_edge_if(vertex_descriptor u, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                        adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;u&lt;/code&gt; の出辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_in_edge_if(vertex_descriptor v, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                       adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;v&lt;/code&gt; の入辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向と双方向の &lt;code&gt;adjacency_list&lt;/code&gt; グラフに利用できるが、有向グラフには利用できない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge_if(&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての辺を取り除く。すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点をグラフに付け加え、新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
           adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;指定されたプロパティを持つ頂点をグラフに付け加える。新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; への、そして &lt;code&gt;u&lt;/code&gt; からの全ての辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点または終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_out_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての出辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点として 持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出す時のそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向グラフには適用できない (代わりに &lt;code&gt;clear_vertex()&lt;/code&gt; を使いなさい)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_in_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての入辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は双方向グラフにのみ適用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; をグラフの頂点集合から取り除く。頂点が削除されるとき、 頂点 &lt;code&gt;u&lt;/code&gt; への、また頂点 &lt;code&gt;u&lt;/code&gt; への辺は存在しないものと仮定する。 これを確実にする一つの手段はあらかじめ &lt;code&gt;clear_vertex()&lt;/code&gt; を呼ぶことである。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータが &lt;code&gt;vecS&lt;/code&gt; なら、グラフのための全ての頂点記述子、辺記述子、そしてイテレータ はこの操作によって無効にされる。各頂点のための組み込みの &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティは操作の後もなお頂点の添え字が連続した範囲 &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; に配列しているように番号が付け直される。 もし組み込みの頂点の添え字に基づく外部のプロパティの記憶領域を使って いるなら、外部の記憶領域は調整される必要があるだろう。 他の選択は組み込みの頂点の添え字を使用せずに独自の頂点の添え字プロパティを付け加えるためにプロパティを代わりに使うことである。 もしたびたび &lt;code&gt;remove_vertex()&lt;/code&gt; 関数を使用する必要があるなら、 &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータには &lt;code&gt;listS&lt;/code&gt; 選択子が非常によい選択である。&lt;/p&gt;
&lt;h3&gt;Property Map Accessors&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PropertyTag&lt;/code&gt; で指定される頂点プロパティのためのプロパティ・マップ・ オブジェクトを返す。&lt;code&gt;PropertyTag&lt;/code&gt; はグラフの &lt;code&gt;VertexProperty&lt;/code&gt; テンプレート引数中に指定されたプロパティの一つに一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; が頂点記述子か辺記述子のどちらか一方である場合、これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を &lt;code&gt;value&lt;/code&gt; にする。&lt;code&gt;x&lt;/code&gt; は頂点記述子か辺記述子のどちらか一方である。&lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_list, PropertyTag&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; と互換でなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_map.html&#34;&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_traits.html&#34;&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェックの利用 -- concept check : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html"/>
      <id>dbf1389e022545699b9e9f8bd3fa70c82b57acf7:archive/boost_docs/libs/concept_check/using_concept_check.md</id>
      <updated>2015-01-17 00:12:13 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンセプト・チェックの利用&lt;/h1&gt;
&lt;p&gt;各コンセプトに対して、与えられた型 (あるいは型の集合) がコンセプトをモデル化していることを確かめるために使用することができる、何らかのコンセプト・チェック用クラスが存在する。 Boost コンセプト・チェック・ライブラリ (BCCL) は、C++ 標準ライブラリの中で使用される全てのコンセプト＋αを対象とした、コンセプト・チェック用クラスを含んでいる。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt; セクションに、このコンセプト・チェック用クラスをリストしてある。 さらに、他の Boost ライブラリも、ライブラリ独自の特別なコンセプトに対応するコンセプト・チェック用クラスを付随している。 例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;graph concept&lt;/a&gt; および &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/property_map.html&#34;&gt;property map concept&lt;/a&gt; がある。 さらに、クラス・テンプレートや関数テンプレートを記述する者は、既存のコンセプトでカバーされていない要求事項を表現する必要のある場合は常に、新しいコンセプト・チェック用クラスを作成すべきである。 その方法は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt; セクションで説明する。&lt;/p&gt;
&lt;p&gt;BCCL のコンセプト・チェック用クラスの例として、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; クラスを挙げる。 このクラスは、C++ 標準 20.1.1 に記述されている &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) 要求事項および、SGI STL で文書化されている &lt;a href=&#34;http://www.sgi.com/tech/stl/EqualityComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;EqualityComparable&lt;/code&gt;&lt;/a&gt; (等値比較可能) コンセプトに相当する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EqualityComparableConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;テンプレート引数 &lt;code&gt;T&lt;/code&gt; はチェック対象の型と意図されている。 すなわち、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; の目的は、&lt;code&gt;T&lt;/code&gt; に対して与えられたテンプレート引数が 等値比較可能コンセプトをモデル化しているかどうか確認することである。&lt;/p&gt;
&lt;p&gt;個々のコンセプト・チェック用クラスには、該当するコンセプトにおいて有効な式を内包する &lt;code&gt;constraints()&lt;/code&gt; という名前のメンバー関数がある。 ある型が &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) であるかどうかチェックするためには、その型でコンセプト・チェック用クラスのインスタンスを生成し、次に、コンパイラに、実際に &lt;code&gt;constraints()&lt;/code&gt; 関数を実行することなくコンパイルさせる方法を見つける必要がある。 Boost コンセプト・チェック・ライブラリは、これを容易にする2つのユーティリティ： &lt;code&gt;function_requires()&lt;/code&gt; と &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; を定義している。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;function_requires()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;function_requires()&lt;/code&gt; 関数は関数本体の中で使用できる。また、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロはクラス定義本体で使用できる。 &lt;code&gt;function_requires()&lt;/code&gt; 関数は引数をとらないが、コンセプト・チェック用クラスを受けるためのテンプレート・パラメータを有する。 これは、以下に示すように、インスタンス化されたコンセプト・チェック用クラスを明示的にテンプレート引数として与えられなければならないことを意味する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; generic_library_function(T x)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; EqualityComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  foo f;
  generic_library_function(f);
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロは、ある型がコンセプトをモデル化しているかどうかチェックするために、クラス定義の内部で使用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; generic_library_class
{
  BOOST_CLASS_REQUIRE(T, boost, EqualityComparableConcept);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  generic_library_class&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; glc;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;以前の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating_example&#34;&gt;動機の例&lt;/a&gt; に対してコンセプト・チェックを応用する場合、良いやり方として、テンプレート・パラメータ型が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデル化していることを確認するために &lt;code&gt;std::stable_sort()&lt;/code&gt; の一番上に &lt;code&gt;function_requires()&lt;/code&gt; を挿入することが一つ挙げられる。 さらに、&lt;code&gt;std::stable_sort()&lt;/code&gt; は、イレテータの &lt;code&gt;value_type&lt;/code&gt; が&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;LessThanComparable&lt;/code&gt; (未満比較可能)&lt;/a&gt; を満足することが必要であるから、これをチェックするために、重ねて &lt;code&gt;function_requires()&lt;/code&gt; を使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIter first, RandomAccessIter last)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; RandomAccessIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type value_type;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; LessThanComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;value_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンセプトによっては複数の型を処理するものがある。 この場合、対応するコンセプト・チェック用クラスは複数のテンプレート・パラメータを持つことになる。 以下の例は、&lt;code&gt;function_requires()&lt;/code&gt; を、２つの型パラメータ（プロパティ・マップ型とそのキーとなる型）をとる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; コンセプトに対して使用する方法を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;IncidenceGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor Vertex;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ReadWritePropertyMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ColorMap, Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; の使用例として、&lt;code&gt;std::vector&lt;/code&gt; が有すべきコンセプト・チェックを考察する。 要素型に対して当てはめる要求事項の一つは、それが &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Assignable&lt;/code&gt; (割当可能)&lt;/a&gt;でなければならない、ということである。 これは、&lt;code&gt;std::vector&lt;/code&gt; の定義の一番上に&lt;code&gt;BOOST_CLASS_REQUIRE(T, boost, AssignableConcept)&lt;/code&gt;を挿入することにより、チェックすることができる。&lt;/p&gt;
&lt;p&gt;コンセプト・チェックは、ジェネリック・ライブラリの実装者が使用するために設計されているが、エンドユーザーにおいても有用である。 往々にして、ある型が特定のコンセプトをモデル化しているかどうか、不明確な場合がある。 こういうケースでは、問題の型とコンセプトを対象として &lt;code&gt;function_requires()&lt;/code&gt; を使用する、小さなプログラムを作成することで容易にチェックできる。 ファイル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/stl_concept_check.cpp.html&#34;&gt;stl_concept_checks.cpp&lt;/a&gt; は、STL コンテナにコンセプト・チェックを適応する実例となっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;次へ：「コンセプト・チェック用クラスの作成」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;前へ：「はじめに」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Distjoint Sets（互いに素な集合） -- disjoint_sets : リンク中のスペースを削除</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html"/>
      <id>c5b2473be845880fb0e11abf1a572442c628ed75:archive/boost_docs/libs/disjoint_sets.md</id>
      <updated>2015-01-17 00:10:26 +0900</updated>
      
        <content type="html">&lt;h1&gt;Distjoint Sets（互いに素な集合）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、互いに素な集合（素集合）の演算に 順位による和集合 および パス圧縮 を提供する。disjoint-sets のデータ構造は、素集合の S = {S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ..., S&lt;sub&gt;k&lt;/sub&gt;} というコレクションを維持する。 各集合は、集合のいくつかの要素である 代表値 によって識別される。 集合は、Parent プロパティマップの中の符号化された有向木によって表わされる。 2つの発見的手法: 「順位による和集合」 および 「パス圧縮」 は、 演算を高速化するのに使われる  [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#tarjan83&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#clr90&#34;&gt;2&lt;/a&gt;]。&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;boost/disjoint_sets.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Rank&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値型が整数型で、キー型が集合の要素型と等しい &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Parent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルで、かつ、キー型および値型は集合の要素型と等しくなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;disjoint_sets&lt;/code&gt; に対する典型的な使用法の手本は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/kruskal_minimum_spanning_tree.html&#34;&gt;&lt;code&gt;kruskal_minimum_spanning_tree()&lt;/code&gt;&lt;/a&gt; アルゴリズムで見ることができる。 この例では、&lt;code&gt;union_set()&lt;/code&gt; の代わりに &lt;code&gt;link()&lt;/code&gt; を呼び出す。 なぜなら、&lt;code&gt;u&lt;/code&gt; および &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;find_set()&lt;/code&gt; から得られ、したがって、既にそれら集合の代表値であるからだ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;...
disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; dsets(rank, p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (ui  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G).first; ui &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vertices(G).second; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ui)
  dsets.make_set(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ui);
...
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; ( &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;Q.empty() ) {
  e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Q.front();
  Q.pop();
  u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(source(e));
  v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(target(e));
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( u &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v ) {
    &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;out&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; e;
    dsets.link(u, v);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(Rank r, Parent p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(const disjoint_sets&amp;amp; x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void make_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Element x&lt;/code&gt; を含む単集合を作成する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void link(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; で表わされる 2つの集合を結合する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void union_set(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; を含む 2つの集合を結合する。 これは、&lt;code&gt;link(find_set(x),find_set(y))&lt;/code&gt; に相当する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Element find_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; を含む集合のための代表値を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;std::size_t count_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;素集合の個数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void compress_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;すべての要素の親がその代表値であるように親ツリーを平滑化する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Complexity&lt;/h2&gt;
&lt;p&gt;時間計算量は、O(m alpha(m,n)) である。alpha は逆アッカーマン関数、 m は disjoint-set の演算（&lt;code&gt;make_set()&lt;/code&gt;、&lt;code&gt;find_set()&lt;/code&gt;、および &lt;code&gt;link()&lt;/code&gt;）の総数、n は要素数である。 alpha 関数はとても遅く、log 関数よりもはるかに遅くなる。&lt;/p&gt;
&lt;p&gt;参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_connected_components.html&#34;&gt;&lt;code&gt;incremental_connected_components()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ID,InverseID,FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、順位および親のプロパティのための記憶領域を内部で管理する。 記憶領域は、要素IDにより索引付けされた配列の中にある。ゆえに、ID および InverseID ファンクタを必要とする。 順位および親のプロパティは、構築中に初期化される、 したがって、各要素は自動的に集合の中にある（従って、このクラスのオブジェクトを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.html#sec:initialize-incremental-components&#34;&gt;&lt;code&gt;initialize_incremental_components()&lt;/code&gt;&lt;/a&gt; 関数で初期化することは必要でない。）。 このクラスは、頂点プロパティを格納する場所を提供しない &lt;code&gt;edge_list&lt;/code&gt; グラフの（動的）接続している構成要素を計算する場合に特に有用である。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0からN（集合中の要素の総数）までの整数に要素を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;InverseID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素に整数を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;representative_with_full_path_compression&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;p&gt;このクラスは、以下のメンバだけでなく &lt;code&gt;disjoint_sets&lt;/code&gt; のすべてのメンバも持っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage(size_type n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
                           ID id &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ID(),
                           InverseID inv &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; InverseID())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンストラクタ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ElementIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;
  normalize_sets(ElementIterator first, ElementIterator last)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;各集合の代表値が最も小さな ID を備えた要素になるように代表値を再整理する。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事後条件: &lt;code&gt;v &amp;gt;= parent[v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事前条件: 素集合の構造は圧縮されていなければならない。 &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_path_halving&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; と同じ構成要素のための代表的な頂点を検索するファンクタである。 代表値木を横断している間、ファンクタは、さらに木の高さを短くするためにパス二分技術を適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_full_path_compression&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; が属する集合のための代表的な要素を検索するファンクタである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~llee1&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:llee1@lsc.nd.edu&#34;&gt;llee1@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:lums@lsc.nd.edu&#34;&gt;lums@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 IKOMA Yoshiki &lt;a href=&#34;mailto:ikoma@mb.i-chubu.ne.jp&#34;&gt;ikoma@mb.i-chubu.ne.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>全体的な設計の目標 -- 表示崩れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/DesignGoals.html"/>
      <id>9037274a16cd1e631be784ffeb3d703a5fbf876f:archive/boost_docs/libs/date_time/DesignGoals.md</id>
      <updated>2015-01-17 00:07:50 +0900</updated>
      
        <content type="html">&lt;h1&gt;全体的な設計の目標&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分類&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;インタフェース&lt;/td&gt;
&lt;td&gt;日付と時間を操作するための具体的なクラスを提供する&lt;/td&gt;
&lt;td&gt;・&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;date_duration&lt;/code&gt;, &lt;code&gt;time_duration&lt;/code&gt;, &lt;code&gt;date_period&lt;/code&gt;, &lt;code&gt;time_period&lt;/code&gt;, ほかにも&lt;br /&gt; 無限数のサポート - 正の無限大, 負の無限大&lt;br /&gt; ・時間と日付の範囲に対するイテレータ&lt;br /&gt; ・日付と時間の実装を可能な限り分離するよう考慮する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;計算&lt;/td&gt;
&lt;td&gt;効率的な時間計算を行うための基盤を提供する&lt;/td&gt;
&lt;td&gt;・日付の間の日数&lt;br /&gt; ・時間の差&lt;br /&gt; ・日付と時間を併せた時間長(durations)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表現の柔軟性&lt;/td&gt;
&lt;td&gt;最大限の再利用性と柔軟性を提供する&lt;/td&gt;
&lt;td&gt;・サイズと分解能を制御するための、traits に基づいた内部表現のカスタマイズ&lt;br /&gt; 異なるエポック(epoch)と分解能の使用が可能 (例:秒とマイクロ秒、2000年から始まる日付と1700年から始まる日付)&lt;br /&gt; ・独特な暦法の内部表現を設定するためのオプション (グレゴリオ暦 + その他)&lt;br /&gt; ・ユリウス通日(Julian Day Number)の使用、および、ユリウス通日とグレゴリオ暦/ユリウス暦との日付変換&lt;br /&gt; ・うるう秒を含む柔軟な調整を考慮する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日付の計算&lt;/td&gt;
&lt;td&gt;日付計算用のツールを提供&lt;/td&gt;
&lt;td&gt;・祝祭日のような複雑な行事予定を計算するための基盤を提供する&lt;br /&gt; ・ある暦法から別の暦法への変換&lt;br /&gt; ・新たな暦法系に拡張するための能力を提供&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;時間の計算&lt;/td&gt;
&lt;td&gt;時間を操作するための具体的なクラスを提供&lt;/td&gt;
&lt;td&gt;・異なった時間帯にまたがる問題を取り扱うための能力を提供&lt;br /&gt; ・昼時間の調整(サマータイム)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;クロックインタフェース&lt;/td&gt;
&lt;td&gt;現在の時刻を取得するクラスを提供&lt;/td&gt;
&lt;td&gt;・ネットワーク、高分解能時間源(time source)へのアクセス&lt;br /&gt; ・クラスに代入するための、現在の日付時間情報を取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O インタフェース&lt;/td&gt;
&lt;td&gt;時間を含む入出力を提供&lt;br /&gt;&lt;/td&gt;
&lt;td&gt;・多言語サポート&lt;br /&gt; ・ISO8601 に準拠した時間面&lt;br /&gt; ・異なるローカル(環境)での振る舞いのためにI/O面を使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 21 15:42:19 MST 2002 by &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost Date-Time Library Documentation -- Date Time : リンク切れを修正。DesignGoalsを移植し忘れていた。</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time.html"/>
      <id>129d9a6a2e662e88615f8b147324e44d64202881:archive/boost_docs/libs/date_time.md</id>
      <updated>2015-01-17 00:06:24 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost Date-Time Library Documentation&lt;/h1&gt;
&lt;p&gt;Version 1.00&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/date_time/doc/index.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/date_time/doc/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;概要&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#usage-examples&#34;&gt;Usage Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#domain-concepts&#34;&gt;Domain Concepts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#tests&#34;&gt;Tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#design-and-extensions&#34;&gt;Design and Extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#more-info&#34;&gt;More Info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html&#34;&gt;Build-Compiler Information&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日付プログラミング&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorian Date System&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html&#34;&gt;Class date&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_duration.html&#34;&gt;Class date_duration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date_period.html&#34;&gt;Class date_period&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_iterators.html&#34;&gt;Date Iterators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/date_algorithms.html&#34;&gt;Date Generators / Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_gregorian_calendar.html&#34;&gt;Class gregorian_calendar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_date.html#construct-from-clock&#34;&gt;Class day_clock&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;時間プログラミング&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Time System&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_ptime.html&#34;&gt;Class ptime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_duration.html&#34;&gt;Class time_duration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/class_time_period.html&#34;&gt;Class time_period&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/time_iterators.html&#34;&gt;Time Iterators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/local_time_adjust.html&#34;&gt;UTC / Local Time Adjustments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#introduction&#34; name=&#34;introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ジェネリックプログラミングの概念に基づいた日付・時間ライブラリ&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#motivation&#34; name=&#34;motivation&#34;&gt;Motivation&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このライブラリの開発動機は、多くのプロジェクトの多くの日付時間ライブラリで動作すること、また、それらの構築を手助けすることである。 日付時間ライブラリは多くの開発プロジェクトに対して、基礎的な構造を提供する。 しかしそれらの多くは、計算、書式化、変換、その他のいくつかの機能に限界がある。 例えば多くのライブラリは、うるう秒を正しく扱うこと、無限のような概念を提供すること、高分解能の時間資源やネットワーク上の時間資源を利用することが出来ない。 そのうえ、これらのライブラリは、どれも日付や時間の表現形式が厳密である傾向にあるため、プロジェクトやサブプロジェクトのためにカスタマイズすることが出来ない。&lt;/p&gt;
&lt;p&gt;日付や時間に関するプログラミングは、文字列や整数に関するプログラミングと同じくらいシンプルで自然であるべきである。 多くの時間論理を備えたアプリケーションは、演算子と計算能力の頑健な集合により、根本的に単純化することができる。 クラスは日付時間の比較、時間の長さ(length)や期間(duration)の加算、時計からの日付時間の取得、日付時間間隔(interval)に関する自然な動作を提供すべきである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#usage-examples&#34; name=&#34;usage-examples&#34;&gt;Usage Examples&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;次に，グレゴリオ暦システムの使用例を示す。 詳細は「&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;日付プログラミング&lt;/a&gt;」で解説する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;gregorian; 
date &lt;span style=&#34;color: #0000FF&#34;&gt;weekstart&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;2002&lt;/span&gt;,Feb,&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);
date &lt;span style=&#34;color: #0000FF&#34;&gt;weekend&lt;/span&gt;  (&lt;span style=&#34;color: #666666&#34;&gt;2002&lt;/span&gt;,Feb,&lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt;);
date_duration &lt;span style=&#34;color: #0000FF&#34;&gt;fiveDays&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;); 
date d3 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; d1 &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; fiveDays;
date today &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; day_clock&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;local_day();
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (d3 &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;=&lt;/span&gt; today) {} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//date comparison operators&lt;/span&gt;

date_period thisWeek(d1,d2);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (thisWeek.contains(today)) {}&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//do something&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//iterate and print the week&lt;/span&gt;
day_iterator itr(weekstart);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (; itr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;=&lt;/span&gt; weekend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;itr) {
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; to_iso_extended_string(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;itr) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;そして &lt;code&gt;posix_time&lt;/code&gt; システムの使用例である。 詳細は「&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;時間プログラミング&lt;/a&gt;」で解説する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;posix_time; 
date &lt;span style=&#34;color: #0000FF&#34;&gt;d&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;2002&lt;/span&gt;,Feb,&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//an arbitrary date&lt;/span&gt;
ptime &lt;span style=&#34;color: #0000FF&#34;&gt;t1&lt;/span&gt;(d, hours(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;nanosec(&lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;));&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//date + time of day offset&lt;/span&gt;
ptime t2 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; t1 &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; minutes(&lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;seconds(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;);
ptime now &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; second_clock&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;local_time(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//use the clock&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//Get the date part out of the time&lt;/span&gt;
date today &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; now.date();
date tommorrow &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; today &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; date_duration(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);
ptime &lt;span style=&#34;color: #0000FF&#34;&gt;tommorrow_start&lt;/span&gt;(tommorrow); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//midnight &lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//starting at current time iterator adds by one hour&lt;/span&gt;
time_iterator &lt;span style=&#34;color: #0000FF&#34;&gt;titr&lt;/span&gt;(now,hours(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)); 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (; titr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; tommorrow_start; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;titr) {
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; to_simple_string(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;titr) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#domain-concepts&#34; name=&#34;domain-concepts&#34;&gt;Domain Concepts&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;日付・時間の分野には専門用語と問題が多い。以下はライブラリ中に見られる概念の簡単な紹介である。&lt;/p&gt;
&lt;p&gt;このライブラリは3つの基本的な時間型をサポートする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Time Point&lt;ul&gt;
&lt;li&gt;時間位置。時刻。連続する時間内での位置を示す&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Time Duration&lt;ul&gt;
&lt;li&gt;時間長。時間連続体においてどの位置にも結びついていない時間の長さ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Time Interval&lt;ul&gt;
&lt;li&gt;時間間隔。時間連続体の特定の位置に結びついた時間長。期間とも&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの時間型にはそれぞれ表現可能な最小の時間間隔(duration)で定義される &lt;strong&gt;分解能&lt;/strong&gt; がある。 &lt;strong&gt;時法系(Time system)&lt;/strong&gt; は、時刻にラベルを付けて計算するための規則はもちろんのこと、これらすべての時間型も提供する。 &lt;strong&gt;暦法系(Calendar system)&lt;/strong&gt; は最大の分解能(1日)を持っている簡素な時法系である。 &lt;strong&gt;グレゴリオ暦&lt;/strong&gt; は今日最も広く使われている暦法系である(ISOシステムは基本的にこれの派生物である)。 しかし、他にも多くの暦法系がある。 &lt;strong&gt;UTC(Coordinated Universal Time;協定標準時)&lt;/strong&gt; は広く使われている民間の時法系である。UTC がうるう秒（これは、必要に応じて適用されるもので、予測可能ではない）の使用によって経度0において地球自転に対して調整される。 たいていの &lt;strong&gt;地域時間システム&lt;/strong&gt; が UTC に基づいているが、地球自転に対して同じように調整されるために、昼時間はどこでも同じである。 さらに、夏の昼時間を長くするためのサマータイム(DST)調整を含む地域時間もある。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;クロックデバイス&lt;/strong&gt; は時法系に関して現在の日付あるいは時刻を供給する(あるハードウェアに結び付けられた)ソフトウェアコンポーネントである。&lt;/p&gt;
&lt;p&gt;ライブラリは日付と時間の計算をサポートする。しかしながら、時間の計算は整数の計算と全く同じというわけにはいかない。 もし、時間計算の正確度(accuracy)が重要ならば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/tradeoffs.html&#34;&gt;Stability, Predictability, and Approximations(安定性、予測性と近似)&lt;/a&gt;を読む必要がある。&lt;/p&gt;
&lt;p&gt;追加資料を以下に示す&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/basic_terms.html&#34;&gt;基本的な専門用語&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/calculations.html&#34;&gt;計算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/tradeoffs.html&#34;&gt;安定性、予測性と近似&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/references.html&#34;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#tests&#34; name=&#34;tests&#34;&gt;Tests&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ライブラリは、以下のディレクトリで多数のテストを提供している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;libs/date_time/test &lt;/li&gt;
&lt;li&gt;libs/date_time/test/gregorian&lt;/li&gt;
&lt;li&gt;libs/date_time/test/posix_time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらのテストをビルドして実行することで、ライブラリが正しくインストールされ、確実に機能していることを確認できる。 加えて、これらのテストは新しいコンパイラへの移植を容易にする。 最後に、テストは使用例で明示的に記述されない多くの機能の例を提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#design-and-extensions&#34; name=&#34;design-and-extensions&#34;&gt;Design and Extensions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このライブラリの起源の大部分は（今まで）ほとんどの日付時間ライブラリがカスタマイズと拡張を許す方法で構築されないという観察であった。 典型的な例では、カレンダーロジックは直接日付クラスに構築される。 あるいは時計検索機能は直接時間クラスに作り上げられる。 これらのデザイン決定は通常、拡張したりライブラリの振る舞いを変更することを不可能にする。 もっと基本的なレベルにおいては、時間表現あるいはグレゴリオ暦の分解能について通常仮定がある。&lt;/p&gt;
&lt;p&gt;高分解能の時間表現やそれ以外の仮定からの要求を、時間ライブラリの実装が満たすことが出来ないために、結果的に不完全なライブラリを使わざるをえない、というのは、よくあることである。 この種のライブラリの開発は、まったく些細なことではないので、こういう結果は非常に残念なことである。&lt;/p&gt;
&lt;p&gt;（このライブラリの）設計は完璧というには程遠いが、それでも現在の設計は、著者の知るどんな時間ライブラリよりもはるかに柔軟である。 将来のバージョンでは、拡張性のさまざまな面について、さらに文書化されることが期待される。 ライブラリの設計目標についての情報は&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/DesignGoals.html&#34;&gt;ここ&lt;/a&gt;に要約されている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Many people have contributed to the development of this library. In particular Hugo Duncan and Joel de Guzman for help with porting to various compilers. For initial development of concepts and design Corwin Joy and Michael Kenniston deserve special thanks. Also extra thanks to Michael for writing up the theory and tradeoffs part of the documentation. Dave Zumbro for initial inspiration and sage thoughts. Many thanks to boost reviewers and users including: William Seymour, Kjell Elster, Beman Dawes, Gary Powell, Andrew Maclean, William Kempf, Peter Dimov, Chris Little, David Moore, Darin Adler, Gennadiy Rozental, Joachim Achtzehnter, Paul Bristow, Jan Langer, Mark Rodgers, Glen Knowles, Matthew Denman, and George Heintzelman.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html#more-info&#34; name=&#34;more-info&#34;&gt;More Info&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;現在、ライブラリの設計はWikiと電子メールによる議論によって発展している。 詳しい情報はこちらへ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?GDTL&#34; target=&#34;_blank&#34;&gt;Boost Wiki GDTL Start Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.crystalclearsoftware.com/libraries/date_time/index.html&#34; target=&#34;_blank&#34;&gt;Full Doxygen Reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Thu Sep 5 07:22:00 MST 2002 by Jeff Garland © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>全体的な設計の目標 -- Date Time : リンク切れを修正。DesignGoalsを移植し忘れていた。</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/DesignGoals.html"/>
      <id>129d9a6a2e662e88615f8b147324e44d64202881:archive/boost_docs/libs/date_time/DesignGoals.md</id>
      <updated>2015-01-17 00:06:24 +0900</updated>
      
        <content type="html">&lt;h1&gt;全体的な設計の目標&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分類&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;インタフェース&lt;/td&gt;
&lt;td&gt;日付と時間を操作するための具体的なクラスを提供する&lt;/td&gt;
&lt;td&gt;・&lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;date_duration&lt;/code&gt;, &lt;code&gt;time_duration&lt;/code&gt;, &lt;code&gt;date_period&lt;/code&gt;, &lt;code&gt;time_period&lt;/code&gt;, ほかにも&lt;br /&gt; 無限数のサポート - 正の無限大, 負の無限大&lt;br /&gt; ・時間と日付の範囲に対するイテレータ&lt;br /&gt; ・日付と時間の実装を可能な限り分離するよう考慮する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;計算&lt;/td&gt;
&lt;td&gt;効率的な時間計算を行うための基盤を提供する&lt;/td&gt;
&lt;td&gt;・日付の間の日数&lt;br /&gt; ・時間の差&lt;br /&gt; ・日付と時間を併せた時間長(durations)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表現の柔軟性&lt;/td&gt;
&lt;td&gt;最大限の再利用性と柔軟性を提供する&lt;br /&gt; ・サイズと分解能を制御するための、traits に基づいた内部表現のカスタマイズ&lt;br /&gt; 異なるエポック(epoch)と分解能の使用が可能 (例:秒とマイクロ秒、2000年から始まる日付と1700年から始まる日付)&lt;br /&gt; ・独特な暦法の内部表現を設定するためのオプション (グレゴリオ暦 + その他)&lt;br /&gt; ・ユリウス通日(Julian Day Number)の使用、および、ユリウス通日とグレゴリオ暦/ユリウス暦との日付変換&lt;br /&gt; ・うるう秒を含む柔軟な調整を考慮する&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;日付の計算&lt;/td&gt;
&lt;td&gt;日付計算用のツールを提供&lt;/td&gt;
&lt;td&gt;・祝祭日のような複雑な行事予定を計算するための基盤を提供する&lt;br /&gt; ・ある暦法から別の暦法への変換&lt;br /&gt; ・新たな暦法系に拡張するための能力を提供&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;時間の計算&lt;/td&gt;
&lt;td&gt;時間を操作するための具体的なクラスを提供&lt;/td&gt;
&lt;td&gt;・異なった時間帯にまたがる問題を取り扱うための能力を提供&lt;br /&gt; ・昼時間の調整(サマータイム)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;クロックインタフェース&lt;/td&gt;
&lt;td&gt;現在の時刻を取得するクラスを提供&lt;/td&gt;
&lt;td&gt;・ネットワーク、高分解能時間源(time source)へのアクセス&lt;br /&gt; ・クラスに代入するための、現在の日付時間情報を取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O インタフェース&lt;/td&gt;
&lt;td&gt;時間を含む入出力を提供&lt;br /&gt;&lt;/td&gt;
&lt;td&gt;・多言語サポート&lt;br /&gt; ・ISO8601 に準拠した時間面&lt;br /&gt; ・異なるローカル(環境)での振る舞いのためにI/O面を使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 21 15:42:19 MST 2002 by &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>