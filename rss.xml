<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2014-12-08T15:51:12.467279</updated>
  <id>a712577f-04b0-4477-a713-27c376c3b9fd</id>

  
    <entry>
      <title>Header `&lt;boost/function.hpp&gt;` -- Boost.Function : Reference manualを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function.html"/>
      <id>d53b81221ad7bd6388320a975f526476a29d9154:archive/boost_docs/libs/function.md</id>
      <updated>2014-12-08 15:51:01 +0900</updated>
      
        <content type="html">&lt;h1&gt;Header &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/doc/html/function.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/doc/html/function.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ヘッダファイル &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt; に含まれるのは、関数オブジェクトのラッパとなるクラステンプレート群である。 Boost.Function の概念はコールバックを一般化したものだ。 Boost.Function は以下の点で関数ポインタと共通の特徴をもっている。 1 つは、何らかの実装によって呼び出される「呼び出しのインタフェース」 (例: 2 つの &lt;code&gt;int&lt;/code&gt; 型引数を取り、 &lt;code&gt;float&lt;/code&gt; を返す関数) を定義していること。もう 1 つは、呼び出される実装をプログラム実行中に変更できる事だ。&lt;/p&gt;
&lt;p&gt;一般に、遅延呼び出しやコールバックを実現するために関数ポインタを使うあらゆる場面で、代わりに Boost.Function を使用できる。そして、それによって呼ばれる側の実装はぐっと自由になる。呼ばれる側にはあらゆる「互換性のある」関数オブジェクト (や関数ポインタ) が指定できる。「互換性がある」とは、 Boost.Function に渡した引数が、対象となる関数オブジェクトの引数に変換できるということだ(訳注：戻り値にも互換性が必要)。&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#compatibility-note&#34;&gt;Compatibility Note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/tutorial.html&#34;&gt;Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html&#34;&gt;Reference manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#function-vs-function-pointers&#34;&gt;Boost.Function vs. Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#portability&#34;&gt;Portability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#design-rationale&#34;&gt;Design rationale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Frequently Asked Questions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compatibility-note&#34; name=&#34;compatibility-note&#34;&gt;Compatibility Note&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function は、インタフェースを小さく、分かりやすくするために、一部が再設計された。昔の Boost.Function にあった、いくつかのめったに (または決して) 使われない機能は推奨されなくなり、近々削除される。以下に推奨されなくなった機能とその理由、それに伴うコードの修正法をリストアップする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::function&lt;/code&gt; クラステンプレートの文法が変更された。以前は&lt;code&gt;boost::function&amp;lt;int, float, double, std::string&amp;gt;&lt;/code&gt;のように書いたが、 &lt;code&gt;boost::function&amp;lt;int (float, double, std::string)&amp;gt;&lt;/code&gt;のような、より自然な書き方になった。戻り値と全ての引数の型が、 1 つの関数型のパラメータに収まる事になったのだ。残りのテンプレートパラメータ (&lt;code&gt;Allocator&lt;/code&gt;など) が、この関数型パラメータの後に続く。
    この変更への対応は、コンパイラに依存する。あなたのコンパイラがテンプレートの部分特殊化版をサポートし、関数型をパース (これは大抵 OK) できるなら、新しい文法を使うようにソースを修正してもいいし (推奨) 、文法が変わっていない&lt;code&gt;functionN&lt;/code&gt; クラスを直接使ってもいい。あなたのコンパイラがテンプレートの部分特殊化版か関数型をサポートしていなければ、&lt;code&gt;functionN&lt;/code&gt;クラスを使う必要がある。&lt;code&gt;functionN&lt;/code&gt;クラスを使うように修正するのは簡単で、クラス名の最後に引数の数を加えるだけだ (例: &lt;code&gt;boost::function&amp;lt;void, int, int&amp;gt;&lt;/code&gt; を &lt;code&gt;boost::function2&amp;lt;void, int, int&amp;gt;&lt;/code&gt; に変更) 。
    &lt;code&gt;boost::function&lt;/code&gt; クラステンプレートの古い文法のサポートはしばらく続くが、いつかは削除される。削除した方がエラーメッセージが分かりやすくなり、リンク互換性が良くなるからだ。&lt;/li&gt;
&lt;li&gt;呼び出しポリシーのテンプレートパラメータ (&lt;code&gt;Policy&lt;/code&gt;) は推奨されておらず、将来削除される。この機能はめったに使われないので、代替となる機能は無い。&lt;/li&gt;
&lt;li&gt;ミックスインのテンプレートパラメータ (&lt;code&gt;Mixin&lt;/code&gt;) は推奨されておらず、将来削除される。この機能はめったに使われないので、代替となる機能は無い。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt; メソッドは推奨されておらず、将来削除される。代わりに代入演算子を使えば良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しい文法に移行し、推奨されない機能を削除するためには、 &lt;code&gt;BOOST_FUNCTION_NO_DEPRECATED&lt;/code&gt; プリプロセサマクロを定義する。このマクロを定義すると、推奨されない全ての機能が使えなくなる。 &lt;code&gt;BOOST_FUNCTION_NO_DEPRECATED&lt;/code&gt; を使ってコンパイルされたプログラムなら、推奨されない機能が削除されても大丈夫だ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function-vs-function-pointers&#34; name=&#34;function-vs-function-pointers&#34;&gt;Boost.Function vs. Function Pointers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function には関数ポインタに比べていくつかの利点がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Function は、任意の互換性がある関数オブジェクトを格納できる (関数ポインタは全く同じシグネチャを持つ関数しか受け付けない) 。&lt;/li&gt;
&lt;li&gt;Boost.Function は、引数の束縛などの関数オブジェクトを作り出すライブラリと共用できる。&lt;/li&gt;
&lt;li&gt;Boost.Function を使えば、空の関数オブジェクトの呼び出しを、デバッグ時に簡単に検出できる。&lt;/li&gt;
&lt;li&gt;Boost.Function では、それぞれの呼び出しの前後に、ある操作を実行するように指定できる。例えば、同期用の基本命令を関数型の一部にすることができる(訳注：この機能 (呼び出しポリシー) は推奨されておらず、将来削除される)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そしてもちろん、関数ポインタにも Boost.Function に比べていくつかの利点がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数ポインタはサイズが小さい (関数ポインタはポインタ 1 つ、 Boost.Function はポインタ 3 つ) 。&lt;/li&gt;
&lt;li&gt;関数ポインタは高速だ (Boost.Function は関数ポインタを通した呼び出しを 2 回する可能性がある) 。&lt;/li&gt;
&lt;li&gt;関数ポインタは C のライブラリと下位互換性がある。&lt;/li&gt;
&lt;li&gt;エラーメッセージが読みやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上 2 つのリストは Darin Adler のコメントを編集したものである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/performance&#34; name=&#34;performance&#34;&gt;Performance&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Function object wrapper size&lt;/h3&gt;
&lt;p&gt;関数オブジェクトのラッパのサイズは 2 つの関数ポインタと、 1 つの関数ポインタまたはデータのポインタ (の大きい方) のサイズになる。一般的な 32 ビットプラットフォームでは、 1 つのラッパ当たり 12 バイトになる。さらに、対象となる関数オブジェクトがヒープに割り当てられる。&lt;/p&gt;
&lt;h3&gt;Copying efficiency&lt;/h3&gt;
&lt;p&gt;関数オブジェクトのラッパのコピーによって、格納された関数オブジェクトのコピーのためにメモリ割り当てが発生する。デフォルトのアロケータを、もっと速いカスタムアロケータで置換することもできる。また、関数オブジェクトのラッパが、対象となる関数オブジェクトの「参照」を格納するように指定できる (&lt;code&gt;ref&lt;/code&gt;を使用) 。これは関数オブジェクトのコピーが酷く高価な場合に有効だ。&lt;/p&gt;
&lt;h3&gt;Invocation efficiency&lt;/h3&gt;
&lt;p&gt;適切なインライン化を行うコンパイラならば、関数オブジェクトの呼び出しによって、関数ポインタを通した呼び出しが 1 回行われる。非メンバ関数ポインタの呼び出しならば、その関数ポインタの呼び出しに加えて、もう 1 回の呼び出しが行われる (コンパイラがとても強力な関数をまたいだ分析を行うならば別だが) 。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/portability&#34; name=&#34;portability&#34;&gt;Portability&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function は、できるだけ移植性を高めるように、できるだけ多くのコンパイラ (C++ 標準準拠度が低いものも含む) をサポートするように設計されている。以下のコンパイラは &lt;code&gt;boost::function&lt;/code&gt;に含まれる全てのテストケースに合格した。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 2.95.3&lt;/li&gt;
&lt;li&gt;GCC 3.0&lt;/li&gt;
&lt;li&gt;SGI MIPSpro 7.3.0&lt;/li&gt;
&lt;li&gt;Borland C++ 5.5.1&lt;/li&gt;
&lt;li&gt;Comeau C++ 4.2.45.2&lt;/li&gt;
&lt;li&gt;Metrowerks Codewarrior 6.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下のコンパイラでも &lt;code&gt;boost::function&lt;/code&gt;を使えるが、いくつか問題がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft Visual C++ 6.0 (service pack 5): アロケータはサポートされない。 &lt;code&gt;boost::function&lt;/code&gt; クラステンプレートにいくつか問題がある ( &lt;code&gt;boost::functionN&lt;/code&gt; の方は動作するようだ) 。&lt;/li&gt;
&lt;li&gt;Intel C++ 5.0: アロケータはサポートされない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あなたのコンパイラが上のリストになければ、 &lt;code&gt;boost::function&lt;/code&gt; ライブラリを使えるかチェックするための小さなテスト群があるので、これを使える。標準に準拠したコンパイラなら、修正無しでコードをコンパイルできるはずだが、問題が起きたらバグレポートを送ってほしい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/design-rationale&#34; name=&#34;design-rationale&#34;&gt;Design rationale&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Combatting virtual function bloat&lt;/h3&gt;
&lt;p&gt;多くのコンパイラでは、仮想関数の使用によって「コードの膨張」が起きがちである。クラスが仮想関数を持つ場合、オブジェクトの型を分類する補助関数を作る必要がある。私達の経験では、多くの &lt;code&gt;boost::function&lt;/code&gt; オブジェクトが使われると、この補助関数が実行可能ファイルのサイズを大きく膨張させる。&lt;/p&gt;
&lt;p&gt;Boost.Function では、仮想関数の代わりに非メンバ関数を使った、代わりの等価なアプローチをとっている。 Boost.Function オブジェクトが関数オブジェクトを呼び出すためには、本質的に 2 つのポインタを持つ必要がある。所有する関数オブジェクトへの &lt;code&gt;void&lt;/code&gt; ポインタと、関数オブジェクトの「呼び出し役」への &lt;code&gt;void&lt;/code&gt; ポインタ (関数ポインタが代入される) だ。 Boost.Function が提供する、引数と戻り値の変換は、この呼び出し役が実行する。第 3 のポインタは「管理者」と呼ばれる非メンバ関数を指す。これは関数オブジェクトのコピーと破棄を扱う。この方法はタイプセーフだ。なぜなら、関数オブジェクトを実際に扱う関数である呼び出し役と管理者は、関数オブジェクトの型を知らされてインスタンス化されるので、入ってくる &lt;code&gt;void&lt;/code&gt; ポインタ (関数オブジェクトへのポインタ) を、正しい型に安全にキャストできるからだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;たくさんの人がこのライブラリの作成に参加した。 William Kempf 、 Jesse Jones 、 Karl Nelson は、ライブラリのインタフェースと守備範囲を、他のライブラリとは独立したものにする上で大きな助けになってくれた。 John Maddock は公式なレビューをやってくれた。他にもたくさんの人がレビューをして、インタフェース、実装、ドキュメントについて優れたコメントを寄せてくれた。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.Function Reference Manual -- Boost.Function : Reference manualを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function/reference.html"/>
      <id>d53b81221ad7bd6388320a975f526476a29d9154:archive/boost_docs/libs/function/reference.md</id>
      <updated>2014-12-08 15:51:01 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost.Function Reference Manual&lt;/h1&gt;
&lt;h2&gt;Header &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt; synopsis&lt;/h2&gt;
&lt;p&gt;以下で、 &lt;code&gt;MAX_ARGS&lt;/code&gt; は実装定義の定数であり、 Boost.Function でサポートされる引数の数の最大値 (少なくとも 10) である。このドキュメント中で参照される &lt;code&gt;MAX_ARGS&lt;/code&gt; 定数は、ライブラリ中で直接的には定義されていない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;function_base&lt;/span&gt;
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; implementation&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;defined safe_bool;
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; empty() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
  };

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// [0, MAX_ARGS] の範囲の全ての N について&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Signature,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg1,
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg2,
           ...
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ArgN,
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy    &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; empty_function_policy, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; empty_function_mixin, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;function_base&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;functionN&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; function_base, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; Mixin
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ResultType result_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#note&#34;&gt;[1]&lt;/a&gt;&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Policy     policy_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Mixin      mixin_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Allocator  allocator_type;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg1 argument_type;        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// N == 1 の場合&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg1 first_argument_type;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// N == 2 の場合&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg2 second_argument_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// N == 2 の場合&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg1 arg1_type;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Arg2 arg2_type;
             .
             .
             .
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ArgN argN_type;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { arity &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; N };

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 構築&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;functionN&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Mixin&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Mixin());
    functionN(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(F, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Mixin&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Mixin());
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 代入&lt;/span&gt;
    functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(F);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;);
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set(F); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;swap&lt;/span&gt;(functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;clear&lt;/span&gt;();

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// bool 型の文脈&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt; safe_bool() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 呼び出し&lt;/span&gt;
    result_type &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Arg1 a1, Arg2 a2, ..., ArgN aN) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
  };

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ResultType,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg1,
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg2,
           ...
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ArgN,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;,
            functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;);

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// [0, MAX_ARGS] の範囲の全ての N について&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Signature, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 関数型: ResultType (Arg1, Arg2, ..., ArgN)&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy    &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; empty_function_policy, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; empty_function_mixin, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;function_base&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 構築&lt;/span&gt;
    function();
    function(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    function(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(F);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 代入&lt;/span&gt;
    function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
    function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(F);
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; function&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set(F); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
  };

  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Signature, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Signature, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;,
            function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Signature, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/definitions&#34; name=&#34;definitions&#34;&gt;定義&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引数型 &lt;code&gt;Arg1&lt;/code&gt;, &lt;code&gt;Arg2&lt;/code&gt;, ..., &lt;code&gt;ArgN&lt;/code&gt; と戻り値型 &lt;code&gt;ResultType&lt;/code&gt; に対して、該当する以下の関数が適格な時、関数オブジェクト &lt;code&gt;f&lt;/code&gt; は「 互換性がある 」という。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 関数型が void 以外の場合&lt;/span&gt;
ResultType &lt;span style=&#34;color: #0000FF&#34;&gt;foo&lt;/span&gt;(Arg1 arg1, Arg2 arg2, ..., ArgN argN)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; f(arg1, arg2, ..., argN);
}

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 関数型が void の場合&lt;/span&gt;
ResultType &lt;span style=&#34;color: #0000FF&#34;&gt;foo&lt;/span&gt;(Arg1 arg1, Arg2 arg2, ..., ArgN argN)
{
  f(arg1, arg2, ..., argN);
}
&lt;/pre&gt;&lt;/div&gt;

メンバ関数ポインタには、特別な規定がある。メンバ関数ポインタは関数オブジェクトではないが、 Boost.Function は内部的にメンバ関数ポインタを関数オブジェクトに作り変える。 &lt;code&gt;R (X::*mf)(Arg1, Arg2, ..., ArgN) cv-quals&lt;/code&gt; の形のメンバ関数ポインタは、以下のように関数呼出し演算子をオーバロードした関数オブジェクトに作り変えられる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; P&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
R &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(cv&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;quals P&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x, Arg1 arg1, Arg2 arg2, ..., ArgN argN) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;x).&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;mf(arg1, arg2, ..., argN);
}
&lt;/pre&gt;&lt;/div&gt;

- &lt;code&gt;F&lt;/code&gt; が関数ポインタであるか、 &lt;code&gt;boost::is_stateless&amp;lt;T&amp;gt;&lt;/code&gt; が真の時、 &lt;code&gt;F&lt;/code&gt; 型の関数オブジェクト &lt;code&gt;f&lt;/code&gt; は「 状態を持たない 」という。状態を持たない関数オブジェクトの Boost.Function での構築/コピーは発生せず、例外は起きず、記憶域の割り当ても起きない。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Class &lt;code&gt;function_base&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;クラス &lt;code&gt;function_base&lt;/code&gt; は全ての Boost.Function オブジェクトに共通する基底クラスだ。 &lt;code&gt;function_base&lt;/code&gt; 型のオブジェクトが直接作られることはないだろう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; empty() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

- 戻り値: 関数オブジェクトを格納していれば &lt;code&gt;true&lt;/code&gt; 、そうでなければ &lt;code&gt;false&lt;/code&gt; 。
- 例外: 例外を起こさない。&lt;/p&gt;
&lt;h2&gt;Class template &lt;code&gt;functionN&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;クラステンプレート &lt;code&gt;functionN&lt;/code&gt; は実際には、 &lt;code&gt;function0&lt;/code&gt;, &lt;code&gt;function1&lt;/code&gt;, ... と、ある実装定義の最大値まで続く、関連するクラス群である。以下の文では、 &lt;code&gt;N&lt;/code&gt; はパラメータの数、 &lt;code&gt;f&lt;/code&gt; は暗黙のオブジェクトパラメータを表す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;functionN&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Mixin&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Mixin());
&lt;/pre&gt;&lt;/div&gt;

- 作用: 与えられたミックスインから &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトを構築する。
- 事後条件: &lt;code&gt;f.empty()&lt;/code&gt;
- 例外: &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトの構築で例外が起きない限り、例外を起こさない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;functionN(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;

- 事後条件: &lt;code&gt;g&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; が格納する関数オブジェクトのコピーを格納する。 &lt;code&gt;g.empty()&lt;/code&gt; ならば &lt;code&gt;f&lt;/code&gt; も空になる。 &lt;code&gt;f&lt;/code&gt; のミックスインは、 &lt;code&gt;g&lt;/code&gt; のミックスインからコピーされる。
- 例外: &lt;code&gt;g&lt;/code&gt; が格納する関数オブジェクトのコピーや &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトの構築で例外が起きない限り、例外を起こさない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(F g, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Mixin&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Mixin());
&lt;/pre&gt;&lt;/div&gt;

- 必須事項: &lt;code&gt;g&lt;/code&gt; は&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#definitions&#34;&gt;互換性がある&lt;/a&gt;関数オブジェクトであること。
- 作用: 与えられたミックスインから &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトを構築する。
- 事後条件: &lt;code&gt;g&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; のコピーを格納する。 &lt;code&gt;g&lt;/code&gt; が空ならば、 &lt;code&gt;f.empty()&lt;/code&gt; が真となる。
- 例外: &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトの構築で例外が起きず、 &lt;code&gt;g&lt;/code&gt; が状態を持たない関数オブジェクトならば、例外を起こさない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN(reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;

- 必須事項: &lt;code&gt;g.get()&lt;/code&gt; は&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#definitions&#34;&gt;互換性がある&lt;/a&gt;関数オブジェクトであること。
- 作用: 与えられたミックスインから &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトを構築する。
- 事後条件: &lt;code&gt;g.get()&lt;/code&gt; が空でなければ、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; (&lt;code&gt;g.get()&lt;/code&gt;のコピーではない) を格納する。 &lt;code&gt;g.get()&lt;/code&gt; が空ならば、 &lt;code&gt;this-&amp;gt;empty()&lt;/code&gt; が真となる。
- 例外: &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトの構築で例外が起きない限り、例外を起こさない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;

- 事後条件: &lt;code&gt;g&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; が格納する関数オブジェクトのコピーを格納する。 &lt;code&gt;g.empty()&lt;/code&gt; ならば、 &lt;code&gt;f&lt;/code&gt; も空になる。 &lt;code&gt;f&lt;/code&gt; のミックスインには &lt;code&gt;g&lt;/code&gt; のミックスインが代入される。
- 戻り値: &lt;code&gt;*this&lt;/code&gt;
- 例外: &lt;code&gt;g&lt;/code&gt; が&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/reference.html#definitions&#34;&gt;状態を持たない&lt;/a&gt;関数オブジェクトを格納しているか、 &lt;code&gt;g&lt;/code&gt; が関数オブジェクトへの参照を格納してる場合は、例外を起こさない。ただし、 &lt;code&gt;Mixin&lt;/code&gt; 型サブオブジェクトのコピーで例外が起きた場合を除く。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(F g);
&lt;/pre&gt;&lt;/div&gt;

- 必須事項: &lt;code&gt;g&lt;/code&gt; は互換性がある関数オブジェクトであること。
- 事後条件: &lt;code&gt;g&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; のコピーを格納する。 &lt;code&gt;g&lt;/code&gt; が空ならば、 &lt;code&gt;f.empty()&lt;/code&gt; が真となる。
- 戻り値: &lt;code&gt;*this&lt;/code&gt;
- 例外: &lt;code&gt;g&lt;/code&gt; が状態を持たない関数オブジェクトを格納していれば、例外を起こさない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(reference_wrapper&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;

- 必須事項: &lt;code&gt;g.get()&lt;/code&gt; が互換性がある関数オブジェクトであること。
- 事後条件: &lt;code&gt;g.get()&lt;/code&gt; が空でなければ、 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;g.get()&lt;/code&gt; ( &lt;code&gt;g.get()&lt;/code&gt; のコピーではない) を格納する。 &lt;code&gt;g.get()&lt;/code&gt; が空ならば、 &lt;code&gt;f.empty()&lt;/code&gt; が真となる。
- 戻り値: &lt;code&gt;*this&lt;/code&gt;
- 例外: &lt;code&gt;this&lt;/code&gt; が格納していた関数オブジェクトの破棄で例外が起きた場合のみ、例外を起こす。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;

- 作用: &lt;code&gt;*this = g&lt;/code&gt;
- 注意: この関数の使用は推奨されない。この関数は Boost.Function の将来のバージョンで削除される。代わりに代入演算子を使って欲しい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; F&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set(F g);
&lt;/pre&gt;&lt;/div&gt;

- 作用: &lt;code&gt;*this = g&lt;/code&gt;
- 注意: この関数の使用は推奨されない。この関数は Boost.Function の将来のバージョンで削除される。代わりに代入演算子を使って欲しい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;swap&lt;/span&gt;(functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;

- 作用: &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;g&lt;/code&gt; が格納する関数オブジェクトを交換し、 &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;g&lt;/code&gt; のミックスインを交換する。
- 例外: 例外は発生しない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;clear&lt;/span&gt;();
&lt;/pre&gt;&lt;/div&gt;

- 作用: &lt;code&gt;!empty()&lt;/code&gt;ならば、格納する関数オブジェクトを破棄する。
- 事後条件: &lt;code&gt;empty()&lt;/code&gt;が真になる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt; safe_bool() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

- 戻り値: &lt;code&gt;!empty()&lt;/code&gt;と等価な&lt;code&gt;safe_bool&lt;/code&gt; 。
- 例外: 例外は発生しない。
- 注意: &lt;code&gt;safe_bool&lt;/code&gt; 型は bool 型が予想される場所 (例: &lt;code&gt;if&lt;/code&gt; の条件) に使用できる。しかし、 &lt;code&gt;bool&lt;/code&gt; 型で起きる暗黙の型変換 (例: &lt;code&gt;int&lt;/code&gt;型への変換) は許されない。これによってユーザの間違いの元を減らせることがある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

- 戻り値: &lt;code&gt;this-&amp;gt;empty()&lt;/code&gt;
- 例外: 例外は発生しない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;result_type &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Arg1 a1, Arg2 a2, ..., ArgN aN) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

- 必須事項: !empty()
- 作用: 以下で、 &lt;code&gt;target&lt;/code&gt; は格納された関数オブジェクトである。 &lt;code&gt;target&lt;/code&gt; 変数には &lt;code&gt;const&lt;/code&gt; 修飾子や &lt;code&gt;volatile&lt;/code&gt; 修飾子が付いていない (ので、関数呼出し演算子に &lt;code&gt;const&lt;/code&gt; 修飾子や &lt;code&gt;volatile&lt;/code&gt; 修飾子が付いている必要はない) 。
    1. &lt;code&gt;policy_type policy;&lt;/code&gt;
    2. &lt;code&gt;policy.precall(this);&lt;/code&gt;
    3. &lt;code&gt;target(a1, a2, ..., aN);&lt;/code&gt;
    4. &lt;code&gt;policy.postcall(this);&lt;/code&gt;
- 戻り値: &lt;code&gt;target&lt;/code&gt; の戻り値。
- 注意: 呼び出しポリシーは推奨されなくなり、今後のリリースで削除される。&lt;/p&gt;
&lt;h2&gt;Class template &lt;code&gt;function&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;クラステンプレート &lt;code&gt;function&lt;/code&gt; は、番号付きクラステンプレート &lt;code&gt;function0&lt;/code&gt;, &lt;code&gt;function1&lt;/code&gt;, ... の薄いラッパである。 &lt;code&gt;MAX_ARGS&lt;/code&gt; までの引数を受け付ける。 &lt;code&gt;N&lt;/code&gt; 個の引数を渡されれば、 &lt;code&gt;functionN&lt;/code&gt; (引数 &lt;code&gt;N&lt;/code&gt; 個専用のクラス) から派生する。&lt;/p&gt;
&lt;p&gt;クラステンプレート &lt;code&gt;function&lt;/code&gt; のメンバ関数のセマンティクスは、全て &lt;code&gt;functionN&lt;/code&gt; オブジェクトと同じである。ただし、 &lt;code&gt;function&lt;/code&gt; オブジェクトの正しいコピーコンストラクトやコピーの代入のために、追加のメンバ関数を定義している。&lt;/p&gt;
&lt;h3&gt;Operations&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ResultType,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg1,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Arg2,
         ...
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ArgN,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 推奨されない&lt;/span&gt;
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; f,
          functionN&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ResultType, Arg1, Arg2, ..., ArgN, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;

- 作用: &lt;code&gt;f.swap(g);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Signature, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Policy, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Mixin, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Signature, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; f,
          function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Signature, Policy, Mixin, Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; g);
&lt;/pre&gt;&lt;/div&gt;

- 作用: &lt;code&gt;f.swap(g);&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;脚注&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[1] : コンパイラが &lt;code&gt;void&lt;/code&gt; 型の &lt;code&gt;return&lt;/code&gt; をサポートしていない場合、 &lt;code&gt;ReturnType&lt;/code&gt; に &lt;code&gt;void&lt;/code&gt; を指定すると、 Boost.Function オブジェクトの &lt;code&gt;result_type&lt;/code&gt; は実装依存になる。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Last modified: Fri Oct 11 05:40:09 EDT 2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Header `&lt;boost/function.hpp&gt;` -- Boost.Function : Tutorialを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function.html"/>
      <id>59cdfc548da6598628853074b00162e0158adbe4:archive/boost_docs/libs/function.md</id>
      <updated>2014-12-08 15:18:24 +0900</updated>
      
        <content type="html">&lt;h1&gt;Header &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/doc/html/function.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/doc/html/function.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ヘッダファイル &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt; に含まれるのは、関数オブジェクトのラッパとなるクラステンプレート群である。 Boost.Function の概念はコールバックを一般化したものだ。 Boost.Function は以下の点で関数ポインタと共通の特徴をもっている。 1 つは、何らかの実装によって呼び出される「呼び出しのインタフェース」 (例: 2 つの &lt;code&gt;int&lt;/code&gt; 型引数を取り、 &lt;code&gt;float&lt;/code&gt; を返す関数) を定義していること。もう 1 つは、呼び出される実装をプログラム実行中に変更できる事だ。&lt;/p&gt;
&lt;p&gt;一般に、遅延呼び出しやコールバックを実現するために関数ポインタを使うあらゆる場面で、代わりに Boost.Function を使用できる。そして、それによって呼ばれる側の実装はぐっと自由になる。呼ばれる側にはあらゆる「互換性のある」関数オブジェクト (や関数ポインタ) が指定できる。「互換性がある」とは、 Boost.Function に渡した引数が、対象となる関数オブジェクトの引数に変換できるということだ(訳注：戻り値にも互換性が必要)。&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#compatibility-note&#34;&gt;Compatibility Note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/tutorial.html&#34;&gt;Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Reference manual&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#function-vs-function-pointers&#34;&gt;Boost.Function vs. Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#portability&#34;&gt;Portability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#design-rationale&#34;&gt;Design rationale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Frequently Asked Questions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compatibility-note&#34; name=&#34;compatibility-note&#34;&gt;Compatibility Note&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function は、インタフェースを小さく、分かりやすくするために、一部が再設計された。昔の Boost.Function にあった、いくつかのめったに (または決して) 使われない機能は推奨されなくなり、近々削除される。以下に推奨されなくなった機能とその理由、それに伴うコードの修正法をリストアップする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::function&lt;/code&gt; クラステンプレートの文法が変更された。以前は&lt;code&gt;boost::function&amp;lt;int, float, double, std::string&amp;gt;&lt;/code&gt;のように書いたが、 &lt;code&gt;boost::function&amp;lt;int (float, double, std::string)&amp;gt;&lt;/code&gt;のような、より自然な書き方になった。戻り値と全ての引数の型が、 1 つの関数型のパラメータに収まる事になったのだ。残りのテンプレートパラメータ (&lt;code&gt;Allocator&lt;/code&gt;など) が、この関数型パラメータの後に続く。
    この変更への対応は、コンパイラに依存する。あなたのコンパイラがテンプレートの部分特殊化版をサポートし、関数型をパース (これは大抵 OK) できるなら、新しい文法を使うようにソースを修正してもいいし (推奨) 、文法が変わっていない&lt;code&gt;functionN&lt;/code&gt; クラスを直接使ってもいい。あなたのコンパイラがテンプレートの部分特殊化版か関数型をサポートしていなければ、&lt;code&gt;functionN&lt;/code&gt;クラスを使う必要がある。&lt;code&gt;functionN&lt;/code&gt;クラスを使うように修正するのは簡単で、クラス名の最後に引数の数を加えるだけだ (例: &lt;code&gt;boost::function&amp;lt;void, int, int&amp;gt;&lt;/code&gt; を &lt;code&gt;boost::function2&amp;lt;void, int, int&amp;gt;&lt;/code&gt; に変更) 。
    &lt;code&gt;boost::function&lt;/code&gt; クラステンプレートの古い文法のサポートはしばらく続くが、いつかは削除される。削除した方がエラーメッセージが分かりやすくなり、リンク互換性が良くなるからだ。&lt;/li&gt;
&lt;li&gt;呼び出しポリシーのテンプレートパラメータ (&lt;code&gt;Policy&lt;/code&gt;) は推奨されておらず、将来削除される。この機能はめったに使われないので、代替となる機能は無い。&lt;/li&gt;
&lt;li&gt;ミックスインのテンプレートパラメータ (&lt;code&gt;Mixin&lt;/code&gt;) は推奨されておらず、将来削除される。この機能はめったに使われないので、代替となる機能は無い。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt; メソッドは推奨されておらず、将来削除される。代わりに代入演算子を使えば良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しい文法に移行し、推奨されない機能を削除するためには、 &lt;code&gt;BOOST_FUNCTION_NO_DEPRECATED&lt;/code&gt; プリプロセサマクロを定義する。このマクロを定義すると、推奨されない全ての機能が使えなくなる。 &lt;code&gt;BOOST_FUNCTION_NO_DEPRECATED&lt;/code&gt; を使ってコンパイルされたプログラムなら、推奨されない機能が削除されても大丈夫だ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function-vs-function-pointers&#34; name=&#34;function-vs-function-pointers&#34;&gt;Boost.Function vs. Function Pointers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function には関数ポインタに比べていくつかの利点がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Function は、任意の互換性がある関数オブジェクトを格納できる (関数ポインタは全く同じシグネチャを持つ関数しか受け付けない) 。&lt;/li&gt;
&lt;li&gt;Boost.Function は、引数の束縛などの関数オブジェクトを作り出すライブラリと共用できる。&lt;/li&gt;
&lt;li&gt;Boost.Function を使えば、空の関数オブジェクトの呼び出しを、デバッグ時に簡単に検出できる。&lt;/li&gt;
&lt;li&gt;Boost.Function では、それぞれの呼び出しの前後に、ある操作を実行するように指定できる。例えば、同期用の基本命令を関数型の一部にすることができる(訳注：この機能 (呼び出しポリシー) は推奨されておらず、将来削除される)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そしてもちろん、関数ポインタにも Boost.Function に比べていくつかの利点がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数ポインタはサイズが小さい (関数ポインタはポインタ 1 つ、 Boost.Function はポインタ 3 つ) 。&lt;/li&gt;
&lt;li&gt;関数ポインタは高速だ (Boost.Function は関数ポインタを通した呼び出しを 2 回する可能性がある) 。&lt;/li&gt;
&lt;li&gt;関数ポインタは C のライブラリと下位互換性がある。&lt;/li&gt;
&lt;li&gt;エラーメッセージが読みやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上 2 つのリストは Darin Adler のコメントを編集したものである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/performance&#34; name=&#34;performance&#34;&gt;Performance&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Function object wrapper size&lt;/h3&gt;
&lt;p&gt;関数オブジェクトのラッパのサイズは 2 つの関数ポインタと、 1 つの関数ポインタまたはデータのポインタ (の大きい方) のサイズになる。一般的な 32 ビットプラットフォームでは、 1 つのラッパ当たり 12 バイトになる。さらに、対象となる関数オブジェクトがヒープに割り当てられる。&lt;/p&gt;
&lt;h3&gt;Copying efficiency&lt;/h3&gt;
&lt;p&gt;関数オブジェクトのラッパのコピーによって、格納された関数オブジェクトのコピーのためにメモリ割り当てが発生する。デフォルトのアロケータを、もっと速いカスタムアロケータで置換することもできる。また、関数オブジェクトのラッパが、対象となる関数オブジェクトの「参照」を格納するように指定できる (&lt;code&gt;ref&lt;/code&gt;を使用) 。これは関数オブジェクトのコピーが酷く高価な場合に有効だ。&lt;/p&gt;
&lt;h3&gt;Invocation efficiency&lt;/h3&gt;
&lt;p&gt;適切なインライン化を行うコンパイラならば、関数オブジェクトの呼び出しによって、関数ポインタを通した呼び出しが 1 回行われる。非メンバ関数ポインタの呼び出しならば、その関数ポインタの呼び出しに加えて、もう 1 回の呼び出しが行われる (コンパイラがとても強力な関数をまたいだ分析を行うならば別だが) 。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/portability&#34; name=&#34;portability&#34;&gt;Portability&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function は、できるだけ移植性を高めるように、できるだけ多くのコンパイラ (C++ 標準準拠度が低いものも含む) をサポートするように設計されている。以下のコンパイラは &lt;code&gt;boost::function&lt;/code&gt;に含まれる全てのテストケースに合格した。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 2.95.3&lt;/li&gt;
&lt;li&gt;GCC 3.0&lt;/li&gt;
&lt;li&gt;SGI MIPSpro 7.3.0&lt;/li&gt;
&lt;li&gt;Borland C++ 5.5.1&lt;/li&gt;
&lt;li&gt;Comeau C++ 4.2.45.2&lt;/li&gt;
&lt;li&gt;Metrowerks Codewarrior 6.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下のコンパイラでも &lt;code&gt;boost::function&lt;/code&gt;を使えるが、いくつか問題がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft Visual C++ 6.0 (service pack 5): アロケータはサポートされない。 &lt;code&gt;boost::function&lt;/code&gt; クラステンプレートにいくつか問題がある ( &lt;code&gt;boost::functionN&lt;/code&gt; の方は動作するようだ) 。&lt;/li&gt;
&lt;li&gt;Intel C++ 5.0: アロケータはサポートされない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あなたのコンパイラが上のリストになければ、 &lt;code&gt;boost::function&lt;/code&gt; ライブラリを使えるかチェックするための小さなテスト群があるので、これを使える。標準に準拠したコンパイラなら、修正無しでコードをコンパイルできるはずだが、問題が起きたらバグレポートを送ってほしい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/design-rationale&#34; name=&#34;design-rationale&#34;&gt;Design rationale&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Combatting virtual function bloat&lt;/h3&gt;
&lt;p&gt;多くのコンパイラでは、仮想関数の使用によって「コードの膨張」が起きがちである。クラスが仮想関数を持つ場合、オブジェクトの型を分類する補助関数を作る必要がある。私達の経験では、多くの &lt;code&gt;boost::function&lt;/code&gt; オブジェクトが使われると、この補助関数が実行可能ファイルのサイズを大きく膨張させる。&lt;/p&gt;
&lt;p&gt;Boost.Function では、仮想関数の代わりに非メンバ関数を使った、代わりの等価なアプローチをとっている。 Boost.Function オブジェクトが関数オブジェクトを呼び出すためには、本質的に 2 つのポインタを持つ必要がある。所有する関数オブジェクトへの &lt;code&gt;void&lt;/code&gt; ポインタと、関数オブジェクトの「呼び出し役」への &lt;code&gt;void&lt;/code&gt; ポインタ (関数ポインタが代入される) だ。 Boost.Function が提供する、引数と戻り値の変換は、この呼び出し役が実行する。第 3 のポインタは「管理者」と呼ばれる非メンバ関数を指す。これは関数オブジェクトのコピーと破棄を扱う。この方法はタイプセーフだ。なぜなら、関数オブジェクトを実際に扱う関数である呼び出し役と管理者は、関数オブジェクトの型を知らされてインスタンス化されるので、入ってくる &lt;code&gt;void&lt;/code&gt; ポインタ (関数オブジェクトへのポインタ) を、正しい型に安全にキャストできるからだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;たくさんの人がこのライブラリの作成に参加した。 William Kempf 、 Jesse Jones 、 Karl Nelson は、ライブラリのインタフェースと守備範囲を、他のライブラリとは独立したものにする上で大きな助けになってくれた。 John Maddock は公式なレビューをやってくれた。他にもたくさんの人がレビューをして、インタフェース、実装、ドキュメントについて優れたコメントを寄せてくれた。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.Function Tutorial -- Boost.Function : Tutorialを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function/tutorial.html"/>
      <id>59cdfc548da6598628853074b00162e0158adbe4:archive/boost_docs/libs/function/tutorial.md</id>
      <updated>2014-12-08 15:18:24 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost.Function Tutorial&lt;/h1&gt;
&lt;p&gt;Boost.Function には 2 種類の文法がある。推奨文法と互換文法である。推奨文法は C++ にフィットし、考慮するテンプレートパラメータの数も減り、可読性を高めることが多い。しかし、コンパイラのバグのせいで、推奨文法が使えないコンパイラもある。互換文法は Boost.Function がサポートする全てのコンパイラで使える。どちらの文法を使うかは、下の表を見て決めてほしい。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GNU C++ 2.95.x, 3.0.x, 3.1.x, 3.2&lt;br /&gt; Comeau C++ 4.2.45.2&lt;br /&gt; SGI MIPSpro 7.3.0&lt;br /&gt; Intel C++ 5.0, 6.0&lt;br /&gt; Compaq&#39;s cxx 6.2&lt;/td&gt;
&lt;td&gt;Microsoft Visual C++ 6.0, 7.0&lt;br /&gt; Borland C++ 5.5.1&lt;br /&gt; Sun WorkShop 6 update 2 C++ 5.3&lt;br /&gt; Metrowerks CodeWarrior 8.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;あなたのコンパイラが表になければ、推奨文法を試してみて、結果を Boost MLに報告してほしい。この表を最新に保つためだ。&lt;/p&gt;
&lt;h2&gt;Basic Usage&lt;/h2&gt;
&lt;p&gt;関数オブジェクトのラッパを定義するには、 &lt;code&gt;function&lt;/code&gt; クラステンプレートをインスタンス化するだけだ。テンプレート引数には、戻り値型と引数型を関数型形式で指定する。ある実装定義の最大値 (デフォルトは 10) までなら、引数は何個でもかまわない。以下に、 2 つの &lt;code&gt;int&lt;/code&gt; 型のパラメータを取り、&lt;code&gt;float&lt;/code&gt; 型を返す関数オブジェクトのラッパ f の定義を示す。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;float (int x, int y)&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function2&amp;lt;float, int, int&amp;gt; f;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;デフォルトでは、関数オブジェクトのラッパは空である。 &lt;code&gt;f&lt;/code&gt; に代入する関数オブジェクトを作ろう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; int_div { 
  &lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; ((&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)x)&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;y; }; 
};

f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; int_div();
&lt;/pre&gt;&lt;/div&gt;

これで、関数オブジェクト &lt;code&gt;int_div&lt;/code&gt; を呼び出す代わりに &lt;code&gt;f&lt;/code&gt; を使える。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;f&lt;/code&gt; には、互換性があれば、どんな関数オブジェクトでも代入できる。 &lt;code&gt;int_div&lt;/code&gt; が 2 つの &lt;code&gt;long&lt;/code&gt; 型の引数をとると宣言されていれば、自動的に暗黙の型変換が適用される。引数型に対する唯一の制限は、コピーコンストラクト可能なことである。だから、参照や配列さえ使える。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;boost::function&amp;lt;void (int values[], int n, int&amp;amp; sum, float&amp;amp; avg)&amp;gt; sum_avg;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::function4&amp;lt;void, int[], int, int&amp;amp;, float&amp;gt; sum_avg;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;do_sum_avg&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; values[], &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; sum, &lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; avg)
{
  sum &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;)
    sum &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; values[i];
  avg &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)sum &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; n;
}

sum_avg &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;do_sum_avg;
&lt;/pre&gt;&lt;/div&gt;

関数オブジェクトを格納していないラッパを呼び出すのは事前条件違反である。ヌルの関数ポインタを呼び出そうとするようなものだ。関数オブジェクトのラッパが空かどうかは &lt;code&gt;empty()&lt;/code&gt; メソッドでチェックできる。もっと簡潔なのは、 &lt;code&gt;bool&lt;/code&gt; 型の文脈でラッパを使う方法だ。ラッパは、空でなければ &lt;code&gt;true&lt;/code&gt; と評価される。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (f)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;f has no target, so it is unsafe to call&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;

ラッパを空にするには、 &lt;code&gt;clear()&lt;/code&gt; メンバ関数を使う。&lt;/p&gt;
&lt;h2&gt;Free functions&lt;/h2&gt;
&lt;p&gt;非メンバ関数へのポインタは、 &lt;code&gt;const&lt;/code&gt; な関数呼出し演算子を持つ (インスタンスが1つだけ存在する) 関数オブジェクトの一種とみなせる。よって、関数オブジェクトのラッパに直接代入できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;mul_ints&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; ((&lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt;)x) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; y; }
f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;mul_ints;
&lt;/pre&gt;&lt;/div&gt;

Microsoft Visual C++ version 6 を使う場合を除けば、本当は &lt;code&gt;&amp;amp;&lt;/code&gt; は不要だ。&lt;/p&gt;
&lt;h2&gt;Member functions&lt;/h2&gt;
&lt;p&gt;多くのシステムで、コールバックは特定のオブジェクトのメンバ関数を呼び出すことが多い。これは「引数の束縛」と呼ばれ、 Boost.Function の守備範囲外である。しかし、 Boost.Function には直接メンバ関数を扱う方法がある。以下のコードのように使う。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X {
  &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; foo(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);
};
&lt;/pre&gt;&lt;/div&gt;

| 推奨文法 | 互換文法 |
|----------|----------|
| &lt;code&gt;boost::function&amp;lt;int (X*, int)&amp;gt; f;&lt;/code&gt; | &lt;code&gt;boost::function2&amp;lt;int, X*, int&amp;gt; f;&lt;/code&gt; |&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;foo;

X x;
f(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;x, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

引数の束縛をサポートするライブラリはいくつかある。その内 3 つを以下に要約する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;Boost.Bind&lt;/a&gt;。このライブラリを使えば、あらゆる関数オブジェクトの引数を束縛できる。軽くて移植性が高い。&lt;/li&gt;
&lt;li&gt;C++ 標準ライブラリ。 &lt;code&gt;std::bind1st&lt;/code&gt; と &lt;code&gt;std::mem_fun&lt;/code&gt; を一緒に使って、メンバ関数ポインタと (その対象となる) オブジェクトを束縛したものは、 Boost.Function で使える。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X {
  &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; foo(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);
};
&lt;/pre&gt;&lt;/div&gt;

| 推奨文法 | 互換文法 |
|----------|----------|
| &lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f;&lt;/code&gt; | &lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f;&lt;/code&gt; |&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;X x;
f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind1st(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;foo), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;x);

f(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// x.foo(5)を呼び出す&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

- &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/lambda.html&#34;&gt;Boost.Lambda&lt;/a&gt; ライブラリ。このライブラリは、自然な C++ の文法を使って関数オブジェクトを構築する強力な機構を提供する。 Lambda は、コンパイラが C++ 標準にかなり準拠していないと使えない。&lt;/p&gt;
&lt;h2&gt;References to Functions&lt;/h2&gt;
&lt;p&gt;Boost.Function による関数オブジェクトのコピーが高価 (または不正) な場合がある。そんな場合は、 Boost.Function に実際の関数オブジェクトの「参照」を格納させることができる。&lt;code&gt;ref&lt;/code&gt; や &lt;code&gt;cref&lt;/code&gt; を使うことで、関数オブジェクトの参照のラッパを作成できる。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;推奨文法&lt;/th&gt;
&lt;th&gt;互換文法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stateful_type a_function_object;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;f = ref(a_function_object);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function&amp;lt;int (int)&amp;gt; f2(f);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;stateful_type a_function_object;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;f = ref(a_function_object);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;boost::function1&amp;lt;int, int&amp;gt; f2(f);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;こうすれば、 &lt;code&gt;f&lt;/code&gt; も &lt;code&gt;f2&lt;/code&gt; も &lt;code&gt;a_function_object&lt;/code&gt; のコピーを作成しない。さらに、関数オブジェクトの参照を使えば、 Boost.Function は代入、構築時に例外を起こさない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Last modified: Fri Oct 11 05:40:00 EDT 2002&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function/gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Boost.Function : トップページを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>1667a0410c8bfcf44a12f502a12b48ecccd64cb6:archive/boost_docs/libs.md</id>
      <updated>2014-12-08 14:34:15 +0900</updated>
      
        <content type="html">&lt;h1&gt;各ライブラリの翻訳ドキュメント&lt;/h1&gt;
&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html&#34;&gt;function&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;遅延呼び出し及びコールバックのための関数オブジェクトラッパ。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Header `&lt;boost/function.hpp&gt;` -- Boost.Function : トップページを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/function.html"/>
      <id>1667a0410c8bfcf44a12f502a12b48ecccd64cb6:archive/boost_docs/libs/function.md</id>
      <updated>2014-12-08 14:34:15 +0900</updated>
      
        <content type="html">&lt;h1&gt;Header &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/doc/html/function.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/doc/html/function.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ヘッダファイル &lt;code&gt;&amp;lt;boost/function.hpp&amp;gt;&lt;/code&gt; に含まれるのは、関数オブジェクトのラッパとなるクラステンプレート群である。 Boost.Function の概念はコールバックを一般化したものだ。 Boost.Function は以下の点で関数ポインタと共通の特徴をもっている。 1 つは、何らかの実装によって呼び出される「呼び出しのインタフェース」 (例: 2 つの &lt;code&gt;int&lt;/code&gt; 型引数を取り、 &lt;code&gt;float&lt;/code&gt; を返す関数) を定義していること。もう 1 つは、呼び出される実装をプログラム実行中に変更できる事だ。&lt;/p&gt;
&lt;p&gt;一般に、遅延呼び出しやコールバックを実現するために関数ポインタを使うあらゆる場面で、代わりに Boost.Function を使用できる。そして、それによって呼ばれる側の実装はぐっと自由になる。呼ばれる側にはあらゆる「互換性のある」関数オブジェクト (や関数ポインタ) が指定できる。「互換性がある」とは、 Boost.Function に渡した引数が、対象となる関数オブジェクトの引数に変換できるということだ(訳注：戻り値にも互換性が必要)。&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#compatibility-note&#34;&gt;Compatibility Note&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tutorial&lt;/li&gt;
&lt;li&gt;Reference manual&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#function-vs-function-pointers&#34;&gt;Boost.Function vs. Function Pointers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#portability&#34;&gt;Portability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#design-rationale&#34;&gt;Design rationale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function.html#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Frequently Asked Questions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compatibility-note&#34; name=&#34;compatibility-note&#34;&gt;Compatibility Note&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function は、インタフェースを小さく、分かりやすくするために、一部が再設計された。昔の Boost.Function にあった、いくつかのめったに (または決して) 使われない機能は推奨されなくなり、近々削除される。以下に推奨されなくなった機能とその理由、それに伴うコードの修正法をリストアップする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::function&lt;/code&gt; クラステンプレートの文法が変更された。以前は&lt;code&gt;boost::function&amp;lt;int, float, double, std::string&amp;gt;&lt;/code&gt;のように書いたが、 &lt;code&gt;boost::function&amp;lt;int (float, double, std::string)&amp;gt;&lt;/code&gt;のような、より自然な書き方になった。戻り値と全ての引数の型が、 1 つの関数型のパラメータに収まる事になったのだ。残りのテンプレートパラメータ (&lt;code&gt;Allocator&lt;/code&gt;など) が、この関数型パラメータの後に続く。
    この変更への対応は、コンパイラに依存する。あなたのコンパイラがテンプレートの部分特殊化版をサポートし、関数型をパース (これは大抵 OK) できるなら、新しい文法を使うようにソースを修正してもいいし (推奨) 、文法が変わっていない&lt;code&gt;functionN&lt;/code&gt; クラスを直接使ってもいい。あなたのコンパイラがテンプレートの部分特殊化版か関数型をサポートしていなければ、&lt;code&gt;functionN&lt;/code&gt;クラスを使う必要がある。&lt;code&gt;functionN&lt;/code&gt;クラスを使うように修正するのは簡単で、クラス名の最後に引数の数を加えるだけだ (例: &lt;code&gt;boost::function&amp;lt;void, int, int&amp;gt;&lt;/code&gt; を &lt;code&gt;boost::function2&amp;lt;void, int, int&amp;gt;&lt;/code&gt; に変更) 。
    &lt;code&gt;boost::function&lt;/code&gt; クラステンプレートの古い文法のサポートはしばらく続くが、いつかは削除される。削除した方がエラーメッセージが分かりやすくなり、リンク互換性が良くなるからだ。&lt;/li&gt;
&lt;li&gt;呼び出しポリシーのテンプレートパラメータ (&lt;code&gt;Policy&lt;/code&gt;) は推奨されておらず、将来削除される。この機能はめったに使われないので、代替となる機能は無い。&lt;/li&gt;
&lt;li&gt;ミックスインのテンプレートパラメータ (&lt;code&gt;Mixin&lt;/code&gt;) は推奨されておらず、将来削除される。この機能はめったに使われないので、代替となる機能は無い。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt; メソッドは推奨されておらず、将来削除される。代わりに代入演算子を使えば良い。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新しい文法に移行し、推奨されない機能を削除するためには、 &lt;code&gt;BOOST_FUNCTION_NO_DEPRECATED&lt;/code&gt; プリプロセサマクロを定義する。このマクロを定義すると、推奨されない全ての機能が使えなくなる。 &lt;code&gt;BOOST_FUNCTION_NO_DEPRECATED&lt;/code&gt; を使ってコンパイルされたプログラムなら、推奨されない機能が削除されても大丈夫だ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/function-vs-function-pointers&#34; name=&#34;function-vs-function-pointers&#34;&gt;Boost.Function vs. Function Pointers&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function には関数ポインタに比べていくつかの利点がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Function は、任意の互換性がある関数オブジェクトを格納できる (関数ポインタは全く同じシグネチャを持つ関数しか受け付けない) 。&lt;/li&gt;
&lt;li&gt;Boost.Function は、引数の束縛などの関数オブジェクトを作り出すライブラリと共用できる。&lt;/li&gt;
&lt;li&gt;Boost.Function を使えば、空の関数オブジェクトの呼び出しを、デバッグ時に簡単に検出できる。&lt;/li&gt;
&lt;li&gt;Boost.Function では、それぞれの呼び出しの前後に、ある操作を実行するように指定できる。例えば、同期用の基本命令を関数型の一部にすることができる(訳注：この機能 (呼び出しポリシー) は推奨されておらず、将来削除される)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そしてもちろん、関数ポインタにも Boost.Function に比べていくつかの利点がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数ポインタはサイズが小さい (関数ポインタはポインタ 1 つ、 Boost.Function はポインタ 3 つ) 。&lt;/li&gt;
&lt;li&gt;関数ポインタは高速だ (Boost.Function は関数ポインタを通した呼び出しを 2 回する可能性がある) 。&lt;/li&gt;
&lt;li&gt;関数ポインタは C のライブラリと下位互換性がある。&lt;/li&gt;
&lt;li&gt;エラーメッセージが読みやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上 2 つのリストは Darin Adler のコメントを編集したものである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/performance&#34; name=&#34;performance&#34;&gt;Performance&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Function object wrapper size&lt;/h3&gt;
&lt;p&gt;関数オブジェクトのラッパのサイズは 2 つの関数ポインタと、 1 つの関数ポインタまたはデータのポインタ (の大きい方) のサイズになる。一般的な 32 ビットプラットフォームでは、 1 つのラッパ当たり 12 バイトになる。さらに、対象となる関数オブジェクトがヒープに割り当てられる。&lt;/p&gt;
&lt;h3&gt;Copying efficiency&lt;/h3&gt;
&lt;p&gt;関数オブジェクトのラッパのコピーによって、格納された関数オブジェクトのコピーのためにメモリ割り当てが発生する。デフォルトのアロケータを、もっと速いカスタムアロケータで置換することもできる。また、関数オブジェクトのラッパが、対象となる関数オブジェクトの「参照」を格納するように指定できる (&lt;code&gt;ref&lt;/code&gt;を使用) 。これは関数オブジェクトのコピーが酷く高価な場合に有効だ。&lt;/p&gt;
&lt;h3&gt;Invocation efficiency&lt;/h3&gt;
&lt;p&gt;適切なインライン化を行うコンパイラならば、関数オブジェクトの呼び出しによって、関数ポインタを通した呼び出しが 1 回行われる。非メンバ関数ポインタの呼び出しならば、その関数ポインタの呼び出しに加えて、もう 1 回の呼び出しが行われる (コンパイラがとても強力な関数をまたいだ分析を行うならば別だが) 。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/portability&#34; name=&#34;portability&#34;&gt;Portability&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Function は、できるだけ移植性を高めるように、できるだけ多くのコンパイラ (C++ 標準準拠度が低いものも含む) をサポートするように設計されている。以下のコンパイラは &lt;code&gt;boost::function&lt;/code&gt;に含まれる全てのテストケースに合格した。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 2.95.3&lt;/li&gt;
&lt;li&gt;GCC 3.0&lt;/li&gt;
&lt;li&gt;SGI MIPSpro 7.3.0&lt;/li&gt;
&lt;li&gt;Borland C++ 5.5.1&lt;/li&gt;
&lt;li&gt;Comeau C++ 4.2.45.2&lt;/li&gt;
&lt;li&gt;Metrowerks Codewarrior 6.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下のコンパイラでも &lt;code&gt;boost::function&lt;/code&gt;を使えるが、いくつか問題がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft Visual C++ 6.0 (service pack 5): アロケータはサポートされない。 &lt;code&gt;boost::function&lt;/code&gt; クラステンプレートにいくつか問題がある ( &lt;code&gt;boost::functionN&lt;/code&gt; の方は動作するようだ) 。&lt;/li&gt;
&lt;li&gt;Intel C++ 5.0: アロケータはサポートされない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;あなたのコンパイラが上のリストになければ、 &lt;code&gt;boost::function&lt;/code&gt; ライブラリを使えるかチェックするための小さなテスト群があるので、これを使える。標準に準拠したコンパイラなら、修正無しでコードをコンパイルできるはずだが、問題が起きたらバグレポートを送ってほしい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/design-rationale&#34; name=&#34;design-rationale&#34;&gt;Design rationale&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;Combatting virtual function bloat&lt;/h3&gt;
&lt;p&gt;多くのコンパイラでは、仮想関数の使用によって「コードの膨張」が起きがちである。クラスが仮想関数を持つ場合、オブジェクトの型を分類する補助関数を作る必要がある。私達の経験では、多くの &lt;code&gt;boost::function&lt;/code&gt; オブジェクトが使われると、この補助関数が実行可能ファイルのサイズを大きく膨張させる。&lt;/p&gt;
&lt;p&gt;Boost.Function では、仮想関数の代わりに非メンバ関数を使った、代わりの等価なアプローチをとっている。 Boost.Function オブジェクトが関数オブジェクトを呼び出すためには、本質的に 2 つのポインタを持つ必要がある。所有する関数オブジェクトへの &lt;code&gt;void&lt;/code&gt; ポインタと、関数オブジェクトの「呼び出し役」への &lt;code&gt;void&lt;/code&gt; ポインタ (関数ポインタが代入される) だ。 Boost.Function が提供する、引数と戻り値の変換は、この呼び出し役が実行する。第 3 のポインタは「管理者」と呼ばれる非メンバ関数を指す。これは関数オブジェクトのコピーと破棄を扱う。この方法はタイプセーフだ。なぜなら、関数オブジェクトを実際に扱う関数である呼び出し役と管理者は、関数オブジェクトの型を知らされてインスタンス化されるので、入ってくる &lt;code&gt;void&lt;/code&gt; ポインタ (関数オブジェクトへのポインタ) を、正しい型に安全にキャストできるからだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;たくさんの人がこのライブラリの作成に参加した。 William Kempf 、 Jesse Jones 、 Karl Nelson は、ライブラリのインタフェースと守備範囲を、他のライブラリとは独立したものにする上で大きな助けになってくれた。 John Maddock は公式なレビューをやってくれた。他にもたくさんの人がレビューをして、インタフェース、実装、ドキュメントについて優れたコメントを寄せてくれた。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Douglas Gregor&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;
&lt;p&gt;このドキュメントの対象: Boost Version 1.29.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Type-safe &#39;printf-like&#39; format class -- コードブロックの見た目が崩れていたので修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/format/choices.html"/>
      <id>779b2993fa8a756e31d330f70c8b6814f7e9a775:archive/boost_docs/libs/format/choices.md</id>
      <updated>2014-12-05 17:13:50 +0900</updated>
      
        <content type="html">&lt;h1&gt;Type-safe &#39;printf-like&#39; format class&lt;/h1&gt;
&lt;h2&gt;Choices made&lt;/h2&gt;
&lt;p&gt;&#34;Le pourquoi du comment&#34; ( - &#34;どうしてそうなの？&#34;)&lt;/p&gt;
&lt;h2&gt;The syntax of the format-string&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; は新しいライブラリだ。そのゴールの一つは、 &lt;code&gt;printf&lt;/code&gt; の代替物を提供することにある。つまり、 &lt;code&gt;format&lt;/code&gt; は &lt;code&gt;printf&lt;/code&gt; 用に設計された書式文字列を構文解析することができて、与えられた引数にその書式を適用して &lt;code&gt;printf&lt;/code&gt; と同じ結果を生成できる。 &lt;/p&gt;
&lt;p&gt;この制限の下で、書式文字列の文法には大雑把に３つの選択肢が有り得た :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; とまったく同じ文法を用いる。これは多くの経験のあるユーザに知られているし、 ほとんどすべてのニーズにフィットする。しかし命令の終端を断定するために不可欠な型変換文字は、 C++ ストリームの文脈では、 ストリームの関連する書式化オプションをセットする程度の役にしか立たない(&lt;code&gt;%x&lt;/code&gt; なら hexa をセットする、等...) このお仕着せの型変換文字は、意味付けを変更した上で、省略可能にするのが良いだろう。&lt;/li&gt;
&lt;li&gt;互換性を維持しながら拡張された &lt;code&gt;printf&lt;/code&gt; 文法。まだ &lt;code&gt;printf&lt;/code&gt; の文法として有効でない文字や構造を用いる。例． : &lt;code&gt;&#34;%1%&#34;, &#34;%[1]&#34;, &#34;%|1$d|&#34;&lt;/code&gt;, .. 始端 / 終端マークを用いることで、あらゆる種類の拡張を考慮できるようになる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; 互換のものと平行して、非レガシーモードを提供する。 既存の &lt;code&gt;printf&lt;/code&gt; 文法との互換性という制約を受けずに、他の目的に適すように設計できる。 &lt;ul&gt;
&lt;li&gt;しかし &lt;code&gt;printf&lt;/code&gt; の文法の代替物(既存のものより明確に優れていて、かつパワフルなものになるだろう)の設計は、 &lt;code&gt;format&lt;/code&gt; クラスの構築とはまた別の仕事だ。 そのような文法が設計されたときには、 Boost.Format を二つのライブラリに分割することも考慮すべき だろう : 一方はこの新しい文法と歩調を合わせて開発され、もう一つはレガシーな文法を サポートする (おそらくは高速で、 &lt;code&gt;snprintf&lt;/code&gt; やその同類に勝る安全面での改良が組み込まれたバージョンになるだろう)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完全で、気の利いた、 &lt;code&gt;printf&lt;/code&gt; よりも明確に C++ ストリームに適応した新しい文法が手元にないので、二つ目のアプローチを選択することにした。 Boost.Format は &lt;code&gt;printf&lt;/code&gt; の文法を用い、その文法を拡張することで拡張機能(桁送り、中寄せ)を表現することができる。 &lt;/p&gt;
&lt;p&gt;また、 &lt;code&gt;printf&lt;/code&gt; の文法の弱点を克服するために、これまでのものに替わる互換表記を提供する :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#34;%N%&#34;&lt;/code&gt; より単純な位置指定、型指定無し、オプション無しの表記。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%|spec|&lt;/code&gt; &lt;code&gt;printf&lt;/code&gt; の命令を視覚的により明確な構造に密閉する一手段であり、 同時に &lt;code&gt;printf&lt;/code&gt; の&#39;型変換文字&#39;を省略可能にする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;なぜ関数呼び出しではなく演算子で引数を渡すのですか？&lt;/h2&gt;
&lt;p&gt;演算子による方法の不便さ(一部の人にとって)は、混乱させられることがあるということだ。 演算子をオーバーロードし過ぎると人々を真の混乱に陥れるという お決まりの警告だ。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; オブジェクトの仕様は限られた文脈(最も多いのは &lt;code&gt;&#34;cout &amp;lt;&amp;lt; &#34;&lt;/code&gt; の直後)になるだろうってことと、 引数がいかにも書式文字列に続いているように見えることから :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34; %s at %s  with %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; z;
&lt;/pre&gt;&lt;/div&gt;

人々をそれほど混乱させないだろうと期待できる。&lt;/p&gt;
&lt;p&gt;演算子の別の恐怖は優先順位の問題だ。 &lt;code&gt;format(&#34;%s&#34;) % (x+y)&lt;/code&gt; と書かずに &lt;code&gt;format(&#34;%s&#34;) % x+y&lt;/code&gt; を書いた場合どうなるだろう？ &lt;/p&gt;
&lt;p&gt;これだとコンパイル時に問題が起きるので、エラーはすぐに検出されるだろう。&lt;/p&gt;
&lt;p&gt;もちろん、この行は &lt;code&gt;tmp = operator%( format(&#34;%s&#34;), x)&lt;/code&gt; を呼び、それから &lt;code&gt;operator+(tmp, y)&lt;/code&gt; を呼ぶ。 &lt;/p&gt;
&lt;p&gt;暗黙の変換が定義されていない限り &lt;code&gt;tmp&lt;/code&gt; は &lt;code&gt;format&lt;/code&gt; オブジェクトとなるだろう。そのため &lt;code&gt;operator+&lt;/code&gt; の呼び出しは失敗する。 (もちろん、君がそんな演算子を定義した場合は除く)。 だから君は優先順位の間違いはコンパイルの際に知らされると安心して決め込んでいい。&lt;/p&gt;
&lt;p&gt;その一方で、関数アプローチには本物の不便さがある。 多くのテンプレート関数を定義する必要があるんだ。こんな感じに :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T2&lt;/span&gt;,  .., &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;TN&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
string format(string s,  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T1&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x1, .... , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T1&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; xN);
&lt;/pre&gt;&lt;/div&gt;

そして N を 500 まで定義したとしても、 まだ C の &lt;code&gt;printf&lt;/code&gt; にはない上限を設けることになる。 &lt;/p&gt;
&lt;p&gt;それに、 &lt;code&gt;format&lt;/code&gt; はどうにかして &lt;code&gt;printf&lt;/code&gt; をエミュレートできる場合もあるけど、 &lt;code&gt;printf&lt;/code&gt; の完全な等価物には程遠い。根本的に異なる外見を用いる方がベストだ。そして演算子呼び出しを使うのは、その点ではとても成功している！&lt;/p&gt;
&lt;p&gt;いずれにせよ、もし僕らが実際にフォーマルな関数呼び出しテンプレートの仕組みを選択していたら、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; (stream, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

が与えられているクラス &lt;code&gt;T&lt;/code&gt; しか表示することができなかっただろう。 なぜなら、 &lt;code&gt;const&lt;/code&gt; と 非 &lt;code&gt;const&lt;/code&gt; の両方を許容すると組み合わせ爆発が生じるからだ - もし 10 個までの引数で行くにしても、 2^10 個の関数が必要になる。&lt;/p&gt;
&lt;p&gt;(&lt;code&gt;T&amp;amp;&lt;/code&gt; と &lt;code&gt;const T&amp;amp;&lt;/code&gt; のオーバーロードを提供することは C++ 標準の不備の最先端だが、おかげでサポートの保証からは程遠い。しかし現在ではいくつかのコンパイラがそうしたオーバーロードをサポートしている) &lt;/p&gt;
&lt;p&gt;非 &lt;code&gt;const&lt;/code&gt; 版の等価物しか提供しないという悪い設計をすることもできるけど、それはユーザにまた別の根拠の無い制限を押し付けることになる。&lt;/p&gt;
&lt;p&gt;また、マニピュレータのいくつかは関数なので、 &lt;code&gt;const&lt;/code&gt; な参照として渡すことができない。 そのため関数呼び出しアプローチはマニピュレータを上手くサポートしない。&lt;/p&gt;
&lt;p&gt;結論として、コンパイル時に引数の数を知ることができない場合には、専用の二項演算子を用いることが最もシンプルで、ロバストで、かつ制限の少ない引数渡しのメカニズムなんだ。&lt;/p&gt;
&lt;h2&gt;なぜ &lt;code&gt;&#39;with(..)&#39;&lt;/code&gt; のようなメンバ関数でなく &lt;code&gt;operator%&lt;/code&gt; なんですか？？&lt;/h2&gt;
&lt;p&gt;技術的には、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format(fstr) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x1 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x2 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x3;
&lt;/pre&gt;&lt;/div&gt;

は、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format(fstr).with( x1 ).with( x2 ).with( x3 );
&lt;/pre&gt;&lt;/div&gt;

と同じ構造をしている。後者には優先順位の問題は何も無い。 後者のただ一つの欠点は、演算子を用いるのに比べて、一見してこの行が何をしているのか 把握しづらいということだ。 &lt;code&gt;.with(..)&lt;/code&gt; を呼び出すのは、コードのほかの行でやっていることと同じように見える。 だから、好みの問題だけど、この方がより良いな解決方法だろう。 余計な文字を用いる点と、&lt;code&gt;&#39;with(..)&#39;&lt;/code&gt; を用いたコードの行の全般的に散らかった側面は、僕に真の演算子を選択させるのに十分だった。&lt;/p&gt;
&lt;h2&gt;なぜいつもの &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; でなく &lt;code&gt;operator%&lt;/code&gt; なんですか？？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;なぜなら &lt;code&gt;format&lt;/code&gt; オブジェクトに引数を渡すことは、ストリームに順に変数を送ること同じではないからだ。それに &lt;code&gt;format&lt;/code&gt; オブジェクトはストリームでも、マニピュレータでもない。&lt;/p&gt;
&lt;p&gt;僕らは引数を渡すのに演算子を使う。 &lt;code&gt;format&lt;/code&gt; は、関数が単純に引数を一つずつ取るようにそれを使うだろう。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; オブジェクトはストリームのような振る舞いはしない。君がマニピュレータのように動作する &lt;code&gt;format&lt;/code&gt; オブジェクトを実装しようとしてストリームを返すようにすれば、ユーザはストリームのマニピュレータと完璧に同じものだと信じることになる。そして遅かれ早かれ、そのユーザはこの視点のおかげで欺かれる。&lt;/p&gt;
&lt;p&gt;振る舞いの違いの最も明白な例は、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y ;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// うわぁ、 format は本当はストリームマニピュレータじゃないよ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

- &lt;code&gt;%&lt;/code&gt; の優先順位は &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; よりも高い。 これは問題のように見える。なぜなら &lt;code&gt;+&lt;/code&gt; や &lt;code&gt;-&lt;/code&gt; は括弧の内側にグループ化しなければならないからだ。一方で &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; にはそんな必要は無い。 しかしもしユーザがこのことを忘れても、誤りはコンパイルの際に捕らえられて、きっと彼は二度と忘れないだろう。&lt;/p&gt;
&lt;p&gt;その一方で、より高い優先順位は &lt;code&gt;format&lt;/code&gt; の振る舞いをとても直観的にしてくれる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;

は正確には次のように扱われる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; ( format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; y ) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;

だから &lt;code&gt;%&lt;/code&gt; を用いることで、 &lt;code&gt;format&lt;/code&gt; オブジェクトの寿命が周囲のストリームの文脈を妨げることはない。 これはあり得る振る舞いの中で最も単純なものだ。そのためユーザは &lt;code&gt;format&lt;/code&gt; オブジェクトの後でストリームを使いつづけることができる。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 演算子では、この状況では物事はより一層厄介だ。この行 :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  x  &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;

は次のように解釈される :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;( ( ( cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) ) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x ) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  y ) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;

代替となる実装の中には &amp;lt;&amp;lt; 演算子を選択しているものもあるが、これが働くようにする方法は一つしかない :&lt;/p&gt;
&lt;p&gt;最初の&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;( ostream&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;, format &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

呼び出しは プロクシを返す。プロクシは最終的な出力先 (&lt;code&gt;cout&lt;/code&gt;) と書式文字列の情報をカプセル化している。 &lt;/p&gt;
&lt;p&gt;引数を渡している先が &lt;code&gt;format&lt;/code&gt; なのか、それとも &lt;code&gt;format&lt;/code&gt; の完了後の最終的な出力先なのかは区別できない。これは問題だ。&lt;/p&gt;
&lt;p&gt;僕はいくつか考え得る実装を試してみたけど、どれも完璧には希望に沿っていない。&lt;/p&gt;
&lt;p&gt;例えば : ユーザの誤りを捕らえるために、引数が多く渡されすぎたときに例外を発生するのは筋が通っている。 しかしこの文脈では、余分な引数が最終的な出力先に向けられていることはほとんど間違いない。 ここでいくつかの選択肢がある :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引数が過剰かどうかの検出を諦めて、プロクシのテンプレートメンバ &lt;code&gt;operator&amp;lt;&amp;lt; ( const T&amp;amp;)&lt;/code&gt; が単純にすべての余分な引数を &lt;code&gt;cout&lt;/code&gt; に転送するようにする。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; の引数を特殊なマニピュレータ &lt;code&gt;&#39;endf&#39;&lt;/code&gt; で以下のように閉じるよう、ユーザに要求する。 :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  x  &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endf &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;endf&lt;/code&gt; はプロキシの内部に保持されていた最終的な出力先を返す関数として定義できる。 それで万事解決だ。 &lt;code&gt;endf&lt;/code&gt; の後は、ユーザは再び &lt;code&gt;cout&lt;/code&gt; に向けて &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; を呼んでいる。
    - 中間的な解決方法もある。最も頻繁な使い方は、単にもう一つ多くのマニピュレータ (&lt;code&gt;std::flush&lt;/code&gt; や &lt;code&gt;endl&lt;/code&gt;, ..) を &lt;code&gt;cout&lt;/code&gt; へ出力したい場合だろう。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  x  &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; flush ;
&lt;/pre&gt;&lt;/div&gt;

だからその解決方法は &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; をマニピュレータに対してオーバーロードすることだ。 この方法では &lt;code&gt;endf&lt;/code&gt; は不要だが、マニピュレータ以外のものを &lt;code&gt;format&lt;/code&gt; の引数の後に出力する事はできない。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最も完全な解決方法は &lt;code&gt;endf&lt;/code&gt; マニピュレータを使うものだ。 &lt;code&gt;%&lt;/code&gt; 演算子を使う場合、この書式終端関数は不要だ。さらにどの引数が &lt;code&gt;format&lt;/code&gt; オブジェクトの中へと向かい、どれがストリームへ向かうのかがすぐに分かる。
- 美しさの問題 : &lt;code&gt;&#39;%&#39;&lt;/code&gt; は書式文字列の内部で使われているものと同じ文字だ。それぞれの引数を渡すのに同じ文字を使うというのはなかなか良い考えだろう。 &lt;code&gt;&#39;&amp;lt;&amp;lt;&#39;&lt;/code&gt; は２文字、 &lt;code&gt;&#39;%&#39;&lt;/code&gt; は１文字。 &lt;code&gt;&#39;%&#39;&lt;/code&gt; はサイズの面でもより小さい。 見た目の面でも全般的に改善している (何がどうなっているのかが分かる) :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s %s&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;x &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;y &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;z &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;And  avg is&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;avg;
&lt;/pre&gt;&lt;/div&gt;

これと次を比較すると :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s %s %s&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; z &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endf &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;And avg is&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; avg;
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;&#34;&amp;lt;&amp;lt;&#34;&lt;/code&gt; は、ストリームに渡されているオブジェクトと同じレベルで引数を与えているから、間違いを起こしやすい。
- python も書式化に &lt;code&gt;%&lt;/code&gt; を使っている。だから &#34;聞いたことも無いような&#34; ものじゃないって納得してくれるよね ;-)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;なぜ &lt;code&gt;operator()&lt;/code&gt; や &lt;code&gt;operator[]&lt;/code&gt; ではなく &lt;code&gt;operator%&lt;/code&gt; なんですか？？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; には、関数に引数を送る自然な方法であるというメリットがある。 また、 &lt;code&gt;operator[]&lt;/code&gt; の意味が &lt;code&gt;format&lt;/code&gt; で使うには上手く当てはまると考える人もいる。&lt;/p&gt;
&lt;p&gt;技術的にはこれらは &lt;code&gt;operator%&lt;/code&gt; と同じくらい良い選択だ。しかしすごく醜い。 (好みの問題だ)&lt;/p&gt;
&lt;p&gt;それにそもそも、書式文字列の中の &lt;code&gt;&#34;%&#34;&lt;/code&gt; で参照されている引数を &lt;code&gt;operator%&lt;/code&gt; を使って渡すことは、それらの演算子を使うよりずっと自然に見える。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;July 07, 2001&lt;/p&gt;
&lt;p&gt;© Copyright Samuel Krempp 2001. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>The Boost Format library -- リンクミスを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/format/format.html"/>
      <id>ef2c2b6b5504baaa2a45d162b3ef33c048013140:archive/boost_docs/libs/format/format.md</id>
      <updated>2014-12-05 17:12:04 +0900</updated>
      
        <content type="html">&lt;h1&gt;The Boost Format library&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;boost/format.hpp&amp;gt;&lt;/code&gt; &lt;code&gt;format&lt;/code&gt;クラスは &lt;code&gt;printf&lt;/code&gt; に似た、ユーザ定義型も扱える型安全な書式化処理を提供する。 &lt;/p&gt;
&lt;p&gt;(このライブラリは他の &lt;code&gt;boost&lt;/code&gt; ライブラリに依存しない)&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#synopsis&#34;&gt;概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#how-it-works&#34;&gt;どのように作用するか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#examples&#34;&gt;コード例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#sample-files&#34;&gt;サンプルファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#syntax&#34;&gt;構文&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#printf-format-specifications&#34;&gt;printfフォーマット仕様&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#new-format-specifications&#34;&gt;新たなフォーマット仕様&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#differences-of-behavior-vs-printf&#34;&gt;printfとの振る舞いの違い&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#user-defined-types-output&#34;&gt;ユーザー定義型の出力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#manipulators-and-the-internal-stream-state&#34;&gt;マニピュレータと、内部的なストリーム状態&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#alternatives&#34;&gt;代替手段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#exceptions&#34;&gt;例外&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#extract&#34;&gt;抜粋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#rationale&#34;&gt;設計原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#credits&#34;&gt;クレジット&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/synopsis&#34; name=&#34;synopsis&#34;&gt;概要&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; オブジェクトは書式文字列から構築され、その後 &lt;code&gt;operator%&lt;/code&gt; を繰り返し呼び出されることで引数を与えられる。 &lt;/p&gt;
&lt;p&gt;それぞれの引数は文字列に変換され、書式文字列に従って順に一つの文字列へと結合される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;writing %1%,  x=%2% : %3%-th try&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;toto&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;40.23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; 
     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#34;writing toto,  x=40.230 : 50-th try&#34;と表示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/how-it-works&#34; name=&#34;how-it-works&#34;&gt;どのように作用するか&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1.書式文字列 &lt;code&gt;s&lt;/code&gt; を伴って &lt;code&gt;format(s)&lt;/code&gt; を呼び出すと、あるオブジェクトが構築される。このオブジェクトは、書式文字列を構文解析してすべての命令を探し、次のステップのために内部構造を準備する。
2.そして、すぐに&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt; )
&lt;/pre&gt;&lt;/div&gt;

のようにするか、あるいは後で、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;);
fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt;; fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

とすることで、フォーマッタに変数を食わせることができる。 &lt;/p&gt;
&lt;p&gt;変数は内部のストリームにダンプされる。ストリームの状態は、与えられた書式文字列の書式化オプション(あれば)によってセットされる。 &lt;code&gt;format&lt;/code&gt; オブジェクトは最後のステップのための結果文字列を保持する。&lt;/p&gt;
&lt;p&gt;3.すべての引数を与えてしまえば、その &lt;code&gt;format&lt;/code&gt; オブジェクトをストリームにダンプしたり、メンバ関数 &lt;code&gt;str()&lt;/code&gt; か名前空間 &lt;code&gt;boost::io&lt;/code&gt; にある &lt;code&gt;str(const format&amp;amp;)&lt;/code&gt; 関数で文字列を取り出すことができる。結果の文字列は、別の引数が与えられて再初期化されるまで、 &lt;code&gt;format&lt;/code&gt; オブジェクトの中にアクセス可能な状態で残る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 先ほど作って引数を与えた fmter の結果を表示:&lt;/span&gt;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter ;  

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 結果の文字列を取り出せる:&lt;/span&gt;
string s  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fmter.str();

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 何度でも:&lt;/span&gt;
s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fmter.str( );

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// すべてのステップを一度に行うこともできる:&lt;/span&gt;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt;; 
string s2 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;str( format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;

4.ステップ３の後で &lt;code&gt;format&lt;/code&gt; オブジェクトを再利用し、ステップ２からやり直すこともできる: &lt;code&gt;fmter % 18 % 39;&lt;/code&gt;
新しい変数を同じ書式文字列で書式化する際は、こうすることでステップ１で生じる高価な処理を節約できる。&lt;/p&gt;
&lt;p&gt;結局のところ、 &lt;code&gt;format&lt;/code&gt; クラスは、書式文字列(&lt;code&gt;printf&lt;/code&gt; に似た命令を用いる)を内部のストリームへの操作に翻訳する。そして最終的に、その書式化の結果を文字列として、あるいは直接に出力ストリームへと返す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/examples&#34; name=&#34;examples&#34;&gt;コード例&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;group;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;str;
&lt;/pre&gt;&lt;/div&gt;

- 並べ替えありの単純な出力:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1% %2% %3% %2% %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;11&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;22&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;333&#34;&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#39;単純な&#39;形式。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

表示はこうなる : &lt;code&gt;&#34;11 22 333 22 11 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POSIX 版 &lt;code&gt;printf&lt;/code&gt; の位置指定命令を用いた、より精細な書式化:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%1$+5d,%2$+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// POSIX版Printf形式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

表示はこうなる : &lt;code&gt;&#34;(x,y) = ( -23, +35) \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;並べ替えのない、古典的な &lt;code&gt;printf&lt;/code&gt; の命令:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;writing %s,  x=%s : %d-th step &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;toto&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;40.23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;

表示はこうなる : &lt;code&gt;&#34;writing toto, x=40.23 : 50-th step \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同じことを表現するにもいろいろな方法がある:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%+5d,%+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%|+5|,%|+5|) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;

cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%1$+5d,%2$+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%|1$+5|,%|2$+5|) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

表示はどれも : &lt;code&gt;&#34;(x,y) = ( -23, +35) \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;マニピュレータによる書式文字列の修飾:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1$+5d_ %1$d &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;);

format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter2&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1%_ %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;);
fmter2.modify_item(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, group(showpos, setw(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;)) ); 

cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt; ;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter2 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt; ;
&lt;/pre&gt;&lt;/div&gt;

どちらも同じように表示する : &lt;code&gt;&#34;_ +101_ 101 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引数を伴うマニピュレータ:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1%_ %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; group(showpos, setw(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;), &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

マニピュレータは、 &lt;code&gt;%1%&lt;/code&gt; が現れるたびに適用されるので、出力はこうなる : &lt;code&gt;&#34;_ +101_ +101 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しいフォーマット機能「絶対桁送り(absolute tabulations)」はループの中で使うと便利である。これはあるフィールドを各行の同じ位置に出力する機能で、たとえ直前の引数の幅が大きく変化したとしても、同じ位置に出力することを保証してくれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color: #666666&#34;&gt;=0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; names.size(); &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
    cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1%, %2%, %|40t|%3%&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; names[i] &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; surname[i] &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; tel[i];
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;names&lt;/code&gt; 、 &lt;code&gt;surnames&lt;/code&gt; 、そして &lt;code&gt;tel&lt;/code&gt; などのベクタ(sample_new_features.cpp を参照)は次のように表示される :&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;Marc-Françis Michel, Durand,           +33 (0) 123 456 789
Jean, de Lattre de Tassigny,           +33 (0) 987 654 321
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/sample-files&#34; name=&#34;sample-files&#34;&gt;サンプルファイル&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/example/sample_formats.cpp.html&#34;&gt;sample_formats.cpp&lt;/a&gt; は &lt;code&gt;format&lt;/code&gt; の簡単な使い方をデモする。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/example/sample_new_features.cpp.html&#34;&gt;sample_new_features.cpp&lt;/a&gt; は、単純な位置指定命令、中寄せ、そして「桁送り」など、 &lt;code&gt;printf&lt;/code&gt; の構文に追加された書式化機能のいくつかを説明する。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/example/sample_advanced.cpp.html&#34;&gt;sample_advanced.cpp&lt;/a&gt; は、 &lt;code&gt;format&lt;/code&gt; オブジェクトの 再利用や修飾といった、さらに進んだ機能の使い方をデモする。&lt;/p&gt;
&lt;p&gt;そして &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/example/sample_userType.cpp.html&#34;&gt;sample_userType.cpp&lt;/a&gt; はユーザ定義型に対する &lt;code&gt;format&lt;/code&gt; の振る舞いを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/syntax&#34; name=&#34;syntax&#34;&gt;構文&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format( format&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;string ) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; arg1 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; arg2 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ... &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; argN
&lt;/pre&gt;&lt;/div&gt;

&lt;strong&gt;format-string&lt;/strong&gt; は特殊な命令を含むテキストである。これらの命令は、与えられた引数の書式化結果の文字列によって置換される。 &lt;/p&gt;
&lt;p&gt;C/C++ の世界におけるレガシーな構文は &lt;code&gt;printf&lt;/code&gt; で使われているものである。そのため &lt;code&gt;format&lt;/code&gt; は &lt;code&gt;printf&lt;/code&gt; の書式文字列をそのまま利用でき、同じ結果を生成する。(ほとんどの場合において。詳細は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#differences-of-behavior-vs-printf&#34;&gt;&lt;code&gt;printf&lt;/code&gt;との違い&lt;/a&gt; を見よ) &lt;/p&gt;
&lt;p&gt;この中核となる構文は、新機能を許すだけでなく、 C++ のストリームの文脈に適合するために拡張された。そのため、 &lt;code&gt;format&lt;/code&gt; は書式文字列のさまざまな形式の命令を受け付ける :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;レガシーな &lt;code&gt;printf&lt;/code&gt; の書式文字列 : &lt;code&gt;%spec&lt;/code&gt;　ここで &lt;strong&gt;spec&lt;/strong&gt; は &lt;code&gt;printf&lt;/code&gt; の書式指定子である &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;spec&lt;/strong&gt; は幅、アライメント、数値を書式化する際の基数、その他の特殊なフラグなどの書式化オプションを渡す。 しかし &lt;code&gt;printf&lt;/code&gt; の古典的な型指定フラグは &lt;code&gt;format&lt;/code&gt; ではより弱い意味しか持たない。 &lt;code&gt;format&lt;/code&gt; は内部ストリームと書式化パラメータのどちらかまたは両方に適当なフラグをセットするだけで、対応する引数が指定した型であるかどうかは問わない。 &lt;/li&gt;
&lt;li&gt;例 : &lt;code&gt;2$x&lt;/code&gt; という指定子は、 &lt;code&gt;printf&lt;/code&gt; にとっては「整数である二つ目の引数を16進数で出力する」という意味であるが、 &lt;code&gt;format&lt;/code&gt; においては「二つ目の引数を、ストリームの &lt;code&gt;basefield&lt;/code&gt; フラグを &lt;code&gt;hex&lt;/code&gt; にセットして出力する」という意味でしかない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%|spec|&lt;/code&gt; ここで &lt;strong&gt;spec&lt;/strong&gt; は &lt;code&gt;printf&lt;/code&gt; の書式指定子である。 &lt;ul&gt;
&lt;li&gt;括弧[訳注：米英語では、二つの記号の組み合わせで何かを囲むものはすべてbracket(括弧)と呼び、ここでは縦棒 &lt;code&gt;|&lt;/code&gt; 二つを括弧と呼んでいる]は書式文字列の可読性を改善するが、本来は &lt;strong&gt;spec&lt;/strong&gt; の型変換文字を省略可能にするために導入された。この情報は C++ の変数には不要だが、 &lt;code&gt;printf&lt;/code&gt; の構文をそのまま用いる場合には、書式指定子の終端を決定するために必要だというだけの理由で、常に型変換文字を与える必要がある。 &lt;/li&gt;
&lt;li&gt;例 : &lt;code&gt;&#34;%|-5|&#34;&lt;/code&gt; は 次の変数を幅を 5 、左寄せにフォーマットする。これは &lt;code&gt;printf&lt;/code&gt; の以下の命令と同じものである : &lt;code&gt;&#34;%-5g&#34;&lt;/code&gt;, &lt;code&gt;&#34;%-5f&#34;&lt;/code&gt;, &lt;code&gt;&#34;%-5s&#34;&lt;/code&gt; ..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%N%&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;この単純な位置指定の表記は、 N 番目の引数を書式化オプションなしでフォーマットするよう要求するものである。 &lt;/li&gt;
&lt;li&gt;(これは &lt;code&gt;printf&lt;/code&gt; の位置指定命令(&lt;code&gt;&#34;%N$s&#34;&lt;/code&gt; のような)の短縮形に過ぎないが、ずっと読みやすく、また「型変換指定」文字を用いないですむというご利益がある)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;printf&lt;/code&gt; の標準の書式指定子に加えて、中寄せのような新しい機能が実装されている。詳細は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#new-format-specifications&#34;&gt;new format specification&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/printf-format-specifications&#34; name=&#34;printf-format-specifications&#34;&gt;printfフォーマット仕様&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Boost.Format でサポートされる &lt;code&gt;printf&lt;/code&gt; の書式指定子は、引数の位置指定をサポートしない標準 C の &lt;code&gt;printf&lt;/code&gt; よりも、むしろ Unix98 &lt;a href=&#34;http://www.opengroup.org/onlinepubs/7908799/xsh/fprintf.html&#34; target=&#34;_blank&#34;&gt;Open-group printf&lt;/a&gt; の構文に従っている。 (両者の間では共通のフラグは同じ意味を持つので、誰も頭痛に悩まされることはない) &lt;/p&gt;
&lt;p&gt;なお、一つの書式文字列に位置指定付きの書式指定子(例．&lt;code&gt;%3$+d&lt;/code&gt;)と位置指定なしのもの(例．&lt;code&gt;%+d&lt;/code&gt;)を混ぜて使用するのはエラーである。 
Open-group の仕様では同じ引数を複数回参照すること(例．&lt;code&gt;&#34;%1$d %1$d&#34;&lt;/code&gt;)は未定義動作であるが、 Boost.Format では各引数を何度でも参照できる。ただ一つの制約は、書式文字列に現れる最大の引数の数が P であるとき、必ず P 個の引数を期待することである。(例．&lt;code&gt;&#34;%1$d %10$d&#34;&lt;/code&gt; ならば P == 10) &lt;/p&gt;
&lt;p&gt;引数の数が多すぎても少なすぎても例外が起こる。 (そうでないようにセットされていなければ。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#exceptions&#34;&gt;exceptions&lt;/a&gt; を参照)&lt;/p&gt;
&lt;p&gt;書式指定子 &lt;strong&gt;spec&lt;/strong&gt; は次の形式を持つ : [ &lt;strong&gt;N&lt;/strong&gt;&lt;code&gt;$&lt;/code&gt; ] [ &lt;strong&gt;flags&lt;/strong&gt; ] [ &lt;strong&gt;width&lt;/strong&gt; ] [ . &lt;strong&gt;precision&lt;/strong&gt; ] &lt;strong&gt;type-char&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大括弧で囲われたフィールドは省略可能である。 各フィールドは以下のリストのように説明される :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;code&gt;$&lt;/code&gt; (省略可能なフィールド)は、その書式指定子が N 番目の引数に適用されると指定する。(これは &lt;strong&gt;位置指定書式指定子&lt;/strong&gt; と呼ばれる) &lt;/li&gt;
&lt;li&gt;これが与えられない場合、引数は前から順番に解釈される。(ただし、その後に引数番号付きの書式指定子を与えるのはエラーである)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flags&lt;/strong&gt; は以下の任意のシーケンスである :&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;フラグ&lt;/th&gt;
&lt;th&gt;意味&lt;/th&gt;
&lt;th&gt;内部ストリームへの作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;-&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左寄せ&lt;/td&gt;
&lt;td&gt;N/A (後で文字列に適用される)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;=&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;中寄せ&lt;/td&gt;
&lt;td&gt;N/A (後で文字列に適用される)&lt;br /&gt; &lt;code&gt;printf&lt;/code&gt; には存在しない(追加機能)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;+&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正の数であっても符号を表示する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;showpos&lt;/code&gt; をセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;#&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基数および小数点を表示する&lt;/td&gt;
&lt;td&gt;&lt;code&gt;showbase&lt;/code&gt; と &lt;code&gt;showpoint&lt;/code&gt; をセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;0&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0 で穴埋めする(符号および基数表示の後に挿入) 左寄せでない場合、 &lt;code&gt;setfill(&#39;0&#39;)&lt;/code&gt; を呼び出し &lt;code&gt;internal&lt;/code&gt; をセットする&lt;br /&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#user-defined-types-output&#34;&gt;ユーザ定義型&lt;/a&gt;を扱うためにストリーム変換の後に追加の動作を行う&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39; &#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列が &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; から始まらない場合、変換された文字の前にスペースを挿入&lt;/td&gt;
&lt;td&gt;N/A (後で文字列に適用される) &lt;br /&gt; &lt;code&gt;printf&lt;/code&gt; のものとは挙動が異なる : 内部のアライメントには影響されない&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;width&lt;/strong&gt; は変換の結果文字列に対する最小の幅を指定する。 必要ならば、文字列はアライメントにあわせてパディングされ、文字で埋める。この文字はマニピュレータ経由でストリームにセットされたものか、あるいは書式文字列で指定された文字(例． &lt;code&gt;&#39;0&#39;&lt;/code&gt;, &lt;code&gt;&#39;-&#39;&lt;/code&gt;, ... などのフラグ)である。 &lt;ul&gt;
&lt;li&gt;この幅は変換ストリームにセットされるのではないことに注意してほしい。 ユーザ定義型の出力をサポートする(これはいくつかのメンバに &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; を何度も呼び出すことになりうる)ため、幅の取り扱いはすべての引数オブジェクトのストリーム変換の後に、 &lt;code&gt;format&lt;/code&gt; クラスのコードの中で行われる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;precision&lt;/strong&gt; (小数点の後に続く)はストリームの精度をセットする。&lt;ul&gt;
&lt;li&gt;浮動少数点型の数値を出力する場合、&lt;ul&gt;
&lt;li&gt;固定小数点表示モードまたは指数表示モードでは、小数点より後ろの数字の最大文字数を設定する。&lt;/li&gt;
&lt;li&gt;デフォルトモード(%g のような&#39;ジェネラルモード&#39;)では、全体の数字の最大文字数を設定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;type-char&lt;/strong&gt; が &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;S&lt;/code&gt; の場合は別の意味を持つ : 変換文字列は最初の &lt;strong&gt;precision&lt;/strong&gt; 文字で切り詰められる。 (&lt;strong&gt;width&lt;/strong&gt; によるパディングは、この切り詰めの後で施される。)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;type-char&lt;/strong&gt; 。これは、対象になっている引数が指定した型のいずれかであることを強要しない。その型指定子に関連付けられたフラグをセットするだけである。&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型変換指定文字&lt;/th&gt;
&lt;th&gt;意味&lt;/th&gt;
&lt;th&gt;ストリームへの作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p&lt;/code&gt; または &lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;１６進数で出力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hex&lt;/code&gt; をセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;８進数で出力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;oct&lt;/code&gt; をセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点数の指数表記&lt;/td&gt;
&lt;td&gt;&lt;code&gt;floatfield&lt;/code&gt; ビットを &lt;code&gt;scientific&lt;/code&gt; にセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;f&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点数の固定小数点表記   &lt;code&gt;floatfield&lt;/code&gt; ビットを &lt;code&gt;fixed&lt;/code&gt; にセットする&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一般的な(デフォルトの)浮動小数点表記&lt;/td&gt;
&lt;td&gt;すべての &lt;code&gt;floatfield&lt;/code&gt; ビットを&lt;strong&gt;外す&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt; または &lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;それぞれの小文字と同じように作用。ただし数値の出力に際して大文字を用いる。(指数、１６進数、..)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&#39;x&#39;&lt;/code&gt;, &lt;code&gt;&#39;e&#39;&lt;/code&gt;, または &lt;code&gt;&#39;g&#39;&lt;/code&gt; と同じ作用に&lt;strong&gt;加え&lt;/strong&gt;、 &lt;code&gt;uppercase&lt;/code&gt; をセットする。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; または &lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;１０進数で出力&lt;/td&gt;
&lt;td&gt;&lt;code&gt;basefield&lt;/code&gt; ビットを &lt;code&gt;dec&lt;/code&gt; にセットする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt; または &lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字列を出力&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;precision&lt;/strong&gt; 指定子が外され、値は後の&#39;切り詰め&#39;のために内部フィールドへ送られる。 (上記の &lt;strong&gt;precision&lt;/strong&gt; の説明を参照)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt; または &lt;code&gt;C&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;１文字出力&lt;/td&gt;
&lt;td&gt;変換文字列の最初の文字のみが用いられる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字&lt;code&gt;%&lt;/code&gt;を表示&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;&#39;n&#39;&lt;/code&gt; 型指定子は、こうした流れに合わないので、無視される(そして対応する引数も)。 &lt;/p&gt;
&lt;p&gt;また、 &lt;code&gt;printf&lt;/code&gt; の &lt;code&gt;&#39;l&#39;&lt;/code&gt;, &lt;code&gt;&#39;L&#39;&lt;/code&gt;, あるいは &lt;code&gt;&#39;h&#39;&lt;/code&gt; 修飾子(ワイド、ロングおよびショート型を示す)もサポートされている(が、内部ストリームには何の作用もしない)。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/new-format-specifications&#34; name=&#34;new-format-specifications&#34;&gt;新たなフォーマット仕様&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;前述の表で述べたように、中寄せフラグ &lt;code&gt;&#39;=&#39;&lt;/code&gt; が追加された。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%{n&lt;/code&gt;&lt;strong&gt;t&lt;/strong&gt;&lt;code&gt;}&lt;/code&gt; は絶対桁送りを挿入する。ここで n は正の数である。 すなわち &lt;code&gt;format&lt;/code&gt; は、必要であれば、作成済みの文字列の長さが n 文字に届くまで文字で埋め込む。 (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#examples&#34;&gt;examples&lt;/a&gt; を参照)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%{n&lt;/code&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;code&gt;X}&lt;/code&gt; も同様に桁送りを挿入するが、埋め込む文字としてストリームの現在の「埋め込み」文字の代わりに &lt;code&gt;X&lt;/code&gt; を用いる。 (デフォルト状態のストリームではスペースを埋め込む)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/differences-of-behavior-vs-printf&#34; name=&#34;differences-of-behavior-vs-printf&#34;&gt;printfとの振る舞いの違い&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt; という二つの変数(組み込み型で、 C の &lt;code&gt;printf&lt;/code&gt; でサポートされているもの)と書式文字列&lt;code&gt;s&lt;/code&gt;があって、 &lt;code&gt;printf&lt;/code&gt; 関数で以下のように使われるとする :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;printf(s, x1, x2);
&lt;/pre&gt;&lt;/div&gt;

ほとんどすべてのケースで、その結果はこの命令と同じものになる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(s) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x1 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x2;
&lt;/pre&gt;&lt;/div&gt;

しかしいくつかの &lt;code&gt;printf&lt;/code&gt; 書式指定子はストリームの書式化オプションに上手く翻訳されないため、 Boost.Format の &lt;code&gt;printf&lt;/code&gt; エミュレーションには注意すべき僅かな不完全性がある。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; クラスは、 &lt;code&gt;printf&lt;/code&gt; の書式文字列を常に受け付けてほとんど同じ出力を生成するように、どのような場合でもサポートしないオプションを黙って無視する。 &lt;/p&gt;
&lt;p&gt;以下はそうした相違点のすべての一覧である :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;0&#39;&lt;/code&gt; および &lt;code&gt;&#39; &#39;&lt;/code&gt; オプション : &lt;code&gt;printf&lt;/code&gt; は数値以外の変換でこれらのオプションを無視するが、 &lt;code&gt;format&lt;/code&gt; は変数のあらゆる型にそれらを適用する。 (そのためこれらのオプションをユーザ定義型に対して用いることができる。例． &lt;code&gt;Rational&lt;/code&gt; クラスなど)&lt;/li&gt;
&lt;li&gt;汎整数型の引数に対する &lt;strong&gt;precision&lt;/strong&gt; は &lt;code&gt;printf&lt;/code&gt; では特別な意味を持つ : &lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf( &#34;(%5.3d)&#34; , 7 ) ;&lt;/code&gt; は &lt;code&gt;«( 007) »&lt;/code&gt; と出力する。 &lt;/li&gt;
&lt;li&gt;一方で &lt;code&gt;format&lt;/code&gt; は、ストリームと同様に、汎整数型への変換に対する精度パラメータを無視する。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; の &lt;code&gt;&#39;&lt;/code&gt; オプション (三桁ごとに数値をグループ化する書式)) は &lt;code&gt;format&lt;/code&gt; では無効である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; では、幅または精度がアスタリスク (&lt;code&gt;*&lt;/code&gt;) にセットされている場合、その値を与えられた引数から読み取る。例． &lt;code&gt;printf(&#34;%1$d:%2$.*3$d:%4$.*3$d\n&#34;, hour, min, precision, sec);&lt;/code&gt; [訳注：この例では、 &lt;code&gt;min&lt;/code&gt; と &lt;code&gt;sec&lt;/code&gt; を表示する際の精度は第三引数 &lt;code&gt;precision&lt;/code&gt; の値が用いられる。 &lt;code&gt;precision=3&lt;/code&gt; なら &lt;code&gt;&#34;%.3d&#34;&lt;/code&gt; だし、 &lt;code&gt;precision=10&lt;/code&gt; なら &lt;code&gt;&#34;%.10d&#34;&lt;/code&gt; になる。] &lt;ul&gt;
&lt;li&gt;このクラスは現在のところ、このメカニズムをサポートしない。そのためこのような精度または幅フィールドは構文解析の時点で黙って無視される。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に、特殊な &lt;code&gt;&#39;n&#39;&lt;/code&gt; 型指定子 (書式化によって出力された文字数を変数に格納するよう &lt;code&gt;printf&lt;/code&gt; に命じるのに用いる) は &lt;code&gt;format&lt;/code&gt; では無効である。&lt;/p&gt;
&lt;p&gt;そのためこの型指定子を含む書式文字列は &lt;code&gt;printf&lt;/code&gt; でも &lt;code&gt;format&lt;/code&gt; でも同じ変換文字列を生成する。 &lt;code&gt;printf&lt;/code&gt; と &lt;code&gt;format&lt;/code&gt; で書式化された文字列に違いは生じない。 &lt;/p&gt;
&lt;p&gt;Boost.Format で書式化された文字数をを得るには以下のようにする :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format &lt;span style=&#34;color: #0000FF&#34;&gt;formatter&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%+5d&#34;&lt;/span&gt;);
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; formatter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; x;
&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; formatter.str().size();
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/user-defined-types-output&#34; name=&#34;user-defined-types-output&#34;&gt;ユーザー定義型の出力&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ストリーム状態の修飾に翻訳されたすべてのフラグは、ユーザ定義型にも再帰的に作用する。 ( フラグはアクティブなまま残るので、 ユーザ定義クラスによって呼ばれる各々の &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 演算に対しても、期待するオプションが渡される) &lt;/p&gt;
&lt;p&gt;例．妥当なクラス &lt;code&gt;Rational&lt;/code&gt; なら次のようになる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Rational &lt;span style=&#34;color: #0000FF&#34;&gt;ratio&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;16&lt;/span&gt;,&lt;span style=&#34;color: #666666&#34;&gt;9&lt;/span&gt;);
cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%#x &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;0x10/0x9 \n&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

その他の書式化オプションでは話は異なる。例えば、幅の設定はオブジェクトによって生成される最終出力に適用され、内部の各々の出力には適用されない。これは都合のいい話である :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%-8d&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;16/9    &#34; であって、 &#34;16      /9       &#34; ではない&lt;/span&gt;
cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%=8d&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;  16/9  &#34; であって、 &#34;   16   /    9   &#34; ではない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

しかし、 &lt;code&gt;0&lt;/code&gt; や &lt;code&gt;&#39; &#39;&lt;/code&gt; オプションにも同様に働くため、不自然なことになってしまう。(意地の悪いことに、 &lt;code&gt;&#39;+&#39;&lt;/code&gt; が &lt;code&gt;showpos&lt;/code&gt; によってストリームの状態へと直接翻訳できるのに対して、 &lt;code&gt;printf&lt;/code&gt; のゼロやスペースに当たるオプションはストリームには存在しない) :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%+08d &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;+00016/9&#34;&lt;/span&gt;
cerr &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;% 08d &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;)  &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; ratio;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// -&amp;gt; &#34;000 16/9&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/manipulators-and-the-internal-stream-state&#34; name=&#34;manipulators-and-the-internal-stream-state&#34;&gt;マニピュレータと、内部的なストリーム状態&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; の内部ストリームの状態は、引数を出力する直前に保存され、直後に復帰される。そのため、修飾子の影響は後まで引きづられずに、適用される引数にだけ作用する。 &lt;/p&gt;
&lt;p&gt;ストリームのデフォルト状態は標準で述べられているように : 精度 6 、幅 0 、右寄せ、そして１０進数基数である。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; ストリームの内部ストリームの状態は引数と一緒に渡されるマニピュレータによって変えることができる； &lt;code&gt;group&lt;/code&gt; 関数を経由して以下のようにできる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1% %2% %1%&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; group(hex, showbase, &lt;span style=&#34;color: #666666&#34;&gt;40&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#34;0x28 50 0x28\n&#34; と表示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;group&lt;/code&gt; の内側にある N 個の項目を渡すとき、 Boost.Format はマニピュレータに通常の引数とは異なる処理をする必要がある。そのため、 &lt;code&gt;group&lt;/code&gt; の使用には以下の制限がある :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表示されるオブジェクトは &lt;code&gt;group&lt;/code&gt; の最後の項目として渡されなければならない&lt;/li&gt;
&lt;li&gt;先頭の N-1 個の項目はマニピュレータとして扱われるので、出力を生成しても破棄される&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;マニピュレータは、それが現れるごとに、後に続く引数の直前にストリームに渡される。 書式文字列で指定された書式化オプションは、この方法で渡されたストリーム状態修飾子によって上書きされる点に注意して欲しい。 例えば以下のコードで、 &lt;code&gt;hex&lt;/code&gt; マニピュレータは、書式文字列の中で１０進数出力を設定している型指定子 d よりも高い優先度を持つ :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1$d %2% %1%&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; group(hex, showbase, &lt;span style=&#34;color: #666666&#34;&gt;40&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; 
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#34;0x28 50 0x28\n&#34; と表示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/alternatives&#34; name=&#34;alternatives&#34;&gt;代替手段&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;printf&lt;/em&gt; は古典的な代替手段である。型安全でなく、ユーザ定義型に対して拡張可能ではない。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ece.ucdavis.edu/~kenelson/ofrstream.cc&#34; target=&#34;_blank&#34;&gt;ofrstream.cc&lt;/a&gt; Karl Nelson によるデザインはこの &lt;code&gt;format&lt;/code&gt; クラスへのインスピレーションの大きな源となった。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.yahoo.com/group/boost/files/format/&#34; target=&#34;_blank&#34;&gt;format.hpp&lt;/a&gt; Rüiger Loo による。 &lt;code&gt;boost:format&lt;/code&gt; クラスの以前の提案だった。 デザインの簡易さにおいてこのクラスの起源である。最小主義的な &lt;code&gt;&#34;%1 %2&#34;&lt;/code&gt; という構文はこのクラスでも借用している。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.gabi-soft.de/code/gabi-lib.tgz&#34; target=&#34;_blank&#34;&gt;James Kanze&#39;s library&lt;/a&gt; は非常に洗練された &lt;code&gt;format&lt;/code&gt; クラス (&lt;code&gt;srcode/Extended/format&lt;/code&gt;) を持っている。 そのデザインは、実際の変換に内部ストリームを用いる点や引数渡しに演算子を用いる点で、このクラスと共通している。 (しかし彼のクラス &lt;code&gt;ofrstream&lt;/code&gt; は &lt;code&gt;operator%&lt;/code&gt; ではなく &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; を用いている)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.yahoo.com/group/boost/files/format3/&#34; target=&#34;_blank&#34;&gt;Karl Nelson&#39;s library&lt;/a&gt; は、 Boost.Format のデザインのための boost メーリングリストの討論において、別の解決法を示すために用意された。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/Exceptions&#34; name=&#34;exceptions&#34;&gt;例外&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Format は &lt;code&gt;format&lt;/code&gt; オブジェクトの使い方にいくつかのルールを強要する。書式文字列は前述の構文に従わなくてはならず、ユーザは最終的な出力までに正しい個数の引数を供給しなければならない。また &lt;code&gt;modify_item&lt;/code&gt; や &lt;code&gt;bind_arg&lt;/code&gt; を用いるなら、項目や引数のインデックスが範囲外を指してはならない。&lt;/p&gt;
&lt;p&gt;ミスが見過ごされたり放置されたりしないように、 &lt;code&gt;format&lt;/code&gt; はいずれかのルールが満たされていないことを検出すると対応する例外を発生する。&lt;/p&gt;
&lt;p&gt;しかしユーザはこの振る舞いを必要に応じて変えることができる。また、どのエラーの型が発生するかを次の関数を用いて選択できる :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;exceptions&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; newexcept); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クエリおよび設定&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; exceptions() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;                  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クエリのみ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

ユーザは、以下のアトムを２進演算で結合することで引数 &lt;code&gt;newexcept&lt;/code&gt; を算出できる :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::io::bad_format_string_bit&lt;/code&gt; 書式文字列が適切でなければ例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::too_few_args_bit&lt;/code&gt; すべての引数が渡される前に結果の文字列を尋ねられたとき、例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::too_many_args_bit&lt;/code&gt; 渡された引数の数が多すぎれば例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::out_of_range_bit&lt;/code&gt; &lt;code&gt;modify_item&lt;/code&gt; や項目インデックスを取る他の関数の呼び出し(および引数のインデックス）の際に、ユーザの与えたインデックスが範囲外であれば例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::all_error_bits&lt;/code&gt; すべてのエラーで例外を発生する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::io::no_error_bits&lt;/code&gt; いずれのエラーでも例外を発生しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例えば、 Boost.Format が引数の個数をチェックしないようにしたければ、適切な例外設定を施した &lt;code&gt;format&lt;/code&gt; オブジェクトを作る特殊なラッパ関数を定義する :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format my_fmt(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; f_string) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io;
    format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter&lt;/span&gt;(f_string);
    fmter.exceptions( all_error_bits &lt;span style=&#34;color: #666666&#34;&gt;^&lt;/span&gt; ( too_many_args_bit &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; too_few_args_bit )  );
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; fmter;
}
&lt;/pre&gt;&lt;/div&gt;

すると、必要とされるよりも多くの引数を与えても許される(単に無視される) :&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; my_fmt(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34; %1% %2% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

また、すべての引数が与えられる前に結果を問い合わせると、結果の対応する部分は単に空になる&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; my_fmt(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34; _%2%_ _%1%_ &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt; ;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// prints      &#34; __ _1_ \n&#34;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/extract&#34; name=&#34;extract&#34;&gt;抜粋&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;charT&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Traits&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;char_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;basic_format&lt;/span&gt; 
{
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;basic_string&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT, Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;string_t&lt;/span&gt;,
  basic_format(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; charT&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; str);
  basic_format(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; charT&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; str, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;locale &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; loc);
  basic_format(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;string_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; s);
  basic_format(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;string_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; s, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;locale &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; loc);

  &lt;span style=&#34;color: #B00040&#34;&gt;string_t&lt;/span&gt; str() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// pass arguments through those operators :&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;  basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;(T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x);  
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;  basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x);

  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// dump buffers to ostream :&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;friend&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;basic_ostream&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT, Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ( std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;basic_ostream&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT, Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; , basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; ); 

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ............  これはただの抜粋である .......&lt;/span&gt;
}; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// basic_format&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;          format;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;wchar_t&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;      wformat;


&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; io {
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// free function for ease of use :&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;charT&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Traits&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;basic_string&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT,Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;  str(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; basic_format&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;charT,Traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; f) {
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; f.str();
}
} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//namespace io&lt;/span&gt;


} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// namespace boost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/rationale&#34; name=&#34;rationale&#34;&gt;設計原理&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このクラスのゴールは、より良い、 C++ 用の、型安全かつ型拡張性のある &lt;code&gt;printf&lt;/code&gt; の等価物が、 ストリームとともに用いられるようにすることである。&lt;/p&gt;
&lt;p&gt;正確には、 &lt;code&gt;format&lt;/code&gt; は以下の機能を実現するようデザインされた :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引数の位置指定のサポート(国際化に必要)&lt;/li&gt;
&lt;li&gt;個数無制限の引数を許す。&lt;/li&gt;
&lt;li&gt;書式化命令の見た目を自然にする。&lt;/li&gt;
&lt;li&gt;書式文字列の構文に加えて、引数の出力を修飾するためのマニピュレータをサポー ト。&lt;/li&gt;
&lt;li&gt;あらゆる型の変数を受け付ける。文字列への実際の変換はストリームに任せる。 これは特にユーザ定義型について、書式化オプションの作用が直観的に自然なものとなるよう考慮したものである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; 互換性の提供、型安全で型拡張性のある文脈においてもできるだけ意味をなすようにする。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;デザインの過程で多くの問題に直面し、いくつかの選択をすることになったが、 中には直観的には正しくないものもあった。しかしいずれのケースにも &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/choices.html&#34;&gt;何らかの意味がある&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/credits&#34; name=&#34;credits&#34;&gt;クレジット&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Format の著者は Samuel Krempp である。彼は Rüiger Loos と Karl Nelson の両者の &lt;code&gt;format&lt;/code&gt; クラスのアイディアを利用した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;February 19, 2002&lt;/p&gt;
&lt;p&gt;© Copyright Samuel Krempp 2002. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>