<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2014-12-22T16:10:59.668784</updated>
  <id>0ff1aa45-d68a-4cc4-a186-31de1a18f208</id>

  
    <entry>
      <title>the Boost Graph Library -- Boost.Graph : dfs_visitorを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph.html"/>
      <id>80d19ddcfe909b9fefc56a9e2079c4ffbe155130:archive/boost_docs/libs/graph.md</id>
      <updated>2014-12-22 16:10:53 +0900</updated>
      
        <content type="html">&lt;h1&gt;the Boost Graph Library&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/table_of_contents.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/table_of_contents.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/bgl-cover.jpg&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;BGLへの序章&lt;/li&gt;
&lt;li&gt;歴史&lt;/li&gt;
&lt;li&gt;刊行物&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/acknowledgements.html&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;クイック・ツアー&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html&#34;&gt;基本的なグラフ理論の復習&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;チュートリアル&lt;ol&gt;
&lt;li&gt;Property Maps&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;adjacency_list&lt;/code&gt; class&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;例題&lt;ol&gt;
&lt;li&gt;ファイル依存関係の例&lt;/li&gt;
&lt;li&gt;Kevin Bacon の６次数&lt;/li&gt;
&lt;li&gt;Graph Coloring&lt;/li&gt;
&lt;li&gt;Sparse Matrix Ordering&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;BGL 拡張&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/constructing_algorithms.html&#34;&gt;BGLでグラフアルゴリズムを構築する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Converting Existing Graphs to BGL&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Boost Graph インタフェイス&lt;ol&gt;
&lt;li&gt;Graph&lt;/li&gt;
&lt;li&gt;Incidence Graph&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BidirectionalGraph.html&#34;&gt;Bidirectional Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;Adjacency Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vertex List Graph&lt;/li&gt;
&lt;li&gt;Edge List Graph&lt;/li&gt;
&lt;li&gt;Vertex and Edge List Graph&lt;/li&gt;
&lt;li&gt;Mutable Graph&lt;/li&gt;
&lt;li&gt;Property Graph&lt;/li&gt;
&lt;li&gt;Mutable Property Graph&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The Property Map Library （専門的にはグラフ・ライブラリの部分ではないが、ここで使用される頻度が高い）&lt;/li&gt;
&lt;li&gt;ビジタ・コンセプト&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS （幅優先探査） Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DFS （深度優先探査） Visitor&lt;/li&gt;
&lt;li&gt;Dijkstra Visitor&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;Bellman Ford Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Event Visitor&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;EventVisitorList アダプタ&lt;ol&gt;
&lt;li&gt;Event Visitor List&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dijkstra_visitor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html&#34;&gt;&lt;code&gt;bellman_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;イベント・ビジタ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・クラス&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・アダプタ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;subgraph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filtered_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector as Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Matrix as Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Leda Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Stanford GraphBase&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;イテレータ・アダプタ&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特性クラス&lt;ol&gt;
&lt;li&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bgl_named_params.html&#34;&gt;&lt;code&gt;bgl_named_params&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;核となるアルゴリズム・パターン&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html&#34;&gt;&lt;code&gt;breadth_first_visit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html&#34;&gt;&lt;code&gt;depth_first_visit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undirected_dfs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform_cost_search&lt;/code&gt; (非推奨、代わりに Dijkstra を使うこと)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・アルゴリズム&lt;ol&gt;
&lt;li&gt;最短経路アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;code&gt;dijkstra_shortest_paths&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html&#34;&gt;&lt;code&gt;bellman_ford_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html&#34;&gt;&lt;code&gt;dag_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;johnson_all_pairs_shortest_paths&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最小全域木アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;code&gt;kruskal_minimum_spanning_tree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prim_minimum_spanning_tree&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/connected_components.html&#34;&gt;&lt;code&gt;connected_components&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strong_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Incremental Connected Components&lt;ol&gt;
&lt;li&gt;&lt;code&gt;initialize_incremental_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;incremental_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;same_component&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component_index&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最大流アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;code&gt;edmunds_karp_max_flow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push_relabel_max_flow&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topological_sort&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transitive_closure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/copy_graph.html&#34;&gt;&lt;code&gt;copy_graph&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transpose_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isomorphism&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/cuthill_mckee_ordering.html&#34;&gt;&lt;code&gt;cuthill_mckee_ordering&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sequential_vertex_coloring&lt;/code&gt;(アンドキュメント)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minimum_degree_ordering&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;AT&amp;amp;T Graphviz フォーマット入出力ユーティリティ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;write_graphviz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_graphviz&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;補助コンセプト、補助クラス、補助関数&lt;ol&gt;
&lt;li&gt;&lt;code&gt;property&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BasicMatrix.html&#34;&gt;BasicMatrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;incident&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opposite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;bandwidth&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;ith_bandwidth&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tools for random graphs&lt;ol&gt;
&lt;li&gt;&lt;code&gt;random_vertex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;random_edge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;generate_random_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;randomize_property&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;目標と To-Do 項目&lt;/li&gt;
&lt;li&gt;トラブルシューティング&lt;/li&gt;
&lt;li&gt;既知の問題&lt;/li&gt;
&lt;li&gt;FAQ&lt;/li&gt;
&lt;li&gt;BGL Book Errata&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dfs_visitor&lt;EventVisitorList&gt; -- Boost.Graph : dfs_visitorを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html"/>
      <id>80d19ddcfe909b9fefc56a9e2079c4ffbe155130:archive/boost_docs/libs/graph/dfs_visitor.md</id>
      <updated>2014-12-22 16:10:53 +0900</updated>
      
        <content type="html">&lt;h1&gt;dfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;例は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた EventVisitor のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは DFSVisitor に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが &lt;code&gt;EventVisitorList&lt;/code&gt; の中の EventVisitor にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_dfs_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを DFS ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list -- リンクミスを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html"/>
      <id>189d7ba59ec0b7c93c2a3f48e4a913ce28ab1e52:archive/boost_docs/libs/graph/adjacency_list.md</id>
      <updated>2014-12-22 15:39:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;adjacency_list&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed,
               VertexProperties, EdgeProperties,
               GraphProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;adjacency_list&lt;/code&gt; クラスは一般化された隣接リストグラフ構造を実装する。 テンプレート・パラメータは要求を最も満たすクラスのバージョンを選べるように多くの形態の選択肢を提供する。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34;&gt;adjacency-list&lt;/a&gt; は基本的に二次元の構造で、ここで最初の次元の各要素は頂点を表し、頂点の各々はその辺リストの一次元構造を含んでいる。 Figure 1 は有向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 1:有向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータは外部の二次元コンテナを表すためにどんな種類のコンテナが使われるかを制御する。 &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータは辺リストを表すためにどんな種類の コンテナが使われるかを制御する。&lt;code&gt;EdgeList&lt;/code&gt; と &lt;code&gt;VertexList&lt;/code&gt; の 選択はグラフ構造の空間計算量を決定するだろう、そして様々なグラフ操作の時間計算量を決定するだろう。可能な選択とトレード・オフは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.html#choosing-graph-type&#34;&gt;Choosing the Edgelist and VertexList&lt;/a&gt; 中で論じられる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータはグラフが有向か無向か、または 入辺と出辺の両方にアクセスする (これを双方向性と呼ぶ) 有向かを制御する。 双方向性グラフは各辺が出辺リストと入辺リストの両方に現れるため、辺当たり有向グラフの二倍の空間を取る。Figure 2 は無向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 2:無向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの使い方のチュートリアルは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.html&#34;&gt;Using &lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/example/family-tree-eg.cpp.html&#34;&gt;&lt;code&gt;examples/family-tree-eg.cpp&lt;/code&gt;&lt;/a&gt; 中にある例は家族の木 (family tree) をグラフで表現する方法を示す。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各々の頂点の辺リストを表わすために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの頂点リストを表すために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向か、無向か、または双方向の辺アクセス (出辺と入辺の両方にアクセス する) の有向かを選ぶ選択子。選択肢は &lt;code&gt;directedS&lt;/code&gt;、&lt;code&gt;undirectedS&lt;/code&gt;、 そして &lt;code&gt;bidirectionalS&lt;/code&gt; である。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ・オブジェクトのためのプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.html&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.html&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Vertex and Edge Properties&lt;/h2&gt;
&lt;p&gt;色、距離、重み、そしてユーザ定義のプロパティのようなプロパティは、プロパティ を用いてグラフの頂点と辺に結びつけることができる。プロパティの値はグラフに よって提供されるプロパティ・マップ経由で読み書きできる。プロパティ・マップ は get(property, g) 関数経由で得られる。プロパティの使い方は 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.html#adjacency-list-properties&#34;&gt;Internal Properties&lt;/a&gt; 内で述べられている。プロパティ・マップは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.html&#34;&gt;Property Map Concepts&lt;/a&gt; 内で定義されているインターフェースを実装するオブジェクトである。 &lt;code&gt;adjacency_list&lt;/code&gt; クラスから得られるプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; コンセプトのモデルである。もし &lt;code&gt;adjacency_list&lt;/code&gt; が &lt;code&gt;const&lt;/code&gt; なら、 プロパティ・マップは定数である。さもなくばプロパティ・マップは変更可能である。&lt;/p&gt;
&lt;p&gt;もしグラフの &lt;code&gt;VertexList&lt;/code&gt; が &lt;code&gt;vecS&lt;/code&gt; なら、グラフは &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティのためのプロパティ・マップを経由して アクセスされた組み込みの頂点の添え字を持っている。添え字は &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲内に整列し、連続している。頂点が 削除される時、添え字はそれらのプロパティを持ち続けるよう調整される。 これらの添え字を外部のプロパティの記憶領域にアクセスするために使う際には いくらか気をつけなければならない。 頂点の添え字のためのプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルである。&lt;/p&gt;
&lt;h2&gt;Iterator and Descriptor Stability/Invalidation&lt;/h2&gt;
&lt;p&gt;辺の追加や削除によってグラフの構造を変更する時はいくらか注意しなければならない。&lt;code&gt;adjacency_list&lt;/code&gt; の型と操作に依存して、グラフ内を指すイテレータや記述子オブジェクトのいくつかは無効になるかもしれない。 例えば、次のコードは未定義の (悪い) 振る舞いの結果となるだろう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, vecS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=vecS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これでもまだ間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;

これが問題である理由は &lt;code&gt;remove_vertex()&lt;/code&gt; を呼び出しており、そしてそれが &lt;code&gt;VertexList=vecS&lt;/code&gt; の &lt;code&gt;adjacency_list&lt;/code&gt; とともに使われたとき、グラフのための全てのイテレータと記述子 (例えば &lt;code&gt;vi&lt;/code&gt; や &lt;code&gt;vi_end&lt;/code&gt;) を無効にするために、ループの次の繰り返し中に災難を引き起こす。&lt;/p&gt;
&lt;p&gt;もし異なる種類の &lt;code&gt;adjacency_list&lt;/code&gt; を使い、そして &lt;code&gt;VertexList=listS&lt;/code&gt; ならば、イテレータが削除された実際の頂点を指してなければ &lt;code&gt;remove_vertex&lt;/code&gt; を呼ぶことによってイテレータは無効にならない。次のコードはこれを説明する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, listS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=listS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これは大丈夫である&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;

安定性の問題は更に頂点記述子と辺記述子に影響を及ぼす。例えば、最短経路木中の頂点の親 (または先行点) の過程を保持するために頂点記述子の &lt;code&gt;vector&lt;/code&gt; を使ったとしよう (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ)。&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; を呼んで親の &lt;code&gt;vector&lt;/code&gt; を作成し、 それからグラフから頂点を削除する。続いて親の &lt;code&gt;vector&lt;/code&gt; を使おうと試みるが、全ての頂点記述子は無効になっているので、結果は正しくない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(num_vertices(G));
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(num_vertices(G));

dijkstra_shortest_paths(G, s, distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
  predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));

remove_vertex(s, G); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// まずい考えだ！親 vector 中の頂点記述子を無効にする&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 次は間違った結果を生じる&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(tie(vi, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; p[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; is the parent of &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;

この議論の中でイテレータと記述子の無効化は、操作によって &lt;strong&gt;直接影響を受けない&lt;/strong&gt; イテレータと記述子の無効化に携わっていることに注意しなさい。 例えば、&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の実行は、&lt;code&gt;adjacency_list&lt;/code&gt; の種類に関係なく、いつも &lt;code&gt;(u,v)&lt;/code&gt; のためのどの辺記述子も、また&lt;code&gt;(u,v)&lt;/code&gt; を指すどの辺記述子も無効にするだろう。 このイテレータと記述子の無効化の議論中で、他の辺 (&lt;code&gt;(u,v)&lt;/code&gt; ではない) を指す辺記述子とイテレータにおける &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の影響にのみ携わっている。&lt;/p&gt;
&lt;p&gt;一般的に頂点記述子と辺記述子を安定に (決して無効にならない) したければ、 &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; と &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;listS&lt;/code&gt; または &lt;code&gt;setS&lt;/code&gt; を使いなさい。もし記述子とイテレータの安定性に気をもまないけれどもメモリの 消費量とグラフの巡回速度をより心配するなら、&lt;code&gt;VertexList&lt;/code&gt; かつ／または &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;vecS&lt;/code&gt; を使いなさい。&lt;/p&gt;
&lt;p&gt;下記の表はどの操作が記述子とイテレータを無効にする原因となるかを要約する。 表中で、&lt;code&gt;EL&lt;/code&gt; は &lt;code&gt;EdgeList&lt;/code&gt; の省略形で &lt;code&gt;VL&lt;/code&gt; は &lt;code&gt;VertexList&lt;/code&gt; を意味する。 &lt;strong&gt;Adj Iter (隣接イテレータ)&lt;/strong&gt; カテゴリは &lt;code&gt;out_edge_iterator&lt;/code&gt;、&lt;code&gt;in_edge_iterator&lt;/code&gt;、そして &lt;code&gt;adjacency_iterator&lt;/code&gt; 型を含む。記述子とイテレータの無効化の より詳しい説明は各操作のドキュメント中で示されている。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;頂点記述子&lt;/th&gt;
&lt;th&gt;辺記述子&lt;/th&gt;
&lt;th&gt;頂点イテレータ&lt;/th&gt;
&lt;th&gt;辺イテレータ&lt;/th&gt;
&lt;th&gt;隣接イテレータ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_out_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_in_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table: 記述子とイテレータの無効化の要約&lt;/p&gt;
&lt;h2&gt;Associated Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;

and&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;adjacency_list_traits&amp;lt;EdgeList, VertexList, Directed&amp;gt;::vertex_descriptor
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた頂点記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;

and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた辺記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;VertexList=vecS&lt;/code&gt; なら &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;EdgeList=vecS&lt;/code&gt; なら &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;adjacency_iterator&lt;/code&gt; は &lt;code&gt;out_edge_iterator&lt;/code&gt; と同じイテレータ・ コンセプトをモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;

and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;

グラフが有向 (&lt;code&gt;directed_tag&lt;/code&gt;) か、無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) かについての情報を提供する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;

and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;

これはグラフのクラスが多重辺 (同じ始点と終点を持つ辺) の挿入を許可するかどうかを述べる。二つのタグは &lt;code&gt;allow_parallel_edge_tag&lt;/code&gt; と &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;code&gt;setS&lt;/code&gt; と &lt;code&gt;hash_setS&lt;/code&gt; の亜種は多重辺を許可しない一方で他の型は多重辺を許可する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;

グラフ中の頂点の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_size_type
&lt;/pre&gt;&lt;/div&gt;

グラフ中の辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;

グラフ中の頂点に接続する辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;

and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;

グラフ中の頂点プロパティまたは辺プロパティのためのプロパティ・マップの型。 具体的なプロパティは &lt;code&gt;Property&lt;/code&gt; テンプレート引数で指定され、グラフのための &lt;code&gt;VertexProperties&lt;/code&gt; もしくは &lt;code&gt;EdgeProperties&lt;/code&gt; で指定されたプロパティのどちらか一つと一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;Property&lt;/code&gt; タグで指定されたグラフのプロパティのためのプロパティの値型。&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;

デフォルト・コンストラクタ。0 個の頂点と0 個の辺からなる空のグラフ・ オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;

コピー・コンストラクタ。辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーである新しいグラフを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;

代入演算子。&lt;code&gt;this&lt;/code&gt; に 辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーを入れる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(vertices_size_type n, 
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;n&lt;/code&gt; 個の頂点と 0 個の辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;template &amp;lt;class EdgeIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               vertices_size_type n, 
               edges_size_type m = 0, 
               const GraphProperty&amp;amp; p = GraphProperty())&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;
`n` 個の頂点と、範囲 `[first, last)` で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 `EdgeIterator` は [`InputIterator`](http://www.sgi.com/tech/stl/InputIterator.html) のモデルでなければならない。`EdgeIterator` の値型は `std::pair` でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは `[0, n)` の範囲内に整列していなければならない。


***
```cpp
template &amp;lt;class EdgeIterator, class EdgePropertyIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               EdgePropertyIterator ep_iter,
               vertices_size_type n,
               vertices_size_type m = 0,
               const GraphProperty&amp;amp; p = GraphProperty())
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;n&lt;/code&gt; 個の頂点と、範囲 &lt;code&gt;[first, last)&lt;/code&gt; で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; と &lt;code&gt;EdgePropertyIterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;code&gt;EdgeIterator&lt;/code&gt; の値型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは &lt;code&gt;[0, n)&lt;/code&gt; の範囲内に整列していなければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperties&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear()
&lt;/pre&gt;&lt;/div&gt;

グラフから全ての辺と頂点を削除する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;this&lt;/code&gt; のグラフの頂点、辺、そしてプロパティと、グラフ&lt;code&gt;x&lt;/code&gt;の頂点、辺、そしてプロパティを交換する。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;h3&gt;Structure Access&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; の出辺へのアクセスを提供するイテレータ範囲を返す。もしグラフが無向グラフなら、このイテレータ範囲は 頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。 有向グラフと無向グラフの両方で、出辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; に隣接する頂点の場合は &lt;code&gt;source(e, g) == u&lt;/code&gt; かつ &lt;code&gt;target(e, g) == v&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
in_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する イテレータ範囲を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに &lt;code&gt;bidirectionalS&lt;/code&gt; が指定されている場合にのみ利用できる。 入辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; に隣接している何らかの頂点 &lt;code&gt;u&lt;/code&gt; に対して、グラフが有向であろうと無向であろうと、&lt;code&gt;target(e, g) == v&lt;/code&gt; かつ &lt;code&gt;source(e, g) == u&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

頂点 &lt;code&gt;u&lt;/code&gt; を出て行く辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
in_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

頂点 &lt;code&gt;u&lt;/code&gt; に入ってくる辺の数を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに&lt;code&gt;bidirectionalS&lt;/code&gt;が指定されている場合にのみ利用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type
num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type
num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフの頂点リスト中の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; と頂点 &lt;code&gt;v&lt;/code&gt; を結ぶ辺を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge_range(vertex_descriptor u, vertex_descriptor v,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; への全ての多重辺のための範囲を与える出辺イテレータのペアを返す。この関数は &lt;code&gt;adjacency_list&lt;/code&gt; 用の &lt;code&gt;EdgeList&lt;/code&gt; が終点に従って出辺をソートし、かつ多重辺を考慮するコンテナである時にのみ動作する。&lt;code&gt;multisetS&lt;/code&gt; 選択子はそのようなコンテナを選択する。&lt;/p&gt;
&lt;h3&gt;Structure Modification&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフに辺 &lt;code&gt;(u,v)&lt;/code&gt; を付け加え、新しい辺のための辺記述子を返す。 多重辺を許可しないグラフにとっては、もし辺がすでにグラフ中にあるなら、二重には付け加えられず、&lt;code&gt;bool&lt;/code&gt; フラグは &lt;code&gt;false&lt;/code&gt; になるだろう。同様に、もし &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; が 同じ頂点のための記述子 (ループを作っている) であり、かつグラフが無向グラフならば、辺は付け加えられずフラグは &lt;code&gt;false&lt;/code&gt; になるだろう。 フラグが &lt;code&gt;false&lt;/code&gt; の時は、返された辺記述子は既に存在している辺を指す。&lt;/p&gt;
&lt;p&gt;出辺リスト中の新しい辺の配置は一般に不定である。もっとも出辺リストの順序付けは &lt;code&gt;EdgeList&lt;/code&gt; の選択を通じて成し遂げられるが。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;VertexList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; でありかつ頂点記述子 &lt;code&gt;u&lt;/code&gt; または &lt;code&gt;v&lt;/code&gt; (それは整数である) がグラフ中の現在の頂点の数より大きな値を持っているなら、頂点の数が &lt;code&gt;std::max(u,v) + 1&lt;/code&gt; に なるようにグラフが拡大される。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; であれば、この操作によって頂点 &lt;code&gt;u&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; も無効になるだろう。 これはもし &lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;push(container, x)&lt;/code&gt; が呼び出されたときにそのイテレータを無効にするようなユーザ定義のコンテナ (章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.html#custom-storage&#34;&gt;Customizing the Adjacency List Storage&lt;/a&gt; を見なさい) であれば同様にあてはまる。 もしグラフが同様に双方向であれば、&lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;in_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりに グラフが無向グラフならば &lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりにグラフが有向グラフならば、 &lt;code&gt;add_edge()&lt;/code&gt; は同様にどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフに付け加え、&lt;code&gt;p&lt;/code&gt; を辺の内部のプロパティの記憶領域の値として添える。さらなる詳細のために前の &lt;code&gt;add_edge()&lt;/code&gt; 非メンバ関数も見なさい。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから取り除く。&lt;/p&gt;
&lt;p&gt;この操作は辺 &lt;code&gt;(u,v)&lt;/code&gt; を指すどの発行済みの辺記述子もイテレータも無効となる原因になる。加えて、もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; ならば無向と双方向のグラフの場合この操作は頂点 &lt;code&gt;u&lt;/code&gt; とまた頂点 &lt;code&gt;v&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

辺 &lt;code&gt;e&lt;/code&gt; をグラフから取り除く。これは多重グラフの場合 &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数とは違う。この &lt;code&gt;remove_edge(e, g)&lt;/code&gt; 関数は一つの辺だけを取り除くのに対して &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数は全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を取り除く。&lt;/p&gt;
&lt;p&gt;この操作は記述子 &lt;code&gt;e&lt;/code&gt; が指す同じ辺のためのどの発行済みの辺記述子も イテレータも無効にする。加えて、この操作は &lt;code&gt;target(e, g)&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはグラフのためのどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(out_edge_iterator iter, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

これは &lt;code&gt;remove_edge(*iter, g)&lt;/code&gt; と同じ効果を持つ。違いはこの関数は有向グラフの場合定数の時間計算量を持つのに対し、&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は O(E/V) の時間計算量を持つ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_out_edge_if(vertex_descriptor u, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                        adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;u&lt;/code&gt; の出辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_in_edge_if(vertex_descriptor v, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                       adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;v&lt;/code&gt; の入辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向と双方向の &lt;code&gt;adjacency_list&lt;/code&gt; グラフに利用できるが、有向グラフには利用できない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge_if(&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての辺を取り除く。すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

頂点をグラフに付け加え、新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
           adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

指定されたプロパティを持つ頂点をグラフに付け加える。新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;u&lt;/code&gt; への、そして &lt;code&gt;u&lt;/code&gt; からの全ての辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点または終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_out_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

頂点 &lt;code&gt;u&lt;/code&gt; からの全ての出辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点として 持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出す時のそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向グラフには適用できない (代わりに &lt;code&gt;clear_vertex()&lt;/code&gt; を使いなさい)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_in_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

頂点 &lt;code&gt;u&lt;/code&gt; からの全ての入辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は双方向グラフにのみ適用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

頂点 &lt;code&gt;u&lt;/code&gt; をグラフの頂点集合から取り除く。頂点が削除されるとき、 頂点 &lt;code&gt;u&lt;/code&gt; への、また頂点 &lt;code&gt;u&lt;/code&gt; への辺は存在しないものと仮定する。 これを確実にする一つの手段はあらかじめ &lt;code&gt;clear_vertex()&lt;/code&gt; を呼ぶことである。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータが &lt;code&gt;vecS&lt;/code&gt; なら、グラフのための全ての頂点記述子、辺記述子、そしてイテレータ はこの操作によって無効にされる。各頂点のための組み込みの &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティは操作の後もなお頂点の添え字が連続した範囲 &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; に配列しているように番号が付け直される。 もし組み込みの頂点の添え字に基づく外部のプロパティの記憶領域を使って いるなら、外部の記憶領域は調整される必要があるだろう。 他の選択は組み込みの頂点の添え字を使用せずに独自の頂点の添え字プロパティを付け加えるためにプロパティを代わりに使うことである。 もしたびたび &lt;code&gt;remove_vertex()&lt;/code&gt; 関数を使用する必要があるなら、 &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータには &lt;code&gt;listS&lt;/code&gt; 選択子が非常によい選択である。&lt;/p&gt;
&lt;h3&gt;Property Map Accessors&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;PropertyTag&lt;/code&gt; で指定される頂点プロパティのためのプロパティ・マップ・ オブジェクトを返す。&lt;code&gt;PropertyTag&lt;/code&gt; はグラフの &lt;code&gt;VertexProperty&lt;/code&gt; テンプレート引数中に指定されたプロパティの一つに一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;x&lt;/code&gt; が頂点記述子か辺記述子のどちらか一方である場合、これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;

これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を &lt;code&gt;value&lt;/code&gt; にする。&lt;code&gt;x&lt;/code&gt; は頂点記述子か辺記述子のどちらか一方である。&lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_list, PropertyTag&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; と互換でなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;

グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.html#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;

グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_map.html&#34;&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_traits.html&#34;&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>breadth_first_search -- リンクミスを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html"/>
      <id>189d7ba59ec0b7c93c2a3f48e4a913ce28ab1e52:archive/boost_docs/libs/graph/breadth_first_search.md</id>
      <updated>2014-12-22 15:39:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;breadth_first_search&lt;/h1&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color);
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は有向グラフまたは無向グラフの幅優先巡回(breadth-first traversal) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#moore59&#34;&gt;[49]&lt;/a&gt; を行う。幅優先巡回は、始点から遠方に離れた頂点を訪れる前に近い頂点を訪れる。 この文脈中で「距離」とは始点からの最短経路中の辺の数として定義される。 &lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は始点から全ての到達可能な頂点への最短経路を計算するのに使用でき、結果として最短経路の距離が得られる。 BFS に関連した更なる定義は章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34;&gt;Breadth-First Search&lt;/a&gt; を見よ。&lt;/p&gt;
&lt;p&gt;BFS は巡回を実装するのに二つのデータ構造を使っている: 各頂点のカラー・マーカーとキューである。白色の頂点は未発見で、一方灰色の頂点は発見されたけれども未発見の隣接頂点を持つ。黒色の頂点は発見されており、他の黒色もしくは灰色の頂点にのみ隣接している。アルゴリズムは頂点 &lt;code&gt;u&lt;/code&gt; をキューから取り除き、 各出辺 &lt;code&gt;(u,v)&lt;/code&gt; を調べながら進められる。もし隣接頂点 &lt;code&gt;v&lt;/code&gt; がまだ 未発見ならば、灰色に色づけしてキューに置く。すべての出辺を調べた後、頂点 &lt;code&gt;u&lt;/code&gt; を黒色に色づけして手順を繰り返す。BFS アルゴリズムの疑似コードを下に示す。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;BFS(G, s)
  for each vertex u in V[G]      頂点uの初期化
    color[u] := WHITE 
    d[u] := infinity 
    p[u] := u 
  end for
  color[s] := GRAY 
  d[s] := 0 
  ENQUEUE(Q, s)                  頂点sの発見
  while (Q != Ø) 
    u := DEQUEUE(Q)              頂点uの調査
    for each vertex v in Adj[u]  辺(u,v)の調査
      if (color[v] = WHITE)      辺(u,v)は木の辺
        color[v] := GRAY 
        d[v] := d[u] + 1  
        p[v] := u  
        ENQUEUE(Q, v)            頂点vの発見
      else                       (u,v)は木でない辺
        if (color[v] = GRAY) 
          ...                    (u,v)は灰色の終点を持つ
        else
          ...                    (u,v)は黒色の終点を持つ
    end for
    color[u] := BLACK            頂点uの終了
  end while
  return (d, p)
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は一定のイベント・ポイントと呼ばれる、 ユーザ定義のアクションで拡張することができる。アクションはビジタ・オブジェクトの形で提供されなければならない。すなわち、型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; の要求を満たしているオブジェクトである。上の擬似コード内で、イベント・ポイントは右側のラベルである。さらに各イベント・ポイントの記述を以下に示した。デフォルトでは &lt;code&gt;breadth_first_search()&lt;/code&gt; 関数はどんなアクションも実行しない。距離や先行点の記録さえも。しかしながらこれらは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; のイベント・ビジタを用いて容易に追加できる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; コンセプトで指定されたイベント・ポイントで呼び出されるビジタ・オブジェクト。 ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 アルゴリズムは開始時に全ての頂点の色を白色に初期化するため、ユーザは &lt;code&gt;breadth_first_search()&lt;/code&gt; を呼ぶ前にカラー・マップを初期化する必要はない。もし複合的な幅優先探索をグラフ上で行う必要があるなら (例えばいくつかの切断された成分があるなら) &lt;code&gt;breadth_first_visit()&lt;/code&gt; 関数を使って独自の初期化を行うこと。
    &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならなく、そのキー型はグラフの頂点記述子型でなければならなく、カラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;code&gt;iterator_property_map&lt;/code&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。 このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。 &lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;buffer(Buffer&amp;amp; Q)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点が発見される順序を決定するために使用されるキュー。もしFIFOキューが使われると、 巡回は通常の BFS 順序付けに従う。他の型のキューも使用できるが、巡回順序は異なる。例えば Dijkstra のアルゴリズムは優先度付きキューを用いて実装することができる。&lt;code&gt;Buffer&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt; のモデルでなければならない。&lt;code&gt;buffer&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; はグラフの &lt;code&gt;vertex_descriptor&lt;/code&gt; 型でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;boost::queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E + V) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(v, g)&lt;/code&gt; は、探索の開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、各頂点においてそれがキューから削除される時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、頂点が キューから削除された後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に加えて 辺が木の辺の場合に呼び出される。辺 &lt;code&gt;e&lt;/code&gt; の終点はこの時に発見される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、アルゴリズムが初めて頂点 &lt;code&gt;u&lt;/code&gt; を通った時に呼び出される。始点に近い全ての頂点が発見されており、始点から遠方に離れた頂点はまだ発見されていない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に加えて辺が tree edge でない場合に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が灰色に色づけされている場合に呼び出される。灰色は頂点が現在 キュー中にある印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が黒色に色づけされている場合に呼び出される。黒色は頂点がもはやキュー中にはない印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、 &lt;code&gt;u&lt;/code&gt; の全ての出辺が調べられ、全ての隣接頂点が発見された後で呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs-example.cpp.html&#34;&gt;examples/bfs-example.cpp&lt;/a&gt; 中にある例は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34;&gt;Figure 6&lt;/a&gt; のグラフにおいて BGL 幅優先探索アルゴリズムを用いて実演している。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs-example2.cpp.html&#34;&gt;examples/bfs-example2.cpp&lt;/a&gt; のファイルは同じ例を含むが、使われている &lt;code&gt;adacency_list&lt;/code&gt; クラスは &lt;code&gt;VertexList&lt;/code&gt; を持っており、&lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;listS&lt;/code&gt; に置かれている。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>基本的なグラフ理論の復習 -- アンカーを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html"/>
      <id>fb62e4554cca4bb3d3340862eaf04e5b30dbfbdb:archive/boost_docs/libs/graph/graph_theory_review.md</id>
      <updated>2014-12-22 15:35:30 +0900</updated>
      
        <content type="html">&lt;h1&gt;基本的なグラフ理論の復習&lt;/h1&gt;
&lt;p&gt;この章は、基本的なグラフ理論を思い出させることを意図している。読者があらかじめグラフアルゴリズムの知識があるのなら、始めるにあたりこの章は十分であろう。もし読者がグラフアルゴリズムの知識がないのならば、 Cormen, Leiserson, Rivestの&lt;a href=&#34;http://www.toc.lcs.mit.edu/~clr/&#34; target=&#34;_blank&#34;&gt;Introduction to Algorithms&lt;/a&gt; のようなもっと詳しいものを薦める。&lt;/p&gt;
&lt;h2&gt;グラフ抽象&lt;/h2&gt;
&lt;p&gt;グラフは、多くの種類の問題を解くのに有効な数学的抽象化である。基本的には、グラフは頂点と辺から構成され、辺は二つの頂点を結ぶ。もっと正確には、グラフ(graph)とは組&lt;code&gt;(V,E)&lt;/code&gt;で表され、&lt;code&gt;V&lt;/code&gt;は有限集合で、&lt;code&gt;E&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の２項関係である。&lt;code&gt;V&lt;/code&gt;は &lt;strong&gt;頂点集合(vertex set)&lt;/strong&gt; と呼ばれ、その要素を &lt;strong&gt;頂点(vertex)&lt;/strong&gt; と呼ぶ。&lt;code&gt;E&lt;/code&gt;は辺の集合で、 &lt;strong&gt;辺(edge)&lt;/strong&gt; とは&lt;code&gt;(u,v)&lt;/code&gt;の組で&lt;code&gt;u&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の要素である。 &lt;strong&gt;有向グラフ(directed graph)&lt;/strong&gt; においては、辺は順序付けられた組で、 &lt;strong&gt;始点(source)&lt;/strong&gt; を &lt;strong&gt;終点(target)&lt;/strong&gt; へと接続する。無向グラフ(undirected graph)においては、辺は順序付けされていない組で、２つの頂点を両方向につなぐ。つまり、無向グラフでは &lt;code&gt;(u,v)&lt;/code&gt;と&lt;code&gt;(v,u)&lt;/code&gt;は同じ辺の２通りの書き方である。&lt;/p&gt;
&lt;p&gt;グラフのこの定義は、いくつかの点であいまいである。辺や頂点が何を表現するかが述べられていない。グラフの例としては、連絡道路やハイパーリンク付きのウェブページなどを挙げることができる。これらの詳細がグラフの定義からは除外されているのは、大きな理由がある。それらの詳細はグラフの &lt;strong&gt;抽象化&lt;/strong&gt; の中では必要な部分ではない。詳細を定義から除外することで再利用可能な理論を構築でき、そのことは多くの異なった種類の問題を解く際に役に立つのである。&lt;/p&gt;
&lt;p&gt;定義にもどろう。グラフは頂点と辺の集合である。実際の様子を見せるため、頂点に文字のラベルがついたグラフを考え、辺を単純に文字の組としよう。ここで、有向グラフの例を次のように書くことができる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y } 
E = { (b,y), (b,y), (y,v), (z,a), (x,x), (b,x), (x,v), (a,z) } 
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;
このグラフを図示すると 図1 のようになる。辺 &lt;code&gt;(x,x)&lt;/code&gt; は &lt;strong&gt;輪(self-loop)&lt;/strong&gt; と呼ばれる。&lt;code&gt;(b,y)&lt;/code&gt;と &lt;code&gt;(b,y)&lt;/code&gt;は &lt;strong&gt;平行辺(parallel edges)&lt;/strong&gt; であり、これは &lt;strong&gt;マルチグラフ(multigraph)&lt;/strong&gt; でのみ許される(ただし、通常は有向グラフでも無向グラフでも許されない)。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/digraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図1: 有向グラフの例&lt;/p&gt;
&lt;p&gt;次に似たようなグラフを示すが、今度は無向グラフである。これは図2に図示する。無向グラフでは輪は許されない。上記のグラフ(から平行辺&lt;code&gt;(b,y)&lt;/code&gt;を除いたもの)の &lt;strong&gt;無向版(undirected version)&lt;/strong&gt; である。それはつまり、同じ頂点をもち、同じ辺から方向を除いたものを持つことを意味し、&lt;code&gt;(a,z)&lt;/code&gt;と&lt;code&gt;(z,a)&lt;/code&gt;という２つの辺は一つの辺に退化する。また、逆を考えることもできる。無向グラフの &lt;strong&gt;有向版(directed version)&lt;/strong&gt; は、すべての辺をそれぞれの方向を向く２つの辺で置き換えることで得られる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y }
E = { (b,y), (y,v), (z,a), (b,x), (x,v) }
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undigraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図2: 無向グラフの例&lt;/p&gt;
&lt;p&gt;ここでさらにグラフの用語を定義する。辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるとき、頂点&lt;code&gt;v&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;について &lt;strong&gt;隣接している(adjacent)&lt;/strong&gt; と言う。有向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は 頂点&lt;code&gt;u&lt;/code&gt;の &lt;strong&gt;出辺(out-edge)&lt;/strong&gt; であり、頂点&lt;code&gt;v&lt;/code&gt;の &lt;strong&gt;入辺(in-edge)&lt;/strong&gt; である。無向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を &lt;strong&gt;接合している(incident on)&lt;/strong&gt; という。&lt;/p&gt;
&lt;p&gt;図1で、頂点&lt;code&gt;y&lt;/code&gt;は頂点&lt;code&gt;b&lt;/code&gt;に対して隣接している (ただし&lt;code&gt;b&lt;/code&gt;は&lt;code&gt;y&lt;/code&gt;に対して隣接していない)。辺&lt;code&gt;(b,y)&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;の出辺であり、&lt;code&gt;y&lt;/code&gt;の入辺である。図2で、&lt;code&gt;y&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;に隣接していて、また逆も同様である。辺&lt;code&gt;(y,b)&lt;/code&gt;は頂点&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;を接合している。&lt;/p&gt;
&lt;p&gt;有向グラフにおいて、ある頂点の出辺の数は &lt;strong&gt;出次数(out-degree)&lt;/strong&gt; と呼ばれ、入辺の数は &lt;strong&gt;入次数(in-degree)&lt;/strong&gt; と呼ばれる。無向グラフにおいて、ある頂点に対して接合している辺の数は &lt;strong&gt;次数(degree)&lt;/strong&gt; と呼ばれる。図1で、頂点&lt;code&gt;b&lt;/code&gt;の出次数は3であり、入次数は0である。図2では単純に頂点&lt;code&gt;b&lt;/code&gt;の次数は2である。&lt;/p&gt;
&lt;p&gt;グラフの &lt;strong&gt;路(path)&lt;/strong&gt; とは辺の列で、それぞれの辺の終点が次の辺の始点であるものである。頂点&lt;code&gt;u&lt;/code&gt;から始まり頂点&lt;code&gt;v&lt;/code&gt;で終わる路があれば、頂点&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;から &lt;strong&gt;到達可能(reachable)&lt;/strong&gt; であるという。路が &lt;strong&gt;単純(simple)&lt;/strong&gt; であるとは、辺の列の中でどの頂点も繰り返し現れないことである。路&lt;code&gt;&amp;lt;(b,x), (x,v)&amp;gt;&lt;/code&gt;は単純であるが、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は単純ではない。また、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は最初の頂点と最後の頂点が一致するので、 &lt;strong&gt;サイクル(cycle)&lt;/strong&gt; と呼ばれる。サイクルのないグラフは &lt;strong&gt;アサイクリック(acyclic)&lt;/strong&gt; と呼ばれる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平面的グラフ(planar graph)&lt;/strong&gt; とは、すべての辺が交差しないように平面上に描けるグラフのことである。そのように描かれたものは &lt;strong&gt;平面グラフ(plane graph)&lt;/strong&gt; と呼ばれる。平面グラフの &lt;strong&gt;面(face)&lt;/strong&gt; とは、辺に囲まれた連結成分のことである。平面的グラフの重要な特性は、面、辺、頂点の数がオイラーの定理：&lt;code&gt;|F| - |E| + |V| = 2&lt;/code&gt;によって関係付けられることである。このことは、平面的グラフは最大でもO(|V|)個の辺しか持たないことを意味する。&lt;/p&gt;
&lt;h2&gt;グラフデータ構造&lt;/h2&gt;
&lt;p&gt;データ構造を考えるときに最初に考えるべきグラフの属性は、&lt;strong&gt;まばらさ(sparsity)&lt;/strong&gt; である。まばらさとは、頂点に対する相対的な辺の数である。&lt;code&gt;E&lt;/code&gt;が&lt;code&gt;V²&lt;/code&gt;に近いグラフは &lt;strong&gt;密(dense)&lt;/strong&gt; であると呼ばれ、&lt;code&gt;E = alpha V&lt;/code&gt;で&lt;code&gt;alpha&lt;/code&gt;が&lt;code&gt;V&lt;/code&gt;より十分に小さい場合は、まばらな(sparse)グラフと呼ばれる。密なグラフについては、通常、 &lt;strong&gt;隣接行列表現(adjacency-matrix representation)&lt;/strong&gt; が最良の選択であり、一方まばらなグラフについては &lt;strong&gt;隣接リスト表現(adjacency-list representation)&lt;/strong&gt; が最良である。また、まばらなグラフについては &lt;strong&gt;辺リスト表現(edge-list representation)&lt;/strong&gt; も適切な状況下では記憶効率面でよい選択である。&lt;/p&gt;
&lt;h3&gt;隣接行列表現&lt;/h3&gt;
&lt;p&gt;グラフの隣接行列表現はV x Vの２次元配列である。 行列a&lt;sub&gt;uv&lt;/sub&gt;の要素は、辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるかどうかを示すブーリアン値である。図3に図1(から&lt;code&gt;(b,y)&lt;/code&gt;を引いたもの)の隣接行列表現を表す。保存に必要な領域はO(V²)である。任意の辺について、アクセス、追加、除去にかかる時間はO(1)である。 頂点の追加や除去は、再割り当てとすべてのグラフのコピーが必要になり、手順数はO(V²)になる。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;クラスは、隣接行列表現によってBGLグラフインターフェースを実装する。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_matrix.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図3: 隣接行列によるグラフの表現&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34; name=&#34;adjacency-list-representation&#34;&gt;隣接リスト表現&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;グラフの隣接リスト表現では、すべての頂点に対して出辺の列を保存する。まばらなグラフでは、こうすることでメモリ領域を節約でき、必要な領域はO(V + E)だけになる。さらに、すべての頂点の出辺にはより効果的にアクセスできる。辺の挿入のコストはO(1)で、任意の辺へのアクセスはO(alpha)である。ここで、alphaは行列のまばらさ(グラフ中のすべての頂点についての出辺の数の最大値)である。図4は図1のグラフの隣接リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;は隣接リスト表現の実装である。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図4: 隣接リストによるグラフ表現&lt;/p&gt;
&lt;h3&gt;辺リスト表現&lt;/h3&gt;
&lt;p&gt;グラフの辺リスト表現は、単純に辺の列であり、辺は頂点のIDの組で表される。必要なメモリはO(E)だけである。辺挿入のコストはO(1)であり、特定の辺のアクセスするのはO(E)(あまり効果的でない)である。図5は図1のグラフの辺リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;アダプタクラスは、辺リスト表現の実装を作るのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/edge_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図5: 辺リストによるグラフの表現&lt;/p&gt;
&lt;h2&gt;グラフアルゴリズム&lt;/h2&gt;
&lt;h3&gt;グラフ探索アルゴリズム&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;木辺(tree edge)&lt;/strong&gt; とは、グラフ探索アルゴリズムをグラフに適用することによって作られた探索木(またはフォレスト)の辺ことである。辺&lt;code&gt;(u,v)&lt;/code&gt;は木辺であるのは、辺&lt;code&gt;(u,v)&lt;/code&gt;の探索(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;ビジタ&lt;/a&gt;の&lt;code&gt;explore()&lt;/code&gt;メソッドにあたる)をしているときに&lt;code&gt;v&lt;/code&gt;が最初に見つかるときである。&lt;strong&gt;後退辺(back edge)&lt;/strong&gt;とは、探索木上で頂点を先祖につなぐ辺である。したがって、辺&lt;code&gt;(u,v)&lt;/code&gt;では&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;の先祖である。輪は後退辺とみなされる。&lt;strong&gt;先行辺(forward edge)&lt;/strong&gt;は木辺ではない辺&lt;code&gt;(u,v)&lt;/code&gt;で、探索木上&lt;code&gt;u&lt;/code&gt;を子孫&lt;code&gt;v&lt;/code&gt;へとつなぐ。&lt;strong&gt;交差辺(cross edge)&lt;/strong&gt;とは、以上の３つのカテゴリに含まれない辺のことである。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34; name=&#34;bfs-algorithm&#34;&gt;幅優先探索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;幅優先探索(Breadth-First Search, BFS)とは、グラフに対して横断的であり、特定の原点から到達可能な頂点をすべて探索する。また横断する順番については、頂点のすべての近傍を探索してから近傍の近傍の探索へと進む。幅優先探索について考えるには、例えば水溜りに石を落としたときに波が放射状に広がるように拡散すると思えばよい。同じ「波」の中の頂点は原点から同じ距離にある。頂点は最初にアルゴリズムによって遭遇するときに&lt;strong&gt;発見される(discovered)&lt;/strong&gt;と言う。頂点は、その近傍がすべて探索されたときに&lt;strong&gt;完了した(finished)&lt;/strong&gt;と言われる。これらをわかりやすくする例がある。グラフを図6に示し、そのBFSにおける発見と完了の順番をその下に示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/bfs_example.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図6: 広さ優先探索がグラフに広がる様子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順番: s r w v t x u y &lt;/li&gt;
&lt;li&gt;完了の順番: s r w v t x u y&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt;から開始して、最初は&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;(&lt;code&gt;s&lt;/code&gt;の近傍)にたどり着く。&lt;code&gt;s&lt;/code&gt;の両方の希望に到達してから、&lt;code&gt;r&lt;/code&gt;の近傍(頂点&lt;code&gt;v&lt;/code&gt;)に到達し、&lt;code&gt;w&lt;/code&gt;の近傍&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;に到達する (&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;の順序は意味を持たない)。最後に&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の近傍、&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;に到達する。&lt;/p&gt;
&lt;p&gt;今グラフ上のどこにいるか、次にどこの頂点に行くかをアルゴリズムが把握するために、BFSは頂点に色を塗る。塗る色を置く場所は、グラフの中でもよいし、アルゴリズムに引数として渡すこともできる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34; name=&#34;dfs-algorithm&#34;&gt;深さ優先探索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;深さ優先探査(Depth-First Search, DFS) は、グラフ中の全頂点を探査する。このアルゴリズムでは、常にグラフ中の「深い」部分を、次に探査すべき辺として選択していく。これは、到達した頂点が未訪問の隣接頂点を持たなくなるまで次の未訪問な隣接頂点を選択していき、端に到達すれば前の頂点へと戻り、その頂点から任意の未探査な辺へと探査を継続していくことである。深さ優先探査は、出発する頂点から到達可能な全ての頂点を訪問した後に、残りの未訪問な頂点のうちから１頂点を選択して探査を継続していく。このプロセスは、深度優先の森からともに深度優先の木という集合を形成する。深さ優先探索は、グラフ中の辺を３つのカテゴリーに分類する：木辺、後退辺、先行辺か交差辺(どちらにも明確に分類しない)。与えられたグラフから多くの有効な深度優先の森が典型的に存在し、それゆえ辺を分類するには様々な(かつ等しく有効な)方法がある。&lt;/p&gt;
&lt;p&gt;深さ優先探査の興味深い特性は、各頂点の発見時と完了時の間において、括弧（入れ子）構造を形成するということである。頂点が発見される場合、私たちが開いた括弧を使用すれば、頂点が探査終了される場合には閉じた括弧が使用され、その結果、括弧により適切に入れ子にされた集合ができあがる。図7は、探査された順番にラベル付けされた辺による無向グラフに適応された DFS （深さ優先探査）である。図の下に、探査を開始した順序と探査を終了した順序を示し、それらから導かれる括弧構造を示す。DFS （深さ優先探査）は、２つが接続されたコンポーネント・アルゴリズム、トポロジカル・ソート、などを含む他のグラフ・アルゴリズムによって使用される核となるアルゴリズムである。これは循環を検知するために利用できる（ファイル依存関係の例における&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/file_dependency_example.html#cycles&#34;&gt;循環依存 （Cylic Dependencies）&lt;/a&gt; の節を見よ）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/dfs.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 7: 無向グラフにおける深度優先探査&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順序: a b e d c f g h i&lt;/li&gt;
&lt;li&gt;完了の順序: d f c e b a&lt;/li&gt;
&lt;li&gt;括弧構造: (a (b (e (d d) (c (f f) c) e) b) a) (g (h (i i) h) g)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#minimum-spanning-tree&#34; name=&#34;minimum-spanning-tree&#34;&gt;最小全域木問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最小全域木問題は、以下のように定義される：グラフ &lt;code&gt;E&lt;/code&gt; 中の全頂点を接続する循環のサブセット &lt;code&gt;T&lt;/code&gt; を接続の全コストが最小となるように選択することである。全コストは下記により与えられる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(T) = T における辺 (u,v) におけるコスト w(u,v) の合計、 w(u,v) は辺 (u,v) のコスト
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;T&lt;/code&gt; は&lt;strong&gt;全域木(spanning tree)&lt;/strong&gt;と呼ばれる.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-paths-algorithms&#34; name=&#34;shortest-paths-algorithms&#34;&gt;最短経路問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;グラフ理論における古典的問題のひとつは、グラフ中の２頂点間を結ぶ最短経路を見つけることである。形式的に経路はグラフ &lt;code&gt;G = (V, E)&lt;/code&gt; 中の頂点のシーケンス &lt;code&gt;&amp;lt;v0,v1,...,vk&amp;gt;&lt;/code&gt; で表される（辺 &lt;code&gt;(vi,vi+1) for i=0,1,...,k-1&lt;/code&gt; は 辺の集合 &lt;code&gt;E&lt;/code&gt; ）。シーケンスにおいて各頂点は次の頂点へ接続される。最短経路問題において、各辺は重みを数値として与えられている。それゆえ、&lt;strong&gt;経路の重み(weight of a path)&lt;/strong&gt;について記す&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(p) = i=1..k of w(vi-1,vi) の合計
&lt;/code&gt;&lt;/pre&gt;
頂点 &lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; に至る&lt;strong&gt;最短経路の重み(shortest path weight)&lt;/strong&gt;は&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;delta (u,v) = min { w(p) : u --&amp;gt; v } もし 頂点 u から v に至る経路が存在すれば
delta (u,v) = 無限(infinity ) そうでなければ（ u から v に至る経路がなければ）
&lt;/code&gt;&lt;/pre&gt;
最短経路は、重みの合計が最小となる経路といえる。&lt;/p&gt;
&lt;p&gt;最短経路問題には、いくつかの変形された問題がある。ここでは単一ペアの問題を定義した、しかし、さらに単一出所問題(グラフ中の1つの頂点から各頂点ごとまでの最短のパス)があり、等価な単一目的地問題、全ペア問題、などである。単一出所の問題を解決するアルゴリズムより漸近的に速い、単一ペアの問題を解決するアルゴリズムは存在しない。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短経路木(shortest-paths tree)&lt;/strong&gt;は、グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; 中のある頂点を原点とした有向サブグラフである。&lt;code&gt;V&#39;&lt;/code&gt; を &lt;code&gt;V&lt;/code&gt; のサブセット、&lt;code&gt;E&#39;&lt;/code&gt; を &lt;code&gt;E&lt;/code&gt; のサブセットとし、 &lt;code&gt;V&#39;&lt;/code&gt; は&lt;code&gt;G&#39;&lt;/code&gt; から到達可能な頂点の集合、&lt;code&gt;G&#39;&lt;/code&gt; は原点から連なる経路木を成すものとすれば、&lt;code&gt;V&#39;&lt;/code&gt; 中の全ての頂点 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;G&#39;&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; から唯一の経路を持つ。再帰的に、単一頂点アルゴリズムによる結果は最短経路木である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#network-flow-algorithms&#34; name=&#34;network-flow-algorithms&#34;&gt;ネットワークフロー問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ネットワークの流れは&lt;strong&gt;送信(source)&lt;/strong&gt;頂点 &lt;code&gt;s&lt;/code&gt; から&lt;strong&gt;受信(sink)&lt;/strong&gt;頂点&lt;code&gt;t&lt;/code&gt;へと向かう有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; である。各辺は数値による、&lt;strong&gt;容量(capacity)&lt;/strong&gt;関数 &lt;code&gt;c&lt;/code&gt; 、および、&lt;strong&gt;流れ(flow)&lt;/strong&gt;関数 &lt;code&gt;f&lt;/code&gt; を持つ。流れ関数は次の３条件を満たしていなければならない：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;f(u,v) &amp;lt;= c(u,v) for all (u,v) in V x V (容量制限) 
f(u,v) = - f(v,u) for all (u,v) in V x V (流れ対称性)
sumv in V f(u,v) = 0 for all u in V - {s,t} (流れ保存則)
&lt;/code&gt;&lt;/pre&gt;
ネットワークにおける&lt;strong&gt;流れ(flow)&lt;/strong&gt;は、受信頂点 &lt;code&gt;t&lt;/code&gt; に流れ込む集合の流れである（それは、送信頂点 &lt;code&gt;s&lt;/code&gt; から流れ出るネットの流れに等価である）。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;|f| = sumu in V f(u,t) = sumv in V f(s,v)
&lt;/code&gt;&lt;/pre&gt;
辺における&lt;strong&gt;余剰容量(residual capacity)&lt;/strong&gt;を &lt;code&gt;r(u,v) = c(u,v) – f(u,v)&lt;/code&gt; とする。 &lt;code&gt;r(u,v) &amp;gt; 0&lt;/code&gt; を満たす辺は余剰辺 &lt;code&gt;E&lt;sub&gt;f&lt;/sub&gt;&lt;/code&gt; であり、それは余剰グラフ &lt;code&gt;G&lt;sub&gt;f&lt;/sub&gt; = (V, E&lt;sub&gt;f&lt;/sub&gt;)&lt;/code&gt; を成す。 &lt;code&gt;r(u,v) = 0&lt;/code&gt; を満たす辺は&lt;strong&gt;飽和(saturated)&lt;/strong&gt;している。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大流問題(maximum flow problem)&lt;/strong&gt;は、最大に可能な流量値 &lt;code&gt;|f|&lt;/code&gt; を決定することであり、そのときのグラフ中における各辺に対する流量値を決定することである。&lt;/p&gt;
&lt;p&gt;ネットワークの流れを 図 8 に示す。 &lt;code&gt;A&lt;/code&gt; は送信頂点で、&lt;code&gt;H&lt;/code&gt; は受信頂点。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/max-flow.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 8: 最大流ネットワーク。各辺は（流れ/容量）のラベルで示している。&lt;/p&gt;
&lt;p&gt;最大流ネットワーク問題を解決するには長い歴史があり、最初のアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford56:_maxim&#34;&gt;Ford と Fulkerson&lt;/a&gt;による。現在に至る最良のアルゴリズムである push-relabel アルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goldberg85:_new_max_flow_algor&#34;&gt;Goldberg&lt;/a&gt; によるもので、これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#karzanov74:_deter&#34;&gt;Karzanov&lt;/a&gt; による &lt;strong&gt;preflow&lt;/strong&gt; introduced という概念を元に成り立っている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 KATO Kimikazu, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>基本的なグラフ理論の復習 -- 改行が抜けていた</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html"/>
      <id>f404a71b8f1f910b7aa3c11e6d838801b845a8f1:archive/boost_docs/libs/graph/graph_theory_review.md</id>
      <updated>2014-12-22 15:32:28 +0900</updated>
      
        <content type="html">&lt;h1&gt;基本的なグラフ理論の復習&lt;/h1&gt;
&lt;p&gt;この章は、基本的なグラフ理論を思い出させることを意図している。読者があらかじめグラフアルゴリズムの知識があるのなら、始めるにあたりこの章は十分であろう。もし読者がグラフアルゴリズムの知識がないのならば、 Cormen, Leiserson, Rivestの&lt;a href=&#34;http://www.toc.lcs.mit.edu/~clr/&#34; target=&#34;_blank&#34;&gt;Introduction to Algorithms&lt;/a&gt; のようなもっと詳しいものを薦める。&lt;/p&gt;
&lt;h2&gt;グラフ抽象&lt;/h2&gt;
&lt;p&gt;グラフは、多くの種類の問題を解くのに有効な数学的抽象化である。基本的には、グラフは頂点と辺から構成され、辺は二つの頂点を結ぶ。もっと正確には、グラフ(graph)とは組&lt;code&gt;(V,E)&lt;/code&gt;で表され、&lt;code&gt;V&lt;/code&gt;は有限集合で、&lt;code&gt;E&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の２項関係である。&lt;code&gt;V&lt;/code&gt;は &lt;strong&gt;頂点集合(vertex set)&lt;/strong&gt; と呼ばれ、その要素を &lt;strong&gt;頂点(vertex)&lt;/strong&gt; と呼ぶ。&lt;code&gt;E&lt;/code&gt;は辺の集合で、 &lt;strong&gt;辺(edge)&lt;/strong&gt; とは&lt;code&gt;(u,v)&lt;/code&gt;の組で&lt;code&gt;u&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の要素である。 &lt;strong&gt;有向グラフ(directed graph)&lt;/strong&gt; においては、辺は順序付けられた組で、 &lt;strong&gt;始点(source)&lt;/strong&gt; を &lt;strong&gt;終点(target)&lt;/strong&gt; へと接続する。無向グラフ(undirected graph)においては、辺は順序付けされていない組で、２つの頂点を両方向につなぐ。つまり、無向グラフでは &lt;code&gt;(u,v)&lt;/code&gt;と&lt;code&gt;(v,u)&lt;/code&gt;は同じ辺の２通りの書き方である。&lt;/p&gt;
&lt;p&gt;グラフのこの定義は、いくつかの点であいまいである。辺や頂点が何を表現するかが述べられていない。グラフの例としては、連絡道路やハイパーリンク付きのウェブページなどを挙げることができる。これらの詳細がグラフの定義からは除外されているのは、大きな理由がある。それらの詳細はグラフの &lt;strong&gt;抽象化&lt;/strong&gt; の中では必要な部分ではない。詳細を定義から除外することで再利用可能な理論を構築でき、そのことは多くの異なった種類の問題を解く際に役に立つのである。&lt;/p&gt;
&lt;p&gt;定義にもどろう。グラフは頂点と辺の集合である。実際の様子を見せるため、頂点に文字のラベルがついたグラフを考え、辺を単純に文字の組としよう。ここで、有向グラフの例を次のように書くことができる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y } 
E = { (b,y), (b,y), (y,v), (z,a), (x,x), (b,x), (x,v), (a,z) } 
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;
このグラフを図示すると 図1 のようになる。辺 &lt;code&gt;(x,x)&lt;/code&gt; は &lt;strong&gt;輪(self-loop)&lt;/strong&gt; と呼ばれる。&lt;code&gt;(b,y)&lt;/code&gt;と &lt;code&gt;(b,y)&lt;/code&gt;は &lt;strong&gt;平行辺(parallel edges)&lt;/strong&gt; であり、これは &lt;strong&gt;マルチグラフ(multigraph)&lt;/strong&gt; でのみ許される(ただし、通常は有向グラフでも無向グラフでも許されない)。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/digraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図1: 有向グラフの例&lt;/p&gt;
&lt;p&gt;次に似たようなグラフを示すが、今度は無向グラフである。これは図2に図示する。無向グラフでは輪は許されない。上記のグラフ(から平行辺&lt;code&gt;(b,y)&lt;/code&gt;を除いたもの)の &lt;strong&gt;無向版(undirected version)&lt;/strong&gt; である。それはつまり、同じ頂点をもち、同じ辺から方向を除いたものを持つことを意味し、&lt;code&gt;(a,z)&lt;/code&gt;と&lt;code&gt;(z,a)&lt;/code&gt;という２つの辺は一つの辺に退化する。また、逆を考えることもできる。無向グラフの &lt;strong&gt;有向版(directed version)&lt;/strong&gt; は、すべての辺をそれぞれの方向を向く２つの辺で置き換えることで得られる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y }
E = { (b,y), (y,v), (z,a), (b,x), (x,v) }
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undigraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図2: 無向グラフの例&lt;/p&gt;
&lt;p&gt;ここでさらにグラフの用語を定義する。辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるとき、頂点&lt;code&gt;v&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;について &lt;strong&gt;隣接している(adjacent)&lt;/strong&gt; と言う。有向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は 頂点&lt;code&gt;u&lt;/code&gt;の &lt;strong&gt;出辺(out-edge)&lt;/strong&gt; であり、頂点&lt;code&gt;v&lt;/code&gt;の &lt;strong&gt;入辺(in-edge)&lt;/strong&gt; である。無向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を &lt;strong&gt;接合している(incident on)&lt;/strong&gt; という。&lt;/p&gt;
&lt;p&gt;図1で、頂点&lt;code&gt;y&lt;/code&gt;は頂点&lt;code&gt;b&lt;/code&gt;に対して隣接している (ただし&lt;code&gt;b&lt;/code&gt;は&lt;code&gt;y&lt;/code&gt;に対して隣接していない)。辺&lt;code&gt;(b,y)&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;の出辺であり、&lt;code&gt;y&lt;/code&gt;の入辺である。図2で、&lt;code&gt;y&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;に隣接していて、また逆も同様である。辺&lt;code&gt;(y,b)&lt;/code&gt;は頂点&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;を接合している。&lt;/p&gt;
&lt;p&gt;有向グラフにおいて、ある頂点の出辺の数は &lt;strong&gt;出次数(out-degree)&lt;/strong&gt; と呼ばれ、入辺の数は &lt;strong&gt;入次数(in-degree)&lt;/strong&gt; と呼ばれる。無向グラフにおいて、ある頂点に対して接合している辺の数は &lt;strong&gt;次数(degree)&lt;/strong&gt; と呼ばれる。図1で、頂点&lt;code&gt;b&lt;/code&gt;の出次数は3であり、入次数は0である。図2では単純に頂点&lt;code&gt;b&lt;/code&gt;の次数は2である。&lt;/p&gt;
&lt;p&gt;グラフの &lt;strong&gt;路(path)&lt;/strong&gt; とは辺の列で、それぞれの辺の終点が次の辺の始点であるものである。頂点&lt;code&gt;u&lt;/code&gt;から始まり頂点&lt;code&gt;v&lt;/code&gt;で終わる路があれば、頂点&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;から &lt;strong&gt;到達可能(reachable)&lt;/strong&gt; であるという。路が &lt;strong&gt;単純(simple)&lt;/strong&gt; であるとは、辺の列の中でどの頂点も繰り返し現れないことである。路&lt;code&gt;&amp;lt;(b,x), (x,v)&amp;gt;&lt;/code&gt;は単純であるが、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は単純ではない。また、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は最初の頂点と最後の頂点が一致するので、 &lt;strong&gt;サイクル(cycle)&lt;/strong&gt; と呼ばれる。サイクルのないグラフは &lt;strong&gt;アサイクリック(acyclic)&lt;/strong&gt; と呼ばれる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平面的グラフ(planar graph)&lt;/strong&gt; とは、すべての辺が交差しないように平面上に描けるグラフのことである。そのように描かれたものは &lt;strong&gt;平面グラフ(plane graph)&lt;/strong&gt; と呼ばれる。平面グラフの &lt;strong&gt;面(face)&lt;/strong&gt; とは、辺に囲まれた連結成分のことである。平面的グラフの重要な特性は、面、辺、頂点の数がオイラーの定理：&lt;code&gt;|F| - |E| + |V| = 2&lt;/code&gt;によって関係付けられることである。このことは、平面的グラフは最大でもO(|V|)個の辺しか持たないことを意味する。&lt;/p&gt;
&lt;h2&gt;グラフデータ構造&lt;/h2&gt;
&lt;p&gt;データ構造を考えるときに最初に考えるべきグラフの属性は、&lt;strong&gt;まばらさ(sparsity)&lt;/strong&gt; である。まばらさとは、頂点に対する相対的な辺の数である。&lt;code&gt;E&lt;/code&gt;が&lt;code&gt;V²&lt;/code&gt;に近いグラフは &lt;strong&gt;密(dense)&lt;/strong&gt; であると呼ばれ、&lt;code&gt;E = alpha V&lt;/code&gt;で&lt;code&gt;alpha&lt;/code&gt;が&lt;code&gt;V&lt;/code&gt;より十分に小さい場合は、まばらな(sparse)グラフと呼ばれる。密なグラフについては、通常、 &lt;strong&gt;隣接行列表現(adjacency-matrix representation)&lt;/strong&gt; が最良の選択であり、一方まばらなグラフについては &lt;strong&gt;隣接リスト表現(adjacency-list representation)&lt;/strong&gt; が最良である。また、まばらなグラフについては &lt;strong&gt;辺リスト表現(edge-list representation)&lt;/strong&gt; も適切な状況下では記憶効率面でよい選択である。&lt;/p&gt;
&lt;h3&gt;隣接行列表現&lt;/h3&gt;
&lt;p&gt;グラフの隣接行列表現はV x Vの２次元配列である。 行列a&lt;sub&gt;uv&lt;/sub&gt;の要素は、辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるかどうかを示すブーリアン値である。図3に図1(から&lt;code&gt;(b,y)&lt;/code&gt;を引いたもの)の隣接行列表現を表す。保存に必要な領域はO(V²)である。任意の辺について、アクセス、追加、除去にかかる時間はO(1)である。 頂点の追加や除去は、再割り当てとすべてのグラフのコピーが必要になり、手順数はO(V²)になる。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;クラスは、隣接行列表現によってBGLグラフインターフェースを実装する。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_matrix.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図3: 隣接行列によるグラフの表現&lt;/p&gt;
&lt;h3&gt;隣接リスト表現&lt;/h3&gt;
&lt;p&gt;グラフの隣接リスト表現では、すべての頂点に対して出辺の列を保存する。まばらなグラフでは、こうすることでメモリ領域を節約でき、必要な領域はO(V + E)だけになる。さらに、すべての頂点の出辺にはより効果的にアクセスできる。辺の挿入のコストはO(1)で、任意の辺へのアクセスはO(alpha)である。ここで、alphaは行列のまばらさ(グラフ中のすべての頂点についての出辺の数の最大値)である。図4は図1のグラフの隣接リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;は隣接リスト表現の実装である。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図4: 隣接リストによるグラフ表現&lt;/p&gt;
&lt;h3&gt;辺リスト表現&lt;/h3&gt;
&lt;p&gt;グラフの辺リスト表現は、単純に辺の列であり、辺は頂点のIDの組で表される。必要なメモリはO(E)だけである。辺挿入のコストはO(1)であり、特定の辺のアクセスするのはO(E)(あまり効果的でない)である。図5は図1のグラフの辺リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;アダプタクラスは、辺リスト表現の実装を作るのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/edge_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図5: 辺リストによるグラフの表現&lt;/p&gt;
&lt;h2&gt;グラフアルゴリズム&lt;/h2&gt;
&lt;h3&gt;グラフ探索アルゴリズム&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;木辺(tree edge)&lt;/strong&gt; とは、グラフ探索アルゴリズムをグラフに適用することによって作られた探索木(またはフォレスト)の辺ことである。辺&lt;code&gt;(u,v)&lt;/code&gt;は木辺であるのは、辺&lt;code&gt;(u,v)&lt;/code&gt;の探索(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;ビジタ&lt;/a&gt;の&lt;code&gt;explore()&lt;/code&gt;メソッドにあたる)をしているときに&lt;code&gt;v&lt;/code&gt;が最初に見つかるときである。&lt;strong&gt;後退辺(back edge)&lt;/strong&gt;とは、探索木上で頂点を先祖につなぐ辺である。したがって、辺&lt;code&gt;(u,v)&lt;/code&gt;では&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;の先祖である。輪は後退辺とみなされる。&lt;strong&gt;先行辺(forward edge)&lt;/strong&gt;は木辺ではない辺&lt;code&gt;(u,v)&lt;/code&gt;で、探索木上&lt;code&gt;u&lt;/code&gt;を子孫&lt;code&gt;v&lt;/code&gt;へとつなぐ。&lt;strong&gt;交差辺(cross edge)&lt;/strong&gt;とは、以上の３つのカテゴリに含まれない辺のことである。&lt;/p&gt;
&lt;h3&gt;幅優先探索&lt;/h3&gt;
&lt;p&gt;幅優先探索(Breadth-First Search, BFS)とは、グラフに対して横断的であり、特定の原点から到達可能な頂点をすべて探索する。また横断する順番については、頂点のすべての近傍を探索してから近傍の近傍の探索へと進む。幅優先探索について考えるには、例えば水溜りに石を落としたときに波が放射状に広がるように拡散すると思えばよい。同じ「波」の中の頂点は原点から同じ距離にある。頂点は最初にアルゴリズムによって遭遇するときに&lt;strong&gt;発見される(discovered)&lt;/strong&gt;と言う。頂点は、その近傍がすべて探索されたときに&lt;strong&gt;完了した(finished)&lt;/strong&gt;と言われる。これらをわかりやすくする例がある。グラフを図6に示し、そのBFSにおける発見と完了の順番をその下に示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/bfs_example.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図6: 広さ優先探索がグラフに広がる様子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順番: s r w v t x u y &lt;/li&gt;
&lt;li&gt;完了の順番: s r w v t x u y&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt;から開始して、最初は&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;(&lt;code&gt;s&lt;/code&gt;の近傍)にたどり着く。&lt;code&gt;s&lt;/code&gt;の両方の希望に到達してから、&lt;code&gt;r&lt;/code&gt;の近傍(頂点&lt;code&gt;v&lt;/code&gt;)に到達し、&lt;code&gt;w&lt;/code&gt;の近傍&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;に到達する (&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;の順序は意味を持たない)。最後に&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の近傍、&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;に到達する。&lt;/p&gt;
&lt;p&gt;今グラフ上のどこにいるか、次にどこの頂点に行くかをアルゴリズムが把握するために、BFSは頂点に色を塗る。塗る色を置く場所は、グラフの中でもよいし、アルゴリズムに引数として渡すこともできる。&lt;/p&gt;
&lt;h3&gt;深さ優先探索&lt;/h3&gt;
&lt;p&gt;深さ優先探査(Depth-First Search, DFS) は、グラフ中の全頂点を探査する。このアルゴリズムでは、常にグラフ中の「深い」部分を、次に探査すべき辺として選択していく。これは、到達した頂点が未訪問の隣接頂点を持たなくなるまで次の未訪問な隣接頂点を選択していき、端に到達すれば前の頂点へと戻り、その頂点から任意の未探査な辺へと探査を継続していくことである。深さ優先探査は、出発する頂点から到達可能な全ての頂点を訪問した後に、残りの未訪問な頂点のうちから１頂点を選択して探査を継続していく。このプロセスは、深度優先の森からともに深度優先の木という集合を形成する。深さ優先探索は、グラフ中の辺を３つのカテゴリーに分類する：木辺、後退辺、先行辺か交差辺(どちらにも明確に分類しない)。与えられたグラフから多くの有効な深度優先の森が典型的に存在し、それゆえ辺を分類するには様々な(かつ等しく有効な)方法がある。&lt;/p&gt;
&lt;p&gt;深さ優先探査の興味深い特性は、各頂点の発見時と完了時の間において、括弧（入れ子）構造を形成するということである。頂点が発見される場合、私たちが開いた括弧を使用すれば、頂点が探査終了される場合には閉じた括弧が使用され、その結果、括弧により適切に入れ子にされた集合ができあがる。図7は、探査された順番にラベル付けされた辺による無向グラフに適応された DFS （深さ優先探査）である。図の下に、探査を開始した順序と探査を終了した順序を示し、それらから導かれる括弧構造を示す。DFS （深さ優先探査）は、２つが接続されたコンポーネント・アルゴリズム、トポロジカル・ソート、などを含む他のグラフ・アルゴリズムによって使用される核となるアルゴリズムである。これは循環を検知するために利用できる（ファイル依存関係の例における&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/file_dependency_example.html#cycles&#34;&gt;循環依存 （Cylic Dependencies）&lt;/a&gt; の節を見よ）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/dfs.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 7: 無向グラフにおける深度優先探査&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順序: a b e d c f g h i&lt;/li&gt;
&lt;li&gt;完了の順序: d f c e b a&lt;/li&gt;
&lt;li&gt;括弧構造: (a (b (e (d d) (c (f f) c) e) b) a) (g (h (i i) h) g)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;最小全域木問題&lt;/h2&gt;
&lt;p&gt;最小全域木問題は、以下のように定義される：グラフ &lt;code&gt;E&lt;/code&gt; 中の全頂点を接続する循環のサブセット &lt;code&gt;T&lt;/code&gt; を接続の全コストが最小となるように選択することである。全コストは下記により与えられる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(T) = T における辺 (u,v) におけるコスト w(u,v) の合計、 w(u,v) は辺 (u,v) のコスト
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;T&lt;/code&gt; は&lt;strong&gt;全域木(spanning tree)&lt;/strong&gt;と呼ばれる.&lt;/p&gt;
&lt;h2&gt;最短経路問題&lt;/h2&gt;
&lt;p&gt;グラフ理論における古典的問題のひとつは、グラフ中の２頂点間を結ぶ最短経路を見つけることである。形式的に経路はグラフ &lt;code&gt;G = (V, E)&lt;/code&gt; 中の頂点のシーケンス &lt;code&gt;&amp;lt;v0,v1,...,vk&amp;gt;&lt;/code&gt; で表される（辺 &lt;code&gt;(vi,vi+1) for i=0,1,...,k-1&lt;/code&gt; は 辺の集合 &lt;code&gt;E&lt;/code&gt; ）。シーケンスにおいて各頂点は次の頂点へ接続される。最短経路問題において、各辺は重みを数値として与えられている。それゆえ、&lt;strong&gt;経路の重み(weight of a path)&lt;/strong&gt;について記す&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(p) = i=1..k of w(vi-1,vi) の合計
&lt;/code&gt;&lt;/pre&gt;
頂点 &lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; に至る&lt;strong&gt;最短経路の重み(shortest path weight)&lt;/strong&gt;は&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;delta (u,v) = min { w(p) : u --&amp;gt; v } もし 頂点 u から v に至る経路が存在すれば
delta (u,v) = 無限(infinity ) そうでなければ（ u から v に至る経路がなければ）
&lt;/code&gt;&lt;/pre&gt;
最短経路は、重みの合計が最小となる経路といえる。&lt;/p&gt;
&lt;p&gt;最短経路問題には、いくつかの変形された問題がある。ここでは単一ペアの問題を定義した、しかし、さらに単一出所問題(グラフ中の1つの頂点から各頂点ごとまでの最短のパス)があり、等価な単一目的地問題、全ペア問題、などである。単一出所の問題を解決するアルゴリズムより漸近的に速い、単一ペアの問題を解決するアルゴリズムは存在しない。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短経路木(shortest-paths tree)&lt;/strong&gt;は、グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; 中のある頂点を原点とした有向サブグラフである。&lt;code&gt;V&#39;&lt;/code&gt; を &lt;code&gt;V&lt;/code&gt; のサブセット、&lt;code&gt;E&#39;&lt;/code&gt; を &lt;code&gt;E&lt;/code&gt; のサブセットとし、 &lt;code&gt;V&#39;&lt;/code&gt; は&lt;code&gt;G&#39;&lt;/code&gt; から到達可能な頂点の集合、&lt;code&gt;G&#39;&lt;/code&gt; は原点から連なる経路木を成すものとすれば、&lt;code&gt;V&#39;&lt;/code&gt; 中の全ての頂点 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;G&#39;&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; から唯一の経路を持つ。再帰的に、単一頂点アルゴリズムによる結果は最短経路木である。&lt;/p&gt;
&lt;h2&gt;ネットワークフロー問題&lt;/h2&gt;
&lt;p&gt;ネットワークの流れは&lt;strong&gt;送信(source)&lt;/strong&gt;頂点 &lt;code&gt;s&lt;/code&gt; から&lt;strong&gt;受信(sink)&lt;/strong&gt;頂点&lt;code&gt;t&lt;/code&gt;へと向かう有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; である。各辺は数値による、&lt;strong&gt;容量(capacity)&lt;/strong&gt;関数 &lt;code&gt;c&lt;/code&gt; 、および、&lt;strong&gt;流れ(flow)&lt;/strong&gt;関数 &lt;code&gt;f&lt;/code&gt; を持つ。流れ関数は次の３条件を満たしていなければならない：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;f(u,v) &amp;lt;= c(u,v) for all (u,v) in V x V (容量制限) 
f(u,v) = - f(v,u) for all (u,v) in V x V (流れ対称性)
sumv in V f(u,v) = 0 for all u in V - {s,t} (流れ保存則)
&lt;/code&gt;&lt;/pre&gt;
ネットワークにおける&lt;strong&gt;流れ(flow)&lt;/strong&gt;は、受信頂点 &lt;code&gt;t&lt;/code&gt; に流れ込む集合の流れである（それは、送信頂点 &lt;code&gt;s&lt;/code&gt; から流れ出るネットの流れに等価である）。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;|f| = sumu in V f(u,t) = sumv in V f(s,v)
&lt;/code&gt;&lt;/pre&gt;
辺における&lt;strong&gt;余剰容量(residual capacity)&lt;/strong&gt;を &lt;code&gt;r(u,v) = c(u,v) – f(u,v)&lt;/code&gt; とする。 &lt;code&gt;r(u,v) &amp;gt; 0&lt;/code&gt; を満たす辺は余剰辺 &lt;code&gt;E&lt;sub&gt;f&lt;/sub&gt;&lt;/code&gt; であり、それは余剰グラフ &lt;code&gt;G&lt;sub&gt;f&lt;/sub&gt; = (V, E&lt;sub&gt;f&lt;/sub&gt;)&lt;/code&gt; を成す。 &lt;code&gt;r(u,v) = 0&lt;/code&gt; を満たす辺は&lt;strong&gt;飽和(saturated)&lt;/strong&gt;している。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大流問題(maximum flow problem)&lt;/strong&gt;は、最大に可能な流量値 &lt;code&gt;|f|&lt;/code&gt; を決定することであり、そのときのグラフ中における各辺に対する流量値を決定することである。&lt;/p&gt;
&lt;p&gt;ネットワークの流れを 図 8 に示す。 &lt;code&gt;A&lt;/code&gt; は送信頂点で、&lt;code&gt;H&lt;/code&gt; は受信頂点。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/max-flow.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 8: 最大流ネットワーク。各辺は（流れ/容量）のラベルで示している。&lt;/p&gt;
&lt;p&gt;最大流ネットワーク問題を解決するには長い歴史があり、最初のアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford56:_maxim&#34;&gt;Ford と Fulkerson&lt;/a&gt;による。現在に至る最良のアルゴリズムである push-relabel アルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goldberg85:_new_max_flow_algor&#34;&gt;Goldberg&lt;/a&gt; によるもので、これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#karzanov74:_deter&#34;&gt;Karzanov&lt;/a&gt; による &lt;strong&gt;preflow&lt;/strong&gt; introduced という概念を元に成り立っている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 KATO Kimikazu, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>基本的なグラフ理論の復習 -- Boost.Graph : 「基本的なグラフ理論の復習」に、「深さ優先探索」「最小全域木問題」「最短経路問題」「ネットワークフロー問題」を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html"/>
      <id>48d953f87ea05046961714ce88d1853c81603895:archive/boost_docs/libs/graph/graph_theory_review.md</id>
      <updated>2014-12-22 15:30:54 +0900</updated>
      
        <content type="html">&lt;h1&gt;基本的なグラフ理論の復習&lt;/h1&gt;
&lt;p&gt;この章は、基本的なグラフ理論を思い出させることを意図している。読者があらかじめグラフアルゴリズムの知識があるのなら、始めるにあたりこの章は十分であろう。もし読者がグラフアルゴリズムの知識がないのならば、 Cormen, Leiserson, Rivestの&lt;a href=&#34;http://www.toc.lcs.mit.edu/~clr/&#34; target=&#34;_blank&#34;&gt;Introduction to Algorithms&lt;/a&gt; のようなもっと詳しいものを薦める。&lt;/p&gt;
&lt;h2&gt;グラフ抽象&lt;/h2&gt;
&lt;p&gt;グラフは、多くの種類の問題を解くのに有効な数学的抽象化である。基本的には、グラフは頂点と辺から構成され、辺は二つの頂点を結ぶ。もっと正確には、グラフ(graph)とは組&lt;code&gt;(V,E)&lt;/code&gt;で表され、&lt;code&gt;V&lt;/code&gt;は有限集合で、&lt;code&gt;E&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の２項関係である。&lt;code&gt;V&lt;/code&gt;は &lt;strong&gt;頂点集合(vertex set)&lt;/strong&gt; と呼ばれ、その要素を &lt;strong&gt;頂点(vertex)&lt;/strong&gt; と呼ぶ。&lt;code&gt;E&lt;/code&gt;は辺の集合で、 &lt;strong&gt;辺(edge)&lt;/strong&gt; とは&lt;code&gt;(u,v)&lt;/code&gt;の組で&lt;code&gt;u&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の要素である。 &lt;strong&gt;有向グラフ(directed graph)&lt;/strong&gt; においては、辺は順序付けられた組で、 &lt;strong&gt;始点(source)&lt;/strong&gt; を &lt;strong&gt;終点(target)&lt;/strong&gt; へと接続する。無向グラフ(undirected graph)においては、辺は順序付けされていない組で、２つの頂点を両方向につなぐ。つまり、無向グラフでは &lt;code&gt;(u,v)&lt;/code&gt;と&lt;code&gt;(v,u)&lt;/code&gt;は同じ辺の２通りの書き方である。&lt;/p&gt;
&lt;p&gt;グラフのこの定義は、いくつかの点であいまいである。辺や頂点が何を表現するかが述べられていない。グラフの例としては、連絡道路やハイパーリンク付きのウェブページなどを挙げることができる。これらの詳細がグラフの定義からは除外されているのは、大きな理由がある。それらの詳細はグラフの &lt;strong&gt;抽象化&lt;/strong&gt; の中では必要な部分ではない。詳細を定義から除外することで再利用可能な理論を構築でき、そのことは多くの異なった種類の問題を解く際に役に立つのである。&lt;/p&gt;
&lt;p&gt;定義にもどろう。グラフは頂点と辺の集合である。実際の様子を見せるため、頂点に文字のラベルがついたグラフを考え、辺を単純に文字の組としよう。ここで、有向グラフの例を次のように書くことができる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y } 
E = { (b,y), (b,y), (y,v), (z,a), (x,x), (b,x), (x,v), (a,z) } 
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;
このグラフを図示すると 図1 のようになる。辺 &lt;code&gt;(x,x)&lt;/code&gt; は &lt;strong&gt;輪(self-loop)&lt;/strong&gt; と呼ばれる。&lt;code&gt;(b,y)&lt;/code&gt;と &lt;code&gt;(b,y)&lt;/code&gt;は &lt;strong&gt;平行辺(parallel edges)&lt;/strong&gt; であり、これは &lt;strong&gt;マルチグラフ(multigraph)&lt;/strong&gt; でのみ許される(ただし、通常は有向グラフでも無向グラフでも許されない)。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/digraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図1: 有向グラフの例&lt;/p&gt;
&lt;p&gt;次に似たようなグラフを示すが、今度は無向グラフである。これは図2に図示する。無向グラフでは輪は許されない。上記のグラフ(から平行辺&lt;code&gt;(b,y)&lt;/code&gt;を除いたもの)の &lt;strong&gt;無向版(undirected version)&lt;/strong&gt; である。それはつまり、同じ頂点をもち、同じ辺から方向を除いたものを持つことを意味し、&lt;code&gt;(a,z)&lt;/code&gt;と&lt;code&gt;(z,a)&lt;/code&gt;という２つの辺は一つの辺に退化する。また、逆を考えることもできる。無向グラフの &lt;strong&gt;有向版(directed version)&lt;/strong&gt; は、すべての辺をそれぞれの方向を向く２つの辺で置き換えることで得られる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y }
E = { (b,y), (y,v), (z,a), (b,x), (x,v) }
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;
&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undigraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図2: 無向グラフの例&lt;/p&gt;
&lt;p&gt;ここでさらにグラフの用語を定義する。辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるとき、頂点&lt;code&gt;v&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;について &lt;strong&gt;隣接している(adjacent)&lt;/strong&gt; と言う。有向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は 頂点&lt;code&gt;u&lt;/code&gt;の &lt;strong&gt;出辺(out-edge)&lt;/strong&gt; であり、頂点&lt;code&gt;v&lt;/code&gt;の &lt;strong&gt;入辺(in-edge)&lt;/strong&gt; である。無向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を &lt;strong&gt;接合している(incident on)&lt;/strong&gt; という。&lt;/p&gt;
&lt;p&gt;図1で、頂点&lt;code&gt;y&lt;/code&gt;は頂点&lt;code&gt;b&lt;/code&gt;に対して隣接している (ただし&lt;code&gt;b&lt;/code&gt;は&lt;code&gt;y&lt;/code&gt;に対して隣接していない)。辺&lt;code&gt;(b,y)&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;の出辺であり、&lt;code&gt;y&lt;/code&gt;の入辺である。図2で、&lt;code&gt;y&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;に隣接していて、また逆も同様である。辺&lt;code&gt;(y,b)&lt;/code&gt;は頂点&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;を接合している。&lt;/p&gt;
&lt;p&gt;有向グラフにおいて、ある頂点の出辺の数は &lt;strong&gt;出次数(out-degree)&lt;/strong&gt; と呼ばれ、入辺の数は &lt;strong&gt;入次数(in-degree)&lt;/strong&gt; と呼ばれる。無向グラフにおいて、ある頂点に対して接合している辺の数は &lt;strong&gt;次数(degree)&lt;/strong&gt; と呼ばれる。図1で、頂点&lt;code&gt;b&lt;/code&gt;の出次数は3であり、入次数は0である。図2では単純に頂点&lt;code&gt;b&lt;/code&gt;の次数は2である。&lt;/p&gt;
&lt;p&gt;グラフの &lt;strong&gt;路(path)&lt;/strong&gt; とは辺の列で、それぞれの辺の終点が次の辺の始点であるものである。頂点&lt;code&gt;u&lt;/code&gt;から始まり頂点&lt;code&gt;v&lt;/code&gt;で終わる路があれば、頂点&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;から &lt;strong&gt;到達可能(reachable)&lt;/strong&gt; であるという。路が &lt;strong&gt;単純(simple)&lt;/strong&gt; であるとは、辺の列の中でどの頂点も繰り返し現れないことである。路&lt;code&gt;&amp;lt;(b,x), (x,v)&amp;gt;&lt;/code&gt;は単純であるが、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は単純ではない。また、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は最初の頂点と最後の頂点が一致するので、 &lt;strong&gt;サイクル(cycle)&lt;/strong&gt; と呼ばれる。サイクルのないグラフは &lt;strong&gt;アサイクリック(acyclic)&lt;/strong&gt; と呼ばれる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平面的グラフ(planar graph)&lt;/strong&gt; とは、すべての辺が交差しないように平面上に描けるグラフのことである。そのように描かれたものは &lt;strong&gt;平面グラフ(plane graph)&lt;/strong&gt; と呼ばれる。平面グラフの &lt;strong&gt;面(face)&lt;/strong&gt; とは、辺に囲まれた連結成分のことである。平面的グラフの重要な特性は、面、辺、頂点の数がオイラーの定理：&lt;code&gt;|F| - |E| + |V| = 2&lt;/code&gt;によって関係付けられることである。このことは、平面的グラフは最大でもO(|V|)個の辺しか持たないことを意味する。&lt;/p&gt;
&lt;h2&gt;グラフデータ構造&lt;/h2&gt;
&lt;p&gt;データ構造を考えるときに最初に考えるべきグラフの属性は、&lt;strong&gt;まばらさ(sparsity)&lt;/strong&gt; である。まばらさとは、頂点に対する相対的な辺の数である。&lt;code&gt;E&lt;/code&gt;が&lt;code&gt;V²&lt;/code&gt;に近いグラフは &lt;strong&gt;密(dense)&lt;/strong&gt; であると呼ばれ、&lt;code&gt;E = alpha V&lt;/code&gt;で&lt;code&gt;alpha&lt;/code&gt;が&lt;code&gt;V&lt;/code&gt;より十分に小さい場合は、まばらな(sparse)グラフと呼ばれる。密なグラフについては、通常、 &lt;strong&gt;隣接行列表現(adjacency-matrix representation)&lt;/strong&gt; が最良の選択であり、一方まばらなグラフについては &lt;strong&gt;隣接リスト表現(adjacency-list representation)&lt;/strong&gt; が最良である。また、まばらなグラフについては &lt;strong&gt;辺リスト表現(edge-list representation)&lt;/strong&gt; も適切な状況下では記憶効率面でよい選択である。&lt;/p&gt;
&lt;h3&gt;隣接行列表現&lt;/h3&gt;
&lt;p&gt;グラフの隣接行列表現はV x Vの２次元配列である。 行列a&lt;sub&gt;uv&lt;/sub&gt;の要素は、辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるかどうかを示すブーリアン値である。図3に図1(から&lt;code&gt;(b,y)&lt;/code&gt;を引いたもの)の隣接行列表現を表す。保存に必要な領域はO(V²)である。任意の辺について、アクセス、追加、除去にかかる時間はO(1)である。 頂点の追加や除去は、再割り当てとすべてのグラフのコピーが必要になり、手順数はO(V²)になる。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;クラスは、隣接行列表現によってBGLグラフインターフェースを実装する。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_matrix.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図3: 隣接行列によるグラフの表現&lt;/p&gt;
&lt;h3&gt;隣接リスト表現&lt;/h3&gt;
&lt;p&gt;グラフの隣接リスト表現では、すべての頂点に対して出辺の列を保存する。まばらなグラフでは、こうすることでメモリ領域を節約でき、必要な領域はO(V + E)だけになる。さらに、すべての頂点の出辺にはより効果的にアクセスできる。辺の挿入のコストはO(1)で、任意の辺へのアクセスはO(alpha)である。ここで、alphaは行列のまばらさ(グラフ中のすべての頂点についての出辺の数の最大値)である。図4は図1のグラフの隣接リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;は隣接リスト表現の実装である。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図4: 隣接リストによるグラフ表現&lt;/p&gt;
&lt;h3&gt;辺リスト表現&lt;/h3&gt;
&lt;p&gt;グラフの辺リスト表現は、単純に辺の列であり、辺は頂点のIDの組で表される。必要なメモリはO(E)だけである。辺挿入のコストはO(1)であり、特定の辺のアクセスするのはO(E)(あまり効果的でない)である。図5は図1のグラフの辺リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;アダプタクラスは、辺リスト表現の実装を作るのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/edge_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図5: 辺リストによるグラフの表現&lt;/p&gt;
&lt;h2&gt;グラフアルゴリズム&lt;/h2&gt;
&lt;h3&gt;グラフ探索アルゴリズム&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;木辺(tree edge)&lt;/strong&gt; とは、グラフ探索アルゴリズムをグラフに適用することによって作られた探索木(またはフォレスト)の辺ことである。辺&lt;code&gt;(u,v)&lt;/code&gt;は木辺であるのは、辺&lt;code&gt;(u,v)&lt;/code&gt;の探索(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;ビジタ&lt;/a&gt;の&lt;code&gt;explore()&lt;/code&gt;メソッドにあたる)をしているときに&lt;code&gt;v&lt;/code&gt;が最初に見つかるときである。&lt;strong&gt;後退辺(back edge)&lt;/strong&gt;とは、探索木上で頂点を先祖につなぐ辺である。したがって、辺&lt;code&gt;(u,v)&lt;/code&gt;では&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;の先祖である。輪は後退辺とみなされる。&lt;strong&gt;先行辺(forward edge)&lt;/strong&gt;は木辺ではない辺&lt;code&gt;(u,v)&lt;/code&gt;で、探索木上&lt;code&gt;u&lt;/code&gt;を子孫&lt;code&gt;v&lt;/code&gt;へとつなぐ。&lt;strong&gt;交差辺(cross edge)&lt;/strong&gt;とは、以上の３つのカテゴリに含まれない辺のことである。&lt;/p&gt;
&lt;h3&gt;幅優先探索&lt;/h3&gt;
&lt;p&gt;幅優先探索(Breadth-First Search, BFS)とは、グラフに対して横断的であり、特定の原点から到達可能な頂点をすべて探索する。また横断する順番については、頂点のすべての近傍を探索してから近傍の近傍の探索へと進む。幅優先探索について考えるには、例えば水溜りに石を落としたときに波が放射状に広がるように拡散すると思えばよい。同じ「波」の中の頂点は原点から同じ距離にある。頂点は最初にアルゴリズムによって遭遇するときに&lt;strong&gt;発見される(discovered)&lt;/strong&gt;と言う。頂点は、その近傍がすべて探索されたときに&lt;strong&gt;完了した(finished)&lt;/strong&gt;と言われる。これらをわかりやすくする例がある。グラフを図6に示し、そのBFSにおける発見と完了の順番をその下に示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/bfs_example.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図6: 広さ優先探索がグラフに広がる様子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順番: s r w v t x u y &lt;/li&gt;
&lt;li&gt;完了の順番: s r w v t x u y&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt;から開始して、最初は&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;(&lt;code&gt;s&lt;/code&gt;の近傍)にたどり着く。&lt;code&gt;s&lt;/code&gt;の両方の希望に到達してから、&lt;code&gt;r&lt;/code&gt;の近傍(頂点&lt;code&gt;v&lt;/code&gt;)に到達し、&lt;code&gt;w&lt;/code&gt;の近傍&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;に到達する (&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;の順序は意味を持たない)。最後に&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の近傍、&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;に到達する。&lt;/p&gt;
&lt;p&gt;今グラフ上のどこにいるか、次にどこの頂点に行くかをアルゴリズムが把握するために、BFSは頂点に色を塗る。塗る色を置く場所は、グラフの中でもよいし、アルゴリズムに引数として渡すこともできる。&lt;/p&gt;
&lt;h3&gt;深さ優先探索&lt;/h3&gt;
&lt;p&gt;深さ優先探査(Depth-First Search, DFS) は、グラフ中の全頂点を探査する。このアルゴリズムでは、常にグラフ中の「深い」部分を、次に探査すべき辺として選択していく。これは、到達した頂点が未訪問の隣接頂点を持たなくなるまで次の未訪問な隣接頂点を選択していき、端に到達すれば前の頂点へと戻り、その頂点から任意の未探査な辺へと探査を継続していくことである。深さ優先探査は、出発する頂点から到達可能な全ての頂点を訪問した後に、残りの未訪問な頂点のうちから１頂点を選択して探査を継続していく。このプロセスは、深度優先の森からともに深度優先の木という集合を形成する。深さ優先探索は、グラフ中の辺を３つのカテゴリーに分類する：木辺、後退辺、先行辺か交差辺(どちらにも明確に分類しない)。与えられたグラフから多くの有効な深度優先の森が典型的に存在し、それゆえ辺を分類するには様々な(かつ等しく有効な)方法がある。&lt;/p&gt;
&lt;p&gt;深さ優先探査の興味深い特性は、各頂点の発見時と完了時の間において、括弧（入れ子）構造を形成するということである。頂点が発見される場合、私たちが開いた括弧を使用すれば、頂点が探査終了される場合には閉じた括弧が使用され、その結果、括弧により適切に入れ子にされた集合ができあがる。図7は、探査された順番にラベル付けされた辺による無向グラフに適応された DFS （深さ優先探査）である。図の下に、探査を開始した順序と探査を終了した順序を示し、それらから導かれる括弧構造を示す。DFS （深さ優先探査）は、２つが接続されたコンポーネント・アルゴリズム、トポロジカル・ソート、などを含む他のグラフ・アルゴリズムによって使用される核となるアルゴリズムである。これは循環を検知するために利用できる（ファイル依存関係の例における&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/file_dependency_example.html#cycles&#34;&gt;循環依存 （Cylic Dependencies）&lt;/a&gt; の節を見よ）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/dfs.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 7: 無向グラフにおける深度優先探査&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順序: a b e d c f g h i&lt;/li&gt;
&lt;li&gt;完了の順序: d f c e b a&lt;/li&gt;
&lt;li&gt;括弧構造: (a (b (e (d d) (c (f f) c) e) b) a) (g (h (i i) h) g)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;最小全域木問題&lt;/h2&gt;
&lt;p&gt;最小全域木問題は、以下のように定義される：グラフ &lt;code&gt;E&lt;/code&gt; 中の全頂点を接続する循環のサブセット &lt;code&gt;T&lt;/code&gt; を接続の全コストが最小となるように選択することである。全コストは下記により与えられる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(T) = T における辺 (u,v) におけるコスト w(u,v) の合計、 w(u,v) は辺 (u,v) のコスト
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;T&lt;/code&gt; は&lt;strong&gt;全域木(spanning tree)&lt;/strong&gt;と呼ばれる.&lt;/p&gt;
&lt;h2&gt;最短経路問題&lt;/h2&gt;
&lt;p&gt;グラフ理論における古典的問題のひとつは、グラフ中の２頂点間を結ぶ最短経路を見つけることである。形式的に経路はグラフ &lt;code&gt;G = (V, E)&lt;/code&gt; 中の頂点のシーケンス &lt;code&gt;&amp;lt;v0,v1,...,vk&amp;gt;&lt;/code&gt; で表される（辺 &lt;code&gt;(vi,vi+1) for i=0,1,...,k-1&lt;/code&gt; は 辺の集合 &lt;code&gt;E&lt;/code&gt; ）。シーケンスにおいて各頂点は次の頂点へ接続される。最短経路問題において、各辺は重みを数値として与えられている。それゆえ、&lt;strong&gt;経路の重み(weight of a path)&lt;/strong&gt;について記す&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(p) = i=1..k of w(vi-1,vi) の合計
&lt;/code&gt;&lt;/pre&gt;
頂点 &lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; に至る&lt;strong&gt;最短経路の重み(shortest path weight)&lt;/strong&gt;は&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;delta (u,v) = min { w(p) : u --&amp;gt; v } もし 頂点 u から v に至る経路が存在すれば
delta (u,v) = 無限(infinity ) そうでなければ（ u から v に至る経路がなければ）
&lt;/code&gt;&lt;/pre&gt;
最短経路は、重みの合計が最小となる経路といえる。&lt;/p&gt;
&lt;p&gt;最短経路問題には、いくつかの変形された問題がある。ここでは単一ペアの問題を定義した、しかし、さらに単一出所問題(グラフ中の1つの頂点から各頂点ごとまでの最短のパス)があり、等価な単一目的地問題、全ペア問題、などである。単一出所の問題を解決するアルゴリズムより漸近的に速い、単一ペアの問題を解決するアルゴリズムは存在しない。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短経路木(shortest-paths tree)&lt;/strong&gt;は、グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; 中のある頂点を原点とした有向サブグラフである。&lt;code&gt;V&#39;&lt;/code&gt; を &lt;code&gt;V&lt;/code&gt; のサブセット、&lt;code&gt;E&#39;&lt;/code&gt; を &lt;code&gt;E&lt;/code&gt; のサブセットとし、 &lt;code&gt;V&#39;&lt;/code&gt; は&lt;code&gt;G&#39;&lt;/code&gt; から到達可能な頂点の集合、&lt;code&gt;G&#39;&lt;/code&gt; は原点から連なる経路木を成すものとすれば、&lt;code&gt;V&#39;&lt;/code&gt; 中の全ての頂点 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;G&#39;&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; から唯一の経路を持つ。再帰的に、単一頂点アルゴリズムによる結果は最短経路木である。&lt;/p&gt;
&lt;h2&gt;ネットワークフロー問題&lt;/h2&gt;
&lt;p&gt;ネットワークの流れは&lt;strong&gt;送信(source)&lt;/strong&gt;頂点 &lt;code&gt;s&lt;/code&gt; から&lt;strong&gt;受信(sink)&lt;/strong&gt;頂点&lt;code&gt;t&lt;/code&gt;へと向かう有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; である。各辺は数値による、&lt;strong&gt;容量(capacity)&lt;/strong&gt;関数 &lt;code&gt;c&lt;/code&gt; 、および、&lt;strong&gt;流れ(flow)&lt;/strong&gt;関数 &lt;code&gt;f&lt;/code&gt; を持つ。流れ関数は次の３条件を満たしていなければならない：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;f(u,v) &amp;lt;= c(u,v) for all (u,v) in V x V (容量制限) 
f(u,v) = - f(v,u) for all (u,v) in V x V (流れ対称性)
sumv in V f(u,v) = 0 for all u in V - {s,t} (流れ保存則)
&lt;/code&gt;&lt;/pre&gt;
ネットワークにおける&lt;strong&gt;流れ(flow)&lt;/strong&gt;は、受信頂点 &lt;code&gt;t&lt;/code&gt; に流れ込む集合の流れである（それは、送信頂点 &lt;code&gt;s&lt;/code&gt; から流れ出るネットの流れに等価である）。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;|f| = sumu in V f(u,t) = sumv in V f(s,v)
&lt;/code&gt;&lt;/pre&gt;
辺における&lt;strong&gt;余剰容量(residual capacity)&lt;/strong&gt;を &lt;code&gt;r(u,v) = c(u,v) – f(u,v)&lt;/code&gt; とする。 &lt;code&gt;r(u,v) &amp;gt; 0&lt;/code&gt; を満たす辺は余剰辺 &lt;code&gt;E&lt;sub&gt;f&lt;/sub&gt;&lt;/code&gt; であり、それは余剰グラフ &lt;code&gt;G&lt;sub&gt;f&lt;/sub&gt; = (V, E&lt;sub&gt;f&lt;/sub&gt;)&lt;/code&gt; を成す。 &lt;code&gt;r(u,v) = 0&lt;/code&gt; を満たす辺は&lt;strong&gt;飽和(saturated)&lt;/strong&gt;している。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大流問題(maximum flow problem)&lt;/strong&gt;は、最大に可能な流量値 &lt;code&gt;|f|&lt;/code&gt; を決定することであり、そのときのグラフ中における各辺に対する流量値を決定することである。&lt;/p&gt;
&lt;p&gt;ネットワークの流れを 図 8 に示す。 &lt;code&gt;A&lt;/code&gt; は送信頂点で、&lt;code&gt;H&lt;/code&gt; は受信頂点。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/max-flow.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 8: 最大流ネットワーク。各辺は（流れ/容量）のラベルで示している。&lt;/p&gt;
&lt;p&gt;最大流ネットワーク問題を解決するには長い歴史があり、最初のアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford56:_maxim&#34;&gt;Ford と Fulkerson&lt;/a&gt;による。現在に至る最良のアルゴリズムである push-relabel アルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goldberg85:_new_max_flow_algor&#34;&gt;Goldberg&lt;/a&gt; によるもので、これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#karzanov74:_deter&#34;&gt;Karzanov&lt;/a&gt; による &lt;strong&gt;preflow&lt;/strong&gt; introduced という概念を元に成り立っている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 KATO Kimikazu, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;
Japanese Translation Copyright © 2014 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>