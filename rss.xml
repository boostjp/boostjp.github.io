<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-01-16T23:49:50.084087</updated>
  <id>68877bbc-10f6-4d97-842f-43e12d5d12d5</id>

  
    <entry>
      <title>The Boost Concept Check Library (BCCL) -- concept check : 参考文献へのリンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check.html"/>
      <id>e2ee0653ae55e6f40e453ff86aba729352130d70:archive/boost_docs/libs/concept_check.md</id>
      <updated>2015-01-16 23:49:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;The Boost Concept Check Library (BCCL)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/concept_check/concept_check.htm&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/concept_check/concept_check.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ヘッダーファイル： boost/concept_check.hpp と boost/concept_archetype.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ におけるジェネリック・プログラミングは、抽象データ型(あるいは「コンセプト」)を表現するためにテンプレート・パラメータを使用することを特徴としている。 しかし、C++ 言語には、クラス・テンプレートや関数テンプレートに対して、与えられたテンプレート引数がモデル化（もしくは順応）すべきコンセプトを明確に規定するためのメカニズムがない。 よく利用されているのは、必要とされるコンセプトのヒントとなるようにテンプレート・パラメータを命名し、付属文書においてコンセプトの要求事項を記述する方式である。 残念ながら、こういった要求事項の記述は、往々にして曖昧であったり不正確であったり、まったく存在しないこともある。 あるテンプレートが想定している引数の性質を、そのテンプレートのユーザーが正確に理解できなければ、それは由々しき問題となる。 さらに、以下の問題が起こりうる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不正なテンプレート引数に起因するコンパイラ・エラー・メッセージは、難解になることが多い。 大抵の場合、エラーの示す位置はテンプレートが使用された所ではなく、ユーザーが目にする必要のないテンプレートの実装内である。&lt;/li&gt;
&lt;li&gt;記述された要求事項が、テンプレートのコンセプトを完全に表現し切れていない場合、使用されたテンプレート引数が記述された要求事項を満足していたとしても、コンパイラ・エラーを受ける可能性がある。&lt;/li&gt;
&lt;li&gt;記述された要求事項が、テンプレートが実際に必要とするよりも厳格である場合がある。&lt;/li&gt;
&lt;li&gt;要求事項は、コードの中で明示的に記述されることは無い。 そのために、コードの理解がより困難になる。 さらに、コードと記述された要求事項が同期していない事態も生じる可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost コンセプト・チェック・ライブラリは、次のような手段を提供する：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレート・パラメータのコンパイル時チェックを導入するためのメカニズム。&lt;/li&gt;
&lt;li&gt;コンセプト・チェック用クラスによって、要求事項を明確化するためのフレームワーク。&lt;/li&gt;
&lt;li&gt;コンセプトの要求事項が、該当テンプレートをカバーしていることを確認するためのメカニズム。&lt;/li&gt;
&lt;li&gt;C++ 標準ライブラリのコンセプト要求事項に対応する、コンセプト・チェック用クラスおよび原型クラス一式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このメカニズムは C++ 標準の機能のみを使用し、実行時オーバーヘッドを課さない。 メカニズムを導入するコストは、コンパイル時間の増大のみである。&lt;/p&gt;
&lt;p&gt;クラス・テンプレートや関数テンプレートを記述するプログラマは、全員が通常のコード作成作業の一環としてコンセプト・チェックを含めるべきである。 コンセプト・チェックは、コンポーネントへのインターフェイスとして公開されている、すべてのテンプレート・パラメータに対して導入すべきである。 利用したいコンセプトが標準ライブラリーで用いられているものであれば、BCCL の該当するコンセプト・チェック用クラスを、そのまま使用すればよい。 そうでなければ、新たにコンセプト・チェック用クラスを記述することになるが、普通は数行程度に収まるはずだ。 新しいコンセプトを用いるならば、対応する原型クラスも作成すべきである。原型クラスとはコンセプトを表す最小限のスケルトン実装である。&lt;/p&gt;
&lt;p&gt;この文書を、以下の通り構成する。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating-example&#34;&gt;動機の例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#history&#34;&gt;歴史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#publications&#34;&gt;公開資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;コンセプト・チェックの利用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html&#34;&gt;コンセプトの充当化と原型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;コンセプトを用いたプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html&#34;&gt;コンセプト・チェックの実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt; はこのライブラリを寄稿した。 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/beman_dawes.html&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt; が公式レビューを管理した。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#introduction&#34; name=&#34;introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;コンセプト &#34;concept&#34; とは、ジェネリック・アルゴリズムに対する引数として与えられる型が、アルゴリズム内部で正しく使用されるために満足しなければならない要求事項(有効な式、関連型、セマンティクス不変、計算量保証など)の組み合わせである。 C++ では、コンセプトは関数テンプレート(ジェネリック・アルゴリズム)のテンプレート・パラメータとして表現される。 しかしながら、C++ にはコンセプトを表現するための明示的なメカニズムがない。テンプレート・パラメータはただのプレースホルダでしかないのだ。 慣例として、こういったパラメータには、必要とされるコンセプトに対応する名前を与える。しかし、テンプレート・パラメータを実際の型で確定するときに、C++ コンパイラはコンセプトへの遵守を強要しない。&lt;/p&gt;
&lt;p&gt;当然ながら、ジェネリック・アルゴリズムを、そのコンセプトの内、構文に関わる要求事項を満足していない型で呼び出した場合、コンパイル・エラーが生じる。 しかし、このエラーは、該当する型がコンセプトの要求事項すべてに適合していない事実を本質的に 反映したものではない。 それどころか、エラーはインスタンス化階層の深部で発生し、該当する型に対して式が有効でないか、想定された関連型が利用可能でないといったことが原因として挙げられることになるだろう。 こうして生じたエラーメッセージは、大抵において情報に乏しく、基本的に不可解である。&lt;/p&gt;
&lt;p&gt;必要とされるものは、インスタンス化位置(かその近傍)で「コンセプトセーフ」を強要するためのメカニズムである。 Boost コンセプト・チェック・ライブラリーは、早い段階でコンセプトの遵守を強要し、遵守していない場合のエラー・メッセージをより有用にするために C++ 標準の機能を使用する。&lt;/p&gt;
&lt;p&gt;注意すべき点は、この技術がコンセプトの要求事項のうち構文に関わる部分(有効な式および関連型)のみを扱うことである。 我々は、コンセプトの要求事項の一部であるセマンティクス不変あるいは計算量保証を扱わない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating-example&#34; name=&#34;motivating-example&#34;&gt;動機の例&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;テンプレート・ライブラリの不正な使用法と、その結果生じるエラーメッセージを例証するために単純なサンプルを示す。 下記のコードでは、標準テンプレート・ライブラリー (STL) のジェネリックな &lt;code&gt;std::stable_sort()&lt;/code&gt; アルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#generic-programming-and-the-stl&#34;&gt;3&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#stl-tutorial-and-reference-guide&#34;&gt;4&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#the-standard-template-library&#34;&gt;5&lt;/a&gt;] をリンクリストに適用している。&lt;/p&gt;
&lt;p&gt;bad_error_eg.cpp:&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;list&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main(int, char*[]) {
    std::list&amp;lt;int&amp;gt; v;
    std::stable_sort(v.begin(), v.end());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;この場合、&lt;code&gt;std::stable_sort()&lt;/code&gt; アルゴリズムは以下のようなプロトタイプを有する：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIterator first, RandomAccessIterator last);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Gnu C++ でこのコードをコンパイルすると、以下のコンパイラ・エラーを生成する。他のコンパイラ出力は Appendix にリストしてある(訳注 : このバージョンのドキュメントには記載されていない)。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;stl_algo.h: In function `void __merge_sort_loop&amp;lt;_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;,
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int)&#39;:
stl_algo.h:1448:   instantiated from `__merge_sort_with_buffer
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(
   _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;,
   int *, int *)&#39;
stl_algo.h:1485:   instantiated from `__stable_sort_adaptive&amp;lt;
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt;, _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int)&#39;
stl_algo.h:1524:   instantiated from here
stl_algo.h:1377: no match for `_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp; -
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;この場合、根本的なエラーの原因は、&lt;code&gt;std:list::iterator&lt;/code&gt; が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; コンセプトをモデル化していないことにある。 リストのイテレータは双方向でしかなく、(ベクタのイテレータのように) 完全なランダム・アクセスが可能なわけではない。 残念ながら、このエラーメッセージには、ユーザーにこの事実を示すものは何もない。&lt;/p&gt;
&lt;p&gt;C++ プログラマがテンプレート・ライブラリに十分な経験を持っていれば、この手のエラーに惑うことは無いかもしれない。 しかし未熟な者にとっては、次のような理由で、このメッセージが理解し難いものとなっている。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;エラーが生じる位置、bad_error_eg.cpp の６行目は、Gnu C++ がインスタンス化スタックを４レベルも深くまで探索して表示するという事実にもかかわらず、エラーメッセージで示されていない。&lt;/li&gt;
&lt;li&gt;エラーメッセージと、&lt;code&gt;std::stable_sort()&lt;/code&gt; および &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; に関する文書化された要求事項との間に、文面上の相関がない。&lt;/li&gt;
&lt;li&gt;エラーメッセージが過度に長く、ユーザーの知らない(かつ知るべきでない！) STL 内部実装用の関数がリストされている。&lt;/li&gt;
&lt;li&gt;エラーメッセージに、ライブラリ内部の実装用関数が数多くリストアップされているため、プログラマが、エラーの原因は自分のコードではなくライブラリ側にあるとの結論に、誤って飛びついてしまう可能性がある。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;次の例示は、より有用なメッセージとして斯くあるべきと我々が考えるものだ (また実際に Boost コンセプト・チェック・ライブラリが生成するものでもある)。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;boost/concept_check.hpp: In method `void LessThanComparableConcept
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;::constraints()&#39;:
boost/concept_check.hpp:334:   instantiated from `RandomAccessIteratorConcept
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;::constraints()&#39;
bad_error_eg.cpp:6:   instantiated from `stable_sort&amp;lt;_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;(_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, 
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;)&#39;
boost/concept_check.hpp:209: no match for `_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;
  &amp;lt; _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このメッセージは、標準的なエラー・メッセージがもつ欠点をいくつかの点で改善する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エラーの生じた位置 (bad_error_eg.cpp:6）がエラーメッセージに明示されている。&lt;/li&gt;
&lt;li&gt;メッセージは、STL 文書に記述されているコンセプト (&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;RandomAccessIterator&lt;/a&gt;) を明示的に言及している。&lt;/li&gt;
&lt;li&gt;エラーメッセージははるかに短くなり、STL の内部実装用関数を露呈しない。&lt;/li&gt;
&lt;li&gt;エラーメッセージの中に concept_check.hpp および &lt;code&gt;constraints()&lt;/code&gt; が示されることで、ライブラリ実装の中にではなくユーザーのコードにエラーがあるという事実をユーザーに警告している。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#history&#34; name=&#34;history&#34;&gt;歴史&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このコンセプト・チェック・システムの初期バージョンは、著者が SGI において、C++ コンパイラおよびライブラリ・グループの一員として勤務している間に開発された。 初期バージョンは今も SGI STL ディストリビューションの一部である。 Boost コンセプト・チェック・ライブラリは、エラーメッセージにおけるそれほど有用でない表現能力を犠牲にして、コンセプト・チェック用クラス定義を非常に単純化しており、その点で SGI STLのコンセプト・チェックとは異なっている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#publications&#34; name=&#34;publications&#34;&gt;公開資料&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oonumerics.org/tmpw00/&#34; target=&#34;_blank&#34;&gt;C++ テンプレート・ワークショップ2000&lt;/a&gt;、コンセプト・チェック。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;インスタンス化を引き起こすために関数ポインタを使用するアイディアは、Alexander Stepanov に拠る。 テンプレートの事前チェックに式を使用するアイディアに関して、その起源を確認できなかった。しかし、それは D&amp;amp;E[&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#design-and-evolution&#34;&gt;2&lt;/a&gt;] に記載されている。 STL コンセプトに関する優れた文書化と構造化を行った Matt Austern に感謝をささげる。このコンセプト・チェックは彼の仕事を基礎にしている。 有益なコメントとレビューを賜った Boost のメンバにも感謝を。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;次へ：「コンセプト・チェックの利用」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>The Boost Concept Check Library (BCCL) -- ConceptCheckのトップページ：リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check.html"/>
      <id>de3f9d15b691267d7cb4ca1d6693f1a94a4a5e85:archive/boost_docs/libs/concept_check.md</id>
      <updated>2015-01-16 23:48:12 +0900</updated>
      
        <content type="html">&lt;h1&gt;The Boost Concept Check Library (BCCL)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/concept_check/concept_check.htm&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/concept_check/concept_check.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ヘッダーファイル： boost/concept_check.hpp と boost/concept_archetype.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ におけるジェネリック・プログラミングは、抽象データ型(あるいは「コンセプト」)を表現するためにテンプレート・パラメータを使用することを特徴としている。 しかし、C++ 言語には、クラス・テンプレートや関数テンプレートに対して、与えられたテンプレート引数がモデル化（もしくは順応）すべきコンセプトを明確に規定するためのメカニズムがない。 よく利用されているのは、必要とされるコンセプトのヒントとなるようにテンプレート・パラメータを命名し、付属文書においてコンセプトの要求事項を記述する方式である。 残念ながら、こういった要求事項の記述は、往々にして曖昧であったり不正確であったり、まったく存在しないこともある。 あるテンプレートが想定している引数の性質を、そのテンプレートのユーザーが正確に理解できなければ、それは由々しき問題となる。 さらに、以下の問題が起こりうる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不正なテンプレート引数に起因するコンパイラ・エラー・メッセージは、難解になることが多い。 大抵の場合、エラーの示す位置はテンプレートが使用された所ではなく、ユーザーが目にする必要のないテンプレートの実装内である。&lt;/li&gt;
&lt;li&gt;記述された要求事項が、テンプレートのコンセプトを完全に表現し切れていない場合、使用されたテンプレート引数が記述された要求事項を満足していたとしても、コンパイラ・エラーを受ける可能性がある。&lt;/li&gt;
&lt;li&gt;記述された要求事項が、テンプレートが実際に必要とするよりも厳格である場合がある。&lt;/li&gt;
&lt;li&gt;要求事項は、コードの中で明示的に記述されることは無い。 そのために、コードの理解がより困難になる。 さらに、コードと記述された要求事項が同期していない事態も生じる可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost コンセプト・チェック・ライブラリは、次のような手段を提供する：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレート・パラメータのコンパイル時チェックを導入するためのメカニズム。&lt;/li&gt;
&lt;li&gt;コンセプト・チェック用クラスによって、要求事項を明確化するためのフレームワーク。&lt;/li&gt;
&lt;li&gt;コンセプトの要求事項が、該当テンプレートをカバーしていることを確認するためのメカニズム。&lt;/li&gt;
&lt;li&gt;C++ 標準ライブラリのコンセプト要求事項に対応する、コンセプト・チェック用クラスおよび原型クラス一式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このメカニズムは C++ 標準の機能のみを使用し、実行時オーバーヘッドを課さない。 メカニズムを導入するコストは、コンパイル時間の増大のみである。&lt;/p&gt;
&lt;p&gt;クラス・テンプレートや関数テンプレートを記述するプログラマは、全員が通常のコード作成作業の一環としてコンセプト・チェックを含めるべきである。 コンセプト・チェックは、コンポーネントへのインターフェイスとして公開されている、すべてのテンプレート・パラメータに対して導入すべきである。 利用したいコンセプトが標準ライブラリーで用いられているものであれば、BCCL の該当するコンセプト・チェック用クラスを、そのまま使用すればよい。 そうでなければ、新たにコンセプト・チェック用クラスを記述することになるが、普通は数行程度に収まるはずだ。 新しいコンセプトを用いるならば、対応する原型クラスも作成すべきである。原型クラスとはコンセプトを表す最小限のスケルトン実装である。&lt;/p&gt;
&lt;p&gt;この文書を、以下の通り構成する。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating-example&#34;&gt;動機の例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#history&#34;&gt;歴史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#publications&#34;&gt;公開資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;コンセプト・チェックの利用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html&#34;&gt;コンセプトの充当化と原型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;コンセプトを用いたプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html&#34;&gt;コンセプト・チェックの実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt; はこのライブラリを寄稿した。 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/beman_dawes.html&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt; が公式レビューを管理した。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#introduction&#34; name=&#34;introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;コンセプト &#34;concept&#34; とは、ジェネリック・アルゴリズムに対する引数として与えられる型が、アルゴリズム内部で正しく使用されるために満足しなければならない要求事項(有効な式、関連型、セマンティクス不変、計算量保証など)の組み合わせである。 C++ では、コンセプトは関数テンプレート(ジェネリック・アルゴリズム)のテンプレート・パラメータとして表現される。 しかしながら、C++ にはコンセプトを表現するための明示的なメカニズムがない。テンプレート・パラメータはただのプレースホルダでしかないのだ。 慣例として、こういったパラメータには、必要とされるコンセプトに対応する名前を与える。しかし、テンプレート・パラメータを実際の型で確定するときに、C++ コンパイラはコンセプトへの遵守を強要しない。&lt;/p&gt;
&lt;p&gt;当然ながら、ジェネリック・アルゴリズムを、そのコンセプトの内、構文に関わる要求事項を満足していない型で呼び出した場合、コンパイル・エラーが生じる。 しかし、このエラーは、該当する型がコンセプトの要求事項すべてに適合していない事実を本質的に 反映したものではない。 それどころか、エラーはインスタンス化階層の深部で発生し、該当する型に対して式が有効でないか、想定された関連型が利用可能でないといったことが原因として挙げられることになるだろう。 こうして生じたエラーメッセージは、大抵において情報に乏しく、基本的に不可解である。&lt;/p&gt;
&lt;p&gt;必要とされるものは、インスタンス化位置(かその近傍)で「コンセプトセーフ」を強要するためのメカニズムである。 Boost コンセプト・チェック・ライブラリーは、早い段階でコンセプトの遵守を強要し、遵守していない場合のエラー・メッセージをより有用にするために C++ 標準の機能を使用する。&lt;/p&gt;
&lt;p&gt;注意すべき点は、この技術がコンセプトの要求事項のうち構文に関わる部分(有効な式および関連型)のみを扱うことである。 我々は、コンセプトの要求事項の一部であるセマンティクス不変あるいは計算量保証を扱わない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating-example&#34; name=&#34;motivating-example&#34;&gt;動機の例&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;テンプレート・ライブラリの不正な使用法と、その結果生じるエラーメッセージを例証するために単純なサンプルを示す。 下記のコードでは、標準テンプレート・ライブラリー (STL) のジェネリックな &lt;code&gt;std::stable_sort()&lt;/code&gt; アルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibiography.html#generic-programming-and-the-stl&#34;&gt;3&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#stl-tutorial-and-reference-guide&#34;&gt;4&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#the-standard-template-library&#34;&gt;5&lt;/a&gt;] をリンクリストに適用している。&lt;/p&gt;
&lt;p&gt;bad_error_eg.cpp:&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;list&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main(int, char*[]) {
    std::list&amp;lt;int&amp;gt; v;
    std::stable_sort(v.begin(), v.end());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;この場合、&lt;code&gt;std::stable_sort()&lt;/code&gt; アルゴリズムは以下のようなプロトタイプを有する：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIterator first, RandomAccessIterator last);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Gnu C++ でこのコードをコンパイルすると、以下のコンパイラ・エラーを生成する。他のコンパイラ出力は Appendix にリストしてある(訳注 : このバージョンのドキュメントには記載されていない)。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;stl_algo.h: In function `void __merge_sort_loop&amp;lt;_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;,
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int)&#39;:
stl_algo.h:1448:   instantiated from `__merge_sort_with_buffer
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(
   _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;,
   int *, int *)&#39;
stl_algo.h:1485:   instantiated from `__stable_sort_adaptive&amp;lt;
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt;, _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int)&#39;
stl_algo.h:1524:   instantiated from here
stl_algo.h:1377: no match for `_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp; -
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;この場合、根本的なエラーの原因は、&lt;code&gt;std:list::iterator&lt;/code&gt; が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; コンセプトをモデル化していないことにある。 リストのイテレータは双方向でしかなく、(ベクタのイテレータのように) 完全なランダム・アクセスが可能なわけではない。 残念ながら、このエラーメッセージには、ユーザーにこの事実を示すものは何もない。&lt;/p&gt;
&lt;p&gt;C++ プログラマがテンプレート・ライブラリに十分な経験を持っていれば、この手のエラーに惑うことは無いかもしれない。 しかし未熟な者にとっては、次のような理由で、このメッセージが理解し難いものとなっている。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;エラーが生じる位置、bad_error_eg.cpp の６行目は、Gnu C++ がインスタンス化スタックを４レベルも深くまで探索して表示するという事実にもかかわらず、エラーメッセージで示されていない。&lt;/li&gt;
&lt;li&gt;エラーメッセージと、&lt;code&gt;std::stable_sort()&lt;/code&gt; および &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; に関する文書化された要求事項との間に、文面上の相関がない。&lt;/li&gt;
&lt;li&gt;エラーメッセージが過度に長く、ユーザーの知らない(かつ知るべきでない！) STL 内部実装用の関数がリストされている。&lt;/li&gt;
&lt;li&gt;エラーメッセージに、ライブラリ内部の実装用関数が数多くリストアップされているため、プログラマが、エラーの原因は自分のコードではなくライブラリ側にあるとの結論に、誤って飛びついてしまう可能性がある。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;次の例示は、より有用なメッセージとして斯くあるべきと我々が考えるものだ (また実際に Boost コンセプト・チェック・ライブラリが生成するものでもある)。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;boost/concept_check.hpp: In method `void LessThanComparableConcept
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;::constraints()&#39;:
boost/concept_check.hpp:334:   instantiated from `RandomAccessIteratorConcept
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;::constraints()&#39;
bad_error_eg.cpp:6:   instantiated from `stable_sort&amp;lt;_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;(_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, 
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;)&#39;
boost/concept_check.hpp:209: no match for `_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;
  &amp;lt; _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このメッセージは、標準的なエラー・メッセージがもつ欠点をいくつかの点で改善する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エラーの生じた位置 (bad_error_eg.cpp:6）がエラーメッセージに明示されている。&lt;/li&gt;
&lt;li&gt;メッセージは、STL 文書に記述されているコンセプト (&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;RandomAccessIterator&lt;/a&gt;) を明示的に言及している。&lt;/li&gt;
&lt;li&gt;エラーメッセージははるかに短くなり、STL の内部実装用関数を露呈しない。&lt;/li&gt;
&lt;li&gt;エラーメッセージの中に concept_check.hpp および &lt;code&gt;constraints()&lt;/code&gt; が示されることで、ライブラリ実装の中にではなくユーザーのコードにエラーがあるという事実をユーザーに警告している。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#history&#34; name=&#34;history&#34;&gt;歴史&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このコンセプト・チェック・システムの初期バージョンは、著者が SGI において、C++ コンパイラおよびライブラリ・グループの一員として勤務している間に開発された。 初期バージョンは今も SGI STL ディストリビューションの一部である。 Boost コンセプト・チェック・ライブラリは、エラーメッセージにおけるそれほど有用でない表現能力を犠牲にして、コンセプト・チェック用クラス定義を非常に単純化しており、その点で SGI STLのコンセプト・チェックとは異なっている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#publications&#34; name=&#34;publications&#34;&gt;公開資料&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oonumerics.org/tmpw00/&#34; target=&#34;_blank&#34;&gt;C++ テンプレート・ワークショップ2000&lt;/a&gt;、コンセプト・チェック。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;インスタンス化を引き起こすために関数ポインタを使用するアイディアは、Alexander Stepanov に拠る。 テンプレートの事前チェックに式を使用するアイディアに関して、その起源を確認できなかった。しかし、それは D&amp;amp;E[&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#design-and-evolution&#34;&gt;2&lt;/a&gt;] に記載されている。 STL コンセプトに関する優れた文書化と構造化を行った Matt Austern に感謝をささげる。このコンセプト・チェックは彼の仕事を基礎にしている。 有益なコメントとレビューを賜った Boost のメンバにも感謝を。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;次へ：「コンセプト・チェックの利用」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bind.hpp -- compose.mdへのリンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/bind.html"/>
      <id>9bd72665f2b7ecc8db14bfd0beeab602a9fdd366:archive/boost_docs/libs/bind.md</id>
      <updated>2015-01-16 23:46:46 +0900</updated>
      
        <content type="html">&lt;h1&gt;bind.hpp&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/bind/bind.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/bind/bind.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#purpose&#34;&gt;目的&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-function-and-function-pointer&#34;&gt;関数と関数ポインタに対して&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-function-object&#34;&gt;関数オブジェクトに対して&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-pointer-to-member&#34;&gt;メンバへのポインタに対して&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-nested-binds-for-function-composition&#34;&gt;関数合成のために入れ子の&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#examples&#34;&gt;コード例&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-standard-algorithms&#34;&gt;標準アルゴリズムに対して&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-boost-function&#34;&gt;Boost.Functionと&lt;code&gt;bind&lt;/code&gt;を組み合わせて使用する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#limitation&#34;&gt;制限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#frequently-asked-questions&#34;&gt;よくある質問と回答&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#why-doesnt-this-compile&#34;&gt;どうしてコンパイルできない？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#why-does-this-compile&#34;&gt;どうしてコンパイルできちゃう？ エラーになる筈なのに。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#what-is-the-difference-between-bind-and-bind-r&#34;&gt;&lt;code&gt;bind(f, ...)&lt;/code&gt; と &lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt; はどう違う？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-win-api&#34;&gt;bind は Windows の API 関数に対して使える？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-com-methods&#34;&gt;bind は COM のメソッドに使える？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-mac-toolbox&#34;&gt;bind は Mac の Toolbox 関数に使える？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-extern-c-functions&#34;&gt;bind は extern &#34;C&#34; な関数に使える？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#why-doesnt-bind-automatically-recognize-nonstd-functions&#34;&gt;どうして bind は非標準の関数を自動的に認識しない？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#troubleshooting&#34;&gt;トラブルシューティング&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#incorrect-number-of-arguments&#34;&gt;引数の数が不正&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#function-object-cannot-be-called-with-the-specified-arguments&#34;&gt;関数オブジェクトは指定された引数とともに呼び出すことはできない&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#access-arg-does-not-exist&#34;&gt;存在しない引数へのアクセス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#inappropriate-use-of-bind&#34;&gt;&lt;code&gt;bind(f, ...)&lt;/code&gt; の不適切な使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#inappropriate-use-of-bind-r&#34;&gt;&lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt; の不適切な使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#binding-a-nonstd-function&#34;&gt;非標準の関数を束縛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#const-in-signatures&#34;&gt;シグネチャが const を含む&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MSVC specific: using boost::bind;&lt;/li&gt;
&lt;li&gt;MSVC specific: class templates shadow function templates&lt;/li&gt;
&lt;li&gt;MSVC specific: ... in signatures treated as type&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interface&lt;ul&gt;
&lt;li&gt;Synopsis&lt;/li&gt;
&lt;li&gt;Common requirements&lt;/li&gt;
&lt;li&gt;Common definitions&lt;/li&gt;
&lt;li&gt;bind&lt;/li&gt;
&lt;li&gt;Additional overloads&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation&lt;ul&gt;
&lt;li&gt;Files&lt;/li&gt;
&lt;li&gt;Dependencies&lt;/li&gt;
&lt;li&gt;Number of Arguments&lt;/li&gt;
&lt;li&gt;&#34;&lt;strong&gt;stdcall&#34;, &#34;&lt;/strong&gt;fastcall&#34;, and &#34;pascal&#34; Support&lt;/li&gt;
&lt;li&gt;Using the BOOST_BIND macro&lt;/li&gt;
&lt;li&gt;visit_each support&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Acknowledgements&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#purpose&#34; name=&#34;purpose&#34;&gt;目的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::bind&lt;/code&gt; は標準ライブラリの関数 &lt;code&gt;std::bind1st&lt;/code&gt; および &lt;code&gt;std::bind2nd&lt;/code&gt; を汎用化したものである。 関数オブジェクトだけでなく、関数や関数へのポインタ、メンバ関数へのポインタをサポートし、任意の引数を特定の値に束縛したり、入力引数を、もとの順番に関係なく自由な位置に移し替えることができる。 &lt;code&gt;bind&lt;/code&gt; が扱うことのできる関数オブジェクトには、特別な条件はない。 特に、標準関数が要求する &lt;code&gt;typedef result_type&lt;/code&gt; や &lt;code&gt;first_argument_type&lt;/code&gt; および &lt;code&gt;second_argument_type&lt;/code&gt; は必須ではない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【訳注：このような関数を一般に「バインダ」または「束縛子」と呼ぶ。】&lt;/li&gt;
&lt;li&gt;【訳注：「入力引数」とは、&lt;code&gt;bind&lt;/code&gt; によって生成された関数オブジェクトを呼び出す時に渡される引数。例えば、&lt;code&gt;bind(f, _1, 5)(x)&lt;/code&gt; における &lt;code&gt;x&lt;/code&gt; のこと。】&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-function-and-function-pointer&#34; name=&#34;using-bind-with-function-and-function-pointer&#34;&gt;関数と関数ポインタに対して&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以下の関数が定義されているとき、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; b)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; b;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; b, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; c)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; b &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; c;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind(f, 1, 2)&lt;/code&gt; は &#34;nullary&#34; (無項)、つまり引数をとらない関数オブジェクトを生成する。これを評価すると &lt;code&gt;f(1, 2)&lt;/code&gt; を返す。 同様に、&lt;code&gt;bind(g, 1, 2, 3)()&lt;/code&gt; は &lt;code&gt;g(1, 2, 3)&lt;/code&gt; と等価である。&lt;/p&gt;
&lt;p&gt;【訳注：&#34;nullary&#34; は boost の造語のようで、「いくつかの邪悪な提案のうち、いちばんマシ」として選ばれたとの記述が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose ライブラリのコメント&lt;/a&gt; にある。】&lt;/p&gt;
&lt;p&gt;引数のうちいくつかだけを、選択的に束縛することもできる。 例えば、&lt;code&gt;bind(f, _1, 5)(x)&lt;/code&gt; は &lt;code&gt;f(x, 5)&lt;/code&gt; と等価である。 ここで、&lt;code&gt;_1&lt;/code&gt; は「最初の入力引数によって置き換えられる」ことを意味するプレースホルダである。&lt;/p&gt;
&lt;p&gt;【訳注：残念ながら、&lt;code&gt;bind(f, _1, 5)(10)&lt;/code&gt; のように、入力引数にリテラルを渡すことはできない。詳しくは、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#limitation&#34;&gt;制限の項&lt;/a&gt; を参照。】&lt;/p&gt;
&lt;p&gt;比較のため、同じ操作を標準ライブラリのプリミティブを使って書くとこうなる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ptr_fun(f), &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;)(x);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; は &lt;code&gt;std::bind1st&lt;/code&gt; の機能もカバーしている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind1st(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ptr_fun(f), &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;)(x);   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// f(5, x)&lt;/span&gt;
bind(f, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;, _1)(x);                     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// f(5, x)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; は二つ以上の引数を持つ関数を扱うことができる。 また、引数の置き換え機能はより一般化されている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;bind(f, _2, _1)(x, y);                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// f(y, x)&lt;/span&gt;
bind(g, _1, &lt;span style=&#34;color: #666666&#34;&gt;9&lt;/span&gt;, _1)(x);                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// g(x, 9, x)&lt;/span&gt;
bind(g, _3, _3, _3)(x, y, z);          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// g(z, z, z)&lt;/span&gt;
bind(g, _1, _1, _1)(x, y, z);          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// g(x, x, x)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最後の例で、&lt;code&gt;bind(g, _1, _1, _1)&lt;/code&gt; が生成する関数オブジェクトは入力引数を一つしか受け取らないにも関わらず、複数の引数を付けて呼び出せることに注意。 このように、余分な引数は黙って無視され、エラーにはならない。 同様に、三番目の例では最初の引数 &lt;code&gt;x&lt;/code&gt; と二番目の引数 &lt;code&gt;y&lt;/code&gt; は無視される。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; に渡される引数はコピーされ、生成された関数オブジェクトの内部に保持される。 例えば、以下のコードでは、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;;
bind(f, i, _1);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt; の値のコピーが関数オブジェクトに格納される。 コピーではなく参照を関数オブジェクトに格納したい場合には、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html&#34;&gt;&lt;code&gt;boost::ref&lt;/code&gt;&lt;/a&gt; および &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html&#34;&gt;&lt;code&gt;boost::cref&lt;/code&gt;&lt;/a&gt; を使う必要がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;;
bind(f, ref(i), _1);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;【訳注：詳しくは、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/ref.html&#34;&gt;&lt;code&gt;ref&lt;/code&gt; のドキュメント&lt;/a&gt;を参照。】&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-function-object&#34; name=&#34;using-bind-with-function-object&#34;&gt;関数オブジェクトに対して&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; は通常の関数だけでなく、任意の関数オブジェクトを受け付ける。 一般的には（標準 C++ には &lt;code&gt;typeof&lt;/code&gt; 演算子がなく、戻り型を推論できないため）、生成される関数オブジェクトの &lt;code&gt;operator()&lt;/code&gt; の戻り型を以下のように明示的に指定する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; F
{
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; b) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; b; }
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #B00040&#34;&gt;long&lt;/span&gt; a, &lt;span style=&#34;color: #B00040&#34;&gt;long&lt;/span&gt; b) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; b; }
};

F f;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;104&lt;/span&gt;;

bind&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(f, _1, _1)(x);        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// f(x, x) つまり、ゼロ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;関数オブジェクトが &lt;code&gt;result_type&lt;/code&gt; という名前の入れ子の型を開示している場合、戻り型を明示的に書く必要はない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;nt x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;8&lt;/span&gt;;

bind(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;less&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(), _1, &lt;span style=&#34;color: #666666&#34;&gt;9&lt;/span&gt;)(x);   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// x &amp;lt; 9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;【注意：戻り型を省略する機能は、コンパイラによっては利用できない場合がある。】&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-pointer-to-member&#34; name=&#34;using-bind-with-pointer-to-member&#34;&gt;メンバへのポインタに対して&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;メンバ関数へのポインタやデータメンバへのポインタは &lt;code&gt;operator()&lt;/code&gt; を持たないので、関数オブジェクトではない。 しかし、それでは不便なので、&lt;code&gt;bind&lt;/code&gt; は最初の引数としてメンバへのポインタも受け付ける。 この場合、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;&lt;code&gt;boost::mem_fn&lt;/code&gt;&lt;/a&gt; によってメンバへのポインタが関数オブジェクトに変換されて渡されたかのように振る舞う。 すなわち、式&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f, &lt;i&gt;args&lt;/i&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;は以下の式と等価である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;bind&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f), &lt;i&gt;args&lt;/i&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここで、&lt;code&gt;R&lt;/code&gt; は &lt;code&gt;X::f&lt;/code&gt; の戻り型（メンバ関数の場合）、またはメンバの型への &lt;code&gt;const&lt;/code&gt; な参照（データメンバの場合）である。&lt;/p&gt;
&lt;p&gt;【注意：&lt;code&gt;mem_fn&lt;/code&gt; が生成する関数オブジェクトを呼び出す際には、最初の引数としてオブジェクトのポインタ、参照またはスマートポインタを渡す。 詳しくは、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;&lt;code&gt;mem_fn&lt;/code&gt; のドキュメント&lt;/a&gt;を参照。】&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X
{
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; f(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; a);
};

X x;

shared_ptr&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; X);

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;;

bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f, ref(x), _1)(i);     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// x.f(i)&lt;/span&gt;
bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f, &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;x, _1)(i);         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (&amp;amp;x)-&amp;gt;f(i)&lt;/span&gt;
bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f, x, _1)(i);          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (x の内部的なコピー).f(i)&lt;/span&gt;
bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f, p, _1)(i);          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (p の内部的なコピー)-&amp;gt;f(i)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;最後の二つの例は「自己充足な」関数オブジェクトを生成する興味深い例である。 &lt;code&gt;bind(&amp;amp;X::f, x, _1)&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; のコピーを保持する。 &lt;code&gt;bind(&amp;amp;X::f, p, _1)&lt;/code&gt; は &lt;code&gt;p&lt;/code&gt; のコピーを保持し、&lt;code&gt;p&lt;/code&gt; が &lt;code&gt;boost::shared_ptr&lt;/code&gt; であるため、関数オブジェクトは &lt;code&gt;X&lt;/code&gt; のインスタンスへの参照を持ち、それは &lt;code&gt;p&lt;/code&gt; のスコープを抜けたり &lt;code&gt;reset()&lt;/code&gt; されたりしても有効である。&lt;/p&gt;
&lt;p&gt;【訳注：つまり、&lt;code&gt;bind&lt;/code&gt; の最初の引数がメンバ関数へのポインタである場合、次の引数はそのメンバ関数を持つクラスまたは派生クラスのオブジェクトまたはポインタ、&lt;code&gt;ref()&lt;/code&gt;、スマートポインタでなければならない。】&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-nested-binds-for-function-composition&#34; name=&#34;using-nested-binds-for-function-composition&#34;&gt;関数合成のために入れ子の&lt;code&gt;bind&lt;/code&gt;を使用する&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; に渡される引数のうちいくつかは、それ自体が &lt;code&gt;bind&lt;/code&gt; の入れ子になった式でもよい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;bind(f, bind(g, _1))(x);               &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// f(g(x))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; によって生成された関数オブジェクトを呼び出す時には、外側の &lt;code&gt;bind&lt;/code&gt; 式が呼ばれる前に内側の &lt;code&gt;bind&lt;/code&gt; 式が、複数ある場合は順不同で評価される。 次に、その結果は外側の &lt;code&gt;bind&lt;/code&gt; が評価される際の引数として渡される。 上の例で、関数オブジェクトが引数リスト &lt;code&gt;(x)&lt;/code&gt; とともに呼び出される場合、&lt;code&gt;bind(g, _1)(x)&lt;/code&gt; がまず評価されて &lt;code&gt;g(x)&lt;/code&gt; となり、次に &lt;code&gt;bind(f, g(x))(x)&lt;/code&gt; が評価され、最終的な結果は &lt;code&gt;f(g(x))&lt;/code&gt; となる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; のこの機能は、関数を合成するために使用することができる。 詳しくは、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind/bind_as_compose.cpp.html&#34;&gt;&lt;code&gt;bind_as_compose.cpp&lt;/code&gt;&lt;/a&gt; に &lt;code&gt;bind&lt;/code&gt; を使って &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;Boost.Compose&lt;/a&gt; と同様の効果を得るサンプルがあるので、それを参照のこと。&lt;/p&gt;
&lt;p&gt;ただし、（&lt;code&gt;bind&lt;/code&gt; 関数の）最初の引数、つまり束縛される関数オブジェクトは、評価されないので注意すること。 特に、関数オブジェクトが &lt;code&gt;bind&lt;/code&gt; で生成されたものや、プレースホルダ引数の場合でも評価されないので、次の例は期待通りには動かない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;pf)(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;pf&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), bind(_1, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;【訳注：動かないというか、コンパイルできない。】&lt;/p&gt;
&lt;p&gt;期待通りの結果を得るには、ヘルパ関数オブジェクト &lt;code&gt;apply&lt;/code&gt; を使用する必要がある。 &lt;code&gt;apply&lt;/code&gt; はその最初の引数である関数オブジェクトを、残りの引数リストに対して適用する。 &lt;code&gt;apply&lt;/code&gt; 関数は &lt;code&gt;boost/bind/apply.hpp&lt;/code&gt; ヘッダファイルに定義されている。 上の例は、この &lt;code&gt;apply&lt;/code&gt; を使って次のように書き直せばよい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;pf)(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;pf&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), bind(apply&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(), _1, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;時には、最初の引数だけでなく、入れ子になった &lt;code&gt;bind&lt;/code&gt; 部分式であるような他の引数を評価したくない場合もある。 この場合は、別のヘルパ関数 &lt;code&gt;protect&lt;/code&gt; を使用するとよい。 これにより、引数の型がマスクされ、&lt;code&gt;bind&lt;/code&gt; が認識されず、評価されない。 呼び出し時には、&lt;code&gt;protect&lt;/code&gt; は単純に引数リストを他の関数オブジェクトのそのまま渡す。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;protect&lt;/code&gt; 関数は &lt;code&gt;boost/bind/protect.hpp&lt;/code&gt; ヘッダに含まれている。 &lt;code&gt;bind&lt;/code&gt; 関数オブジェクトを評価されないように保護するには、&lt;code&gt;protect(bind(f, ...))&lt;/code&gt; と書けばよい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#examples&#34; name=&#34;examples&#34;&gt;コード例&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-standard-algorithms&#34; name=&#34;using-bind-with-standard-algorithms&#34;&gt;標準アルゴリズムと&lt;code&gt;bind&lt;/code&gt;を組み合わせて使用する&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;image&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;animation&lt;/span&gt;
{
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;

    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; advance(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; ms);
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; inactive() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; render(image &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; target) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;animation&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; anims;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; erase_if(C &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; c, P pred)
{
    c.erase(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;remove_if(c.begin(), c.end(), pred), c.end());
}

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; update(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; ms)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(anims.begin(), anims.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;animation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;advance, _1, ms));
    erase_if(anims, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;animation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;inactive));
}

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; render(image &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; target)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(anims.begin(), anims.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;animation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;render, _1, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ref(target)));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-boost-function&#34; name=&#34;using-bind-with-boost-function&#34;&gt;Boost.Functionと&lt;code&gt;bind&lt;/code&gt;を組み合わせて使用する&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;button&lt;/span&gt;
{
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;

    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; onClick;
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;player&lt;/span&gt;
{
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;

    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; play();
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;stop&lt;/span&gt;();
};

button playButton, stopButton;
player thePlayer;

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;connect&lt;/span&gt;()
{
    playButton.onClick &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;player&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;play, &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;thePlayer);
    stopButton.onClick &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;player&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;stop, &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;thePlayer);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#limitation&#34; name=&#34;limitation&#34;&gt;制限&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; が生成する関数オブジェクトは、引数を参照渡しで受け取る。このため、&lt;code&gt;const&lt;/code&gt; でない一時オブジェクトやリテラル定数を受け取ることはできない。 これは、C++ 言語自体の制約であり、「転送する関数の問題（？）」として知られている。&lt;/p&gt;
&lt;p&gt;任意の型の引数を受け取り、それらをそのまま渡すために、&lt;code&gt;bind&lt;/code&gt; ライブラリでは、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;という形式のシグネチャを（訳注：仮引数に）使っている。 上記のように、この方法は &lt;code&gt;const&lt;/code&gt; でない右辺値には使えない。&lt;/p&gt;
&lt;p&gt;この問題に対して、次のようにオーバーロードを追加する「解決策」がよく提案される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;残念ながら、この方法は (a) 引数が 9 つある場合、512 ものオーバーロードを提供する必要があり、(b) 引数が &lt;code&gt;const&lt;/code&gt; である場合、シグネチャが全く同じであるために半順序（？）を定義できず、左辺値にも右辺値にもうまく働かない。&lt;/p&gt;
&lt;p&gt;【注意：これは C++ 言語の暗い隅（？）であり、該当する問題はまだ解決されていない。】&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#frequently-asked-questions&#34; name=&#34;frequently-asked-questions&#34;&gt;よくある質問と回答&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#why-doesnt-this-compile&#34; name=&#34;why-doesnt-this-compile&#34;&gt;どうしてコンパイルできない？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#troubleshooting&#34;&gt;トラブルシューティング&lt;/a&gt; の項を参照。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#why-does-this-compile&#34; name=&#34;why-does-this-compile&#34;&gt;どうしてコンパイルできちゃう？ エラーになる筈なのに。&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;おそらく、&lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt; という汎用の構文を使っているためであろう。この書き方は、&lt;code&gt;bind&lt;/code&gt; に対して &lt;code&gt;f&lt;/code&gt; の引数の数や戻り型に関するエラーチェックをしないように指示するものである。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#what-is-the-difference-between-bind-and-bind-r&#34; name=&#34;what-is-the-difference-between-bind-and-bind-r&#34;&gt;&lt;code&gt;bind(f, ...)&lt;/code&gt; と &lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt; はどう違う？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最初の形式は &lt;code&gt;bind&lt;/code&gt; に &lt;code&gt;f&lt;/code&gt; の型を調べて、引数の数や戻り型を解決するように指示する。 引数の数の間違いは「バインド時」に検出される。 この構文はもちろん、&lt;code&gt;f&lt;/code&gt; に対していくつかのことを要求する。 つまり、&lt;code&gt;f&lt;/code&gt; は関数、関数ポインタ、メンバ関数へのポインタのいずれかであるか、関数オブジェクトの場合には &lt;code&gt;result_type&lt;/code&gt; という入れ子の型を定義する必要がある。簡単に言えば、&lt;code&gt;bind&lt;/code&gt; が認識できるものでなければならない。&lt;/p&gt;
&lt;p&gt;二番目の形式は &lt;code&gt;bind&lt;/code&gt; に &lt;code&gt;f&lt;/code&gt; の型を識別しないように指示する。 これは一般的には、&lt;code&gt;result_type&lt;/code&gt; を開示しない、あるいはできない関数オブジェクトとともに用いられるが、その他に非標準の関数に対しても用いることができる。 たとえば、現在の実装は &lt;code&gt;printf&lt;/code&gt; のような可変引数の関数を自動的に認識しないため、&lt;code&gt;bind&amp;lt;int&amp;gt;(printf, ...)&lt;/code&gt; と書く必要がある。&lt;/p&gt;
&lt;p&gt;【訳注：「非標準」は原文では nonstandard だが、printf が「非標準」というのは変だなぁ。】&lt;/p&gt;
&lt;p&gt;他に考慮すべき重要な点として、コンパイラがテンプレートの部分特殊化版や関数テンプレートの半順序（？）に対応していない場合、&lt;code&gt;f&lt;/code&gt; が関数オブジェクトであれば最初の形式は扱えず、また、&lt;code&gt;f&lt;/code&gt; が関数（ポインタ）やメンバ関数へのポインタであれば二番目の形式は扱えないことが多い。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-win-api&#34; name=&#34;does-bind-work-with-win-api&#34;&gt;bind は Windows の API 関数に対して使える？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい、&lt;code&gt;#define BOOST_BIND_ENABLE_STDCALL&lt;/code&gt; すれば。 または、目的の関数を &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-function-object&#34;&gt;generic function object&lt;/a&gt; として扱って、&lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt; の構文を使っても良い。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-com-methods&#34; name=&#34;does-bind-work-with-com-methods&#34;&gt;bind は COM のメソッドに使える？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい、&lt;code&gt;#define BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; すれば。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-mac-toolbox&#34; name=&#34;does-bind-work-with-mac-toolbox&#34;&gt;bind は Mac の Toolbox 関数に使える？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい、&lt;code&gt;#define BOOST_BIND_ENABLE_PASCAL&lt;/code&gt; すれば。 または、目的の関数を &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-function-object&#34;&gt;generic function object&lt;/a&gt; として扱って、&lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt; の構文を使っても良い。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-extern-c-functions&#34; name=&#34;does-bind-work-with-extern-c-functions&#34;&gt;bind は extern &#34;C&#34; な関数に使える？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;場合による。 いくつかのプラットフォームでは、&lt;code&gt;extern &#34;C&#34;&lt;/code&gt; な関数へのポインタは「通常の」関数ポインタと等価であり、問題なく動く。 他のプラットフォームでは、それらは別物として扱われる。 プラットフォーム固有の &lt;code&gt;bind&lt;/code&gt; の実装があれば、問題を透過的に解決できることが期待されるが、この実装はそうなっていない。 いつものように、回避策は目的の関数を &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#using-bind-with-function-object&#34;&gt;generic function object&lt;/a&gt; として扱って、&lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt; の構文を使うことである。&lt;/p&gt;
&lt;p&gt;【訳注：「この実装」とあるが、このドキュメントは &lt;code&gt;bind&lt;/code&gt; の仕様を定義するもので、附属の実装は「サンプル実装」という位置付けで書かれているものと思われる。（？）】&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#why-doesnt-bind-automatically-recognize-nonstd-functions&#34; name=&#34;why-doesnt-bind-automatically-recognize-nonstd-functions&#34;&gt;どうして bind は非標準の関数を自動的に認識しない？&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;特定のベンダに縛られることを防ぐために、非標準の拡張は一般的にデフォルトでオフにすべきである。 もしも&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html##does-bind-work-with-win-api&#34;&gt;固有のマクロ&lt;/a&gt;が自動的に定義されたら、そのつもりがないのにそれらの機能を使ってしまい、知らない間に互換性を損なってしまう危険性がある。 また、いくつかのコンパイラは &lt;code&gt;__stdcall (__fastcall)&lt;/code&gt; をデフォルトの呼び出し規約とするオプションを用意しており、特別なサポートは必要ない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#troubleshooting&#34; name=&#34;troubleshooting&#34;&gt;トラブルシューティング&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#incorrect-number-of-arguments&#34; name=&#34;incorrect-number-of-arguments&#34;&gt;引数の数が不正(Incorrect number of arguments)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;式 &lt;code&gt;bind(f, a1, a2, ..., aN)&lt;/code&gt; において、関数オブジェクト &lt;code&gt;f&lt;/code&gt; はちょうど &lt;code&gt;N&lt;/code&gt; 個の引数を取らなければならない。 このエラーは、通常「バインド時」に検出される。すなわち、&lt;code&gt;bind()&lt;/code&gt; を呼び出している行に対してコンパイルエラーが報告される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// エラー、f は二つの引数を取る&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このエラーの変種として、メンバ関数に対する暗黙の「&lt;code&gt;this&lt;/code&gt;」引数を忘れることも多い。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X
{
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; f(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// エラー、X::f は二つの引数を取る&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f, _1, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;【訳注：&lt;code&gt;bind&lt;/code&gt; では、メンバ関数へのポインタは、通常の引数の前に暗黙の「&lt;code&gt;this&lt;/code&gt;」引数をとるものとみなす。】&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#function-object-cannot-be-called-with-the-specified-arguments&#34; name=&#34;function-object-cannot-be-called-with-the-specified-arguments&#34;&gt;関数オブジェクトは指定された引数とともに呼び出すことはできない(The function object cannot be called with the specified arguments)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通常の関数呼び出しと同様、束縛される関数オブジェクトは引数リストと互換性を持つ必要がある。 非互換性は、通常コンパイラによって「呼び出し時」に検出され、&lt;code&gt;bind.hpp&lt;/code&gt; の次のような行に対するエラーとなる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;    return f(a[a1_], a[a2_]);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;An example of this kind of error:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;incompatible&#34;&lt;/span&gt;);      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK、呼び出さないので&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;incompatible&#34;&lt;/span&gt;)();    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// エラー、&#34;incompatible&#34; は int ではない&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, _1);                  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, _1)(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;incompatible&#34;&lt;/span&gt;);  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// エラー、&#34;incompatible&#34; は int ではない&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#access-arg-does-not-exist&#34; name=&#34;access-arg-does-not-exist&#34;&gt;存在しない引数へのアクセス(Accessing an argument that does not exist)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;プレースホルダ &lt;code&gt;_N&lt;/code&gt; は引数リストの &lt;code&gt;N&lt;/code&gt; 番目の引数を、「呼び出し時」に選択する。 当然、引数リストの範囲外のものにアクセスしようとすればエラーになる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;);

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, _1);                  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, _1)();                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// エラー、一番目の引数は存在しない&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このエラーは、通常 &lt;code&gt;bind.hpp&lt;/code&gt; の次のような行に対して報告される。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;    return f(a[a1_]);
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::bind1st(f, a)&lt;/code&gt; の代わりに使う場合、&lt;code&gt;bind(f, a, _1)&lt;/code&gt; ではなく間違って &lt;code&gt;bind(f, a, _2)&lt;/code&gt; としてしまうことも多い。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#inappropriate-use-of-bind&#34; name=&#34;inappropriate-use-of-bind&#34;&gt;&lt;code&gt;bind(f, ...)&lt;/code&gt; の不適切な使用(Inappropriate use of &lt;code&gt;bind(f, ...)&lt;/code&gt;)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bind(f, a1, a2, ..., aN)&lt;/code&gt; の&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#what-is-the-difference-between-bind-and-bind-r&#34;&gt;形式&lt;/a&gt;は &lt;code&gt;f&lt;/code&gt; を自動的に認識させる。 これは、任意の関数オブジェクトに対して働くわけではない。&lt;code&gt;f&lt;/code&gt; は関数またはメンバ関数へのポインタでなければならない。&lt;/p&gt;
&lt;p&gt;この形式を &lt;code&gt;result_type&lt;/code&gt; を定義する関数オブジェクトに使えるのは、部分特殊化版や半順序（？）をサポートしているコンパイラに限られる。 特に、MSVC のバージョン 7.0 までは、関数オブジェクトに対するこの構文はサポートしない。&lt;/p&gt;
&lt;p&gt;【訳注：原文では MSVC up to version 7.0 となっているが、これは 7.0 を含むのだろうか？】&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#inappropriate-use-of-bind-r&#34; name=&#34;inappropriate-use-of-bind-r&#34;&gt;&lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt; の不適切な使用(Inappropriate use of &lt;code&gt;bind&amp;lt;R&amp;gt;(f, ...)&lt;/code&gt;)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bind&amp;lt;R&amp;gt;(f, a1, a2, ..., aN)&lt;/code&gt;の&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#what-is-the-difference-between-bind-and-bind-r&#34;&gt;形式&lt;/a&gt;は、任意の関数オブジェクトをサポートする。&lt;/p&gt;
&lt;p&gt;この形式を、(推奨はしないが)関数もしくメンバ関数ポインタに使えるのは、半順序をサポートしているコンパイラに限られる。特に、MSVC のバージョン 7.0 までは、関数とメンバ関数ポインタに対するこの構文はサポートしない。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#binding-a-nonstd-function&#34; name=&#34;binding-a-nonstd-function&#34;&gt;非標準の関数を束縛(Binding a nonstandard function)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;デフォルトでは、&lt;code&gt;bind(f, a1, a2, ..., aN)&lt;/code&gt; の&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#what-is-the-difference-between-bind-and-bind&#34;&gt;形式&lt;/a&gt;は、「通常」のC++関数と関数ポインタのみを受け入れる。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-win-api&#34;&gt;関数が異なる呼び出し規約を使っていたり&lt;/a&gt;、&lt;code&gt;std::printf&lt;/code&gt;のような可変引数の関数では、動作しない。汎用的な&lt;code&gt;bind&amp;lt;R&amp;gt;(f, a1, a2, ..., aN)&lt;/code&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#what-is-the-difference-between-bind-and-bind-r&#34;&gt;形式&lt;/a&gt;なら、そのような非標準関数に対しても動作する。&lt;/p&gt;
&lt;p&gt;いくつかのプラットフォームでは、&lt;code&gt;extern &#34;C&#34;&lt;/code&gt;の付いた&lt;code&gt;stdcmp&lt;/code&gt;のような関数は、短い形式の&lt;code&gt;bind&lt;/code&gt;では動作しない。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-win-api&#34;&gt;&#34;&lt;code&gt;__stdcall&lt;/code&gt;&#34;&lt;/a&gt;や&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#does-bind-work-with-mac-toolbox&#34;&gt;&#34;&lt;code&gt;pascal&lt;/code&gt;&#34;&lt;/a&gt;のサポートを参照。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html#const-in-signatures&#34; name=&#34;const-in-signatures&#34;&gt;シグネチャが const を含む(const in signatures)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;MSVC 6.0やBorland C++ 5.5.1を含むいくつかのプラットフォームでは、関数のシグニチャがトップレベルの&lt;code&gt;const&lt;/code&gt;を持っていることが問題になる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(f, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// エラー&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;回避策は、引数の形式から&lt;code&gt;const&lt;/code&gt;修飾を削除することだ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;以下、未翻訳。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2001, 2002 by Peter Dimov and Multi Media Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>template_page.md -- 逆引きリファレンスのテンプレートページは、いらなくなったので削除。(#29)</title>
      <link href="http://boostjp.github.io/tips/template_page.html"/>
      <id>4f43989f90a40a06b2cb0db8b466743047ec67cb:tips/template_page.md</id>
      <updated>2015-01-16 23:43:03 +0900</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/tips/template_page.md b/tips/template_page.md
deleted file mode 100644
index 41df4ff..0000000
--- a/tips/template_page.md
+++ /dev/null
@@ -1,39 +0,0 @@
-#テンプレートページ
-逆引きリファレンスを書く上での、雛型と、Google Sitesの使い方を説明します。
-まず、ページの先頭に概要を書いてください。
-
-目次は、メニューから「挿入」→「目次」を選択してください。
-書式設定で「見出しN」を付けられた項目が自動的に目次になります。
-
-
-Contents
-&amp;lt;ol class=&amp;#39;goog-toc&amp;#39;&amp;gt;&amp;lt;li class=&amp;#39;goog-toc&amp;#39;&amp;gt;[&amp;lt;strong&amp;gt;1 &amp;lt;/strong&amp;gt;項目](#TOC--)&amp;lt;/li&amp;gt;&amp;lt;/ol&amp;gt;
-
-
-
-&amp;lt;h4&amp;gt;項目&amp;lt;/h4&amp;gt;項目は、メニューから「書式」→「準見出し(H4)」を選択して書式を設定します。
-
-ソースコードは、以下のようにプレーンテキストで記述し、
-
-#include &amp;lt;iostream&amp;gt;
-
-int main()
-{
-    std::cout &amp;lt;&amp;lt; &amp;#34;Hello&amp;#34; &amp;lt;&amp;lt; std::endl;}
-
-次に、そのコードを選択し、メニューから「書式」→「コードを引用」を選択します。
-
-```cpp
-#include &amp;lt;iostream&amp;gt;
-
-int main()
-{
-    std::cout &amp;lt;&amp;lt; &amp;#34;Hello&amp;#34; &amp;lt;&amp;lt; std::endl;}
-```
-
-するとコードが緑色になってしまうので、ソースコードを選択し、メニュー下の書式設定バーから「A▼」で黒を選択します。
-たまに緑色になったままになってしまうので、試行錯誤してください。
-ソースを張り付け直したりタブをスペースに直したり。
-
-HTMLソースを編集してしまうのも一つの手段でしょう。
-
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost逆引きリファレンス -- 逆引きリファレンスのテンプレートページは、いらなくなったので削除。(#29)</title>
      <link href="http://boostjp.github.io/tips.html"/>
      <id>d64886a398e2279738ea528b7729f56a762a1c36:tips.md</id>
      <updated>2015-01-16 23:42:46 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost逆引きリファレンス&lt;/h1&gt;
&lt;p&gt;逆引きリファレンスは、やりたいことから方法を調べるためのリファレンスです。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目次&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#data_structure&#34;&gt;データ構造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#concurrent_data_structure&#34;&gt;並行データ構造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#io&#34;&gt;入出力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#numeric&#34;&gt;数値演算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#string&#34;&gt;文字列操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#function&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#class&#34;&gt;クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#idiom&#34;&gt;イディオム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#memory&#34;&gt;メモリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#validation&#34;&gt;検証&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#process&#34;&gt;プロセス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#math&#34;&gt;数学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#compile_time&#34;&gt;コンパイル時処理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#concurrency&#34;&gt;並行処理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#network&#34;&gt;ネットワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#datetime&#34;&gt;日付・時間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#lang_binding&#34;&gt;言語バインディング&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#data_structure&#34; name=&#34;data_structure&#34;&gt;データ構造&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/array.html&#34;&gt;配列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multi_array.html&#34;&gt;多次元配列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/tuple.html&#34;&gt;タプル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/hashmap.html&#34;&gt;ハッシュ表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/graph.html&#34;&gt;グラフ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multi_index.html&#34;&gt;コンテナに複数の並び順を持たせる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/foreach.html&#34;&gt;for each文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/list.html&#34;&gt;リスト処理の遅延評価&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/dynamic_type.html&#34;&gt;動的型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/dynamic_bitset.html&#34;&gt;サイズを動的に変更できるビット集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/circular_buffer.html&#34;&gt;循環バッファ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/priority_sort.html&#34;&gt;優先順位を付けて並べ替える&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#concurrent_data_structure&#34; name=&#34;concurrent_data_structure&#34;&gt;並行データ構造&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lockfree-queue.html&#34;&gt;ロックフリーキュー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lockfree-stack.html&#34;&gt;ロックフリースタック&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#io&#34; name=&#34;io&#34;&gt;入出力&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/filesystem.html&#34;&gt;ファイル／ディレクトリ操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/serialize.html&#34;&gt;シリアライズ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/xml.html&#34;&gt;XMLの読み込み／書き込み&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/json.html&#34;&gt;JSONの読み込み／書き込み&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/ini.html&#34;&gt;iniファイルの読み込み／書き込み&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/memory_mapped_file.html&#34;&gt;メモリマップドファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/io_state.html&#34;&gt;ストリームの状態を戻す&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/logging.html&#34;&gt;ロギング&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#numeric&#34; name=&#34;numeric&#34;&gt;数値演算&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html&#34;&gt;多倍長整数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-float.html&#34;&gt;多倍長浮動小数点数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#string&#34; name=&#34;string&#34;&gt;文字列操作&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/string_algo.html&#34;&gt;文字列操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/format.html&#34;&gt;文字列フォーマット&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html&#34;&gt;構文解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/static_regex.html&#34;&gt;静的な正規表現&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/dynamic_regex.html&#34;&gt;動的な正規表現&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#function&#34; name=&#34;function&#34;&gt;関数&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/function.html&#34;&gt;関数ポインタと関数オブジェクトを統一的に扱う&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/partial_eval.html&#34;&gt;カリー化／部分適用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lambda.html&#34;&gt;無名関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/named_parameter.html&#34;&gt;名前付き引数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#class&#34; name=&#34;class&#34;&gt;クラス&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/noncopyable.html&#34;&gt;クラスをコピー不可にする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/noncopyable_container.html&#34;&gt;コピー不可なオブジェクトを持ちまわる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/move.html&#34;&gt;ムーブ可能なクラスを定義する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/initialize.html&#34;&gt;組み込み型を必ず初期化する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/optional.html&#34;&gt;無効値の統一的な表現&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/variant.html&#34;&gt;ユーザー定義型を扱える型安全な共用体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/uuid.html&#34;&gt;オブジェクトにユニークなIDを付ける&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/operators.html&#34;&gt;演算子自動定義する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/iterator.html&#34;&gt;イテレータを作る&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#idiom&#34; name=&#34;idiom&#34;&gt;イディオム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/finite_state_machine.html&#34;&gt;有限状態マシン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/scope_guard.html&#34;&gt;スコープを抜ける際に実行されるブロック&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html&#34;&gt;シグナル／スロット&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;コルーチン&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#memory&#34; name=&#34;memory&#34;&gt;メモリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/smart_ptr.html&#34;&gt;リソースを自動的に解放する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;プロセス間共有メモリ&lt;/li&gt;
&lt;li&gt;値の共有／Flyweightパターン&lt;/li&gt;
&lt;li&gt;メモリプール&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#validation&#34; name=&#34;validation&#34;&gt;検証&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/unit_test.html&#34;&gt;単体テスト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/dynamic_assert.html&#34;&gt;実行時アサート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/static_assert.html&#34;&gt;コンパイル時アサート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#process&#34; name=&#34;process&#34;&gt;プロセス&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/program_options.html&#34;&gt;コマンドラインオプションの定義／取得&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#math&#34; name=&#34;math&#34;&gt;数学&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/random.html&#34;&gt;乱数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/linear-algebra.html&#34;&gt;線形代数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/math.html&#34;&gt;数学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;単位演算&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/interval_arithmetic.html&#34;&gt;区間演算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/statistics.html&#34;&gt;統計処理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/geometry.html&#34;&gt;計算幾何&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;常微分方程式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#compile_time&#34; name=&#34;compile_time&#34;&gt;コンパイル時処理&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;EDSLの作成&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/type_traits.html&#34;&gt;型特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;型リスト操作&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/static_assert.html&#34;&gt;コンパイル時アサート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/constcond_overload.html&#34;&gt;コンパイル時条件によるオーバーロード&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#concurrency&#34; name=&#34;concurrency&#34;&gt;並行処理&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/thread.html&#34;&gt;スレッド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/mpi.html&#34;&gt;MPI並列計算&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#network&#34; name=&#34;network&#34;&gt;ネットワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/network/tcp.html&#34;&gt;TCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;li&gt;SSL&lt;/li&gt;
&lt;li&gt;シリアルポート&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#datetime&#34; name=&#34;datetime&#34;&gt;日付・時間&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/date_time.html&#34;&gt;日付の計算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/timer.html&#34;&gt;処理時間の計測&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#lang_binding&#34; name=&#34;lang_binding&#34;&gt;言語バインディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Pythonバインディング&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#computer_vision&#34; name=&#34;computer_vision&#34;&gt;コンピュータビジョン&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;画像処理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips.html#env&#34; name=&#34;env&#34;&gt;開発環境&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/version.html&#34;&gt;Boostのバージョンを調べる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html&#34;&gt;コンパイラ間の差を吸収する&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;コンパイラが、あるC++11の機能をサポートしているかどうかでコードを変更する&lt;/li&gt;
&lt;li&gt;コンパイラによって、テンプレート中の &lt;code&gt;hoge&amp;lt;T&amp;gt;::type x;&lt;/code&gt; や &lt;code&gt;fuga.f();&lt;/code&gt; がコンパイルエラーになったりならなかったりする問題を回避する&lt;/li&gt;
&lt;li&gt;メンバ関数テンプレートの呼び出しでコンパイルエラーになる問題を回避する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/build.html&#34;&gt;ビルドツール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビルドしたバイナリを実行する&lt;/li&gt;
&lt;li&gt;ディレクトリ構造を保存した状態でインストールを行う&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/build_link.html&#34;&gt;ヘッダオンリー or ビルドが必要なライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/cxx11-boost-mapping.html&#34;&gt;C++11にもBoostにも存在するライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>