<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="https://boostjp.github.io" />
  <updated>2020-06-28T14:33:59.325734</updated>
  <id>75b5d3b2-4964-4eaa-82fc-3e47d8eadb11</id>

  
    <entry>
      <title>Rational Numbers -- Boost.Rationalのnameをidに変更</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/rational/rational.html"/>
      <id>401affa1498fb5c70de6f83d40dbe7081acc2c31:archive/boost_docs/libs/rational/rational.md</id>
      <updated>2020-06-03T21:10:57+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/rational/rational.md b/archive/boost_docs/libs/rational/rational.md
index e629d10..adaf24e 100644
--- a/archive/boost_docs/libs/rational/rational.md
+++ b/archive/boost_docs/libs/rational/rational.md
@@ -1,6 +1,6 @@
 # Rational Numbers
 
-## &amp;lt;a name=&amp;#34;Contents&amp;#34;&amp;gt;コンテンツ&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Contents&amp;#34;&amp;gt;コンテンツ&amp;lt;/a&amp;gt;
 
 1. [Class rational synopsis](#Class rational synopsis)
 2. [理論的根拠](#Rationale)
@@ -25,7 +25,7 @@
 10. [リファレンス](#References)
 11. [History and Acknowledgements](#History and Acknowledgements)
 
-## &amp;lt;a name=&amp;#34;Class rational synopsis&amp;#34;&amp;gt;Class rational synopsis&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Class rational synopsis&amp;#34;&amp;gt;Class rational synopsis&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/rational.hpp&amp;gt;
@@ -109,7 +109,7 @@ template &amp;lt;typename I&amp;gt; std::ostream&amp;amp; operator&amp;lt;&amp;lt; (std::ostream&amp;amp; os, const rational
 template &amp;lt;typename T, typename I&amp;gt; T rational_cast (const rational&amp;lt;I&amp;gt;&amp;amp; r);
 ```
 
-## &amp;lt;a name=&amp;#34;Rationale&amp;#34;&amp;gt;理論的根拠&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Rationale&amp;#34;&amp;gt;理論的根拠&amp;lt;/a&amp;gt;
 
 「数」の分類には種々のものがある。
 最も基本的なものとしては、自然数（非負の整数）、そして、整数と実数がある。
@@ -121,7 +121,7 @@ template &amp;lt;typename T, typename I&amp;gt; T rational_cast (const rational&amp;lt;I&amp;gt;&amp;amp; r);
 
 実際には、本ライブラリにおける **有理数クラス** は、標準ライブラリにおける **複素数** 型と同じくテンプレートベースで提供される。
 
-## &amp;lt;a name=&amp;#34;Background&amp;#34;&amp;gt;背景&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Background&amp;#34;&amp;gt;背景&amp;lt;/a&amp;gt;
 
 数学的に言えば、有理数とは分数――２つの整数の比で表される数のことである。
 このため、有理数の範囲では表現できない実数値（実数は、２の平方根など分数で表現できない数も表すことができる）も存在する。
@@ -139,7 +139,7 @@ template &amp;lt;typename T, typename I&amp;gt; T rational_cast (const rational&amp;lt;I&amp;gt;&amp;amp; r);
 有理数クラスは、プログラマが、基本要素となる整数型を適切に選択することによって、オーバーフローの発生を制御できるようにテンプレートクラスとして実装されている。
 たとえば、テンプレートで無限精度の整数型（に類する）クラスが与えられれば、有理数クラスの中でオーバーフローは発生することがなく、あらゆる環境に於いて正確な演算結果が得られる。
 
-## &amp;lt;a name=&amp;#34;Integer Type Requirements&amp;#34;&amp;gt;基本要素となる整数型の要件&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Integer Type Requirements&amp;#34;&amp;gt;基本要素となる整数型の要件&amp;lt;/a&amp;gt;
 
 有理数クラスは、単一の型パラメータ `I` をとるテンプレートクラスである。
 この単一の整数型パラメータは、有理数クラスを構成する *基本要素* となる。
@@ -181,9 +181,9 @@ Fさらに、基本要素として利用できる型は、整数型に類似し
 	また、`x`, `y` がいずれも `T` 型であるときに、`x/y` は有効である。
 - 入出力のための演算子は、型パラメータ `I` における入出力演算子の動作と同様に動作する。
 
-## &amp;lt;a name=&amp;#34;Interface&amp;#34;&amp;gt;インターフェイス&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Interface&amp;#34;&amp;gt;インターフェイス&amp;lt;/a&amp;gt;
 
-### &amp;lt;a name=&amp;#34;Utility functions&amp;#34;&amp;gt;ユーティリティ関数&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Utility functions&amp;#34;&amp;gt;ユーティリティ関数&amp;lt;/a&amp;gt;
 
 ユーティリティ関数として、以下の２個が提供される。
 
@@ -199,7 +199,7 @@ Fさらに、基本要素として利用できる型は、整数型に類似し
 
 補足：将来的にこの２つの関数は、別途「ユーティリティライブラリ」のなかで定義される可能性がある
 
-### &amp;lt;a name=&amp;#34;Constructors&amp;#34;&amp;gt;コンストラクタ&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Constructors&amp;#34;&amp;gt;コンストラクタ&amp;lt;/a&amp;gt;
 
 有理数クラスは、２つの整数値（分子、分母）の組み合わせ、あるいは、単一の整数値から生成される。
 また、デフォルトコンストラクタは、値がゼロであるような有理数を生成する。
@@ -215,7 +215,7 @@ rational&amp;lt;I&amp;gt; r2(n, d);
 単一の整数値を取るコンストラクタは、`explicit` 修飾されて *いない* 。
 このため、基本要素となる整数型から有理数クラスへの暗黙の型変換が発生しうる。
 
-### &amp;lt;a name=&amp;#34;Arithmetic operations&amp;#34;&amp;gt;算術演算子&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Arithmetic operations&amp;#34;&amp;gt;算術演算子&amp;lt;/a&amp;gt;
 
 有理数クラスにおいては、以下に示す標準的な算術演算子が定義される。
 
@@ -230,7 +230,7 @@ rational&amp;lt;I&amp;gt; r2(n, d);
 &amp;lt;=   &amp;gt;=
 ```
 
-### &amp;lt;a name=&amp;#34;Input and Output&amp;#34;&amp;gt;入出力&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Input and Output&amp;#34;&amp;gt;入出力&amp;lt;/a&amp;gt;
 
 入出力のために、`&amp;lt;&amp;lt;`  および、`&amp;gt;&amp;gt;` のそれぞれの演算子が定義される。
 有理数クラスの外部での表現形（The external representation）は、`/` で区切られた２つの整数値である。
@@ -238,12 +238,12 @@ rational&amp;lt;I&amp;gt; r2(n, d);
 （入力においては、整数値の後間にホワイトスペースが存在せずに、`/` が続き、さらにその後にもホワイトスペースが存在せず）２番目の整数値が現れなければならない）整数値の表現形は基本要素となる整数型によって定義される形である。
 
 
-### &amp;lt;a name=&amp;#34;In-place assignment&amp;#34;&amp;gt;In-place assignment&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;In-place assignment&amp;#34;&amp;gt;In-place assignment&amp;lt;/a&amp;gt;
 
 有理数クラスの任意のインスタンス `rational&amp;lt;I&amp;gt; r` に対して、`r.assign(n, m)`は、一時インスタンスを生成しないため、`r = rational&amp;lt;I&amp;amp;&amp;gt;(n, m);` より高速に処理を行うことができる。
 この機能は、基本要素となる整数型がＣ＋＋組み込みの場合であればそれほど有効ではないかもしれないが、たとえば、無限精度整数型の上に構成された有理数クラスの場合には有効である。
 
-### &amp;lt;a name=&amp;#34;Conversions&amp;#34;&amp;gt;型変換&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Conversions&amp;#34;&amp;gt;型変換&amp;lt;/a&amp;gt;
 
 有理数クラスは暗黙には他の *いかなる型にも変換されない* 。
 しかしながら、明示的な型変換のためには、関数、 `rational_cast&amp;lt;T&amp;gt;(r)` を提供する。
@@ -276,14 +276,14 @@ Float rational_cast(const rational&amp;lt;Int&amp;gt;&amp;amp; src)
 である。
 しかしながら、この実装に依存するようなプログラムを書いてはならない。
 
-### &amp;lt;a name=&amp;#34;Numerator and Denominator&amp;#34;&amp;gt;分数表現（Numerator and Denominator）&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Numerator and Denominator&amp;#34;&amp;gt;分数表現（Numerator and Denominator）&amp;lt;/a&amp;gt;
 
 直接的に有理数クラスの内部表現にアクセスするためには２つの関数、 `numerator()` と、 `denominator()` を使用する。
 
 この２つの関数を使用することで、ユーザーは有理数を取り扱う上の任意の機能を追加することができる。
 とりわけ、上で示した `rational_cast` の実装がうまく動かない場合――基本要素として、無限精度の整数型を使用している場合にはありそうだが――に、ユーザーがもっと適切な浮動小数点型への型変換関数を、別途準備できることに注意したい。
 
-## &amp;lt;a name=&amp;#34;Performance&amp;#34;&amp;gt;パフォーマンス&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Performance&amp;#34;&amp;gt;パフォーマンス&amp;lt;/a&amp;gt;
 
 有理数クラスは、基本要素となる整数型が、組み込みの整数型と“類似の”振る舞いをすることを暗黙のうちに想定している。
 この基本要素となる整数型の振る舞いを明文化したものが、前述した [基本要素となる整数型の要件](#Integer Type Requirements) である。
@@ -322,7 +322,7 @@ Float rational_cast(const rational&amp;lt;Int&amp;gt;&amp;amp; src)
 以上のような仮定に合致しない整数型は、有理数クラスの基本要素としては有用ではない。
 殊にパフォーマンスの点では、ひどく重く、最適化できない。
 
-## &amp;lt;a name=&amp;#34;Exceptions&amp;#34;&amp;gt;例外&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Exceptions&amp;#34;&amp;gt;例外&amp;lt;/a&amp;gt;
 
 有理数クラスでは、分母がゼロとなることは決してない。
 （本ライブラリでは、NaN や無限大の表現形式としても、分母がゼロになることはない）
@@ -334,7 +334,7 @@ Float rational_cast(const rational&amp;lt;Int&amp;gt;&amp;amp; src)
 加えて、有理数クラスのコンストラクタは、正規化の段階に於いて基本要素クラスで発生した例外をスルーする。
 この事項に対する唯一の例外事項は、有理数クラスのデストラクタは、基本要素クラスのデストラクタがスルーした例外しかスルーしないということである（ただし、通常デストラクタの実行中に基本要素クラスで例外が発生することはない）
 
-## &amp;lt;a name=&amp;#34;Internal representation&amp;#34;&amp;gt;内部表現&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Internal representation&amp;#34;&amp;gt;内部表現&amp;lt;/a&amp;gt;
 
 *補足：* ここで記述する内容は単純に情報を提供するためにのものにすぎない。
 プログラミングの際に、ここで述べるような実装の詳細に依存するようなプログラムを書くべきではない。
@@ -342,9 +342,9 @@ Float rational_cast(const rational&amp;lt;Int&amp;gt;&amp;amp; src)
 内部的には有理数クラスは、分子・分母の２つの整数型（テンプレートで与えられる型パラメータである）の値として保持される。
 有理数クラスの内部表現に置いては、常に約分（すなわち、分子と分母の最大公約数が１となる状態）され、分母が正であるように正規化されている。
 
-## &amp;lt;a name=&amp;#34;Design notes&amp;#34;&amp;gt;デザインノート&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;Design notes&amp;#34;&amp;gt;デザインノート&amp;lt;/a&amp;gt;
 
-### &amp;lt;a name=&amp;#34;Minimal Implementation&amp;#34;&amp;gt;最小の構成となるような設計&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Minimal Implementation&amp;#34;&amp;gt;最小の構成となるような設計&amp;lt;/a&amp;gt;
 
 有理数クラスは数としての基本原則を崩さないように実装されている。
 有理数として持つべき最小限の機能しか持たないが、基本要素となる整数型にアクセスするための、 `numerator()` と `denominator()` の関数を持つことで、必要に応じて、どのような機能拡張も行うことができる。
@@ -357,7 +357,7 @@ Float rational_cast(const rational&amp;lt;Int&amp;gt;&amp;amp; src)
 このユーザー定義による型変換関数が、 `rational_cast()` という名前である必要はない。
 そのため、 `rational_cast()` が、特殊化／オーバーロード可能な形で定義される *必要はない* 。
 
-### &amp;lt;a name=&amp;#34;Limited-range integer types&amp;#34;&amp;gt;基本要素の数値表現範囲（Limited-range integer types）&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Limited-range integer types&amp;#34;&amp;gt;基本要素の数値表現範囲（Limited-range integer types）&amp;lt;/a&amp;gt;
 
 有理数クラスは、表現範囲に制限のないような整数型を使用するように設計されている。
 このような整数型を要素として利用する場合には、演算結果は常に正確に表現され、桁落ちやオーバーフロー／アンダーフローの問題も発生することはない。
@@ -379,7 +379,7 @@ Float rational_cast(const rational&amp;lt;Int&amp;gt;&amp;amp; src)
 
 有理数クラスの基本要素として、表現範囲が制限された整数型を使用することの得失に注意し、前もって意識するのはユーザー次第だということである。
 
-### &amp;lt;a name=&amp;#34;Conversion from floating point&amp;#34;&amp;gt;浮動小数点型からの型変換&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Conversion from floating point&amp;#34;&amp;gt;浮動小数点型からの型変換&amp;lt;/a&amp;gt;
 
 有理数クラスライブラリでは、浮動小数点型から有理数クラスへの型変換関数を提供していない。
 浮動小数点型から有理数クラスへの型変換関数を希望する意見をいくつか受け取ってはいる。
@@ -421,7 +421,7 @@ rational&amp;lt;I&amp;gt; r = rational_from_double(z);
 このような相容れない要求に対して、万人を満足させる単一の解決方法を見いだすことはできなかった。
 その上に、有理数クラスの演算に対するアルゴリズムは複雑であり、また専門化されているため、アプリケーションに要求される事項を理解した上で、最適な実装を行うことが良いと考える。
 
-### &amp;lt;a name=&amp;#34;Absolute Value&amp;#34;&amp;gt;絶対値&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;Absolute Value&amp;#34;&amp;gt;絶対値&amp;lt;/a&amp;gt;
 
 普通に考えれば、基本要素となる整数型の絶対値 `abs(IntType)` が定義されていれば、これを用いて、有理数クラスにおける絶対値（ `rational&amp;lt;IntType&amp;gt;` ）が定義されているべきであると考えられるだろう。
 しかしながら、絶対値を定義するにはいくつもの問題が存在する。
@@ -452,13 +452,13 @@ inline rational&amp;lt;IntType&amp;gt; abs(const rational&amp;lt;IntType&amp;gt;&amp;amp; r)
 このことから、基本要素となる整数型の絶対値が他の場所で定義されたとしても、有理数クラスの絶対値はインライン関数で計算できるということがわかる。
 
 
-## &amp;lt;a name=&amp;#34;References&amp;#34;&amp;gt;リファレンス&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;References&amp;#34;&amp;gt;リファレンス&amp;lt;/a&amp;gt;
 
 - 有理数クラスのヘッダファイル： [rational.hpp](https://www.boost.org/doc/libs/1_31_0/boost/rational.hpp)
 - サンプルコード： [rational_example.cpp](https://www.boost.org/doc/libs/1_31_0/libs/rational/rational_example.cpp)
 - 回帰テスト： [rational_test.cpp](https://www.boost.org/doc/libs/1_31_0/libs/rational/rational_test.cpp)
 
-## &amp;lt;a name=&amp;#34;History and Acknowledgements&amp;#34;&amp;gt;History and Acknowledgements&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;History and Acknowledgements&amp;#34;&amp;gt;History and Acknowledgements&amp;lt;/a&amp;gt;
 
 1999年12月著者（原著者 Paul Moore）は、有理数クラスの最初の実装を行い、 [boost.org](http://www.boost.org/) メーリングリストに投稿した。
 メーリングリストにおいて、いくつかの議論が交わされた。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Appendices. -- Boost.Regexのnameをidに変更</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html"/>
      <id>1fba47854aea7f4599f99e4647b2b1c4f1fa045d:archive/boost_docs/libs/regex/appendix.md</id>
      <updated>2020-06-03T21:10:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/appendix.md b/archive/boost_docs/libs/regex/appendix.md
index 1d1af68..da6ee98 100644
--- a/archive/boost_docs/libs/regex/appendix.md
+++ b/archive/boost_docs/libs/regex/appendix.md
@@ -10,7 +10,7 @@ It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
 
 ---
 
-### &amp;lt;a name=&amp;#34;implementation&amp;#34;&amp;gt;Appendix 1: Implementation notes&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;implementation&amp;#34;&amp;gt;Appendix 1: Implementation notes&amp;lt;/a&amp;gt;
 
 これは boost ライブラリへ regex++ を導入した最初のものであり、 regex++ 2.x に基づいている。
 以前のバージョンからの変更の完全なリストについては changes.txt を見よ。
@@ -60,7 +60,7 @@ C++ 信者はこのコードをいくつかの点で馬鹿げていると考え
 
 ---
 
-### &amp;lt;a name=&amp;#34;threads&amp;#34;&amp;gt;Appendix 2: スレッド安全性&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;threads&amp;#34;&amp;gt;Appendix 2: スレッド安全性&amp;lt;/a&amp;gt;
 
 クラス `reg_expression&amp;lt;&amp;gt;` とその `typedef` である `regex` と `wregex` はスレッド安全性を実現している。
 コンパイルされた正規表現はスレッド間で安全に共有できる。
@@ -82,7 +82,7 @@ POSIX API 関数は全て再入可能でスレッドセーフである。
 
 ---
 
-### &amp;lt;a name=&amp;#34;localisation&amp;#34;&amp;gt;Appendix 3: Localization&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;localisation&amp;#34;&amp;gt;Appendix 3: Localization&amp;lt;/a&amp;gt;
 
 Regex++ は実行時地域化に対して拡張されたサポートを提供している。
 地域化モデルは2つの部分に分かれる: フロントエンドとバックエンドだ。
@@ -303,7 +303,7 @@ POSIX が定義した文字クラス名と照合要素は常に利用可能で
 
 ---
 
-### &amp;lt;a name=&amp;#34;demos&amp;#34;&amp;gt;Appendix 4: 応用例 &amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;demos&amp;#34;&amp;gt;Appendix 4: 応用例 &amp;lt;/a&amp;gt;
 
 このライブラリに関する3つのデモアプリケーションがある。
 Borland, Microsoft, gcc コンパイラのメイクファイルは付属しているが、それ以外は自分でメイクファイルを作成しなければならない
@@ -353,7 +353,7 @@ Files: [`regex_timer.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/exam
 
 ---
 
-### &amp;lt;a name=&amp;#34;headers&amp;#34;&amp;gt;Appendix 5: ヘッダファイル&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;headers&amp;#34;&amp;gt;Appendix 5: ヘッダファイル&amp;lt;/a&amp;gt;
 
 このライブラリが使う2つの主要なヘッダファイルがある:
 `&amp;lt;boost/regex.hpp&amp;gt;` は完全なライブラリへの完全なアクセスを提供する。
@@ -361,7 +361,7 @@ Files: [`regex_timer.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/exam
 
 ---
 
-### &amp;lt;a name=&amp;#34;redist&amp;#34;&amp;gt;Appendix 6: 再配布&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;redist&amp;#34;&amp;gt;Appendix 6: 再配布&amp;lt;/a&amp;gt;
 
 もし Microsoft か Borland C++ を使っていて、 dll 版のランタイムライブラリにリンクしているなら、 regex++ の dll のひとつのバージョンにもリンクしているだろう。
 これらの dll は再配布可能だが、 &amp;#34;標準の&amp;#34; バージョンというものが存在しないので、ユーザの PC にインストールするとき、これらを、PC のディレクトリパスにではなく、アプリケーションのプライベートディレクトリに置くべきである。
@@ -399,7 +399,7 @@ Files: [`regex_timer.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/exam
 
 ---
 
-### &amp;lt;a name=&amp;#34;upgrade&amp;#34;&amp;gt;アップグレードに関する注記&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;upgrade&amp;#34;&amp;gt;アップグレードに関する注記&amp;lt;/a&amp;gt;
 
 このバージョンの regex++ は [boost](http://www.boost.org/) プロジェクトに移植された最初のものであり、結果的に、boost コーディングガイドラインに従うために、多くの変更が為された。
 
@@ -423,7 +423,7 @@ Files: [`regex_timer.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/exam
 
 ---
 
-### &amp;lt;a name=&amp;#34;furtherInfo&amp;#34;&amp;gt;より多くの情報 (連絡と謝辞)&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;furtherInfo&amp;#34;&amp;gt;より多くの情報 (連絡と謝辞)&amp;lt;/a&amp;gt;
 
 作者への連絡は [John_Maddock@compuserve.com](mailto:John_Maddock@compuserve.com) で可能である。
 このライブラリのためのホームページは [http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm](http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm) にある。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Format String Reference. -- Boost.Regexのnameをidに変更</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/format_string.html"/>
      <id>1fba47854aea7f4599f99e4647b2b1c4f1fa045d:archive/boost_docs/libs/regex/format_string.md</id>
      <updated>2020-06-03T21:10:10+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Regex++, Format String Reference.&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;em&gt;Copyright (c) 1998-2001&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
Dr John Maddock makes no representations about the suitability of this software for any purpose.
It is provided &#34;as is&#34; without express or implied warranty.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;a id=&#34;format_string&#34;&gt;Format String Syntax&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;書式文字列は、アルゴリズム &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_format&#34;&gt;regex_format&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_merge&#34;&gt;regex_merge&lt;/a&gt;&lt;/code&gt; で使われている。
これは、一つの文字列を別の文字列に変形するために使われる。&lt;/p&gt;
&lt;p&gt;3種類の書式文字列がある: sed, perl, そして拡張である。
拡張構文はデフォルトなので、最初にこれについて説明する。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拡張文字列構文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;書式文字列では、次のものを除く全ての文字はリテラルとして扱われる: ()\$\?: &lt;/p&gt;
&lt;p&gt;これらをリテラルとして使うには、エスケープ文字 \ を前につけなければならない。&lt;/p&gt;
&lt;p&gt;次の特別なシーケンスを扱うことが出来る。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;グループ化:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;書式文字列の中で子表現をグループ化するには、丸括弧 ( と ) を使うこと。
リテラル &#39;(&#39; と &#39;)&#39; をあらわすには、 \( と \) を使う。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;子表現展開:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次の perl のような表現は、特定の一致した子表現を展開する。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\$`&lt;/td&gt;
&lt;td&gt;前の一致の終端から現在の一致の先頭までの全てのテキストを展開する。もし現在の一致の操作中に前の一致がなければ、入力文字列の先頭から現在の一致の先頭までの全てが展開される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\$&#39;&lt;/td&gt;
&lt;td&gt;一致の終端から入力文字列の終端までの全てのテキストを展開する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\$&amp;amp;&lt;/td&gt;
&lt;td&gt;現在の一致を全て展開する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\$0&lt;/td&gt;
&lt;td&gt;現在の一致を全て展開する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\$N&lt;/td&gt;
&lt;td&gt;子表現 &lt;em&gt;N&lt;/em&gt; に一致したテキストを展開する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;条件付表現:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;条件付表現は二つの異なる書式文字列を、子表現が入力文字列に一致したかどうかに依存して選択することを可能にする：&lt;/p&gt;
&lt;p&gt;?N 真表現 : 偽表現&lt;/p&gt;
&lt;p&gt;もし子表現 &lt;em&gt;N&lt;/em&gt; が一致していれば、 真表現が実行される。
そうでなければ偽表現が実行される。&lt;/p&gt;
&lt;p&gt;例: &#34;(while)|(for)&#34; を検索した時、書式文字列 &#34;?1WHILE:FOR&#34; は一致したものを大文字にして出力する。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;エスケープシーケンス:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次のエスケープシーケンスが可能である:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\a&lt;/td&gt;
&lt;td&gt;ベル文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;フォームフィード(FF)文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;改行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;復帰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;タブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;垂直タブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\x&lt;/td&gt;
&lt;td&gt;16進文字 - 例えば: \x0D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\x{}&lt;/td&gt;
&lt;td&gt;可能なユニコード16進文字 - 例えば \x{1A0}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\cx&lt;/td&gt;
&lt;td&gt;ASCII エスケープ文字 x 、例えば \c@ は escape-@ と等価。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\e&lt;/td&gt;
&lt;td&gt;ASCII エスケープ文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\dd&lt;/td&gt;
&lt;td&gt;8進文字定数、例えば \10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Perl 書式文字列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Perl 書式文字列は文字 ()?: が特別な意味を持たないこと以外は、
デフォルト構文と同じである。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sed 書式文字列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sed 書式文字列は、文字 \ と &amp;amp; のみを特殊文字として使う。&lt;/p&gt;
&lt;p&gt;n が数字のとき、 \n は n 番目の子表現に展開される。&lt;/p&gt;
&lt;p&gt;&amp;amp; は一致全体に展開される。
( \0 と等価)。&lt;/p&gt;
&lt;p&gt;他のエスケープシーケンスはデフォルト構文と同じように展開される。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Copyright&lt;/em&gt; &lt;a href=&#34;mailto:John_Maddock@compuserve.com&#34;&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/a&gt; &lt;em&gt;1998-2001 all rights reserved.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:k_takahashi@cppll.jp&#34;&gt;Kohske Takahashi&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, POSIX API Reference -- Boost.Regexのnameをidに変更</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/posix_ref.html"/>
      <id>1fba47854aea7f4599f99e4647b2b1c4f1fa045d:archive/boost_docs/libs/regex/posix_ref.md</id>
      <updated>2020-06-03T21:10:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/posix_ref.md b/archive/boost_docs/libs/regex/posix_ref.md
index fff543b..9a1dd99 100644
--- a/archive/boost_docs/libs/regex/posix_ref.md
+++ b/archive/boost_docs/libs/regex/posix_ref.md
@@ -10,7 +10,7 @@ It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
 
 ---
 
-### &amp;lt;a name=&amp;#34;posix&amp;#34;&amp;gt;POSIX compatibility library&amp;lt;/a&amp;gt;
+### &amp;lt;a id=&amp;#34;posix&amp;#34;&amp;gt;POSIX compatibility library&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/cregex.hpp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Regular Expression Syntax -- Boost.Regexのnameをidに変更</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/syntax.html"/>
      <id>1fba47854aea7f4599f99e4647b2b1c4f1fa045d:archive/boost_docs/libs/regex/syntax.md</id>
      <updated>2020-06-03T21:10:10+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Regex++, Regular Expression Syntax&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;em&gt;Copyright (c) 1998-2001&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation.
Dr John Maddock makes no representations about the suitability of this software for any purpose.
It is provided &#34;as is&#34; without express or implied warranty.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;a id=&#34;syntax&#34;&gt;Regular expression syntax&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;この章では、このライブラリで使われる正規表現文法について述べる。
これは、プログラマーズガイドであって、プログラムの中でユーザに与えられる実際の文法は正規表現の翻訳の間に使われるフラグに依存する。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Literals&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以下のものを除く全ての文字はリテラルである: &#34;.&#34;, &#34;|&#34;, &#34;*&#34;, &#34;?&#34;, &#34;+&#34;, &#34;(&#34;, &#34;)&#34;, &#34;{&#34;, &#34;}&#34;, &#34;[&#34;, &#34;]&#34;, &#34;\^&#34;, &#34;\$&#34;, &#34;\&#34; 。
これらの文字列は、&#34;\&#34; に続いたときはリテラルである。
リテラルはそれ自身にマッチするか、または、 &lt;code&gt;traits_type::translate()&lt;/code&gt; の結果にマッチする文字である。
&lt;code&gt;traits_type&lt;/code&gt; は &lt;code&gt;reg_expression&lt;/code&gt; クラスの特性テンプレートパラメータである。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ワイルドカード&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ドット文字 &#34;.&#34; はあらゆる1文字にマッチする。
例外: &lt;code&gt;match_not_dot_null&lt;/code&gt; がマッチアルゴリズムに渡されたときは、ドットはヌル文字にはマッチしない。
&lt;code&gt;match_not_dot_newline&lt;/code&gt; がマッチアルゴリズムに渡されたときは、ドットは改行文字にはマッチしない。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;繰り返し&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;繰り返しは任意の回数繰り返される正規表現である。
&#34;*&#34; が続く正規表現はゼロを含む何回の繰り返しも可能である。
&#34;+&#34; が続く正規表現は1回以上の何回の繰り返しも可能である。
もし正規表現が &lt;code&gt;regbase::bk_plus_qm&lt;/code&gt; フラグ付きで翻訳されるなら、 &#34;+&#34; は通常の文字であり、 &#34;\+&#34; が1回以上の繰り返しを表す。
&#34;?&#34; が続く正規表現は0回か1回の繰り返しである。
もし正規表現が &lt;code&gt;regbase::bk_plus_qm&lt;/code&gt; フラグ付きで翻訳されるなら、 &#34;?&#34; は通常の文字であり、 &#34;\?&#34; が0回か1回の繰り返しを示す。
繰り返しの最小回数と最大回数を明示する必要があるなら、範囲指定子 &#34;{}&#34; が使われる。
&#34;a{2}&#34; は、ちょうど2回だけ繰り返される文字 &#34;a&#34; である。
&#34;a{2,4}&#34; は2回以上4回以下繰り返される文字 &#34;a&#34; であり、 &#34;a{2,}&#34; は2回以上上限なく繰り返される文字 &#34;a&#34; である。
{}の中に空白があってはいけないこと、最小回数と最大回数の指定に上限がないことに注意せよ。
正規表現が &lt;code&gt;regbase::bk_braces&lt;/code&gt; フラグ付で翻訳されるとき、 &#34;{&#34; と &#34;}&#34; は通常の文字であり、代わりに &#34;\{&#34; と &#34;\}&#34; が範囲指定に使われる。
全ての繰り返し表現は、可能な限り短く、前方の子表現を参照する。
例えば、1文字、文字集合、 &#34;()&#34; で囲まれた子表現を参照する。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;&#34;ba*&#34; は &#34;b&#34;, &#34;ba&#34;, &#34;baaa&#34; などの全てにマッチする。&lt;/p&gt;
&lt;p&gt;&#34;ba+&#34; は &#34;ba&#34; や &#34;baaaa&#34; にマッチするが、 例えば &#34;b&#34; にはマッチしない。&lt;/p&gt;
&lt;p&gt;&#34;ba?&#34; は &#34;b&#34; と &#34;ba&#34; にマッチする。&lt;/p&gt;
&lt;p&gt;&#34;ba{2,4}&#34; は &#34;baa&#34; と  &#34;baaa&#34; と &#34;baaaa&#34; にマッチする。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;貪欲でない繰り返し&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;「拡張」正規表現構文が(デフォルトで)使われるときはいつでも、繰り返しのあとに &#39;?&#39; を付け足すことで、貪欲でない繰り返しが可能である。
貪欲でない繰り返しとは、 可能な限り &lt;em&gt;もっとも短い&lt;/em&gt; 文字列にマッチするものである。&lt;/p&gt;
&lt;p&gt;例えば、一組の html タグのマッチには次のようにすることができる:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;\s*tagname[^&amp;gt;]*&amp;gt;(.*?)&amp;lt;\s*/tagname\s*&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;この場合、 &lt;code&gt;\$1&lt;/code&gt; はタグに挟まれたテキストを保持する。
これが、可能な限り最も短い文字列である。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;丸括弧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;丸括弧はふたつの目的で使われる。
一つは子表現をまとめることであり、もう一つはマッチを生成したものを印付けることである。
例えば、正規表現 &#34;(ab)*&#34; は文字列 &#34;ababab&#34; の全てにマッチする。
マッチアルゴリズム &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#query_match&#34;&gt;regex_match&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_search&#34;&gt;regex_search&lt;/a&gt;&lt;/code&gt; はそれぞれ、何がマッチを引き起こしたかを報告する、 &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_match&#34;&gt;match_results&lt;/a&gt;&lt;/code&gt; のインスタンスを得る。
これらの関数から抜けるとき、 &lt;code&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html#reg_match&#34;&gt;match_results&lt;/a&gt;&lt;/code&gt; 正規表現全体が何とマッチしたか、そしてそれぞれの子表現が何とマッチしたかについての情報を保持している。
上の例では、 &lt;code&gt;match_results[1]&lt;/code&gt; はマッチした文字列の最後の &#34;ab&#34; を示す一組のイテレータを保持している。
子表現がヌル文字列にマッチすることも許されている。
もし子表現がどの部分ともマッチしなければ、例えばそれが、マッチしなかった選択肢の一部なら、その子表現に対して返される両方のイテレータは、入力文字列の終端を指していて、 その子表現に対する &lt;code&gt;matched&lt;/code&gt; パラメータは &lt;code&gt;false&lt;/code&gt; である。
子表現は1で始まり左から右に数えられる。
子表現 0 は正規表現全体である。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;印付けをしない丸括弧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;丸括弧で子表現をグループ化したいが、丸括弧に子表現の印を作って欲しくないようなときは、印付けをしない丸括弧 (?:expression) を使うことができる。
例えば、 次の正規表現は子表現を作らない: (訳注: 子表現を作らないいうよりは、子表現に印付けをしないということ)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&#34;(?:abc)*&#34;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;前方先読み宣言&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;これにはふたつの形式がある。
一つは肯定的前方先読み宣言であり、もう一つは否定的前方先読み宣言である:&lt;/p&gt;
&lt;p&gt;&#34;(?=abc)&#34; はゼロ文字列に正規表現 &#34;abc&#34; が続くときのみ、そのゼロ文字列にマッチする。&lt;/p&gt;
&lt;p&gt;&#34;(?!abc)&#34; はゼロ文字列に正規表現 &#34;abc&#34; 続かないときのみ、そのゼロ文字列にマッチする。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;選択&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;選択は、正規表現がある子表現か、別の子表現のいずれかにマッチするときに起こる。
それぞれの選択肢は &#34;|&#34; か、 &lt;code&gt;regbase::bk_vbar&lt;/code&gt; フラグが設定されているなら &#34;\|&#34; または &lt;code&gt;regbase::newline_alt&lt;/code&gt; フラグが設定されていれば改行文字によって区切られる。
それぞれの選択肢は先行する可能な限り大きな子表現である。
これは繰り返し演算子とは逆の動作である。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;&#34;a(b|c)&#34; は &#34;ab&#34; または &#34;ac&#34; にマッチする。&lt;/p&gt;
&lt;p&gt;&#34;abc|def&#34; は &#34;abc&#34; または &#34;def&#34; にマッチする。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;集合&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;集合は、集合の要素であるあらゆる1文字とマッチすることができる文字集合である。
文字集合は &#34;[&#34; と &#34;]&#34; で囲まれていて、リテラル、文字範囲、文字クラス、照合要素、等価クラスを含むことができる。
&#34;\^&#34; で始まる文字集合の宣言は、それに続く要素以外を含む。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;p&gt;文字リテラル:&lt;/p&gt;
&lt;p&gt;&#34;[abc]&#34; は &#34;a&#34; , &#34;b&#34; , &#34;c&#34; のいずれかとマッチする。&lt;/p&gt;
&lt;p&gt;&#34;[\^abc]&#34; は &#34;a&#34;, &#34;b&#34;, or &#34;c&#34; 以外のあらゆる文字にマッチする。&lt;/p&gt;
&lt;p&gt;文字範囲:&lt;/p&gt;
&lt;p&gt;&#34;[a-z]&#34; は &#34;a&#34; から &#34;z&#34; の範囲にあるあらゆる文字にマッチする。 &lt;/p&gt;
&lt;p&gt;&#34;[\^A-Z]&#34; は &#34;A&#34; から &#34;Z&#34; の範囲にある文字以外の、あらゆる文字にマッチする。&lt;/p&gt;
&lt;p&gt;文字範囲は、ロケールに強く依存することに注意せよ: これは、その範囲の両端の間に並んでいる、あらゆる文字にマッチする。
デフォルトの &#34;C&#34; ロケールが有効なときは、文字範囲は ASCII に基づいて振舞うだけである。
しかし、例えばライブラリが、 Win32 ロケールモデルでコンパイルされていれば、 &#34;[a-z]&#34; は ASCII 文字 a-z 、そして &#39;A&#39;、&#39;B&#39;などにもマッチするが、 &#39;z&#39;のすぐあとに並んでいる &#39;Z&#39;にはマッチしない。
このロケール特有の振る舞いは翻訳するときに &lt;code&gt;regbase::nocollate&lt;/code&gt; フラグを設定することで、不可能にすることができる。
これは &lt;code&gt;regbase::normal&lt;/code&gt; を使ったときのデフォルトの振る舞いであり、文字範囲が ASCII 文字コードに基づいて並んでいることを強制する。
同様に、もし POSIX C API 関数をつかうなら、 &lt;code&gt;REG_NOCOLLATE&lt;/code&gt; を設定することでロケールに依存する並びを無効にすることができる。&lt;/p&gt;
&lt;p&gt;文字クラスは、文字集合の中で、構文 &#34;[:classname:]&#34; を使うことで表現される。
例えば、 &#34;[[:space:]]&#34; は全ての空白文字の集合である。
文字クラスは &lt;code&gt;regbase::char_classes&lt;/code&gt; フラグが設定されているときのみ利用できる。
利用できる文字クラスは:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alnum&lt;ul&gt;
&lt;li&gt;全ての数字とアルファベット&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;alpha&lt;ul&gt;
&lt;li&gt;a-z と A-Z の全てのアルファベット。
    ロケールによっては他の文字も含まれるかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;blank&lt;ul&gt;
&lt;li&gt;スペースかタブの、あらゆる空白文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cntrl&lt;ul&gt;
&lt;li&gt;全ての制御文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;digit&lt;ul&gt;
&lt;li&gt;0-9 の全ての数字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;graph&lt;ul&gt;
&lt;li&gt;空白以外の印刷可能文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lower&lt;ul&gt;
&lt;li&gt;a-z の全ての小文字。
    ロケールによっては他の文字も含まれるかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;print&lt;ul&gt;
&lt;li&gt;全ての印刷可能な文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;punct&lt;ul&gt;
&lt;li&gt;全ての句読点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;space&lt;ul&gt;
&lt;li&gt;全ての空白文字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;upper&lt;ul&gt;
&lt;li&gt;A-Z の全ての大文字。
    ロケールによっては他の文字も含まれるかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;xdigit&lt;ul&gt;
&lt;li&gt;全ての16進文字。
    0-9, a-f, A-F。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;word&lt;ul&gt;
&lt;li&gt;全ての単語形成文字。
    つまり、全てのアルファベットとアンダースコア。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;unicode&lt;ul&gt;
&lt;li&gt;文字コードが 255 より大きい全ての文字。
    これはワイド文字特性クラスだけに適用される。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文字クラスの代わりに使うことができる略記がいくつかある。
これらは &lt;code&gt;regbase::escape_in_lists&lt;/code&gt; フラグが設定されていときに使うことができる。&lt;/p&gt;
&lt;p&gt;\w in place of [:word:]&lt;/p&gt;
&lt;p&gt;\s in place of [:space:]&lt;/p&gt;
&lt;p&gt;\d in place of [:digit:]&lt;/p&gt;
&lt;p&gt;\l in place of [:lower:]&lt;/p&gt;
&lt;p&gt;\u in place of [:upper:] &lt;/p&gt;
&lt;p&gt;照合要素は文字集合宣言の中での [.tagname.] という一般的な形式をとる。
&lt;em&gt;tagname&lt;/em&gt; は一文字か、照合要素の名前である。
たとえば、 [[.a.]] は [a] と等価であり、 [[.comma.]] は [,] と等価である。
ライブラリは全ての標準 POSIX の照合要素名に加えて、以下の連字サポートしている: &#34;ae&#34;, &#34;ch&#34;, &#34;ll&#34;, &#34;ss&#34;, &#34;nj&#34;, &#34;dz&#34;, &#34;lj&#34;, それぞれ小文字、大文字、タイトルケース版がある。
マルチ文字照合要素は結局、一文字より多くにマッチする集合である。
例えば、 [[.ae.]] は2文字にマッチするが、 [\^[.ae.]] は一文字にしかマッチしないことに注意せよ。&lt;/p&gt;
&lt;p&gt;等価クラスは文字集合宣言の中で [=tagname=] という一般的な形式をとる。
&lt;em&gt;tagname&lt;/em&gt; は一文字か、照合要素の名前である。
これは、照合要素 [.tagname.] と同じ第一等価クラスの要素である、あらゆる文字とマッチする。
等価クラスは照合順序が同じ文字集合である。
第一等価クラスは、第一のソートキーがすべて同じである文字集合である(例えば文字列は典型的に文字によって並べられ、続いてアクセント、そして大文字/小文字によって並べられる。
この時、第一のソートキーは文字に関係し、第二のそれはアクセントに、第三のそれは大文字/小文字である)。
もし &lt;em&gt;tagname&lt;/em&gt; に対応する等価クラスがなければ、[=tagname=] は実際には [.tagname.] と同じである。
不幸にも、Win32 環境を除いては、文字に対する第一のソートキーをロケールに依存しないで得る方法はない。
他のOSでは、ライブラリは (&lt;code&gt;strxfrm&lt;/code&gt; から得た)全部のソートキーから、第一のソートキーを「推測する」ので、等価クラスはおそらく、 Win32 以外の OS では最も不確実だと考えられる。&lt;/p&gt;
&lt;p&gt;文字集合の中にリテラル &#34;-&#34; を含むためには、それを 開き括弧 &#34;[&#34; 、 &#34;[\^&#34; 、範囲指定の端、または照合要素に続く最初の文字にしなければならない。
&lt;code&gt;regbase::escape_in_lists&lt;/code&gt; フラグが設定されているなら、 &#34;[\-]&#34; のようにエスケープ文字に続けてもよい。
リテラル &#34;[&#34; 、 &#34;]&#34; と &#34;\^&#34; を文字集合に含めるには、範囲指定の端、照合要素、またはもし &lt;code&gt;regbase::escape_in_lists&lt;/code&gt; フラグが設定されているなら、エスケープ文字に続けてもよい。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ラインアンカ&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;アンカは 行頭及び行末で null 文字に一致するものである: &#34;\^&#34; は行頭の null 文字に一致し、 &#34;\$&#34; は行末の null 文字に一致する。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;後方参照&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;後方参照は、既に一致した、先行する子表現への参照である。
これは、一致した子表現に対する参照であり、表現そのものに対する参照ではない。
後方参照はエスケープ文字 &#34;\&#34; に数字 &#34;1&#34; から &#34;9&#34; を続けることで出来る。
&#34;\1&#34; は最初の子表現に、 &#34;\2&#34; は2番目の正規表現に、といった具合である。
例えば正規表現 &#34;(.*)\1&#34; は中間点について繰り返されるあらゆる文字列に一致する(訳注:文字列の前半と後半が同じであるということ)。
例えば、 &#34;abcabc&#34; や &#34;xyzxyz&#34; である。
どんな一致も起こらない子表現への後方参照は、 null 文字列に一致する: これが他のいくつかの正規表現の一致とは異なることに注意せよ。
後方参照は正規表現がフラグ &lt;code&gt;regbase::bk_refs&lt;/code&gt; を設定されてコンパイルされた時のみ利用できる。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;コードによる文字&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;これは他のライブラリでは利用できないアルゴリズムへの拡張である。
コードはエスケープ文字と、それに続く数字 &#34;0&#34; と、更にそれに、8進数の文字コードを続けることで成り立つ。
例えば、 &#34;\023&#34; はその8進文字コードが 23 である文字をあらわす。
曖昧になるような場合、正規表現を区切るのに丸括弧を利用すること: &#34;\0103&#34; は文字コードが 103 の文字をあらわし、 &#34;(\010)3&#34; は文字コードが 10 の文字と、それに続く &#34;3&#34; をあらわす。
16進コードで文字を一致させるには、 \x に 16 進の文字列を続ける。
この文字列は {} の中に閉じ込めることも可能である。
例えば、 \xf0 や \x{aff} など。
後者はユニコード文字である。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;単語演算子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次の演算子は GNU 正規表現ライブラリとの互換性のために提供されている。&lt;/p&gt;
&lt;p&gt;&#34;\w&#34; は &#34;word&#34; 文字クラスの要素であるあらゆる1文字に一致する。
これは表現 &#34;[[:word:]]&#34; と同じである。&lt;/p&gt;
&lt;p&gt;&#34;\W&#34; は &#34;word&#34; 文字クラスの要素ではないあらゆる1文字に一致する。
これは表現 &#34;[\^[:word:]]&#34; と同じである。&lt;/p&gt;
&lt;p&gt;&#34;\&amp;lt;&#34; は単語の先頭の null 文字列に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\&amp;gt;&#34; は単語の終端の null 文字列に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\b&#34; は単語の先頭及び終端の null 文字列に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\B&#34; は単語の中の null 文字列に一致する。&lt;/p&gt;
&lt;p&gt;一致判定アルゴリズムに渡されるシーケンスの先頭は、フラグ &lt;code&gt;match_not_bow&lt;/code&gt; が設定されていない限り、単語の先頭の可能性があると考えられる。
一致判定アルゴリズムに渡されるシーケンスの終端は、フラグ &lt;code&gt;match_not_eow&lt;/code&gt; が設定されていない限り、単語の終端の可能性があると考えられる。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;バッファ演算子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次の演算子は GNU 正規表現ライブラリ、及び Perl 正規表現との互換性のために提供されている:&lt;/p&gt;
&lt;p&gt;&#34;\`&#34; はバッファの先頭に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\A&#34; はバッファの先頭に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\&#39;&#34; はバッファの終端に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\z&#34; はバッファの終端に一致する。&lt;/p&gt;
&lt;p&gt;&#34;\Z&#34; はバッファの終端に一致する。
または可能であれば、バッファの終端が続く1つ以上の改行文字に一致する。&lt;/p&gt;
&lt;p&gt;フラグ &lt;code&gt;match_not_bob&lt;/code&gt; 及び &lt;code&gt;match_not_eob&lt;/code&gt; が設定されていない限り、バッファは一致判定アルゴリズムに渡されるシーケンス全体で出来ていると考えられる。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;エスケープ演算子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;エスケープ文字 &#34;\&#34; は多くの一致を持つ。&lt;/p&gt;
&lt;p&gt;集合宣言の中ではエスケープ文字は、フラグ &lt;code&gt;regbase::escape_in_lists&lt;/code&gt; が設定されていない限り通常の文字である。
この場合、エスケープに続くどんな文字も、その通常の意味に関わらずリテラル文字である。&lt;/p&gt;
&lt;p&gt;エスケープ演算子は例えば、後方参照や単語演算子などの演算子を導入する。&lt;/p&gt;
&lt;p&gt;エスケープ演算子は、それに続く文字を通常の文字にすることもある。
例えば、&#34;\*&#34; は繰り返し演算子ではなく、リテラル &#34;*&#34; をあらわす。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;単一文字エスケープシーケンス&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次のエスケープシーケンスは単一文字の略記である:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;エスケープシーケンス&lt;/th&gt;
&lt;th&gt;文字コード&lt;/th&gt;
&lt;th&gt;意味&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\a&lt;/td&gt;
&lt;td&gt;0x07&lt;/td&gt;
&lt;td&gt;ベル文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;0x0C&lt;/td&gt;
&lt;td&gt;フォームフィード(FF)文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;0x0A&lt;/td&gt;
&lt;td&gt;改行文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;0x0D&lt;/td&gt;
&lt;td&gt;復帰(キャリッジリターン)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;0x09&lt;/td&gt;
&lt;td&gt;タブ文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;0x0B&lt;/td&gt;
&lt;td&gt;垂直タブ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\e&lt;/td&gt;
&lt;td&gt;0x1B&lt;/td&gt;
&lt;td&gt;ASCII エスケープ文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\0dd&lt;/td&gt;
&lt;td&gt;0dd&lt;/td&gt;
&lt;td&gt;8進文字コード。 &lt;em&gt;dd&lt;/em&gt; は1文字以上の8進文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\xXX&lt;/td&gt;
&lt;td&gt;0xXX&lt;/td&gt;
&lt;td&gt;16進文字コード。 XX は1文字以上の16進文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\x{XX}&lt;/td&gt;
&lt;td&gt;0xXX&lt;/td&gt;
&lt;td&gt;16進文字コード。 XX は1文字以上の16進文字。 ユニコード文字でもよい。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\cZ&lt;/td&gt;
&lt;td&gt;z-@&lt;/td&gt;
&lt;td&gt;ASCII エスケープシーケンス control-Z。 Z は &#39;@&#39; の文字コードに等しいか、それより大きければどんな ASCII 文字でもよい。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;様々なエスケープシーケンス&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;次のものの多くは perl との互換性のために提供されている。
しかし、 \l \L \u \U の意味はいくらか異なることに注意せよ。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;[[:word:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;[\^[:word:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;[[:space:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;[\^[:space:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;[[:digit:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;[\^[:digit:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\l&lt;/td&gt;
&lt;td&gt;[[:lower:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\L&lt;/td&gt;
&lt;td&gt;[\^[:lower:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\u&lt;/td&gt;
&lt;td&gt;[[:upper:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\U&lt;/td&gt;
&lt;td&gt;[\^[:upper:]] と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\C&lt;/td&gt;
&lt;td&gt;あらゆる1文字。 &#39;.&#39; と等価&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\X&lt;/td&gt;
&lt;td&gt;あらゆるユニコード複合文字シーケンスに一致する。 例えば、 &#34;a\x 0301&#34; (鋭アクセントをもつ文字)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\Q&lt;/td&gt;
&lt;td&gt;引用符開始演算子。 これに続く全ては 引用符終了演算子 \E が発見されるまでリテラル文字として扱われる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\E&lt;/td&gt;
&lt;td&gt;引用符終了演算子。 \Q で始まったシーケンスを終了させる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;何が一致するのか?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;正規表現ライブラリは、可能な限り最初の一致文字列と一致する。
もし与えられた場所で始まる一つ以上の文字列が一致可能なら、フラグ &lt;code&gt;match_any&lt;/code&gt; が設定されていない限り、可能な限り長い文字列に一致する。
そして出会った最初の一致が返される。
&lt;code&gt;match_any&lt;/code&gt; フラグを設定することで、一致を発見するのにかかる時間を削減することが出来る。
しかしこれは、ユーザが何が一致するかに関心がないときのみ役に立つ。
例えば、検索と置換の操作には適していない。
同じ場所で始まる複数の可能な一致があるような場合、そしてそれら全てが同じ長さである場合、選ばれる一致は最も長い最初の子表現を持つものである。
ふたつ目以上の一致でもそれが同じなら、2番目の子表現が試され、3番目・・・と続いていく。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Copyright&lt;/em&gt; &lt;a href=&#34;mailto:John_Maddock@compuserve.com&#34;&gt;&lt;em&gt;Dr John Maddock&lt;/em&gt;&lt;/a&gt; &lt;em&gt;1998-2001 all rights reserved.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:k_takahashi@cppll.jp&#34;&gt;Kohske Takahashi&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++ template class reference. -- Boost.Regexのnameをidに変更</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/template_class_ref.html"/>
      <id>1fba47854aea7f4599f99e4647b2b1c4f1fa045d:archive/boost_docs/libs/regex/template_class_ref.md</id>
      <updated>2020-06-03T21:10:10+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/template_class_ref.md b/archive/boost_docs/libs/regex/template_class_ref.md
index 1b8d70e..5ba1b2c 100644
--- a/archive/boost_docs/libs/regex/template_class_ref.md
+++ b/archive/boost_docs/libs/regex/template_class_ref.md
@@ -10,7 +10,7 @@ It is provided &amp;#34;as is&amp;#34; without express or implied warranty.*
 
 ---
 
-## &amp;lt;a name=&amp;#34;regbase&amp;#34;&amp;gt;class regbase&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;regbase&amp;#34;&amp;gt;class regbase&amp;lt;/a&amp;gt;
 
 ```cpp
 #include boost/regex.hpp&amp;gt;
@@ -140,7 +140,7 @@ public:
 
 ---
 
-## &amp;lt;a name=&amp;#34;bad_expression&amp;#34;&amp;gt;Exception classes.&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;bad_expression&amp;#34;&amp;gt;Exception classes.&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/pat_except.hpp&amp;gt;
@@ -173,7 +173,7 @@ public:
 
 ---
 
-## &amp;lt;a name=&amp;#34;reg_expression&amp;#34;&amp;gt;Class `reg_expression`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;reg_expression&amp;#34;&amp;gt;Class `reg_expression`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex.hpp&amp;gt;
@@ -383,7 +383,7 @@ public:
 
 ---
 
-## &amp;lt;a name=&amp;#34;regex_char_traits&amp;#34;&amp;gt;Class `regex_traits`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;regex_char_traits&amp;#34;&amp;gt;Class `regex_traits`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex/regex_traits.hpp&amp;gt;
@@ -428,7 +428,7 @@ template &amp;lt;class charT&amp;gt; class regex_traits : public base_type { /*detailts*/ };
 
 ---
 
-## &amp;lt;a name=&amp;#34;reg_match&amp;#34;&amp;gt;Class `match_results`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;reg_match&amp;#34;&amp;gt;Class `match_results`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex.hpp&amp;gt;
@@ -585,7 +585,7 @@ typedef match_results&amp;lt;std::wstring::const_iterator&amp;gt; wsmatch;
 
 ---
 
-## &amp;lt;a name=&amp;#34;query_match&amp;#34;&amp;gt;Algorithm `regex_match`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;query_match&amp;#34;&amp;gt;Algorithm `regex_match`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex.hpp&amp;gt;
@@ -700,7 +700,7 @@ int process_ftp(const char* response, std::string* msg)
 }
 ```
 
-&amp;lt;a name=&amp;#34;match_type&amp;#34;&amp;gt;アルゴリズムに渡されるフラグパラメータの値は次の値のひとつ以上の組み合わせでなければならない。&amp;lt;/a&amp;gt;
+&amp;lt;a id=&amp;#34;match_type&amp;#34;&amp;gt;アルゴリズムに渡されるフラグパラメータの値は次の値のひとつ以上の組み合わせでなければならない。&amp;lt;/a&amp;gt;
 
 - `match_default`
 	- デフォルトの値である。
@@ -738,7 +738,7 @@ int process_ftp(const char* response, std::string* msg)
 
 ---
 
-## &amp;lt;a name=&amp;#34;reg_search&amp;#34;&amp;gt;Algorithm `regex_search`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;reg_search&amp;#34;&amp;gt;Algorithm `regex_search`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex.hpp&amp;gt;
@@ -838,7 +838,7 @@ void IndexClasses(map_type&amp;amp; m, const std::string&amp;amp; file)
 
 ---
 
-## &amp;lt;a name=&amp;#34;reg_grep&amp;#34;&amp;gt;Algorithm `regex_grep`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;reg_grep&amp;#34;&amp;gt;Algorithm `regex_grep`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex.hpp&amp;gt;
@@ -1118,7 +1118,7 @@ void class_index::IndexClasses(const std::string&amp;amp; file)
 
 ---
 
-## &amp;lt;a name=&amp;#34;reg_format&amp;#34;&amp;gt;Algorithm `regex_format`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;reg_format&amp;#34;&amp;gt;Algorithm `regex_format`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex.hpp&amp;gt;
@@ -1173,7 +1173,7 @@ std::basic_string&amp;lt;charT&amp;gt; regex_format
 - `unsigned flags`
 	- 書式指定子がどのように解釈されるかを示す、オプションのフラグ。
 
-&amp;lt;a name=&amp;#34;format_flags&amp;#34;&amp;gt;書式のフラグは以下のように定義されている。&amp;lt;/a&amp;gt;
+&amp;lt;a id=&amp;#34;format_flags&amp;#34;&amp;gt;書式のフラグは以下のように定義されている。&amp;lt;/a&amp;gt;
 
 - `format_all`
 	- すべての構文のオプションを可能にする。
@@ -1192,7 +1192,7 @@ std::basic_string&amp;lt;charT&amp;gt; regex_format
 
 ---
 
-## &amp;lt;a name=&amp;#34;reg_merge&amp;#34;&amp;gt;Algorithm `regex_merge`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;reg_merge&amp;#34;&amp;gt;Algorithm `regex_merge`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex.hpp&amp;gt;
@@ -1370,7 +1370,7 @@ const char* footer_text = &amp;#34;&amp;lt;/PRE&amp;gt;\n&amp;lt;/BODY&amp;gt;\n\n&amp;#34;;
 
 ---
 
-## &amp;lt;a name=&amp;#34;regex_split&amp;#34;&amp;gt;Algorithm `regex_split`&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;regex_split&amp;#34;&amp;gt;Algorithm `regex_split`&amp;lt;/a&amp;gt;
 
 ```cpp
 #include &amp;lt;boost/regex.hpp&amp;gt;
@@ -1474,7 +1474,7 @@ int main(int argc, char** argv)
 
 ---
 
-## &amp;lt;a name=&amp;#34;partial_matches&amp;#34;&amp;gt;Partial Matches&amp;lt;/a&amp;gt;
+## &amp;lt;a id=&amp;#34;partial_matches&amp;#34;&amp;gt;Partial Matches&amp;lt;/a&amp;gt;
 
 一致フラグ `match_partial` は次のアルゴリズムに渡すことが出来る:
 [`regex_match`](#reg_match), [`regex_search`](#reg_search), そして [`regex_grep`](#reg_grep) 。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Boost.Rationalの翻訳ドキュメントを移植(close #20)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>e89a3b43e52a34bc1f84036ce2000b465215e2cb:archive/boost_docs/libs.md</id>
      <updated>2020-06-03T20:41:07+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;各ライブラリの翻訳ドキュメント&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/function.html&#34;&gt;function&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;遅延呼び出し及びコールバックのための関数オブジェクトラッパ。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/functional.html&#34;&gt;functional&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;機能強化された関数オブジェクトアダプタ。 Mark Rodgers 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/graph.html&#34;&gt;graph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;汎用グラフコンポーネント及びアルゴリズム。 Jeremy Siek and a University of Notre Dame team 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/io/ios_state.html&#34;&gt;io state savers&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;入出力の状態を保存して、データが化けるのを防ぐ。 Daryle Walker 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/lambda.html&#34;&gt;lambda&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;実際の呼び出し時の、小さな無名関数オブジェクトの定義。, from Jaakko Jävi and Gary Powell.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/math.html&#34;&gt;math&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学の領域での多くの貢献。様々な作者による。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/multi_array.html&#34;&gt;muti_array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリ上で連続したデータの配列のための多次元コンテナとアダプタ。 Ron Garcia 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/preprocessor.html&#34;&gt;preprocessor&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;繰り返しと再帰を含むプリプロセッサメタプログラミングツール群。 Vesa Karvonen 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/pool.html&#34;&gt;pool&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;メモリプールの管理。Steve Cleary 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/random.html&#34;&gt;random&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;乱数生成のためのシステム一式。 Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/rational.html&#34;&gt;rational&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;有理数クラス。 Paul Moore 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/regex.html&#34;&gt;regex&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;正規表現ライブラリ。 John Maddock 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/signals.html&#34;&gt;signals&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;管理されたシグナルとスロットのコールバックでの実装。 Doug Gregor 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/static_assert.html&#34;&gt;static_assert&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;静的アサート(コンパイル時アサート)。 John Maddock 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/smart_ptr.html&#34;&gt;smart_ptr&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;5つのスマートポインタクラステンプレート Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/tuple.html&#34;&gt;tuple&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数の値を返す関数の簡単な定義など。 Jaakko Javi 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/type_traits.html&#34;&gt;type_traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型の基本的な特徴のためのテンプレート。 John Maddock, Steve Cleary, et al 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Rational Number Library -- Boost.Rationalの翻訳ドキュメントを移植(close #20)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/rational.html"/>
      <id>e89a3b43e52a34bc1f84036ce2000b465215e2cb:archive/boost_docs/libs/rational.md</id>
      <updated>2020-06-03T20:41:07+09:00</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;&lt;span class=&#34;token&#34;&gt;Rational Number Library&lt;/span&gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;rational.hpp ヘッダは有理数を扱うための実装を提供する。
有理数ライブラリは、ちょうど一般的な複素数クラスのようにテンプレートベースで実装されている。&lt;/p&gt;
&lt;p&gt;本ライブラリは一般的な用途を想定しており、数論への適用や、それ以外でも、数学的に厳密な演算が必要な場合には、もっと専門的な目的のライブラリを使うことを考えるべきである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/rational/rational.html&#34;&gt;ドキュメンテーション&lt;/a&gt; (HTML).&lt;/li&gt;
&lt;li&gt;Header &lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/boost/rational.hpp&#34; target=&#34;_blank&#34;&gt;ヘッダファイル（rational.hpp）&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;See the &lt;a href=&#34;https://boostjp.github.io/archive/boost_docs/libs/rational/rational.html&#34;&gt;documentation&lt;/a&gt; サンプルプログラム&lt;/li&gt;
&lt;li&gt;Submitted by &lt;a href=&#34;https://www.boost.org/doc/libs/1_31_0/people/paul_moore.htm&#34; target=&#34;_blank&#34;&gt; Paul Moore&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Revised December 14, 1999&lt;/p&gt;
&lt;p&gt;(c) Copyright Paul Moore 1999.
Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies.
This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Rational Numbers -- Boost.Rationalの翻訳ドキュメントを移植(close #20)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/rational/rational.html"/>
      <id>e89a3b43e52a34bc1f84036ce2000b465215e2cb:archive/boost_docs/libs/rational/rational.md</id>
      <updated>2020-06-03T20:41:07+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/rational/rational.md b/archive/boost_docs/libs/rational/rational.md
new file mode 100644
index 0000000..e629d10
--- /dev/null
+++ b/archive/boost_docs/libs/rational/rational.md
@@ -0,0 +1,491 @@
+# Rational Numbers
+
+## &amp;lt;a name=&amp;#34;Contents&amp;#34;&amp;gt;コンテンツ&amp;lt;/a&amp;gt;
+
+1. [Class rational synopsis](#Class rational synopsis)
+2. [理論的根拠](#Rationale)
+3. [背景](#Background)
+4. [基本要素となる整数型の要件](#Integer Type Requirements)
+5. [インターフェイス](#Interface)
+	- [ユーティリティ関数](#Utility functions)
+	- [コンストラクタ](#Constructors)
+	- [算術演算子](#Arithmetic operations)
+	- [入出力](#Input and Output)
+	- [In-place assignment](#In-place assignment)
+	- [型変換](#Conversions)
+	- [分数表現（Numerator and Denominator）](#Numerator and Denominator)
+6. [パフォーマンス](#Performance)
+7. [例外](#Exceptions)
+8. [内部表現](#Internal representation)
+9. [デザインノート](#Design notes)
+	- [最小の実装（Minimal Implementation）](#Minimal Implementation)
+	- [範囲制限された整数型（Limited-range integer types）](#Limited-range integer types)
+	- [浮動小数点データからの型変換](#Conversion from floating point)
+	- [絶対値](#Absolute Value)
+10. [リファレンス](#References)
+11. [History and Acknowledgements](#History and Acknowledgements)
+
+## &amp;lt;a name=&amp;#34;Class rational synopsis&amp;#34;&amp;gt;Class rational synopsis&amp;lt;/a&amp;gt;
+
+```cpp
+#include &amp;lt;boost/rational.hpp&amp;gt;
+
+namespace boost {
+
+template &amp;lt;typename I&amp;gt; I gcd(I n, I m);
+template &amp;lt;typename I&amp;gt; I lcm(I n, I m);
+
+class bad_rational;
+
+template&amp;lt;typename I&amp;gt; class rational {
+    typedef I int_type;
+
+    // コンストラクタ
+    rational();          // ゼロ
+    rational(I n);       // n/1 （つまり、整数値の n）
+    rational(I n, I d);  // n/d に等しい
+
+    // コピーコンストラクタと代入演算子
+
+    // 基本要素となる整数型からの代入
+    rational&amp;amp; operator=(I n);
+
+    // in place 代入
+    rational&amp;amp; assign(I n, I d);
+
+    // （内部の）表記へのアクセス
+    I numerator() const;
+    I denominator() const;
+
+    // 以下の演算子に加えて、継承した演算子が使用可能である。
+    // operators.hpp を参照のこと。
+
+    // 数値演算
+    rational&amp;amp; operator+= (const rational&amp;amp; r);
+    rational&amp;amp; operator-= (const rational&amp;amp; r);
+    rational&amp;amp; operator*= (const rational&amp;amp; r);
+    rational&amp;amp; operator/= (const rational&amp;amp; r);
+
+    // 整数型との数値演算
+    rational&amp;amp; operator+= (I i);
+    rational&amp;amp; operator-= (I i);
+    rational&amp;amp; operator*= (I i);
+    rational&amp;amp; operator/= (I i);
+
+    // インクリメントとデクリメント
+    const rational&amp;amp; operator++();
+    const rational&amp;amp; operator--();
+
+    // 否定演算
+    bool operator!() const;
+
+    // 比較演算
+    bool operator&amp;lt; (const rational&amp;amp; r) const;
+    bool operator== (const rational&amp;amp; r) const;
+
+    // 整数型との比較演算
+    bool operator&amp;lt; (I i) const;
+    bool operator&amp;gt; (I i) const;
+    bool operator== (I i) const;
+}
+
+// 単項演算子
+template &amp;lt;typename I&amp;gt; rational&amp;lt;I&amp;gt; operator+ (const rational&amp;lt;I&amp;gt;&amp;amp; r);
+template &amp;lt;typename I&amp;gt; rational&amp;lt;I&amp;gt; operator- (const rational&amp;lt;I&amp;gt;&amp;amp; r);
+
+// 整数型（と型コンパチブルな型）から有理数クラスを引く／割る演算子
+// Reversed order operators for - and / between (types convertible to) I and rational
+template &amp;lt;typename I, typename II&amp;gt; inline rational&amp;lt;I&amp;gt; operator- (II i, const rational&amp;lt;I&amp;gt;&amp;amp; r);
+template &amp;lt;typename I, typename II&amp;gt; inline rational&amp;lt;I&amp;gt; operator/ (II i, const rational&amp;lt;I&amp;gt;&amp;amp; r);
+
+// 絶対値
+template &amp;lt;typename I&amp;gt; rational&amp;lt;I&amp;gt; abs (const rational&amp;lt;I&amp;gt;&amp;amp; r);
+
+// 入出力
+template &amp;lt;typename I&amp;gt; std::istream&amp;amp; operator&amp;gt;&amp;gt; (std::istream&amp;amp; is, rational&amp;lt;I&amp;gt;&amp;amp; r);
+template &amp;lt;typename I&amp;gt; std::ostream&amp;amp; operator&amp;lt;&amp;lt; (std::ostream&amp;amp; os, const rational&amp;lt;I&amp;gt;&amp;amp; r);
+
+// 型変換
+template &amp;lt;typename T, typename I&amp;gt; T rational_cast (const rational&amp;lt;I&amp;gt;&amp;amp; r);
+```
+
+## &amp;lt;a name=&amp;#34;Rationale&amp;#34;&amp;gt;理論的根拠&amp;lt;/a&amp;gt;
+
+「数」の分類には種々のものがある。
+最も基本的なものとしては、自然数（非負の整数）、そして、整数と実数がある。
+こういった数は（数学的な厳密性は犠牲にされているものの）Ｃ＋＋において `unsigned int`, `int`, `float` （そして、おのおのに対応する異なったサイズのデータ型）として、組み込まれている。
+
+Ｃ＋＋標準ライブラリは、さらに複素数型の機能を提供している。
+
+本ライブラリでは、さらに、**有理数クラス** の機能を提供する。
+
+実際には、本ライブラリにおける **有理数クラス** は、標準ライブラリにおける **複素数** 型と同じくテンプレートベースで提供される。
+
+## &amp;lt;a name=&amp;#34;Background&amp;#34;&amp;gt;背景&amp;lt;/a&amp;gt;
+
+数学的に言えば、有理数とは分数――２つの整数の比で表される数のことである。
+このため、有理数の範囲では表現できない実数値（実数は、２の平方根など分数で表現できない数も表すことができる）も存在する。
+
+コンピュータにおいては数学的な概念を厳密に表現することはできず、数値の扱いにおいて、「妥協」が存在する。
+整数型では値を表現できる範囲に制限（しばしば、32bit幅）が存在し、実数値の近似では精度の限界が存在する。
+こういった、「妥協」は計算の目的に応じて採用されている。
+整数演算は表現範囲が狭いが正確な計算が可能であり、一方、実数演算であれば、精度を犠牲にしなければならないものの、表現できる数値の範囲はずっと広くなる。
+
+有理数ライブラリはこの表現範囲と精度の制限に対して、整数や実数で行われているのとは別の方法を実現するものである。
+有理数による演算は正確に行われる。
+依然として数値の表現範囲に限界があるものの、（通分が行われた後の）分子と分母のデータ長が、テンプレートで使用された整数型のデータ長の範囲である限りにおいては、数値を表現することができる。
+しかしながら、分母や分子の値がテンプレートで与えられた整数型の範囲を超える場合には、演算結果は未定義となる。
+
+有理数クラスは、プログラマが、基本要素となる整数型を適切に選択することによって、オーバーフローの発生を制御できるようにテンプレートクラスとして実装されている。
+たとえば、テンプレートで無限精度の整数型（に類する）クラスが与えられれば、有理数クラスの中でオーバーフローは発生することがなく、あらゆる環境に於いて正確な演算結果が得られる。
+
+## &amp;lt;a name=&amp;#34;Integer Type Requirements&amp;#34;&amp;gt;基本要素となる整数型の要件&amp;lt;/a&amp;gt;
+
+有理数クラスは、単一の型パラメータ `I` をとるテンプレートクラスである。
+この単一の整数型パラメータは、有理数クラスを構成する *基本要素* となる。
+C++ のすべての汎整数型は、型パラメータ `I` として使用できる。
+ユーザー定義の整数型も同様に使用できるが、ユーザー定義型を使用する場合には、ユーザー定義型の演算速度や能力が有理数クラスの演算に大きく影響することを考慮する必要がある。
+（考慮すべき点はしばしば複雑であり――そのため、詳細は後述する [パフォーマンス](#Performance) の項目を参照すること）
+
+補足：boost ライブラリは無限精度整数型をサポートする予定である。
+この無限精度整数型は、有理数クラスの基本要素として利用できるものである。
+
+ユーザー定義の整数型を有理数クラスの基本要素として利用する場合には、以下の関数を準備する必要がある。
+
+- 代入
+- デフォルトコンストラクタ
+- 比較演算子 `==`
+- 比較演算子 `&amp;lt;`
+
+Fさらに、基本要素として利用できる型は、整数型に類似していて、任意の２つのインスタンスの間で以下の演算が、整数型として自然に定義されていなければならない。
+
+- `n + m`
+- `n - m`
+- `n * m`
+- `n / m` （結果は切り捨てられること。また、`n`, `m` が正の場合には結果も正であること）
+- `n % m` （`n`, `m` が正の場合には結果も正であること）
+- 上記の演算結果が代入できること
+- `+n`, `-n`
+
+ユーザー定義整数型に、*０*および、*１* に相当する要素が存在でき。
+それらは、`I(0)` `I(1)` でそれぞれ、生成できなければならない。
+
+補足：この条件は必ずしも `int` 型と暗黙の型変換が可能であることを意味しない。
+`explicit` 修飾されたコンストラクタが存在してもよい。
+
+ユーザー定義整数型として、符号無しのものも許される。
+この場合、生成された有理数クラスもまた符号無しとなる。
+この場合には、引き算によるアンダーフローが発生した場合でも結果は負になることはなく、予測されない結果となる。
+
+- `rational_cast&amp;lt;T&amp;gt;(rational&amp;lt;I&amp;gt;)` が可能か否かは、`I` から `T` への `sataic_cast` が可能かどうかと等価である。
+	また、`x`, `y` がいずれも `T` 型であるときに、`x/y` は有効である。
+- 入出力のための演算子は、型パラメータ `I` における入出力演算子の動作と同様に動作する。
+
+## &amp;lt;a name=&amp;#34;Interface&amp;#34;&amp;gt;インターフェイス&amp;lt;/a&amp;gt;
+
+### &amp;lt;a name=&amp;#34;Utility functions&amp;#34;&amp;gt;ユーティリティ関数&amp;lt;/a&amp;gt;
+
+ユーティリティ関数として、以下の２個が提供される。
+
+|             |                                 |
+|-------------|---------------------------------|
+| `gcd(n, m)` | `n` と `m` の最大公約数を返す。 |
+| `lcm(n, m)` | `n` と `m` の最小公倍数を返す。 |
+
+これらのユーティリティ関数は、有理数クラスの基本要素となる整数型 `I` に対して定義される。
+この際、`I` において以下のオペレータが定義されていなければならない。
+
+`=`, `+=`, `*=`, `/=`, `%`, `&amp;lt;` そして、`I(0)` によって、ゼロ元にアクセスできること。
+
+補足：将来的にこの２つの関数は、別途「ユーティリティライブラリ」のなかで定義される可能性がある
+
+### &amp;lt;a name=&amp;#34;Constructors&amp;#34;&amp;gt;コンストラクタ&amp;lt;/a&amp;gt;
+
+有理数クラスは、２つの整数値（分子、分母）の組み合わせ、あるいは、単一の整数値から生成される。
+また、デフォルトコンストラクタは、値がゼロであるような有理数を生成する。
+コンストラクタとしては、以下の形が有効である。
+
+```cpp
+I n, d;
+rational&amp;lt;I&amp;gt; zero;
+rational&amp;lt;I&amp;gt; r1(n);
+rational&amp;lt;I&amp;gt; r2(n, d);
+```
+
+単一の整数値を取るコンストラクタは、`explicit` 修飾されて *いない* 。
+このため、基本要素となる整数型から有理数クラスへの暗黙の型変換が発生しうる。
+
+### &amp;lt;a name=&amp;#34;Arithmetic operations&amp;#34;&amp;gt;算術演算子&amp;lt;/a&amp;gt;
+
+有理数クラスにおいては、以下に示す標準的な算術演算子が定義される。
+
+```cpp
++    +=
+-    -=
+*    *=
+/    /=
+++   --    前置・後置の両方の演算子）
+==   !=
+&amp;lt;    &amp;gt;
+&amp;lt;=   &amp;gt;=
+```
+
+### &amp;lt;a name=&amp;#34;Input and Output&amp;#34;&amp;gt;入出力&amp;lt;/a&amp;gt;
+
+入出力のために、`&amp;lt;&amp;lt;`  および、`&amp;gt;&amp;gt;` のそれぞれの演算子が定義される。
+有理数クラスの外部での表現形（The external representation）は、`/` で区切られた２つの整数値である。
+入力の場合、`/` と整数値の間にホワイトスペースが存在してはならない。
+（入力においては、整数値の後間にホワイトスペースが存在せずに、`/` が続き、さらにその後にもホワイトスペースが存在せず）２番目の整数値が現れなければならない）整数値の表現形は基本要素となる整数型によって定義される形である。
+
+
+### &amp;lt;a name=&amp;#34;In-place assignment&amp;#34;&amp;gt;In-place assignment&amp;lt;/a&amp;gt;
+
+有理数クラスの任意のインスタンス `rational&amp;lt;I&amp;gt; r` に対して、`r.assign(n, m)`は、一時インスタンスを生成しないため、`r = rational&amp;lt;I&amp;amp;&amp;gt;(n, m);` より高速に処理を行うことができる。
+この機能は、基本要素となる整数型がＣ＋＋組み込みの場合であればそれほど有効ではないかもしれないが、たとえば、無限精度整数型の上に構成された有理数クラスの場合には有効である。
+
+### &amp;lt;a name=&amp;#34;Conversions&amp;#34;&amp;gt;型変換&amp;lt;/a&amp;gt;
+
+有理数クラスは暗黙には他の *いかなる型にも変換されない* 。
+しかしながら、明示的な型変換のためには、関数、 `rational_cast&amp;lt;T&amp;gt;(r)` を提供する。
+これは。
+
+```cpp
+rational r(22,7);
+double nearly_pi = boost::rational_cast&amp;lt;double&amp;gt;(r);
+```
+
+に示すように使用することができる。
+
+関数 `rational_cast&amp;lt;T&amp;gt;` は、分母と分子の両方が安全に `T` にキャストできない場合、あるいは、（`T` にキャストした後で）分子／分母 の（割り算の値が）`T` の範囲で正しく表現できない場合には、未定義動作となる。
+
+本質的には、型変換の際に数字としてみた値が保存され、また、演算結果は理にかなったものでなければならないということである。
+ここに述べるような制約が不都合である場合には、別途ユーザー定義の型変換を行った方がより適切であろう。
+
+*実装上の注意：*
+
+`ratinal_cast&amp;lt;T&amp;gt;` の具体的な実装は、
+
+```cpp
+template &amp;lt;typename Float, typename Int&amp;gt;
+Float rational_cast(const rational&amp;lt;Int&amp;gt;&amp;amp; src)
+{
+    return static_cast&amp;lt;Float&amp;gt;(src.numerator()) / src.denominator();
+}
+```
+
+である。
+しかしながら、この実装に依存するようなプログラムを書いてはならない。
+
+### &amp;lt;a name=&amp;#34;Numerator and Denominator&amp;#34;&amp;gt;分数表現（Numerator and Denominator）&amp;lt;/a&amp;gt;
+
+直接的に有理数クラスの内部表現にアクセスするためには２つの関数、 `numerator()` と、 `denominator()` を使用する。
+
+この２つの関数を使用することで、ユーザーは有理数を取り扱う上の任意の機能を追加することができる。
+とりわけ、上で示した `rational_cast` の実装がうまく動かない場合――基本要素として、無限精度の整数型を使用している場合にはありそうだが――に、ユーザーがもっと適切な浮動小数点型への型変換関数を、別途準備できることに注意したい。
+
+## &amp;lt;a name=&amp;#34;Performance&amp;#34;&amp;gt;パフォーマンス&amp;lt;/a&amp;gt;
+
+有理数クラスは、基本要素となる整数型が、組み込みの整数型と“類似の”振る舞いをすることを暗黙のうちに想定している。
+この基本要素となる整数型の振る舞いを明文化したものが、前述した [基本要素となる整数型の要件](#Integer Type Requirements) である。
+しかしながら、振る舞いの他にも、演算のパフォーマンスもまた組み込みの整数型と同等であることも、暗黙のうちに想定されている。
+
+有理数クラスにおける演算のパフォーマンスを精密に保証することはできない。
+その上、パフォーマンスにおける議論は（標準クラスライブラリに於いても同様であるが）ユーザーに詳細な演算コストを提供するためには、有用なものではない。
+その代わりに、このセクションでは有理数クラスの特性に関する一般的な情報を提供する。
+
+ここでは、[`&amp;lt;boost/rational.hpp&amp;gt;`](https://www.boost.org/doc/libs/1_31_0/boost/rational.hpp) に定義された演算子と、その演算子の実行にかかるコストの非公式なリストを示す。
+このリストの内容は、現時点の実装に依存しているものであり、将来変更される可能性があるととに注意されたし。
+
+- コンストラクタの実行は、本質的には２つの要素を基本要素の型で生成し、約分を行うことである。
+- インクリメントとデクリメントは、基本要素の型における加算および減算と同じ程度の負荷である。
+- 等号および、不等号の比較は、基本要素の型における同一の比較と同じ程度の負荷である。
+- I/O の負荷は低くはない。
+	しかしながら、本質的には I/O の動作自体の時間がほとんどである。
+- `gcd()` 関数は、本質的には剰余演算の繰り返しである。
+	このほかに、コンストラクタ・代入・０との比較が行われるが、これらの負荷は剰余演算に比べると、取るに足らないものである。
+- `lcm()` 関数は、本質的に `gcd()` を算出した後、２回の乗算と（１回の）除算を行うものである。
+- 加算と減算は複雑である。
+	加算と減算には基本要素となる整数型上で、平均して２回の `gcm()` 、３回の除算、３回の乗算と１回の加算が必要である。
+- 乗算と除算には、２回の ``gcd()、２回の乗算、そして、４回の除算が必要である。
+- 比較演算子の実行には、最悪の場合、２回の `gcd()` , ２回の乗算、４回の除算、そして比較が必要である。
+	しかしながら、`int` タイプにおける比較演算のコストが低い（そして、０との比較はさらに低コストである）と仮定すると、比較演算のオーバーヘッドを下げることのできる特別なケースがいくつか存在する。
+	特に、 `==` と `!=` の実行時間は、基本要素となる整数型の比較時間程度のコストで終了する。
+- 残りの基本的な演算は、約分である。
+	約分はコンストラクタの起動時と、内部での代入の際に暗黙のうちに実行される。
+	その他の演算結果も基本要素となる整数型の範囲に収まるように注意深く約分される。
+	約分のコストは、 `gcd()` １回と、除算が２回分に相当する。
+
+上記の議論の際に、注意すべきことは、基本要素となる整数型の演算は“常識的な”パフォーマンスで実行できることが暗黙のうちに仮定されているということ――すなわち、演算コストがかかるのは乗算・除算・剰余の計算であり、加算と減算のコストは比較的安価だと仮定されているということである。
+コンストラクタ（整数値０，１から生成される場合）と代入のコストはさらに安価だと仮定しているが、それでも、本有理数クラスライブラリにおいて、不要なコンストラクタやコピーが発生しないような配慮は行っている。
+また、比較（特に０に対する比較）の演算コストも低いと仮定している
+
+以上のような仮定に合致しない整数型は、有理数クラスの基本要素としては有用ではない。
+殊にパフォーマンスの点では、ひどく重く、最適化できない。
+
+## &amp;lt;a name=&amp;#34;Exceptions&amp;#34;&amp;gt;例外&amp;lt;/a&amp;gt;
+
+有理数クラスでは、分母がゼロとなることは決してない。
+（本ライブラリでは、NaN や無限大の表現形式としても、分母がゼロになることはない）
+そのため、分母の値が０となる場合には、`boost::bad_rational` 例外（これは、`std::domain_error` のサブクラスである）をスルーする。
+これは、ユーザーが分母を０としてコンストラクタを実行した場合と、任意の有理数クラス数値を、ゼロで除算しようとした際にのみ発生する。
+
+さらに、基本要素となる整数型での演算の結果、例外が発生した場合には、その例外は有理数クラスクラスに伝番する。
+原則はひとつである。基本要素となる整数型がスルーするあらゆる例外は、有理数クラスのあらゆる演算に於いてスルーされる。
+加えて、有理数クラスのコンストラクタは、正規化の段階に於いて基本要素クラスで発生した例外をスルーする。
+この事項に対する唯一の例外事項は、有理数クラスのデストラクタは、基本要素クラスのデストラクタがスルーした例外しかスルーしないということである（ただし、通常デストラクタの実行中に基本要素クラスで例外が発生することはない）
+
+## &amp;lt;a name=&amp;#34;Internal representation&amp;#34;&amp;gt;内部表現&amp;lt;/a&amp;gt;
+
+*補足：* ここで記述する内容は単純に情報を提供するためにのものにすぎない。
+プログラミングの際に、ここで述べるような実装の詳細に依存するようなプログラムを書くべきではない。
+
+内部的には有理数クラスは、分子・分母の２つの整数型（テンプレートで与えられる型パラメータである）の値として保持される。
+有理数クラスの内部表現に置いては、常に約分（すなわち、分子と分母の最大公約数が１となる状態）され、分母が正であるように正規化されている。
+
+## &amp;lt;a name=&amp;#34;Design notes&amp;#34;&amp;gt;デザインノート&amp;lt;/a&amp;gt;
+
+### &amp;lt;a name=&amp;#34;Minimal Implementation&amp;#34;&amp;gt;最小の構成となるような設計&amp;lt;/a&amp;gt;
+
+有理数クラスは数としての基本原則を崩さないように実装されている。
+有理数として持つべき最小限の機能しか持たないが、基本要素となる整数型にアクセスするための、 `numerator()` と `denominator()` の関数を持つことで、必要に応じて、どのような機能拡張も行うことができる。
+
+入出力と、 `rational_cast()` の関数については厳密には、有理数として持つべき最小構成の範囲からは逸脱している。
+入出力については明らかであろう。
+しかしながら、浮動小数点型の変数に型変換するたために、 `rational_cast()` が最善でない場合もある。
+（ことにユーザー定義型の浮動小数点型への変換は複雑である）
+こういった場合には、ユーザー定義の型変換関数を定義することができるし、また、すべきである。
+このユーザー定義による型変換関数が、 `rational_cast()` という名前である必要はない。
+そのため、 `rational_cast()` が、特殊化／オーバーロード可能な形で定義される *必要はない* 。
+
+### &amp;lt;a name=&amp;#34;Limited-range integer types&amp;#34;&amp;gt;基本要素の数値表現範囲（Limited-range integer types）&amp;lt;/a&amp;gt;
+
+有理数クラスは、表現範囲に制限のないような整数型を使用するように設計されている。
+このような整数型を要素として利用する場合には、演算結果は常に正確に表現され、桁落ちやオーバーフロー／アンダーフローの問題も発生することはない。
+
+不幸なことに、標準の C++ においては、このような整数型を使用することはできない（boost ライブラリにおいても、現時点では同様である）
+このような事情で、有理数クラスは、多分、C++ の `int` のような、数値表現の範囲に限界を持った型を基本要素として使用されるであろう。
+
+数値表現の範囲が限定されるような要素を基本要素として使用した場合、有理数クラスは、ちょうど浮動小数点型と同じような多くの精度の問題に見舞われる。
+しかしながら、有理数クラスがシンプルな使われ方をしている限りは精度の問題が表面化することは少ないものと考える。
+それでも、ユーザーは整数型の表現範囲が制限されることによる精度の問題が発生しうることを考慮しておくべきである。
+
+表現範囲が制限された整数型の影響による問題点を、C++ の `int` を 32bit の符号付きであるものとして説明する。
+この場合、 `rational&amp;lt;int&amp;gt;` として表現できるもっとも小さな正数値は、`1/0x7FFFFFFF` である。
+換言すれば、０の近辺では、 `rational&amp;lt;int&amp;gt;` で表現できる“粒度”は、約 4.66e-10 である。
+他方、 `rational&amp;lt;int&amp;gt;` で表現可能な最大の数は、`0x7FFFFFFF/1` であり、 `rational&amp;lt;int&amp;gt;` におけるその次に小さい数は、`0x7FFFFFFE/1` である。
+これは、表現可能な最大値付近では数値の粒度は１であることを意味している。
+このように、数値の粒度が数値の絶対値の影響を受けることがすなわち、浮動小数点数と同じ特徴なのである。
+しかしながら、このような性質は有理数クラスを使用する上で、自然なものとは“感じられない”だろう。
+
+有理数クラスの基本要素として、表現範囲が制限された整数型を使用することの得失に注意し、前もって意識するのはユーザー次第だということである。
+
+### &amp;lt;a name=&amp;#34;Conversion from floating point&amp;#34;&amp;gt;浮動小数点型からの型変換&amp;lt;/a&amp;gt;
+
+有理数クラスライブラリでは、浮動小数点型から有理数クラスへの型変換関数を提供していない。
+浮動小数点型から有理数クラスへの型変換関数を希望する意見をいくつか受け取ってはいる。
+しかしながら、boost における広範な議論の結果として、浮動小数点型からの型変換には“最適解”が存在しないという結論に達した。
+本ライブラリのユーザーが、その目的に適した型変換関数を作成することは可能であるが、そのいずれをも、“スタンダード”として採用することはできなかった。
+
+浮動小数点型からの型変換を行う際にもっとも大きな問題となるのは、浮動小数点型の演算における誤差をどう扱うかという点である。
+以下のコードで具体的な例を示す
+
+```cpp
+// 以下の２つの数値は、ユーザによる入力であったり、
+// 計測器からの入力であったりする。
+double x = 1.0;
+double y = 3.0;
+
+double z = x/y;
+
+rational&amp;lt;I&amp;gt; r = rational_from_double(z);
+```
+
+根本的な疑問は、この場合 `r` の値はどうなるかということである。
+自然な回答は、`1/3` ということになるが、これはたくさんの問題を無視しているものである。
+
+まず、`z` は厳密には `1/3` でないという点が挙げられる。
+浮動小数点型の持つ制度上の限界から、どのような表現形式を以てしても `1/3` を厳密に表現することはできないのである。
+それなら、`r` は、`z` それ自体の値を（厳密に）に表現すればよいのだろうか？
+`r` の値として、`33333333333333331/100000000000000000` を用いることが適切なのであろうか？
+
+しかし、`z` の厳密性を議論する前に、そもそも、`x` と `y` の厳密性について議論しなければならない。
+例えば、`x` や `y` の値がアナログ的な計測器の計測結果であったとしたら、常に有限の精度でしか評価できない。
+この場合、有理数クラスで勝手な桁数の精度を一律に仮定することは、元の精度を悪化させることになる。
+
+このような議論ののち、“単純な整数比のうちで、最も近いもの”を探すべきなのではないかと思うかもしれない。
+しかも、このような数値を求めるためのアルゴリズムは実際に存在する。
+しかしながら、すべてのアプリケーションでこの方法が最適であるとは限らない。
+別の例では、一連の計算における桁落ちを防止するために、有理数クラスへの変換の際に正確性が要求される。
+この場合には、たとえ数値表現の上で“不自然”であったとしても、厳密な値を表現する必要がある。
+
+このような相容れない要求に対して、万人を満足させる単一の解決方法を見いだすことはできなかった。
+その上に、有理数クラスの演算に対するアルゴリズムは複雑であり、また専門化されているため、アプリケーションに要求される事項を理解した上で、最適な実装を行うことが良いと考える。
+
+### &amp;lt;a name=&amp;#34;Absolute Value&amp;#34;&amp;gt;絶対値&amp;lt;/a&amp;gt;
+
+普通に考えれば、基本要素となる整数型の絶対値 `abs(IntType)` が定義されていれば、これを用いて、有理数クラスにおける絶対値（ `rational&amp;lt;IntType&amp;gt;` ）が定義されているべきであると考えられるだろう。
+しかしながら、絶対値を定義するにはいくつもの問題が存在する。
+
+最初の問題は、 `abs()` 関数の探索に関する問題である。
+`asb(IntType)` の実装を調べるためには、特に、`IntType` がユーザーの定義した形であり、ユーザー定義の名前空間にある場合、Koenig lookup （関数を引数の所属する名前空間で探索すること）が必須となる。
+現時点では、関数についてはこの機能をサポートしていないコンパイラも存在する。
+このような機能をサポートしないコンパイラを使用する場合には、ユーザーは意図的に、有理数クラスの動作と協調できるようなクラス設計を行う必要がある。
+
+次の問題は、標準的でない組込整数型の問題であり、こちらの方がより深刻な問題であると考えられる。
+`long long` や `__int64` のような標準的でない組み込み整数型に対して、コンパイラベンダーが `abs()` 関数を提供するという保証がないことである。
+これは、実装品質の問題ではあるが、しかしながら、`long long` のような型の追加自体が多分に場当たり的なものであるのだ。
+
+結論は、 `abs(IntType)` を使用して、 `abs(rational&amp;lt;IntType&amp;gt;)` を定義することは実用的ではないということだ。
+代わりに、以下のシンプルなインライン関数を使用している。
+
+```cpp
+template &amp;lt;typename IntType&amp;gt;
+inline rational&amp;lt;IntType&amp;gt; abs(const rational&amp;lt;IntType&amp;gt;&amp;amp; r)
+{
+    if (r.numerator() &amp;gt;= IntType(0))
+        return r;
+
+        return rational&amp;lt;IntType&amp;gt;(-r.numerator(), r.denominator());
+}
+```
+
+このことから、基本要素となる整数型の絶対値が他の場所で定義されたとしても、有理数クラスの絶対値はインライン関数で計算できるということがわかる。
+
+
+## &amp;lt;a name=&amp;#34;References&amp;#34;&amp;gt;リファレンス&amp;lt;/a&amp;gt;
+
+- 有理数クラスのヘッダファイル： [rational.hpp](https://www.boost.org/doc/libs/1_31_0/boost/rational.hpp)
+- サンプルコード： [rational_example.cpp](https://www.boost.org/doc/libs/1_31_0/libs/rational/rational_example.cpp)
+- 回帰テスト： [rational_test.cpp](https://www.boost.org/doc/libs/1_31_0/libs/rational/rational_test.cpp)
+
+## &amp;lt;a name=&amp;#34;History and Acknowledgements&amp;#34;&amp;gt;History and Acknowledgements&amp;lt;/a&amp;gt;
+
+1999年12月著者（原著者 Paul Moore）は、有理数クラスの最初の実装を行い、 [boost.org](http://www.boost.org/) メーリングリストに投稿した。
+メーリングリストにおいて、いくつかの議論が交わされた。
+殊に、Andrew D. Jewell は、オーバーフローとアンダーフローの発生を防止することの重要性を指摘するとともに、ほとんどの基本的な数値演算に於いてオーバーフローを回避するための実装方法を提供してくれた。
+`rational_cast` は、Kevlin Henney の提案によるものである。
+Ed Brey は、オリジナルのソースコードにあった、少なくないタイプミスについて、重要なコメントを与えてくれた。
+
+David Abrahams は、このドキュメントに於いて有用なフィードバックを行ってくれた
+
+浮動小数点型から、有理数クラスへの型変換関数を提供することについては、boost メーリングリストで、2000年11月に長い議論が交わされた。
+Reggie Seagraves, Lutz Kettner そして、Daniel Frey を含む、メンバーがこの点の中心メンバーとなった（もっとも、boost メーリングリストのほとんどのメンバーがそれぞれに、白熱した議論に参加していたのを感じているが）それでもなお、議論の最終結論としての実装は *行えなかった。*
+浮動小数点からの変換関数を巡る問題を理解するためには、このメーリングリストでの議論は価値のあるものである。
+
+Stephen Silver は、有理数クラスをユーザー定義の整数型の上で使用する際の、有用な知見を示してくれた。
+
+Nickolay Mladenov は、`operator+=` と `operator-=` の、現行の実装を提供してくれた。
+
+上述した、有理数クラスの理論的な説明部分、[絶対値](#Absolute Value) と、[Swap Operation](#Swap Operation) に現れた、Koenig lookup と、`std::swap` について議論は、2001年1月に、boost メーリングリストで行われた。
+
+Revised February 5, 2001
+
+(c) Copyright Paul Moore 1999-2001.
+Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies.
+This document is provided &amp;#34;as is&amp;#34; without express or implied warranty, and with no claim as to its suitability for any purpose.
+
+Japanese Translation Copyright (C) 2003 FUJIHARA Keiichi &amp;lt;keiichi@fujihara.name&amp;gt;.
+オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。
+このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。
+また、いかなる目的に対しても、その利用が適していることを関知しない。
+
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Appendices. -- Boost.Regexの翻訳ドキュメントを修正(#21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/appendix.html"/>
      <id>cdcafeb6853d3125b6d11af5a2466534909da2c6:archive/boost_docs/libs/regex/appendix.md</id>
      <updated>2020-06-01T23:03:58+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/appendix.md b/archive/boost_docs/libs/regex/appendix.md
index 152cd40..1d1af68 100644
--- a/archive/boost_docs/libs/regex/appendix.md
+++ b/archive/boost_docs/libs/regex/appendix.md
@@ -434,13 +434,13 @@ Files: [`regex_timer.cpp`](https://www.boost.org/doc/libs/1_31_0/libs/regex/exam
 また boost の人々は私に *考え*させてくれた、以上。
 以下の人々は皆、有益なコメントや修正をしてくれた:
 Dave Abrahams, Mike Allison, Edan Ayal, Jayashree
-Balasubramanian, Jan BNBvlsche, Beman Dawes, Paul Baxter, David
+Balasubramanian, Jan BNBvlsche, Beman Dawes, Paul Baxter, David
 Bergman, David Dennerline, Edward Diener, Peter Dimov, Robert
 Dunn, Fabio Forno, Tobias Gabrielsson, Rob Gillen, Marc Gregoire,
 Chris Hecker, Nick Hodapp, Jesse Jones, Martin Jost, Boris
 Krasnovskiy, Jan Hermelink, Max Leung, Wei-hao Lin, Jens Maurer,
 Richard Peters, Heiko Schmidt, Jason Shirk, Gerald Slacik, Scobie
-Smith, Mike Smyth, Alexander Sokolovsky, HervNBi Poirier, Michael
+Smith, Mike Smyth, Alexander Sokolovsky, HervNBi Poirier, Michael
 Raykh, Marc Recht, Scott VanCamp, Bruno Voigt, Alexey Voinov,
 Jerry Waldorf, Rob Ward, Lealon Watts, Thomas Witt and Yuval
 Yosef. 
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, FAQ. -- Boost.Regexの翻訳ドキュメントを修正(#21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/faq.html"/>
      <id>215bcda0a1e20b95b370a550468c9b7439c340d9:archive/boost_docs/libs/regex/faq.md</id>
      <updated>2020-06-01T22:57:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/faq.md b/archive/boost_docs/libs/regex/faq.md
index 959afd2..b68dfea 100644
--- a/archive/boost_docs/libs/regex/faq.md
+++ b/archive/boost_docs/libs/regex/faq.md
@@ -79,7 +79,7 @@ A. 静的なデータを含むテンプレートを結合できないコンパ
 regex++ のデフォルトの振る舞いは、 無名名前空間の中で &amp;#34;problem&amp;#34; テンプレートを宣言することにより、この問題を修復しようとするので、テンプレートは内部リンケージをもつ。
 これが、大量のコード膨張を引き起こすことに注意せよ。
 もしコンパイラが名前空間をサポートしていないか、コード膨張が問題になったら、単一翻訳単位の中に全てのテンプレートを置くための上のガイドラインに従うこと。
-そして、 boost/regex/config.hpp を編集し、 `BOOST_REGEX_NO_TEMPLATE_SWITCH_MERGE` を定義しないようにすること。
+そして、 `boost/regex/config.hpp` を編集し、 `BOOST_REGEX_NO_TEMPLATE_SWITCH_MERGE` を定義しないようにすること。
 
 ### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. 私は regex++ でエスケープ文字を使うことが出来ません。何が起こっているのですか？&amp;lt;/font&amp;gt;
 
@@ -100,7 +100,7 @@ A. POSIX 標準は、文字範囲表現がロケールに敏感であること
 後者の場合、もしロケールに敏感な照合を行いたくなければ、 `REG_NOCOLLATE` を `REG_BASIC` か `REG_EXTENDED` を組み合わせて使えばよい。
 *[注意: `regbase::nocollate` が作用しているとき、ライブラリは、実際にの設定値に関わらず、`_COLLATE` ロケートカテゴリーが常に &amp;#34;C&amp;#34; である &amp;#34;かのように&amp;#34; 振る舞う。]*
 
-### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;&amp;amp;nbsp;Q. なぜ私は、「簡易版の」 `query_match/reg_search/reg_grep/reg_format/reg_merge` を使うことが出来ないのですか?&amp;lt;/font&amp;gt;
+### &amp;lt;font color=&amp;#34;#FF0000&amp;#34;&amp;gt;Q. なぜ私は、「簡易版の」 `query_match/reg_search/reg_grep/reg_format/reg_merge` を使うことが出来ないのですか?&amp;lt;/font&amp;gt;
 
 A. これらの簡易版はあなたのコンパイラの能力によって使えたり使えなかったりする。
 これらの関数の形式を決定する規則は極めて複雑である。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Regex++, Traits Class Reference. -- Boost.Regexの翻訳ドキュメントを修正(#21)</title>
      <link href="https://boostjp.github.io/archive/boost_docs/libs/regex/traits_class_ref.html"/>
      <id>215bcda0a1e20b95b370a550468c9b7439c340d9:archive/boost_docs/libs/regex/traits_class_ref.md</id>
      <updated>2020-06-01T22:57:15+09:00</updated>
      
        <summary type="html">&lt;pre&gt;&lt;code&gt;diff --git a/archive/boost_docs/libs/regex/traits_class_ref.md b/archive/boost_docs/libs/regex/traits_class_ref.md
index ee91fed..d92cdb6 100644
--- a/archive/boost_docs/libs/regex/traits_class_ref.md
+++ b/archive/boost_docs/libs/regex/traits_class_ref.md
@@ -57,7 +57,7 @@ class mytraits
       syntax_digit = 17,                        // 0-9
       syntax_b = 18,                            // for \b
       syntax_B = 19,                            // for \B
-      syntax_left_word = 20,                    // for \&amp;amp;lt;
+      syntax_left_word = 20,                    // for \&amp;lt;
       syntax_right_word = 21,                   // for \
       syntax_w = 22,                            // for \w
       syntax_W = 23,                            // for \W
&lt;/code&gt;&lt;/pre&gt;</summary>
      
      <author>
        <name>Shogo Furusawa</name>
        <email>graighle@gmail.com</email>
      </author>
    </entry>
  
</feed>