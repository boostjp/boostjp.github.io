<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-01-17T00:32:26.412475</updated>
  <id>2b235f10-b522-4d11-b357-02b51858302b</id>

  
    <entry>
      <title>第3回 C++Now! 読書会 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/cpp_online_reading/archive_003.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:archive/cpp_online_reading/archive_003.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;第3回 C++Now! 読書会&lt;/h1&gt;
&lt;h2&gt;日時&lt;/h2&gt;
&lt;p&gt;2012/09/23 13:00-&lt;/p&gt;
&lt;h2&gt;資料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#haskell-pseudo-cpp&#34;&gt;Haskell - C++テンプレートメタプログラミングのための擬似言語&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;参加者リスト&lt;/h2&gt;
&lt;p&gt;2名。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LNSEAB&lt;/li&gt;
&lt;li&gt;manga_osyo&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;ログ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://lingr.com/room/reading_cpp_now_2012_doc/archives/2012/09/23#message-12089750&#34; target=&#34;_blank&#34;&gt;http://lingr.com/room/reading_cpp_now_2012_doc/archives/2012/09/23#message-12089750&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/osyo-manga/20120923/1348379488&#34; target=&#34;_blank&#34;&gt;http://d.hatena.ne.jp/osyo-manga/20120923/1348379488&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>第4回 C++Now! 読書会 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/cpp_online_reading/archive_004.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:archive/cpp_online_reading/archive_004.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;第4回 C++Now! 読書会&lt;/h1&gt;
&lt;h2&gt;日時&lt;/h2&gt;
&lt;p&gt;2012/10/07 13:00-&lt;/p&gt;
&lt;h2&gt;資料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#haskell-pseudo-cpp&#34;&gt;Haskell - C++テンプレートメタプログラミングのための擬似言語&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;参加者リスト&lt;/h2&gt;
&lt;p&gt;4名。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lindan&lt;/li&gt;
&lt;li&gt;manga_osyo&lt;/li&gt;
&lt;li&gt;saki7&lt;/li&gt;
&lt;li&gt;yutopp&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;ログ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://lingr.com/room/reading_cpp_now_2012_doc/archives/2012/10/07#message-12332231&#34; target=&#34;_blank&#34;&gt;http://lingr.com/room/reading_cpp_now_2012_doc/archives/2012/10/07#message-12332231&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/osyo-manga/20120923/1348379488&#34; target=&#34;_blank&#34;&gt;http://d.hatena.ne.jp/osyo-manga/20120923/1348379488&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BoostCon 2010 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/boostcon/2010.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:boostcon/2010.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;BoostCon 2010&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/&#34; target=&#34;_blank&#34;&gt;2010 Program - boostcon&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/2010_presentations&#34; target=&#34;_blank&#34;&gt;BoostCon 2010 Presentations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#clang-lib&#34;&gt;Clang: オープンソースのC++コンパイラライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#generic-programming-graph-lib&#34;&gt;ジェネリックプログラミングとBoost Graph Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#geometry&#34;&gt;幾何学のためのジェネリックプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#instantiations-must-go&#34;&gt;Instantiations Must Go!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-update&#34;&gt;C++0x update&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#exception-safety&#34;&gt;C++での例外使用に関するガイドラインの再考 - 例外安全なコードを効果的に設計するための10の助言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-rad-framework&#34;&gt;RAD Spiritのためのフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#is-boost-broken&#34;&gt;Is Boost Broken?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#data-structure-visualizers&#34;&gt;Data Structure Visualizers in Visual Studio 2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#alabaster&#34;&gt;Boost.Alabaster: A Law Based Tester&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tool-builder&#34;&gt;C++ Tool-Builders Workshop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-concurrency&#34;&gt;C++0x Concurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#basic-lock-free&#34;&gt;Lock-freeプログラミングの基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tboost-stm&#34;&gt;TBoost.STMエンジン: コミット時無効化を使用したSoftware Transactional Memoryの効率化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-v2&#34;&gt;Using Spirit V2: Qi and Karma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#boost-test&#34;&gt;Production use of Boost.Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#asio-based-flash-xml-server&#34;&gt;An Asio Based Flash XML Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#msm-v2&#34;&gt;The Meta State Machine Library V2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#overview-of-transactional-memory&#34;&gt;Transactional Memoryの概観&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#ame-pattern-library&#34;&gt;AME Patterns Library: モデリング、認識、シーケンシャルパターンの統合のためのジェネリックライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#type-erasure&#34;&gt;Type Erasure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#dsel-design&#34;&gt;Protoによる実用的なDSELの設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#network-library-implementation&#34;&gt;柔軟なヘッダオンリーC++ネットワークライブラリ実装の手法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#mime&#34;&gt;A MIME library for Boost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#nt2&#34;&gt;The Numerical Template Toolbox : 高性能コンピューティングのための加速(Boost)されたGeneric配列ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#functional-programming&#34;&gt;C++による関数型プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#logic&#34;&gt;C++による論理型パラダイム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#qt&#34;&gt;QtとBoostによるクロスプラットフォーム開発&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-history-and-evolution&#34;&gt;Spiritの歴史と進化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#future-of-boost&#34;&gt;Future of Boost Panel ’10&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#clang-lib&#34; name=&#34;clang-lib&#34;&gt;Clang: オープンソースのC++コンパイラライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Clang: An Open-Source C++ Compiler Library&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Clangは、C言語ファミリー(C, C++, Objective-C)のための新たなオープンソースコンパイラフロントエンドである。&lt;br /&gt;
C++コンパイラとして、Clangは速く提供できる生産品質なコンパイラであり、省メモリ使用、表現力豊かな診断、標準一致に関する強い関心で、低レベル仮想マシン(Low Level Virtual Machine ： LLVM)を通じて、様々な構造のためにコード生成を最適化した。&lt;/p&gt;
&lt;p&gt;しかし、Clangはコンパイラを超えるものである。&lt;br /&gt;
再使用可能なC++コンパイラライブラリとして設計され、Clangは大きなC++開発ツールを作るためのプラットフォームである。&lt;br /&gt;
Clang内部のデータ構造は、プログラムソースコードに関する完全な構文情報(マクロを含む、正確な位置情報)とセマンティクス(解決されたオーバーロード関数呼び出し、暗黙の変換)、両方を提供する。&lt;br /&gt;
その、Boost互換で、BSDライクなオープンソースライセンスは、新たなC++言語機能とアイデアのための潜在的な実験場としてや、C++コードを完全に、正しく構文解析することに依存するあらゆるツールのための理想的なベースにもなる。&lt;/p&gt;
&lt;p&gt;このトークでは、Clangコンパイラを導入し、その豊かな内部のデータ構造がどれほど大きなユーザーエクスペリアンスを提供するか、次に、Clangに基づく開発ツールを作るためのアーキテクチャ、主要なデータ構造と、ライブラリのチュートリアルに焦点をあてる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#generic-programming-graph-lib&#34; name=&#34;generic-programming-graph-lib&#34;&gt;ジェネリックプログラミングとBoost Graph Library&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming And the Boost Graph Library&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jeremy-siek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;グラフのアルゴリズムとデータ構造は、インターネットパケットルーティング、分子生物学、科学的なコンピューティング、電話ネットワーク設計などの多様な領域の問題を解決するが伝統的なグラフライブラリ設計は、十分な柔軟性を提供することに失敗していた。&lt;br /&gt;
Boost Graph Library(BGL)はSTLをグラフドメインに適用し、グラフ問題を解決するための非常に柔軟で効率的なライブラリとなった。&lt;br /&gt;
しかし、BGLは使うのが難しいため、このチュートリアルではプログラミングの基本原則を学び、それらがBGLでどう適用されるのかを学んでいく。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#href&#34; name=&#34;geometry&#34;&gt;計算幾何のためのジェネリックプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming for Geometry&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#barend-gehrels&#34; target=&#34;_blank&#34;&gt;Barend Gehrels&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#bruno-lalande&#34; target=&#34;_blank&#34;&gt;Bruno Lalande&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#mateusz-loskot&#34; target=&#34;_blank&#34;&gt;Mateusz Loskot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Geometryは、現代のC++ジェネリックプログラミング手法を使用して設計された。&lt;br /&gt;
タグディスパッチはいたるところで使用され、メタ関数、テンプレートメタプログラミング、Traitsおよびコンセプトチェックを組み合わせた。&lt;br /&gt;
この講義では、タグディスパッチによって通常ではとれない値をとるなどの、手法を一歩一歩説明し、どのようにそれを使用することができるか、他の技術を組み合わせることができるかを解説する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#instantiations-must-go&#34; name=&#34;instantiations-must-go&#34;&gt;Instantiations Must Go!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#matt-calabrese&#34; target=&#34;_blank&#34;&gt;Matt Calabrese&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#zachary-laine&#34; target=&#34;_blank&#34;&gt;Zachary Laine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon 2009では、メタ関数を簡単に書くための取り組みで変なことをしていたが、あとで多くの専門家と話してそれが不可能であることがわかった。一方、彼らは時々ゾッとするようなTMPのコードをより通常の関数プログラミングのようなコードで書き、大部分のメタ関数のテンプレート定義(宣言ではない)をインスタンス化する必要性を取り除くおもしろい手法を発見した。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-update&#34; name=&#34;cpp0x-update&#34;&gt;C++0x update&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-wong&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;
形式 ： 講義
トラック ： Track II 2010&lt;/p&gt;
&lt;p&gt;BoostCon 2009から継続して、最新コンパイラの実装状況に関するレポートと、C++0x機能に関する最新ニュースについての詳細を伝える。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#exception-safety&#34; name=&#34;exception-safety&#34;&gt;C++での例外使用に関するガイドラインの再考 - 例外安全なコードを設計するための10の助言&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Demystifying C++ Exceptions – 10 Tips to Effectively Design Exception-Safe Code&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#ken-joyner&#34; target=&#34;_blank&#34;&gt;Ken Joyner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例外安全なコードを書くことが挑戦的であることは有名である。これは、多くの開発者に、例外の使用が避けられるべきであると結論させる。しかし、この結論に関する問題は、開発者が例外を使わずにエラー安全なコードを書くことがより簡単であると仮定しているということである。私は、この仮定が間違っていると考える。その代わりに、私は実際には、多くの開発者がエラー安全なコードを書くというわけではないと考えている。そして、例外は発生するエラーを無視することは、より挑戦的になる。(あなたのプログラムが未処理例外で終わるので処理しなければならない)&lt;/p&gt;
&lt;p&gt;エラー安全なコードを書くのは例外の使用のあるなしにかかわらず、やりがいがある。そして、エラー安全なコードを書かないのは予測できない、不安定なコードをもたらす。&lt;/p&gt;
&lt;p&gt;この論文は、(いくつかの修正をした)例外安全性のレベルを再文書化した例外安全推奨を提供する。これは、会社や開発者が必要とする、安全性のレベルを達成するために従うべき実質的なガイドラインの包括的なマニュアルとなる。特定の推奨とともに例外を使用することで、エラー安全なコードを書くことを、例外を使用することへの付加的な利益を加えるとともに、挑戦的なことをしないで済むアシスタントライブラリを提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-rad-framework&#34; name=&#34;spirit-rad-framework&#34;&gt;RAD Spiritのためのフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Framework for RAD Spirit&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-de-guzman&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#hartmut-kaiser&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;従来のパーサージェネレータと比較したBoost Spiritパーサーの魅力は、それがC++に埋め込まれることである。ライブラリのユーザーは、C++コードにおいてExpression Templateを使ってパーサー文法を直接指定する。このアプローチには利点もあるが、同時に問題もある。&lt;/p&gt;
&lt;p&gt;最も目に付く問題点は、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コンパイル時間が長い&lt;/li&gt;
&lt;li&gt;エラーメッセージを理解するのが難しい&lt;/li&gt;
&lt;li&gt;パーサーのデバッグとテストが難しい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という点である。&lt;/p&gt;
&lt;p&gt;小さな構文解析については、これらは許容できる。しかし、アクティブな開発の8年後、より複雑な構文解析の中で使用されるポイントに来た。2と3はどうにか、Protoを使用することで軽減できる。しかしそれは、ライブラリがもはや役に立たない点にコンパイル時間を増大させる。&lt;/p&gt;
&lt;p&gt;EBNF/PEG式を受け入れて、すぐに実行可能であるパーサーかC++ Boost Spiritコードを出力するツールを持つことはおもしろい。RADツールは、パーサーを記述することをできるだけ容易にする。&lt;/p&gt;
&lt;p&gt;私たちは、そのようなツールの設計と開発を示したい。明らかに、この「動的なSpirit」ツールは「静止なSpirit」を使用して書かれるだろう。これはSpiritを使用した、本当に実用的な例になるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#is-boost-broken&#34; name=&#34;is-boost-broken&#34;&gt;Is Boost Broken?&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#robert-ramey&#34; target=&#34;_blank&#34;&gt;Robert Ramey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostのいいところ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;形式的なレビュープロセスによるライブラリ品質と完全性の「証明」&lt;/li&gt;
&lt;li&gt;形式的なテスト、リリースプロセスの実施による信頼できる実装の「証明」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostは拡張性が高くない&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テスト時間が長く、より長くなる・・・&lt;/li&gt;
&lt;li&gt;有名でないコンパイラをテストすることは難しい&lt;/li&gt;
&lt;li&gt;現在のテストはコンパイラ設定(RTTIのON/OFF、デバッグ/リリース、STLライブラリなど)のすべての可能な組み合わせを扱うことができるというわけではない&lt;/li&gt;
&lt;li&gt;より多くのライブラリが追加されるとき、インストールが面倒で、壊れやすくなる&lt;/li&gt;
&lt;li&gt;したがって、新規ユーザーがひとつのライブラリだけを使い始める場合でも、　Boostを使うための「コスト」と「オーバーヘッド」は時間とともに増加する。しかし、ひとつのライブラリをテスト／使用するための方法がない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostのアイデンティティの危機&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コアユーティリティの唯一のライブラリ？&lt;ul&gt;
&lt;li&gt;i) ツールがテスト、リリース、配置を行う&lt;/li&gt;
&lt;li&gt;ii) ライブラリのサブセットのテスト、リリース、配置が必要であると考えられる&lt;/li&gt;
&lt;li&gt;iii) 全てのライブラリのためのひとつのバージョンを振る&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;あるいは、独立、分離されたライブラリのグループ(現在大きい)？&lt;ul&gt;
&lt;li&gt;i) 多く、あるいはほとんどのライブラリが他のBoostライブラリのサブセットにだけ依存する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私の議論は、Boostが前者として始まり、後者へ向かって進化していきそうだということである。&lt;br /&gt;
Boostにとってすばらしい10年だったが、成功し続けるためには進化しなければならないだろう。&lt;br /&gt;
この発表では、私が、Boostがどのように変わらなければならないと思うかを説明する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#data-structure-visualizers&#34; name=&#34;data-structure-visualizers&#34;&gt;Data Structure Visualizers in Visual Studio 2010&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#stephan-t-lavavej&#34; target=&#34;_blank&#34;&gt;Stephan T. Lavavej&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多くのSTLクラスが説明を複雑にした。デバッグをより簡単にするために、Visual Studio 2005と2008は、人間が読めるようにSTLオブジェクトを表示する「Visualizer」を持っていた。誰でも、Boostクラスのような他の型のためのVisualizerを書くことができる。これはアンドキュメントで、サポートもされないが、非常に有用になりえる。&lt;/p&gt;
&lt;p&gt;この発表は、&lt;code&gt;shared_ptr&lt;/code&gt;、&lt;code&gt;function&lt;/code&gt;および&lt;code&gt;map&lt;/code&gt;の表示を改善するためにVisualizerを書く方法について説明し、Visual Studio 2010の新しい特徴を利用する方法を紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#alabaster&#34; name=&#34;alabaster&#34;&gt;Boost.Alabaster: A Law Based Tester&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joachim-faulhaber&#34; target=&#34;_blank&#34;&gt;Joachim Faulhaber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これは、形式的に規定された法則あるいは公理に基づいて自動テストを提供する、Boostライブラリのための提案である。&lt;br /&gt;
テストシステムは3部から成る。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;法則のインスタンス化変数を表わす型の並び上のクラステンプレートとして公理または法則を表現することを可能にする法則概念。&lt;/li&gt;
&lt;li&gt;与えられた法則と与えられた型の並び用の法則インスタンス化を任意に生成する、法則インスタンス用のジェネレーター。&lt;/li&gt;
&lt;li&gt;法則違反を選択し、単純性順序によってそれらを格納するフィルタ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost Interval Containerライブラリの開発のために、Boost.Alabasterのプロトタイプは法則に基づいた開発(law based development)に使用された。手法とツールとしての法則に基づいたテスト(law based testing)は、多くの面で有益であることが判明した:&lt;/p&gt;
&lt;p&gt;形式仕様の探究はより深く根付いた設計決定を生じさせ、より耐久性のある設計に結びつく。進化のプロセスでは、一般的なソフトウェアに関してあなたが即座に作った公理で開発を始められなかったとしても、ソフトウェア開発(法則のテスト)では前部(仕様)が抽象化と抽象推論を引っ張り出す。法則に基づいた開発プロセスは、ソフトウェアだけでなくそのソフトウェアに関して保証することができる形式上のプロパティももたらす。それらのプロパティの検証はいつでも繰り返す(replicate)ことができる。テストは、退屈で愛されなかった義務から抽象と設計の品質を促進する非常にクリエイティブなプロセスへと変形される。法則に基づいたテストは、従来の単体テストが提示することができる利点をすべて持ち、それを超える方法である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tool-builder&#34; name=&#34;tool-builder&#34;&gt;C++ Tool-Builders Workshop&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： ワークショップ&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多くの専門家のように、プログラマは、生産性を改善する様々なツールを使用し、プロジェクト特有のニーズに焦点を当てた自分のツールを作るだろう。不運にも、C++プログラマのために、よいC++ツールの構築は、C++コードを解析する固有の複雑さによって非常に複雑になる。C++の全てを解析することができるオープンソースライブラリの不足と結び付けられたこの複雑さは、C++ツールを他の言語でそれらに相当するものより劣らせていた。Clang( &lt;a href=&#34;http://clang.llvm.org&#34; target=&#34;_blank&#34;&gt;http://clang.llvm.org&lt;/a&gt; )は、大きなC++開発ツールを構築することをより簡単にすることによりこの不均衡に焦点を当てたサポートを意図した新たなオープンソースC++コンパイラライブラリである。&lt;/p&gt;
&lt;p&gt;このハンズオンワークショップでは、出席者は、新たなC++ツールを構築するためにClangライブラリを使用する方法を学習する。私たちはまず、C++プログラムを解析および識別する面白いプログラム構築から始める。そこから私たちは、その抽象構文ツリーによって語彙の構造(トークン、マクロのインスタンス化など)から意味的な構造(クラス、関数、式、テンプレートなど)までClangがどのようにプログラムを表わすかを知るだろう。最後に、私たちは手を汚して、Clangを使用して、あるC++ツールを構築する。私たちが構築する実際のツールは出席者によって決定されるだろう。しかし、可能性は以下のものを含んでいる:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;プロジェクト絶対コーディング標準、&lt;/li&gt;
&lt;li&gt;特定のオーバーロードが選ばれた理由の説明、&lt;/li&gt;
&lt;li&gt;クラスを自動的に生成するシリアライズコード、&lt;/li&gt;
&lt;li&gt;Boostライブラリから抽出するドキュメンテーション、&lt;/li&gt;
&lt;li&gt;あるいは、対話的にテンプレートやプリプロセッサのメタプログラムをデバッグする&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といったものを強化する。&lt;/p&gt;
&lt;p&gt;プログラム委員会は以下のことに注意する:&lt;/p&gt;
&lt;p&gt;私は、Clangに基づいた2つの異なるセッションを提案している。&lt;br /&gt;
90分の発表(「Clang: An Open-Source C++ Compiler Library」)は、Clangをコンパイラ、ライブラリおよびオープンソースプロジェクトと評するだろう:&lt;br /&gt;
これはあまり深く話せないため、実際には概要である。&lt;/p&gt;
&lt;p&gt;ワークショップは、去年のDaveによるハンズオンBoost++0xワークショップに沿った単なる実験ではない:&lt;br /&gt;
今年、私たちは、出席者にBoosterが使用するべきクールなツールを構築させることができるかどうか確かめたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-concurrency&#34; name=&#34;cpp0x-concurrency&#34;&gt;C++0x Concurrency&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-wong&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この話では、私はBoostCon 09でのC++0x並列性の議論に引き続いて話していくつもりである。&lt;br /&gt;
とくに、C++のメモリモデル、新たなC++0xライブラリを通じて並列性がどのように扱われるか、スレッド管理、スレッド間のデータ共有、同期並列操作に関して話す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#basic-lock-free&#34; name=&#34;basic-lock-free&#34;&gt;Lock-freeプログラミングの基礎&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Basics of Lock-free Programming&lt;/li&gt;
&lt;li&gt;スピーカー ： Tony Van Eerd&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基礎から始め、共有データにアクセスするという問題を示し、ゆっくり問題を露出させていき、問題へのLock-freeによる解決策を示す。この話は以下を含む：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始性についての説明&lt;/li&gt;
&lt;li&gt;CAS命令とCASループについての説明&lt;/li&gt;
&lt;li&gt;Double-Checked-Locking Pattern(DCLP)の危険性とそれを避ける方法(メモリバリア)の説明&lt;/li&gt;
&lt;li&gt;read-request queueとwrite-request queueのアイデアに基づき、どのように複数のCPUが働くか理解できるモデルを提示しメモリバリアを説明する&lt;/li&gt;
&lt;li&gt;Lock free stackを提示する&lt;/li&gt;
&lt;li&gt;ABAと、それを回避する方法についての説明&lt;/li&gt;
&lt;li&gt;Lock-freeプログラミング(楽観的なrelaxed memory operation)におけるいくつかの最前線開発に触れる&lt;/li&gt;
&lt;li&gt;BoostとC++0xがどのようにLock-freeプログラミングに影響するかについて触れる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tboost-stm&#34; name=&#34;tboost-stm&#34;&gt;TBoost.STMエンジン:コミット時無効化を使用したSoftware Transactional Memoryの効率化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Reducing the Integration Complexity of Software Transactional Memory with TBoost.STM&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#vicente-j-botet-escriba&#34; target=&#34;_blank&#34;&gt;Vicente J. Botet Escriba&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#justin-gottschlich&#34; target=&#34;_blank&#34;&gt;Justin Gottschlich&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dwight-y-winkler&#34; target=&#34;_blank&#34;&gt;Dwight Y. Winkler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここでは、具体的なTBoost.STMの内部エンジンの現状、トランザクションコンフリクトの検出、トランザクションがコミットできるかどうかを決定するプロセスを調査する。多くのtransactional memory(TM)は矛盾検知の最適化に専念するが、ほぼ全てのTMがトランザクションのコミット段階で同じ矛盾検知戦略を行う。つまり、彼らはコミット時に検証を行うのである。そこでは、トランザクションが、以前にコミットされたトランザクションによってコンフリクトチェックされる。コミット時検証(commit-time validation)が限られた競合を示す作業量に対して効率的な間、それは競合した作業量のために並列性をきびしく制限できる。&lt;/p&gt;
&lt;p&gt;ここでは、TBoost.STMがこのモデルからどう逸れるかを説明し、コミット時無効化(commit-time invalidation)を使用することでコミットする前に飛行中(コミットされていない)トランザクションがそれらのコンフリクトを全て解決する戦略について話す。コミット時無効化は競合マネージャ(CM:contention manager)にコミット時検証を通じて利用不可能なデータを供給し、CMが決定にBoost Concurrencyを作ることを可能にする。コミット時無効化はまた、メモリ集約的なトランザクションのためにコミット時検証より著しく少ない操作を必要とし、動的に検出されたread-onlyトランザクションのための操作と保証、どんなトランザクションでもO(N)時間で完全な不透明性を保証する(インクリメンタルな検証のO(N^2)より速い)。作業量競合の実験結果は、私たちの効率的なコミット時無効化されたSTMは、TL2(最高水準のSTM)より3倍速かった。&lt;/p&gt;
&lt;p&gt;しかし、コミット時無効化だけでは不十分である。プログラマはそれらがこの競合検出戦略の利点を完全に利用するために実行している作業量のための効率的な競合マネージャに書く方法を知らなければならない。私たちは、プログラマがどのように自身の競合マネージャに書くか、そして正しい競合マネージャが実行される作業量に基づくTBoost.STMの性能を根本的にどうしたら向上させることができるかを調査する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-v2&#34; name=&#34;spirit-v2&#34;&gt;Using Spirit V2: Qi and Karma&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-caisse&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;機械、センサー、機材、クライアント/サーバーコミュニケーション、ファイル形式でさえ...コミュニケーションストリームの解析と生成はどこでも見るだろう。多くの場合、これらのタスクはその場限りの解決策を勧めるのに十分に単純であるか、あるいは小さい。Spirit 2.1ライブラリは、それらの「quick hacks」に取り組むのに十分に単純で、AST生成のために容易に拡張できる十分な機能のモデルを提供する。&lt;/p&gt;
&lt;p&gt;このセッションは、Spiritライブラリのパーサーとジェネレーター(Qi/Karma)による現実の経験を調査する。様々な製品の中で使用された、様々な小型/中型のパーサー/ジェネレーターを見るとともに、私たちは「rules-of-thumb」、およびQi/Karmaを持ったパーサー/ジェネレータードメインに取り組むためのガイドラインを確立するだろう。このセッションは、使用可能なXMLパーサーと、単純化されたXPathのようなノード抽出器の実装で終える。&lt;/p&gt;
&lt;p&gt;このセッションは、いくつかのレクチャーと、多くのチュートリアルを含む。&lt;br /&gt;
出席者は、知識と、Spirit Qi/Karmaで解析し生成することを始めるツールを持ち帰るだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#boost-test&#34; name=&#34;boost-test&#34;&gt;Production use of Boost.Test&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#gennadiy-rozental&#34; target=&#34;_blank&#34;&gt;Gennadiy Rozental&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションでは、プロダクションコンポーネントにおいてのBoost.Testの様々な使用法のシナリオをカバーする。&lt;br /&gt;
とくに、以下の主題をカバーする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数実行を保護する&lt;code&gt;execution_monitor&lt;/code&gt;の使用法。&lt;/li&gt;
&lt;li&gt;高水準なプログラム実行保護のための&lt;code&gt;program_execution_monitor&lt;/code&gt;の使用法。様々な配置オプション。&lt;ul&gt;
&lt;li&gt;(New) 浮動小数点例外の取り扱い。&lt;/li&gt;
&lt;li&gt;(New) コールバックでの罠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(New) 生産コンポーネントにおけるBoostテストツールの使用法。&lt;/li&gt;
&lt;li&gt;単体テストにおいて：実装自体の内部を構築コンポーネントユニットテストする2つのアプローチ：&lt;ul&gt;
&lt;li&gt;a) コンパイル時のスイッチを使用する&lt;/li&gt;
&lt;li&gt;b) コンソールテスト実行と、共有ライブラリとして組み込まれた実装を使用する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#asio-based-flash-xml-server&#34; name=&#34;asio-based-flash-xml-server&#34;&gt;An Asio Based Flash XML Server&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-caisse&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reactiveシステムはいたるところで見つけられる。多くの待ちスレッドでそれらを実装する誘惑は強くなりえる。しかし、結果はほとんどいつも期待はずれである。&lt;/p&gt;
&lt;p&gt;Boost.Asioライブラリは、特定のクラスがネットワーク、シリアルポートI/O、タイマー、およびその他に向けられている状態で非同期なリソースを扱うためのフレームワークを提供する。このセッションでは、様々なシリアル入出力ハードウェアコンポーネントから接続されたFlashディスプレイへのデータストリームを送るサーバーを構築するつもりである。以前のセッションのときに開発したQiパーサーとKarmaジェネレータは、それらの適切な目的地へとシャッフルされるASTを作成するのに使われるだろう。&lt;/p&gt;
&lt;p&gt;この講演/チュートリアルは、Flash XML Socketからサーバーを組み合わせてデータストリーミングし、要求を受け取ることができるようにAsio、Spirit、Fusion、Phoenix、Smart_ptr、Thread、FunctionとBindを含むライブラリを使用するだろう。&lt;br /&gt;
出席者は、彼ら自身のAsioベースサーバーを作成するために、Asioモデルと様々な実装パターンを理解することになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#msm-v2&#34; name=&#34;msm-v2&#34;&gt;The Meta State Machine Library V2&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#christophe-henry&#34; target=&#34;_blank&#34;&gt;Christophe Henry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon09でのMSM v1に関する私のアーティクルは、MDD(モデル駆動開発)アプローチと呼ばれるMDA(モデル駆動アーキテクチャ)を促進するというゴールをもつライブラリの主な特徴を示した。具体的に、その話はMSMの記述的に表現する性質を主張した。この論文は初めに、メインサポートされたUML機能を要約し、MSM v2によって提供される新たなフロントエンドでのそれらの使用法を示すだろう。第2部では、MDDコンテキストにおいて使用可能なより多くの能力の提供により、いまMSMがどのようにMDD法をより先に進めさせたかを知ることになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#overview-of-transactional-memory&#34; name=&#34;overview-of-transactional-memory&#34;&gt;Transactional Memoryの概観&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Overview of Transactional Memory Day&lt;/li&gt;
&lt;li&gt;スピーカー ： Tatiana Shpeisman&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Transactional Memory(TM)は並列プログラミングを単純化し、制限のない実行モデルをサポートする現代の並列制御パラダイムである。この終日セッションは、それらの最近のTM研究開発について議論するために業界と学会のエキスパートを集める。Boost、IBM、Intel、Microsoft、およびSun Microsystemsから招待された講演者は、最新作の概要を提供してくれるだろう。セッションは彼らがTMの短期的、あるいは長期的な挑戦についての考えを示すところでパネルディスカッションを締めくくる。最後に、聴衆からの質問に答える。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#ame-pattern-library&#34; name=&#34;ame-pattern-library&#34;&gt;AME Patterns Library: モデリング、認識、シーケンシャルパターンの統合のためのジェネリックライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AME Patterns Library: a generic library for modeling, recognition, and synthesis of sequential patterns&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#stjepan-rajko&#34; target=&#34;_blank&#34;&gt;Stjepan Rajko&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルは、モデリング、認識、シーケンシャルパターンの統合のためのオープンソースのジェネリックC++ライブラリであるAMEパターンライブラリについて発表する。&lt;/p&gt;
&lt;p&gt;このライブラリは、ジェスチャーや音声認識などのアプリケーション、およびそのようなパターンの統合に役立つ。また、隠れマルコフモデル(Hidden Markov Model)などのモデルのための汎用ライブラリとして使用することができる。コンセプトベースのジェネリックプログラミングの使用は、ライブラリに大きな柔軟性を与える。パターン解析が多くのドメインにまたがるので、それは役立つだろう。&lt;/p&gt;
&lt;p&gt;また、このライブラリはさらに、プログラミングの計算量、柔軟性、汎用性、およびコンパイルタイムの異なるトレードオフを提供する、いくつかのAPIレベルを提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#type-erasure&#34; name=&#34;type-erasure&#34;&gt;Type Erasure&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#nevin-liber&#34; target=&#34;_blank&#34;&gt;Nevin Liber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ Template Metaprogrammingで見つかった定義から始め、Type Erasureとは何かと、それがどのような利点とコストがあるかについて話す。継承ベースのインタフェースから、それをType Erasureで変換する例から始める。Boost.AnyとBoost.Functionの簡易実装をカバーする予定だ。&lt;/p&gt;
&lt;p&gt;regular型とクラスの概念について触れる。( &lt;a href=&#34;http://stlab.adobe.com/wiki/index.php/Image:2008_06_26_classes_that_work.pdf&#34; target=&#34;_blank&#34;&gt;http://stlab.adobe.com/wiki/index.php/Image:2008_06_26_classes_that_work.pdf&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;それと共に、Copyable/Assignable型のコンテナを使用することでBoost.shared_ptrとBoost.Pointer Containerを比較する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#dsel-design&#34; name=&#34;dsel-design&#34;&gt;Protoによる実用的なDSELの設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Practical DSEL Design with Proto&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#eric-niebler&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この発表は、Boost.Protoで有用なDSELを急速に構築する方法に注目する。&lt;/p&gt;
&lt;p&gt;このセッションは、数個の現実世界のDSELの設計と実装に踏み出すだろう。簡単な例(例えば、Boost.Assignのmake_list_of())から始めて、中級(例えば、Howard Hinnantのfutureグループ)、最後に、単純化されたPhoenixライブラリの設計について解説する。現実世界のライブラリ設計問題への解決策に重点を置く。特定の現実世界の問題を通じて、ProtoによってC++でそれを実装する価値があるように、一般的なDSELの価値が明白になるだろう。また、コンパイル時間とテンプレートのエラーメッセージについて議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#network-library-implementation&#34; name=&#34;network-library-implementation&#34;&gt;柔軟なヘッダオンリーC++ネットワークライブラリ実装の手法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Techniques in Flexible Header-Only C++ Network Library Implementations&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dean-michael-berris&#34; target=&#34;_blank&#34;&gt;Dean Michael Berris&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この論文は、Boost.Asio上に単純ではあるが強力なヘッダオンリーC++ネットワークライブラリを提供するcpp-netlibプロジェクトによって使用された様々な手法に重点を置く。&lt;/p&gt;
&lt;p&gt;一般的なプログラミング法則に従うベストプラクティスから発生している一方、使用される手法のうちのいくつかは他の既存のライブラリから借りられる。この論文は、共通メッセージ型、型安全なURIパーサーおよびオブジェクト表現の非常にモジュラーで柔軟な実装を達成するために使用されるイディオムと同様にライブラリの異なる部品の構成およびセマンティクス的に一貫したHTTPクライアントを強調することを目標とする。&lt;/p&gt;
&lt;p&gt;この論文は、ライブラリの様々なモジュールの実装の全体にわたって使用される現代C++の手法に関する調査と、同様にcpp-netlibプロジェクトへの入門として役立つ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#mime&#34; name=&#34;mime&#34;&gt;A MIME library for Boost&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#marshall-clow&#34; target=&#34;_blank&#34;&gt;Marshall Clow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： lecture&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;インターネットプロトコル中のデータをカプセル化する最も一般的な方法はMIME(Multipurpose Internet Mail Extensions:多目的インターネットメール拡張)を使用することである。このフォーマットはHTTP、emailおよび他の多くのプロトコルの中で使用される。&lt;/p&gt;
&lt;p&gt;私は、作成、解析、およびMIME構造の操作のために、Boostを包含するという視点から開始し、このライブラリを作る際の設計選択について話そう。(提案された)Boost.MIMEライブラリはDean Michael Berrisのネットワークライブラリによって使用される(だろう)。&lt;/p&gt;
&lt;p&gt;MIME処理ライブラリは、(スレッド、ネットワークI/Oおよび状態マシンを合わせた)ネットワークプロトコルを実装するために必要とされる基本ビルディングブロックのうちの1つである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#nt2&#34; name=&#34;nt2&#34;&gt;The Numerical Template Toolbox:高性能コンピューティングのための加速(Boost)されたGeneric配列ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Numerical Template Toolbox:BOOST’ed Generic Array Library for High Performance Computing&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-falcou&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jean-thierry-lapreste&#34; target=&#34;_blank&#34;&gt;Jean-Thierry Lapreste&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配列のようなデータ構造上での集中的、あるいは非自明なコンピューティングを行うことは、科学的なコンピューティング、ビデオゲーム開発、および他のフィールドで最も一般的なタスクのうちのひとつである。この事実は、そのようなタスクを行うために、ツール、言語、そしてライブラリといったかなりの数のものによってバックアップされる。私たちが自身をC++に基づいた解決策に制限する場合、1ダース以上のライブラリはテンプレートメタプログラミングに基づいたBlitz++やEigen2といったBLAS/LAPACKのC++バインディングが存在している。これらのライブラリの全てが良いパフォーマンス、または良い抽象化を提供する場合、そられのどれも非常に多くのユーザー型に適合するようには思えない。&lt;/p&gt;
&lt;p&gt;ここで私たちは、Numeric Template Toolbox(NT2)を提供する。これはテンプレートメタプログラミングで、配列に基づいた演算ライブラリで、直感的であるが拡張可能なユーザーAPIと開発者SDKを提供している間に、メモリハンドリングと自動的な並行処理のようなアーキテクチャの懸念に関して良い性能を出すためにrock-solid実装を目指す。また、全体のライブラリ設計とパフォーマンスのためにBoost.Components(MPI, Proto, Fusion, PP, Serialization, etc...)を使用しているという付加価値を強調する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#functional-programming&#34; name=&#34;functional-programming&#34;&gt;C++による関数型プログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Functional Programming in C++&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#david-sankel&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;関数型プログラミング(FP)手法は、一般的で、簡潔で、合成可能で、正確なコードを生成する。最近まで、これらの手法の多くは学究的な世界と難解プログラミング言語(esoteric programming language)の領域に制限されていた。新たなC++とboostでの開発は最終的にこれらの高度な技術にアクセス可能にする。&lt;/p&gt;
&lt;p&gt;このセッションの最初では、いま可能なFP手法のHowとWhyを調査する。私たちは代数のデータ型、ポイントフリー高階関数、純粋、ジェネリックプログラミング、型族(Type Families)、圏論および実用的な関数記号をカバーする。&lt;/p&gt;
&lt;p&gt;セッションの第2部では、FPの事例研究について話す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1に、運動コントローラーに基づいた組み込みドメイン特化言語(EDSL)。&lt;/li&gt;
&lt;li&gt;第2に、他に類を見ないジェネリックなXMLシリアライズフレームワーク。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#logic&#34; name=&#34;logic&#34;&gt;C++による論理型パラダイム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Logic Paradigm for C++&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#roshan-naik&#34; target=&#34;_blank&#34;&gt;Roshan Naik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;論理型パラダイム(LP)は、オブジェクト指向、命令型、関数型のパラダイムと比較して、主流言語では表現をほとんど見ない、強力でチューリング完全なプログラミングパラダイムである。&lt;br /&gt;
LPは時々、プログラミングの聖杯と呼ばれるものへのコンピュータ科学の重要なアプローチである。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「ユーザーが問題を延べ、コンピュータがそれを解決する」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理論の起源は、アリストテレスが論理的な推論に厳格さをもたらすために形式論理を構築した約紀元前300年までさかのぼる。ラッセルとホワイトヘッドが数学をすべて実行することができるかもしれないことを示した時、理論は、現代の論理へ最近(1900年の初め)成熟した。&lt;/p&gt;
&lt;p&gt;この話は、Boostへ提案することを目的とする新たなオープンソースライブラリであるCastorを中心に展開する。LPをサポートするBoostの能力の拡張に加えて、これはBoostプログラマがLPと関数型のパラダイムからの機能を組み合わせて、イテレータや範囲の必要なしでストリーム、アルゴリズムおよびコンテナの統合を可能にするだろう。&lt;/p&gt;
&lt;p&gt;この話は、C++でLPの基本的な入門を提供する。そして、あなたをこのパラダイムについて考えるようにするための多くの例が続く。私たちは、既存のBoostとC++の概念で、それがどのように自然に混じるか話す。最後に、プログラマが自由にパラダイムを混合しマッチすることができる場合に強力なマルチパラダイム解決がどのように出現するか確かめるために範囲を広げる。LPのきれいで深い統合が、C++を源泉とする多くのデザインパターンがいまだ発見されていないことがこの話で明確になるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#qt&#34; name=&#34;qt&#34;&gt;QtとBoostによるクロスプラットフォーム開発&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cross-platform development with Qt and Boost&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joao-p-r-abecasis&#34; target=&#34;_blank&#34;&gt;Joao P. R. Abecasis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このワークショップの意図は、Qtライブラリの簡潔な概要と、QtとBoostを混合するための現在の現実的解決策を提供することである。&lt;/p&gt;
&lt;p&gt;とくに私は、MOCモデルとQObjectモデル(BoostとQtを混合したプロジェクトのための構造システムインテグレーション)を調べ、Boostベースのコンポーネントを小さなサンプルアプリケーションに基づくQObjectシグナル/スロット実装に融合させる様相を調査するつもりである。&lt;/p&gt;
&lt;p&gt;私は、相互運用問題と、それがどのように改善することができるかについてBoostコミュニティからフィードバックを集めたいと考えている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-history-and-evolution&#34; name=&#34;spirit-history-and-evolution&#34;&gt;Spiritの歴史と進化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Spirit: History and Evolution&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-de-guzman&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#hartmut-kaiser&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今年、私たちは、90年代初期に非常に大きいGUIライブラリから枝分かれし、2001年にBoostデビューしたSpiritの10周年を祝福する。Spiritは、控えめな7ヘッダファイルのライブラリから成長して最も洗練されたBoostライブラリのうちの一つとなり、途中からBoost.Fusion, Boost.Phoenix, Boost.Wave, Boost.Protoライブラリの培養器となった。&lt;/p&gt;
&lt;p&gt;私たちは、歴史的観点からSpirit(そして、それに刺激されたライブラリ)を紹介したい。この発表は、およそ10年間で少なくても4つのライブラリへと発展させ、演算子を虐待し、クレイジーなテンプレートメタプログラムを好む、正真正銘のマッドサイエンティストであるBoost作者の経験と観点から、起爆剤を提供することを目標とする。もちろん、あちこちでC++トリックを誇示するのであれば、私たちはそれを助けることはできないが、私たちがそれを行うのと同じくらい、できるだけ簡単にすることができる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Future of Boost Panel ’10&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dave-abrahams&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#beman-dawes&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jeff-garland&#34; target=&#34;_blank&#34;&gt;Jeff Garland&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： パネル&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostには、メーリングリストの話題上で、丁寧で、役立つポストを適度に走らせる少数のモデレーターグループがある。さらに、彼らはウェブサイト、ソースリポジトリ、および他の行政機構の内部を管理する。また、大事なことを一つ言い残していましたが、モデレータは、Boostを促進するための委員会を監督する非公式の幹部の役割を務める。&lt;/p&gt;
&lt;p&gt;このセッションでは、モデレータにそれぞれBoostの将来のビジョンに関して5分ずつ話してもらう。しかし、セッションの大部分は聴衆からの質問と提案に専念するだろう。これは、Boostコミュニティの方向性に関して何でも聞けて、提案できる絶好のチャンスである。例えば、特別な政策、ツール、あるいはあなたの考えを採用する。&lt;/p&gt;
&lt;h2&gt;翻訳者&lt;/h2&gt;
&lt;p&gt;Akira Takahashi&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2012 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/cppnow/2012.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:cppnow/2012.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;C++Now! 2012&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://cppnow.org/2012/&#34; target=&#34;_blank&#34;&gt;C++Now! 2012&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2012&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/cpp_online_reading.html&#34;&gt;C++オンライン読書会&lt;/a&gt; にて有志が一部の資料を読んでいるので、そちらも資料を読むお供にどうぞ。&lt;/p&gt;
&lt;h2&gt;ビデオ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.youtube.com/user/BoostCon&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/user/BoostCon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参加レポート&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/redboltz/20120519/1337385881&#34; target=&#34;_blank&#34;&gt;C++Now2012体験記 - redboltzの日記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/faith_and_brave/20120522/1337650107&#34; target=&#34;_blank&#34;&gt;C++Now! 2012に参加してきました - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zakkas783.tumblr.com/post/25007975614/c-now-boostcon-c-now-boost-konferenz-im&#34; target=&#34;_blank&#34;&gt;C++Now! - BoostCon新装開店 (C++Now! – Boost-Konferenz im neuen Gewand) - 雑貨’s tumblr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#50-boost-libs&#34;&gt;180分でめぐるBoost Library 50個の旅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#more-useful-computations&#34;&gt;おなじ環境でより効果的な計算を： C++で組み込みリアルタイムコード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#whirlwind-overview-cpp11&#34;&gt;駆け足でC++11の概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#odeint&#34;&gt;odeint - C++で常微分方程式を解く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#fresh-paint&#34;&gt;新仕様できたてほやほや!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#openmp-for-better-high&#34;&gt;ハイパフォーマンスを求めるためだけではなく、高次の並列化のためのOpenMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#hpx&#34;&gt;HPX: C++11並列実行システム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#lambda-functions&#34;&gt;ラムダ関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#future-cpp1x-proposals&#34;&gt;来るC++1xへの提案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#variadic-tmp&#34;&gt;モナドを使って可変長テンプレートメタプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#ustring&#34;&gt;Ustring - 現代的な&lt;code&gt;std::string&lt;/code&gt;の代替&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#high-level-threading&#34;&gt;C++11: 高次のスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#grill-the-committee&#34;&gt;標準委員を質問攻めにしよう!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#moving-forward&#34;&gt;キーノート：C++11で前進せよ!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#metaparse&#34;&gt;Metaparse – テンプレートメタプログラミングによるコンパイル時構文解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#ladon&#34;&gt;Ladon - 分散状態マシンフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#low-level-threading&#34;&gt;黒魔術につき取扱注意 - C++11で低レヴェルスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#exception-safety&#34;&gt;C++で例外安全なコーディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#moving-boost-to-git&#34;&gt;BoostをGitに移行しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#learned-developing-std-lib&#34;&gt;C++11標準ライブラリの策定を通じて学んだこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#utilizing-modern-programming&#34;&gt;科学的ソフトウェア開発における今日的プログラミングテクニックとBoostライブラリの適用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#vs-ide&#34;&gt;C++開発者むけVisual Studio IDEの最新情報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#modules&#34;&gt;キーノート： C++におけるモジュール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#generic-programming-real-world&#34;&gt;C++でのジェネリックプログラミング： 実例を交えて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#lowest-variational-methods&#34;&gt;Boost.Protoを用いた最低次変分法のドメイン特化固有言語の実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-containers&#34;&gt;C++11コンテナの最新情報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#concept-clang&#34;&gt;ConceptClang： C++ Conceptの実装モデル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#modern-cpp-techniques&#34;&gt;現代的C++テクニック入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#smart-pointers-algorithm&#34;&gt;C++11のスマートポインタとアルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#voronoi&#34;&gt;Boost.Polygon.Voronoiライブラリを例に、堅牢かつ効率的多倍精度アルゴリズムの設計について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#tool-for-class-and-library-authors&#34;&gt;C++11: クラスやライブラリ実装者のための新しいツール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cmake-modularization&#34;&gt;CMake、モジュール化と Ryppl 開発者向けプレヴュー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#now-what&#34;&gt;キーノート： さて、これからどうしよう？ 3つの視点から&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#compile-time-reparsing&#34;&gt;コンパイル時 再パース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#type-string-conversions&#34;&gt;型から文字列への変換と、その逆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34;&gt;C++11にある珠玉の品々&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#linear-programming-proto&#34;&gt;Boost Protoで線型計画法を簡単に&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#solidfire&#34;&gt;SolidFireではC++11への移行をいかにして成しとげたか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#refactoring-clang&#34;&gt;ClangでC++のリファクタリング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#state-machine-coroutine&#34;&gt;Boost.Coroutineを用いてステートマシンを解決する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#metaprogramming-cpp11&#34;&gt;C++11でのメタプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#numerical-problems-metaprogramming&#34;&gt;メタプログラミングの数学的問題への適用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#tr2-boost&#34;&gt;TR2に向けたBoostライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#how-i-code-and-why&#34;&gt;どうしてそう書くの？なんで？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#preparation-cppnow-2013&#34;&gt;C++Now! 2013に向けた準備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#winrt&#34;&gt;WinRTにむけたC++コンポーネント拡張&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#value-semantics&#34;&gt;値のセマンティクスとConceptベースの多態&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#future-of-boost&#34;&gt;Boostの将来&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#50-boost-libs&#34; name=&#34;50-boost-libs&#34;&gt;180分でめぐるBoost Library 50個の旅&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;50 Boost Libraries in 180 minutes&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/boris-schaeling/&#34; target=&#34;_blank&#34;&gt;Boris Schäling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/50_boost_libraries.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/50_boost_libraries.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションでは、50個のBoost Libraryを180分かけて紹介する。多くのBoost Libraryについて、幅広く俯瞰する。あまりboostに詳しくない方、または、いくつかのライブラリしか知らない方は、今後、boostが提供すべきすぐれたアイデアを得ることができるだろう。このセッションは、後程どのライブラリについて学びたいか、いまのプロジェクトで使えるか、さらには貢献できそうか判断する指針となるだろう。 このセッションは、プレゼンターの著書である「The Boost C++ Libraries」(英語版 2011/6刊行)と「Die Boost C++ Bibliotheken」(ドイツ語版 2012/1刊行)に基づいている。これらの書籍ではすぐに習得できる一般的なライブラリを紹介している。このセッションでは、これらの本から例を引用するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#more-useful-computations&#34; name=&#34;more-useful-computations&#34;&gt;おなじ時間でより効果的な計算を： C++で組み込みリアルタイムコード&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;More Useful Computations in the Same Duration: Optimizing Embedded Hard Real-Time Code in C++
スピーカー：&lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/schurr_more_useful_computations.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/schurr_more_useful_computations.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=mJjYgpeo5ws&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=mJjYgpeo5ws&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は非常に広い問題領域に適用可能なマルチパラダイム言語である。このセッションでは限られたメモリリソース、かつ、200KHz(5マイクロ秒)サーボインタラプト割合のリアルタイム組み込みシステムにC++を利用した際の最適化と拡張について紹介する。二年以上かけて、このシステムのデータ処理帯域幅は、ハードウェアの強化をすることなく大きく改善した。この改善を達成するために、様々なアプローチとテクニックについて議論した。その結果、ほとんどのよく知られているC++イディオムは組み込みのリアルタイムシステム環境にはよく合わないことが分かった。しかし、C++はCよりもメンテナンスの面でもコード実行速度の面でも優位な性能を見せた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、組み込み向け、汎用機向けという区分なく、特定のC++コードの実行速度の高速化に興味がある方には有意だろう。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションで、特定の組み込み環境について、何が正しく動き、何が正しく動かないのか、そしてその理由はなにかについて説明する。主なテーマはパフォーマンスモニタリング、特定領域のコードデザイン、コンパイラに高速なコードを生成させる方法、スレッドセーフオプションである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#whirlwind-overview-cpp11&#34; name=&#34;whirlwind-overview-cpp11&#34;&gt;駆け足でC++11の概要&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Whirlwind Overview of C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/leor-zolman/&#34; target=&#34;_blank&#34;&gt;Leor Zolman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/cpp_overview_handout.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/cpp_overview_handout.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=jrCrWdrH17g&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=jrCrWdrH17g&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このC++11の簡潔なイントロダクションでは、プレゼンターであるLeor Zolmanが言語への主要な機能追加について調査する。また以下の項目についても述べる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コード可読性の向上について(ラムダ, 統一初期化, &lt;code&gt;auto&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;パフォーマンスの向上について(右辺値参照とムーブコンストラクタ)&lt;/li&gt;
&lt;li&gt;マルチスレッドについて(並行性とアトミック型)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、他の多岐に渡る便利な機能や、標準ライブラリのコンポーネント(スマートポインタと新しいSTLコンテナ)についても触れる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションはC++11の簡潔な概要を知りたい方向けである。そのため、詳細をカヴァーしきれない言語機能、ライブラリが多々あることをご了承いただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#odeint&#34; name=&#34;odeint&#34;&gt;odeint - C++で常微分方程式を解く&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;odeint – Solving ordinary differential equations in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/karsten-ahnert/&#34; target=&#34;_blank&#34;&gt;Karsten Ahnert&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mario-mulansky/&#34; target=&#34;_blank&#34;&gt;Mario Mulansky&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/odeint.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/odeint.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=jv2oDfT-jds&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=jv2oDfT-jds&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常微分方程式(ODE: Ordinary differential equation)は自然科学、応用分野の諸領域で重要な役割を果たしている。&lt;br /&gt;
例示すると、古典的ニュートン物理学、化学反応式、量子系から神経系にわたる、個体群動態における反応速度式などである。&lt;br /&gt;
さらに、常微分方程式は偏微分方程式(PDE: partial differential equation)の離散化をする際頻出する。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、odeint(&lt;a href=&#34;http://odeint.com&#34; target=&#34;_blank&#34;&gt;odeint.com&lt;/a&gt;) -常微分方程式の数値解法を探索するためだけのC++ライブラリ- を紹介する。このライブラリはBoost入りを目指している。&lt;/p&gt;
&lt;p&gt;odeintは非常にジェネリックに実装されており、高速に相互運用することができる。&lt;/p&gt;
&lt;p&gt;odeintはODEソルバのためのC++コンセプトを導入しており、標準的なメソッドを数多く実装している。例えば、古典的Runge-Kuttaスキーム、ステップサイズコントロールと稠密出力のメソッド、非明示なメソッドとシンプレティック解法などである。； odeintはコンテナ非依存であることを強調しておきたい。つまり、使用者はstd::vectorのような特定の型を使うことを強いられない。 それゆえ、ネットワーク、ラティス上のODEを解くこともできる。 さらに、多倍精度か区間演算を利用できる。 ジェネリックな設計を取っているので、odeintは容易に並列化してCUDA GPUで実行できる。 それにもかかわず、odeintはわかりやすいインターフェースを備えているので、簡単に、容易に使うことができる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではodeintの主要な機能ならびにそのソフトウェアデザインについて述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#fresh-paint&#34; name=&#34;fresh-paint&#34;&gt;新仕様できたてほやほや!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Fresh Paint&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/fresh_paint.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/fresh_paint.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=ourmFvidEpk&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=ourmFvidEpk&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11では様々な方法で言語を拡張する興味深い新機能が導入された。&lt;/p&gt;
&lt;p&gt;このセッションではそれらを完全に無視して、別のテーマに焦点を当てる。すなわち、C++11でよりシンプルに、クリーンに、エレガントに記述する方法について述べる。このセッションはソフトウェアデザインの最先端についてあまりよく知らないけれど、クリーンかつシンプルかつ効率的なコードを書くことに関心がある方に最適である。話のなかでデザインについて知見が得られれば幸いである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#openmp-for-better-high&#34; name=&#34;openmp-for-better-high&#34;&gt;ハイパフォーマンスを求めるためだけではなく、高次の並列化のためのOpenMP&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OpenMP for better high-level parallelism, not just for High Performance Computing&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/47981ddb3630f7fc1651ae0ecb608b0344d19b5f/mon/cppnow_openmp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/47981ddb3630f7fc1651ae0ecb608b0344d19b5f/mon/cppnow_openmp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=iGrk2mbKTS0&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=iGrk2mbKTS0&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OpenMPは高次の言語を用いたインクリメンタル並列化をサポートする、C,C++,FORTRAN向けの分散メモリ並列化の仕様である。&lt;/p&gt;
&lt;p&gt;OpenMPはハイパフォーマンスコンピューティング、スーパーコンピューティングのためのもの、と思っている方がいるかもしれないが、実際は他にほぼ類をみない分散メモリ並列化 - これは3つの汎用言語で実装されている - に適しており、それ自体高次言語である。OpenMPはグラフィクスや可視化の分野や、組み込みやリアルタイムアプリケーション分野、コミュニケーションとネットワーク分野、自動化とロボディクス分野、財務や通商分野、医療と生命工学分野、石油・ガス業界、シミュレーション、データベースとミドルウェア、音声・オーディオ処理、汎用データ解析などの分野でも有効であることが知られている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#hpx&#34; name=&#34;hpx&#34;&gt;HPX: C++11並列実行システム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HPX: A C++11 parallel runtime system&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/bryce-adelstein-lelbach/&#34; target=&#34;_blank&#34;&gt;Bryce Adelstein-Lelbach&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/hartmut-kaiser/&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/matthew-anderson/&#34; target=&#34;_blank&#34;&gt;Matthew Anderson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/thu/hpx_a_cxx11_parallel_distributed_system.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/thu/hpx_a_cxx11_parallel_distributed_system.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;計算科学のアプリケーションは、しばしば基になる実行モデルから受けついだ選択の影響を受ける。並列計算アプリケーションにおいては、MPIが注目をあつめている。しかし、電源や、プロセッサコアの複雑性、マルチコアソケット、GPUの異種混在という問題が深刻になってきたため、並列アプリケーションはスケーリング不全の危機に陥っている。&lt;/p&gt;
&lt;p&gt;HPX実行時システムはモジュラーであり、完全実装であり、SMPノードとコモディティ・クラスターのような従来型の並列計算アーキテクチャを対象としたParalleX実行モデルのパフォーマンス指向の表現である。MPIの代替として、HPXは軽量ユーザースレッドを管理するためのルーチンに加えて、アクティヴグローバルアドレス空間(AGAS: Active Global Address Space)を提供している。HPXはC++11で実装され、20のBoostライブラリ/Boostライブラリ候補を利用している。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、実行時システムアーキテクチャに焦点を当てるとともに、HPXでどのようにBoost C++ライブラリやC++11機能を利用しているかについて議論する。HPXの概要についてプレゼンテーションし、さらに、競合するランタイムシステムおよび科学計算コミュニティ向けアプリケーションとの比較とベンチマークを紹介する。HPXに興味、関心をもたれて、実際に試用していただければ幸いである。ダウンロードはこちらから： &lt;a href=&#34;http://stellar.cct.lsu.edu/&#34; target=&#34;_blank&#34;&gt;http://stellar.cct.lsu.edu/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#lambda-functions&#34; name=&#34;lambda-functions&#34;&gt;ラムダ関数&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lambda Functions&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/lambda.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/lambda.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=tLp6ZBHwvj4&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=tLp6ZBHwvj4&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;無名関数は多くの言語で有用なツールとして成功を収めている。その局所性と明瞭な構文により、高い表現力と、バグの少ないコードを記述できる。Boost.LambdaやBoost.Phoenix、そしてFC++といったライブラリによって、C++にラムダ式がもたらされたが、今日、C++11には言語機能としてラムダ関数がある。ラムダ関数は無名関数オブジェクトとよく似ている。というのは、ラムダのスコープ外でキャプチャ/識別子の状態の変更が可能だからだ。&lt;/p&gt;
&lt;p&gt;この90分のチュートリアルセッションで、この新しい言語機能の構文と利用方法を概観する。上達を図るために練習問題や例を多数用意している。ラムダが利用可能なコンパイラを持参し、ぜひラムダ関数を使うとコードがどれほどよくなるか体験していただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#future-cpp1x-proposals&#34; name=&#34;future-cpp1x-proposals&#34;&gt;来るC++1xへの提案&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Future C++1x proposals&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/cppnow_future.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/cppnow_future.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=NdWHVyZBazo&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=NdWHVyZBazo&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11が公開された今、C++1xに搭載される次の機能は何だろうか？ このプレゼンテーションでは2月のコナ会議で提案されたものを紹介していく。Evolution Working Groupでレヴュー済みのペーパーと、ConcurrencyおよびLibrary Working Groupの活動についても焦点を当てる。 おまけ： 主要なコンパイラについて、最新のC++11実装状態についてもお伝えしたい。&lt;/p&gt;
&lt;p&gt;2012年2月のコナ会議を経て、標準委員会は次のC++標準を暫定的に2017年に、その次を2022年に、おおよそ五年毎に公開するように決定した。また、いくつか主要なものを例にあげると、モジュールや高度な並列抽象化、リフレクションといった次の標準にむけての提案についても精査した。このプレゼンテーションではこれらの機能について焦点をあて、C++11にどのような影響を与えるかについて議論する。&lt;/p&gt;
&lt;p&gt;カナダ、IBMのC++標準委員会代表や、BoostConでトランザクショナル・メモリからC++11の並行について多様なトピックを長きにわたってプレゼンターを務めた者として、標準委員会でC++の将来搭載されるべき機能についての議論にはできるだけ参加するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#variadic-tmp&#34; name=&#34;variadic-tmp&#34;&gt;モナドを使って可変長テンプレートメタプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Variadic Template Metaprogramming using Monads&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bartosz-milewski/&#34; target=&#34;_blank&#34;&gt;Bartosz Milewski&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/eric-niebler/&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/compile_time_runtime_cpp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/compile_time_runtime_cpp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11 の新機能である可変引数テンプレートは，パワフルだが気の触れた制限がついている．なんと template parameter pack が一級市民ではないので，一部のよくある(メタ)プログラミングの定石で使いにくいのだ．うれしいことに偶然，関数型プログラミング，正確に言うと Haskell では，おもしろい方法でこの問題を解決している．というわけで我々は，可変個継続，継続モナド，カリー化，その他C++メタプログラミングで使うためのエキゾチックな構成を使った方法について話す．&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#ustring&#34; name=&#34;ustring&#34;&gt;Ustring - 現代的なstd::stringの代替&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ustring – A Modern Alternative to &lt;code&gt;std::string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alan-talbot/&#34; target=&#34;_blank&#34;&gt;Alan Talbot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/ustring.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/ustring.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=nAm1Tbk068U&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=nAm1Tbk068U&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++プログラミングで推奨される文字列表現はstd::stringである。しかし、実際には、あるプログラムには三つ以上の文字列型(例えば、&lt;code&gt;std::string&lt;/code&gt;、MFCの&lt;code&gt;CString&lt;/code&gt;、&lt;code&gt;char*&lt;/code&gt;)が混在していることがほとんどである。われらが&lt;code&gt;std::&lt;/code&gt;stringは長年よくやってくれているが、いろいろな制限やときどき見せる奇行に悩まされることもままある。そして、他の文字列クラスが備えている便利な機能、特に言うならUnicodeサポートが欠けている。C++11が公開されたことと、&lt;code&gt;std::string&lt;/code&gt;が実装されてから数十年来の知見を集めて、よりよいツールを創ってみた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションの前半は、将来、強力かつ競争力のあるツールとなるよう、&lt;code&gt;std::string&lt;/code&gt;の制限や問題を解決することをめざした新しいクラスの設計について述べる。多くの知見を集積して、C++11にふさわしい、簡便で、表現力豊かで、強力な文字列処理を創りだすことが目標である。そのために、後半は理論や秘話、懸案事項やアイデアなどをいただきたく、聴講されている皆様とブレインストーミングするセッションにするつもりである。このライブラリは開発の初期段階にあるので、変更の余地はあるし、どんなアイデアでも歓迎する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#high-level-threading&#34; name=&#34;high-level-threading&#34;&gt;C++11: 高次のスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11: High-Level Threading&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/concurrency.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/concurrency.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=9GILH2U94Ls&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=9GILH2U94Ls&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11は並行処理の新しい機構を備えている。慎重に設計されたシステムのプログラミング言語であるならば当然のことだが、言語機能は厳格な理論的基礎(メモリモデル)に基いて構築され、低レヴェルプリミティヴ(atomic)へのアクセスを提供している。幸運にも、C++11ではスレッドを効果的に使う際に、こうした難解な詳細について理解する必要はない。(もし低レヴェルの事柄について詳細を知りたければ、Tony Van Eerdのプレゼンテーションを見るべし)&lt;/p&gt;
&lt;p&gt;その基礎の上に、プログラマが日々のコンカレントなコードを記述する際、実際に使うべきAPIが用意されている。すなわち、大量のロックやミューテクスや条件変数、そして、より高いレヴェルの&lt;code&gt;future&lt;/code&gt;, &lt;code&gt;promise&lt;/code&gt;, &lt;code&gt;packaged_task&lt;/code&gt;などだ。また、スレッドセーフなプログラミングの中核的問題についても述べ、これら問題を解決するためのコンポーネントの使いかたについても述べる。&lt;/p&gt;
&lt;p&gt;メモ： このプレゼンテーションに興味を持たれたかたは、&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34;&gt;&#34;Other C++11 Gems&#34;&lt;/a&gt;のプレゼンテーションにも食指が動くかもしれない。そちらのプレゼンテーションでは、時刻や時間、タイムアウトでのロック、スリープといった優れたデザインの新機能について取りあげるそうだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#grill-the-committee&#34; name=&#34;grill-the-committee&#34;&gt;標準委員を質問攻めにしよう!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Grill the Committee&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準のなれそめについて知りたくないか？ このパネルディスカッションではC++標準委員会のメンバーに登壇いただき、聴衆の皆様に気になっていることを質問していただく趣旨である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#moving-forward&#34; name=&#34;moving-forward&#34;&gt;キーノート： C++11で前進せよ!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Moving Forward with C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料&lt;ul&gt;
&lt;li&gt;前編：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part1.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part1.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;後編：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part2.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part2.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;前編・後編一括：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;右辺値参照はC++に二つの新しい相乗的に機能するプログラミングイディオムをもたらす。すなわちムーブセマンティクスと完全転送である。このプレゼンテーションでは右辺値参照とは何か、ムーブセマンティクスとは何か、完全転送とは何か、といった基礎からはいる。また、このプレゼンテーションではこれらが導入された動機や利用法、コンパイラがこれらを自動生成する条件についても述べる。さらに、クラスを設計した後でも、条件に合致すれば自動的に、ムーブセマンティクスが最適化の役目を果たすことができるけれども、ムーブセマンティクスの知識は直接的にクラス設計に影響を与えることを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#metaparse&#34; name=&#34;metaparse&#34;&gt;Metaparse – テンプレートメタプログラミングによるコンパイル時構文解析&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaparse – Complie-time parsing with template metaprogramming&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/abel-sinkovics/&#34; target=&#34;_blank&#34;&gt;Ábel Sinkovics&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/zoltan-porkolab/&#34; target=&#34;_blank&#34;&gt;Zoltan Porkolab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/2b6b26f9fcc28fa7b2c777819111012217116ff5/tue/metaparse.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/tue/metaparse.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=v3XoWi0XbZk&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=v3XoWi0XbZk&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Metaparseは、C++のコンパイル時文字列を解析する、パーサー生成のためのC++テンプレートメタプログラミングライブラリである。Boostはすでに2つのパーサージェネレータライブラリを持っている：Boost.SpiritとBoost.Proto。MetaparseとBoost.Spiritの主な違いは、Metaparseによって生成されたパーサーはコンパイル時に実行され、Boost.Spiritによって生成されたパーサーは実行時に実行されるということである。Boost.ProtoパーサーはC++の有効な式をコンパイル時に処理し、Metaparseは自由形式の文字列を入力としてパーサーを構築する。&lt;/p&gt;
&lt;p&gt;コンパイル時の任意なテキストを解析することは、多くの状況で有用である。我々はより複雑なユースケースを比較的に簡単にする方法を提供する。一般的な構文は、以下の正規表現のコンパイル時検証を有効にすることでBoost.Xpressiveのラッパーを作成できる。より複雑な例として、printfの書式指定文字列を解析し、コンパイル時に引数の型を検査する。コンパイル時パーサーの別な手段は、組み込みDSLスクリプトをC++のネイティブな関数への変換をコンパイル時に行い、実行時にそれを実行することである。最も複雑な例では、テンプレートメタ関数を定義するために、組み込みDSLをどのようにして実装するかを示す。Metaparseはパーサー生成のDSLをメタ関数に変換する能力を持つ。&lt;/p&gt;
&lt;p&gt;Metaparseの内部構造と、それをどのようにして拡張するかを説明する。ライブラリの正確なエラー報告の機能を紹介する。モナドの概念の入門と、それを使用することでパーサーの構築を容易にすることを示す。新たなC++標準の&lt;code&gt;constexpr&lt;/code&gt;は、コンパイル時にアルゴリズムを実行するための構造を提供する。メタプログラミングと&lt;code&gt;constexpr&lt;/code&gt;の間を繋ぎ、パーサーによって処理される入力の構文的なオーバーヘッドを最小限にしてそれを利用する方法を提供する。&lt;/p&gt;
&lt;p&gt;Metaparseと、その元となるライブラリは、以下から利用可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://abel.web.elte.hu/mpllibs&#34; target=&#34;_blank&#34;&gt;http://abel.web.elte.hu/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sabel83/mpllibs&#34; target=&#34;_blank&#34;&gt;https://github.com/sabel83/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これはユーザーと開発者にとって高度な話である。Boost.MPLに精通していることを前提とする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#ladon&#34; name=&#34;ladon&#34;&gt;Ladon - 分散状態マシンフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ladon - A Distributed State-Machine Framework&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/ladon.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/ladon.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=KExYq1bepT0&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=KExYq1bepT0&amp;amp;feature=plcp&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;階層的な状態マシンは、多くのドメインにエレガントな解決策を提供する。それらの厳格な要件は、高い信頼性のシステムのための規律を一段階強化する。状態マシンはシステムの反応的な振る舞い(reactive behavior)について記述するのに役立つ。ポート束縛、メッセージ配信、およびプロトコル変換を提供する一方で、コミュニケーションポートや包含コンセプト(containment concepts)のようないくつかの(ROOMのような)構造的コンポーネントを加える。そうすれば、分散状態マシンフレームワークが生まれる。よく定義されたインタフェースを持ったより小さな分散マシンに分割することは、大きな反応的システムのための強力なツールである。&lt;/p&gt;
&lt;p&gt;このセッションでは、Ladon分散状態マシンフレームワーク(C++Now 2012でデビューするciere consultingのオープンソースプロジェクト)を導入する。Ladonは、反応的なシステムのためのリッチな分散ソリューションを作成するために、Boost.MSM、Boost.AsioおよびBoost.Spiritを融合させる。フレームワークの設計と基本的な使用法についての議論に加え、我々はあなたのシステムで使用できるおもしろいパターンと解決策のいくつかを紹介する。我々が言及するライブラリは、以下のものを含む：MSM、Spirit、Asio、Fusion、Signals2、そしてPhoenix。&lt;/p&gt;
&lt;p&gt;この90分間のセッションは、初心者と中級レベルの出席者に、いくつかのBoostライブラリと現代的なC++手法の概観を提供する。&lt;/p&gt;
&lt;p&gt;語源 - Ladon(Λάδων)は、ヘスペリデスの庭のトマトを守護する、ギリシャの100の頭を持つヘビのようなドラゴンである。頭がそれぞれ異なる言語を話したという噂がある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#low-level-threading&#34; name=&#34;low-level-threading&#34;&gt;黒魔術につき取扱注意 - C++11で低レヴェルスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Don’t Try This at Work – Low Level Threading with C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/low_level_threading_with_cpp11.pps?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/low_level_threading_with_cpp11.pps?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のC++は&#34;メモリモデル&#34;がある。しかしこれはどんな意味で、どうして導入されたのか、また、以前のC++に必要なかったのは何故か？ これを使って何ができるか？ そしてこれらの新しい原子操作にはなにやら相関があるようだ… むむむ…&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#exception-safety&#34; name=&#34;exception-safety&#34;&gt;C++で例外安全なコーディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Exception-Safe Coding in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/exception_safe_coding.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/exception_safe_coding.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;皆様のコードは100%例外安全を達成していると言えるだろうか？&lt;/p&gt;
&lt;p&gt;例外を安全に利用するのはなまはんかな問題ではない。この業界では20年来この問題に奮闘してきた。もし皆様が恐怖や不透明感、例外安全に疑いをもっていたり、純粋にC++で例外のベストプラクティスを知りたいと思っているならば、ぜひこのプレゼンテーションを聞いていただきたい。まず始めに、&#34;何を解決しようとしているか&#34;から入り、代案について議論し、例外の利用に関する問題を確認し、例外安全について曲解されやすい試みについて述べる。また、安全な例外の利用法についての基本的なガイドラインと過去の例外安全ではないコードベースから移行するための鉄板の実装テクについても述べる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションの目的は、皆様に、簡単に記述できて、理解しやすく、高速に動作し、例外が発生しても100%の堅牢性を誇るコードをどうやったら書けるようになるかお伝えすることである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#moving-boost-to-git&#34; name=&#34;moving-boost-to-git&#34;&gt;BoostをGitに移行しよう&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Moving Boost to Git&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/moving_to_git.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/moving_to_git.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=rqKGX2LJOmU&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=rqKGX2LJOmU&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gitヴァージョン管理システムはSubversionに比べてBoostの開発者、利用者双方に利益がある。このセッションではBoostからみたGitについて紹介し、徐々に高度な議題について述べていく：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;なぜGitなのか？ - 成層圏から俯瞰してみよう&lt;/li&gt;
&lt;li&gt;皆様にGitの基礎を知っていただくために、駆け足のGitのチュートリアル&lt;/li&gt;
&lt;li&gt;Subversionに対するGitの優位性 - Boost開発者の視点から&lt;/li&gt;
&lt;li&gt;Subversionに対するGitの優位性 - Boost利用者の視点から&lt;/li&gt;
&lt;li&gt;Boostのモジュール化への試み - 課題、アプローチ、トレードオフについて&lt;/li&gt;
&lt;li&gt;Boost開発者にあわせたワークフロー構築の試み&lt;/li&gt;
&lt;li&gt;BoostをGitに移行してみるワークショップ - 実行計画の開発&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この&#34;BoostをGitに移行しよう の前準備&#34;と題したドキュメントとファイルをC++Now!の二週間前くらいまでに用意するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#learned-developing-std-lib&#34; name=&#34;learned-developing-std-lib&#34;&gt;C++11標準ライブラリの策定を通じて学んだこと&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lessons Learned Developing the C++11 Standard Library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/lessons_from_the_library.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/lessons_from_the_library.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11の標準化作業はおおよそ8年かかり、標準ライブラリのサイズは少なくともページ数上では倍増した。標準化作業は標準ライブラリの設計を再確認し、おおよそ十年間で蓄積したBoostライブラリで得られた知見や開発技術をもって仕様をクリーンアップし、右辺値参照やコンセプト、並行処理のサポートといった、言語に導入が考えられた新しいアイデアについて学び、最後に新しい機能でライブラリを拡張した。この経験は有意だったか、それとも無意だったか？ 次の機会によりうまくやるために、いったい何を学んだのか？ 次のライブラリ TR を策定するにあたり、このレッスンをどう生かせばいいのか？&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#utilizing-modern-programming&#34; name=&#34;utilizing-modern-programming&#34;&gt;科学的ソフトウェア開発における現代的プログラミングテクニックとBoostライブラリの適用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Utilizing Modern Programming Techniques and the Boost Libraries for Scientific Software Development&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/josef-weinbub/&#34; target=&#34;_blank&#34;&gt;Josef Weinbub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_weinbub.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_weinbub.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現代的プログラミングテクニックとライブラリを利用することで、ソフトウェア開発者は膨大な機能と柔軟性を手にいれることができる。しかし、ジェネリックプログラミング、関数型プログラミング、メタプログラミングのような関連技術を利用するには、高度なプログラミングスキルが要求されるので、マニアかコンピュータサイエンティストでなければ使い熟し得ない。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、Boostライブラリのような現代的プログラミング技術を利用する科学的コンピューティングの範疇に含まれる3つの仕事について報告する。まず、主にBoost GraphライブラリとBoost Phoenixライブラリを利用した順次および並列タスクグラフ実行のための拡張可能なプラグインスケジューラを紹介する。次に、Boost MetaprogrammingライブラリとBoost Fusionライブラリを利用した、コンパイルタイムに任意のプロパティに基づいてコンポーネントのサブセットを選択するというメタプロパティの選択方法について紹介する。最後に、ジェネリックパラダイムのもと幾何学的アルゴリズムを一般化するためのアプローチについて示す。&lt;/p&gt;
&lt;p&gt;これらアプローチの紹介を通じて、現代的プログラミングテクニックとBoostライブラリの適用により、非常に汎用的で、維持可能で、コンパクトで、拡張可能なコードを生み出せることを示す。以上から、長期的には高度なC++スキルを習得するために費した時間はペイすると結論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#vs-ide&#34; name=&#34;vs-ide&#34;&gt;C++開発者むけVisual Studio IDEの最新情報&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What’s new in Visual Studio IDE for C++ Developers&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sumit-kumar/&#34; target=&#34;_blank&#34;&gt;Sumit Kumar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/visual_studio_ide_for_cpp%20_developers.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/visual_studio_ide_for_cpp%20_developers.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=XLrR3cJCjlI&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=XLrR3cJCjlI&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;きたるVisual Studio 11のリリースには、IDEとのやりとりやチーム内の他のC++開発者と共同作業するといった、日々のコーディング作業でC++開発をより効率的にするような新しい機能や革新が数多く詰まっている。&lt;/p&gt;
&lt;p&gt;本プレゼンテーションではデモをごらんいただきながら、構文の色分け、参照のハイライト、進化したインテリセンス、コード解析、プロファイリングといった機能に焦点を当てて紹介する。また、ドキュメントとの連携、検索やナビゲーションといった普段の作業を非常に簡易化するIDEの改善点についてもひととおりごらんいただく。このプレゼンテーションではコードレヴューやテスト、コードカヴァレッジといった統合機能についても概説する。Visual Studio 11はC++開発者チーム全体に有益である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#modules&#34; name=&#34;modules&#34;&gt;キーノート： C++におけるモジュール&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Modules in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/david-vandevoorde/&#34; target=&#34;_blank&#34;&gt;David Vandevoorde&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modules_aspen2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modules_aspen2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=8SOCYQ033K8&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=8SOCYQ033K8&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の幕開け以来、プリプロセッサはC++ライブラリインターフェースとやりとりするための手段としての役割を果たしてきた。しかし、長年にわたり、プリプロセッサであるがゆえに生じる制約によって、不愉快なビルド時間は増加の一途をたどっている。今日、プリプロセッサはよりよいC++開発ツールをつくるにあたり唯一最大の阻害要因になっている。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、C++に&#34;モジュール&#34;の概念を導入するための選択肢を紹介し、それらがもたらす課題と恩恵について議論する。次のC++標準仕様に向けて、C++標準委員会はこれらの選択肢について活発に検討している段階である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#generic-programming-real-world&#34; name=&#34;generic-programming-real-world&#34;&gt;C++でのジェネリックプログラミング： 実例を交えて&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming in C++: A Real-World Example&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/marshall-clow/&#34; target=&#34;_blank&#34;&gt;Marshall Clow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/marshall_generic_programming.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/marshall_generic_programming.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=SWGMq0_X32Q&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=SWGMq0_X32Q&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この90分のセッションでは、Boost MLでいただいたリクエストに答えようと思う。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;なぜBoostには&lt;code&gt;hex&lt;/code&gt;／&lt;code&gt;unhex&lt;/code&gt;関数がないのか？ とても有用だと思うけど。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;また、Boost.Algorithmライブラリにマッチしたこれらのアルゴリズムのデザインと実装についても概説する。&lt;/p&gt;
&lt;p&gt;この関数は単純であるけれども、非常に多くの興味深い設計決定が実装中になされている。これについてもこのプレゼンテーションで述べるつもりだ。&lt;/p&gt;
&lt;p&gt;カヴァーする議題は以下の通り：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ジェネリックプログラミングデザイン&lt;/li&gt;
&lt;li&gt;イテレータの取り扱い(出力イテレータの問題についても述べる)&lt;/li&gt;
&lt;li&gt;テンプレートメタプログラミング(&lt;code&gt;enable_if&lt;/code&gt;の用法についても述べる)&lt;/li&gt;
&lt;li&gt;Boost.Exception&lt;/li&gt;
&lt;li&gt;コードの最適化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#lowest-variational-methods&#34; name=&#34;lowest-variational-methods&#34;&gt;Boost.Protoを用いた最低次変分法のドメイン特化固有言語の実装&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Implementing a Domain Specific Embedded Language for lowest-order variational methods with Boost Proto&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jean-marc-gratien/&#34; target=&#34;_blank&#34;&gt;Jean-Marc Gratien&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/jmg_cppnow_2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/jmg_cppnow_2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このペーパーでは、FreeFEM様のドメイン特化言語を用いて線型離散と双線型離散の定義を対象とする拡散問題を解くための最低次変分法族の原実装を示す。Boost Protoフレームワークの利用によって、この言語のバックエンドとフロントエンドをどう実装したかについて議論する。種々の学術的問題の実装を行なうことで、このDSEL設計を検証する。この言語のオーヴァーヘッドは従来の実装と比較することで評価する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-containers&#34; name=&#34;cpp11-containers&#34;&gt;C++11コンテナの最新情報&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What’s new with C++11 containers?&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/cppnow_containers.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/cppnow_containers.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11でピカピカのコンテナがいくつか導入された。すなわち、単方向リスト、ハッシュコンテナ、固定長同型コンテナ、そして異形コンテナである。しかしこれだけではない。前仕様C++98/03のコンテナも新しいメンバ関数の追加、ムーブのサポート、&#34;移動のみ&#34;のコンテナをつくれるように、&lt;code&gt;value_type&lt;/code&gt;に課されていた制限の緩和といった手直しがなされている。さあC++11のコンテナを有効利用する方法についてみていこう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#concept-clang&#34; name=&#34;concept-clang&#34;&gt;ConceptClang： C++ Conceptの実装モデル&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ConceptClang: An Implementation Model for C++ Concepts&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/andrew-lumsdaine/&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;,&lt;a href=&#34;http://cppnow.org/participant/larisse-voufo/&#34; target=&#34;_blank&#34;&gt;Larisse Voufo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/concept_clang.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/concept_clang.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Conceptはテンプレートに安全性を付与することを意図として、制約ベースのポリモルフィズムを行うために提案されたC++の拡張である。本プレゼンテーションではConceptClangを紹介する。これは、C族言語のLLVMフロントエンドであるClangをベースとする、Conceptデザインの検証を行うための基盤の実装例である。このプレゼンテーションでは、Conceptの提案された主要な機能(コンセプトに基づく探索、テンプレートのオーヴァーロード、テンプレートの拘束など)をどう実装したかについて述べるとともに、種々のConcept設計を深めていくために、ConceptClang基盤をいかに利用すればいいかについても示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#modern-cpp-techniques&#34; name=&#34;modern-cpp-techniques&#34;&gt;現代的C++テクニック入門&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Introduction to Modern C++ Techniques&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modern_cpp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modern_cpp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ポリシー、SFINAE、タグディスパッチ… ktkr! 現代的C++にノって弾みをつける準備はOK? Ciere C++ ニンジャシリーズから、このセッションでは基本的なことから、ジェネリックプログラミングで使われているテクニックやストラテジーを紹介する。このセッションで話すトピックは以下のとおり：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Concept&lt;/li&gt;
&lt;li&gt;Trait&lt;/li&gt;
&lt;li&gt;ポリシークラス&lt;/li&gt;
&lt;li&gt;CRTP (Curiously Recurring Template Pattern)&lt;/li&gt;
&lt;li&gt;SFINAE (Substitution Failure is not an Error)&lt;/li&gt;
&lt;li&gt;タグディスパッチ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この3時間のハンズオンチュートリアルは例がびっしりの参加型セッションである。ノートPCを持参されたし! 日々のコーディングで現代的C++の技法を使いたい開発者には、きっと得るものがあるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#smart-pointers-algorithm&#34; name=&#34;smart-pointers-algorithm&#34;&gt;C++11のスマートポインタとアルゴリズム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11 Smart Pointers and Algorithms&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/smart_pointers_algorithms.key?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/smart_pointers_algorithms.key?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++03で言うところのスマートポインタとは&lt;code&gt;auto_ptr&lt;/code&gt;だった。&lt;code&gt;auto_ptr&lt;/code&gt;は最良の型であり最悪の型である。このプレゼンテーションでは&lt;code&gt;auto_ptr&lt;/code&gt;がどのように&lt;code&gt;unique_ptr&lt;/code&gt;を触発したか、その違いはなにかについて説明する。&lt;code&gt;unique_ptr&lt;/code&gt;を比較対象として、&lt;code&gt;shared_ptr&lt;/code&gt;についても概説する。これらを使うべきときはいつか？ どちらのスマートポインタを使うべきか？&lt;/p&gt;
&lt;p&gt;加えて、このプレゼンテーションではC++11に新しく追加されたアルリズムについて、また、&lt;code&gt;unique_ptr&lt;/code&gt;のようなムーブのみ可能な型で動作するよう修正された多数の新旧アルゴリズムについても述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#voronoi&#34; name=&#34;voronoi&#34;&gt;Boost.Polygon.Voronoiライブラリを例に、堅牢かつ効率的多倍精度アルゴリズムの設計について&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Robust and efficient multi precision algorithms design based on Boost.Polygon.Voronoi library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/andrii-sydorchuk/&#34; target=&#34;_blank&#34;&gt;Andrii Sydorchuk&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/lucanus-simonson/&#34; target=&#34;_blank&#34;&gt;Lucanus Simonson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/voronoi_presentation_andrii_sydorchuk.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/voronoi_presentation_andrii_sydorchuk.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;複雑な数値計算アルゴリズムの設計と実装はユーザビリティ、拡張性、効率性、堅牢性という4つの要素を満たさねばならない。&lt;/p&gt;
&lt;p&gt;ユーザビリティとは、その分野に精通していないユーザーにとっての、公開されているアルゴリズムインターフェースのわかりやすさである。同時に、精通しているユーザーにとっての、アルゴリズムを構成できる幅のことでもある。&lt;/p&gt;
&lt;p&gt;拡張性とは、アルゴリズムそれ自身、依存するデータ構造、計算カーネル、数値型といった部分を再構成または置換する際、アルゴリズムに汎用性と柔軟性を持たせることである。&lt;/p&gt;
&lt;p&gt;効率性はまずアルゴリズムの複雑度とデータ構造の分析に始まり、メモリやパフォーマンスプロファイルを行い、システム/コンパイラ特異的な最適化に終わる。これには、数値型の操作および現実装と他のよく知られたアプローチとの比較も含まれる。&lt;/p&gt;
&lt;p&gt;堅牢性は数値アルゴリズムの最も重要な研究分野であろう。もし内部データ構造が実行時に破壊されたらどうなるか、という問いに対する答を用意しておくことである。アルゴリズムの出力と、出力がどの範囲で正常かつ信頼できるかを定義することでもある。言い変えれば、受けとった出力とランダムデータとの違いは何か、ということである。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、アルゴリズムの動機となった実世界の問題を見ていきながらアルゴリズムを紹介する。Boost.Polygon.Voronoiライブラリで用いているアルゴリズム設計テクニックと実装をもとに、上記で言及した要素全てについて示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#tool-for-class-and-library-authors&#34; name=&#34;tool-for-class-and-library-authors&#34;&gt;C++11: クラスやライブラリ実装者のための新しいツール&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11: New Tools for Class and Library Authors&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/schurr_cpp11_tools_for_class_authors.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/schurr_cpp11_tools_for_class_authors.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この新しい標準はクラスやライブラリ実装者のために、可変引数テンプレートや&lt;code&gt;static_assert&lt;/code&gt;、&lt;code&gt;constexpr&lt;/code&gt;、明示的な変換関数、および&lt;code&gt;decltype&lt;/code&gt;といった多数のツールが用意されている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cmake-modularization&#34; name=&#34;cmake-modularization&#34;&gt;CMake、モジュール化と Ryppl 開発者向けプレヴュー&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CMake, Modularization and Ryppl Developer Preview&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rypplは、C++の開発や、構築、テストならびにBoostとそのユーザーの要求、すなわちC++コミュニティに合わせて設計された配信のための基盤フレームワークである。巨大化、複雑化、また潜在的にモジュール化がすすむBoostは、Rypplの完全なテストケースになりえる。このため我々は一年間、このコンセプトを証明するために必要なシステムと変更に取りくんできた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、CMakeを使ってビルドおよびテストできるように、なにもインストールせずに配置できるように、またBuildBotを用いてリモートでビルド、テストできるようにするための、Boostのモジュール化にむけた作業の進捗について示す。BoostCon(訳註：C++Now2012のことか)が始まった時点で、Boost開発者に利用いただける、コミュニティ全体で予備的なレヴュー可能なシステムの機能を完全に揃えている予定である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#now-what&#34; name=&#34;now-what&#34;&gt;キーノート： さて、これからどうしよう？ 3つの視点から&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Now What? A vignette in 3 parts&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sean-parent/&#34; target=&#34;_blank&#34;&gt;Sean Parent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/now_what.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/now_what.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=iGenpw2NeKQ&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=iGenpw2NeKQ&amp;amp;feature=plcp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;パート1： 美しさ&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は効率性が要求されるところでは復権を果たした。しかし、C++へ移行してきた者に対して、いまだ多くの者が歓迎していない。これはJavaやJavaScript、Pythonからきたプログラマにとって移行の脅威になりえる。C++コミュニティとして、美しく、効率的なコードを書くための、C++11で提供されるツールを梃入れする必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;パート2： 真実&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のハードウェア上では、単一スレッドで実行されるC++コードではマシン性能のたった0.25%ほどしか引き出せない。C++11ではほんのちょっとだけスレッドサポートが解禁された。未来を見据える言語、ライブラリに課せられた最大の試練は、いかにマシン性能の残り99.75%を引き出すか、ということに尽きるだろう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;パート3： 美点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;過剰なネットワークディヴァイスはソフトウェアの展望を変えつつある。インターネットの基盤は次第に裏方にまわり、増えつづける顧客はディヴァイス上にある情報を簡便に取得できるよう要求している。そのようなシステムが我々のソフトウェア設計と記述にどんな影響を与えるだろうか？この新しい世界におけるC++の果たす役割とは何だろうか。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#compile-time-reparsing&#34; name=&#34;compile-time-reparsing&#34;&gt;コンパイル時 &#39;再パース&#39;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Compile-time ‘reparsing’&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/gordon-woodhull/&#34; target=&#34;_blank&#34;&gt;Gordon Woodhull&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/gordon_woodhull_reparsing_2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/gordon_woodhull_reparsing_2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++コンパイラは今コードをパースしているとする。さて、その一部を再度パースしたいとしたらどうだろう？&lt;/p&gt;
&lt;p&gt;数年前から、ドメイン固有特化言語のためのメタプログラミングライブラリ群が提案され、ユーザーや特殊なライブラリアンはC++内に独自の言語を構築できるようになった。このようなユーザーやライブラリアンは皆、実行時表現のEric Niebler氏によるBoost.Protoに精通する必要がある。しかし、Ábel Sinkovic氏による、コンパイル時文字列パースのためのMetaparseや、&amp;lt;&amp;gt;表記をパースするための、プレゼンターが作成した&#34;とんがった(原：Angly)&#34;パーサもある。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではこれら三つのライブラリを研究し、計算的に等価であることを(一方で、ドメインや表現力の違いについても)示す。コンピュータサイエンスの視点からは、これらライブラリは全てプッシュダウン・オートマトンである。ではなぜインターフェースがこうも違っているのだろう？対象ドメインの違いから生れるものなのか？それともライブラリ著者のバックグラウンドによるものなのか？&lt;/p&gt;
&lt;p&gt;また、コードをごらんいただきながら、これらのライブラリが実際にどのように動作するかごらんいただきたいと思う。このプレゼンテーションの大きな目的は、これらライブラリでどんなテクニックが一般的になっているか見ていくことと、共通のパターンがあるかどうか見ること、そして聴衆の皆様にメタプログラミングテクニックについて習熟していただくことである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#type-string-conversions&#34; name=&#34;type-string-conversions&#34;&gt;型から文字列への変換と、その逆&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Type to string conversions, and vice-versa&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jeroen-habraken/&#34; target=&#34;_blank&#34;&gt;Jeroen Habraken&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/convert_types_to_strings.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/convert_types_to_strings.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=WLYcyu6mlgg&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=WLYcyu6mlgg&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、型から文字列への変換、またその逆に変換する際の、さまざまな選択肢について研究していく。古くは&lt;code&gt;atoi&lt;/code&gt;や&lt;code&gt;strtol&lt;/code&gt;から、真新しくは&lt;code&gt;std::stoi&lt;/code&gt;や、&lt;code&gt;boost::lexical_cast&lt;/code&gt;のようなBoostで提供されているものまで見る。これら選択肢のエラーハンドリングやフォールバック機構、localeサポートといった観点からみた利点と欠点についても研究する。&lt;/p&gt;
&lt;p&gt;利点と欠点を見ていただいた後は、それら利点と欠点をもとにGoogle Summer of Codeで作成したboost::coerceについて、現在の選択肢をどう補間するか紹介したい。このライブラリは速度や拡張性の面で優れている。このプレゼンテーションでは設計について概説し、またどう達成したかについて、使用法の豊富な例とともに紹介する。&lt;/p&gt;
&lt;p&gt;時間が許すなら、カスタマイズポイントやSpiritとの関連を見ていきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34; name=&#34;cpp11-gems&#34;&gt;C++11にある珠玉の品々&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Other C++11 Gems&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jeff-garland/&#34; target=&#34;_blank&#34;&gt;Jeff Garland&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp11_allocators.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp11_allocators.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp_gems_garland_chrono_ratio.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp_gems_garland_chrono_ratio.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非常に重要だが、それ単品では1セッションに満たないようなトピックについてとりあげる。GarlandとHinnantは&lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;から。またstateful allocatorとregexへのサポートについてもとりあげる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#linear-programming-proto&#34; name=&#34;linear-programming-proto&#34;&gt;Boost Protoで線型計画法を簡単に&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linear programming made easy with Boost Proto&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/patrick-mihelich/&#34; target=&#34;_blank&#34;&gt;Patrick Mihelich&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/linear_programming_proto.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/linear_programming_proto.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;オペレーションリサーチや金融、チップデザインに渡る分野の問題は、線型計画にモデル化できる。決定問題のための高度に汎用的で効率的なアルゴリズムがあるメソッドとして、線型計画法は有効なツールである。&lt;/p&gt;
&lt;p&gt;GLPKのような、線型計画を解くための強力なソフトウェアライブラリが存在するが、低レヴェルAPIが非常に使いにくいので、問題を一旦人が読みづらい形式に変換する必要がある。AMPLのようなモデリング言語を使えば、問題を容易に叙述的に表現できるが、汎用プログラミング言語としての力量と親和性が足りない。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは線型計画法を表現し解くための、Boost.Protoを用いたDSELであるCVX++を紹介する。Protoはどちらの世界、すなわちC++に組み込まれた叙述的プログラミングスタイルとして最高の役割を果たしてくれる。CVX++はGLPKをバックエンドソルバとして備え、Protoを用いて目的関数と制約をより機械が読みとりやすい表現に変換する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#solidfire&#34; name=&#34;solidfire&#34;&gt;SolidFireではC++11への移行をいかにして成しとげたか&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How we switched to C++11 at SolidFire and how it worked out&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/travis-gockel/&#34; target=&#34;_blank&#34;&gt;Travis Gockel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=43ej-H8yHWE&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=43ej-H8yHWE&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、SolidFireのコードベースをC++03からC++11に移行する過程について、まず作業チームがワクワクするところから順に見ていく。正確性の検証やパフォーマンステストをどう行なったか、またそれとともに、C++03とC++11のどちらでも動作するコードをどう書いたらいいか紹介していくつもりだ(また、どうやって障害を迅速に乗り越えたかについても)。&lt;/p&gt;
&lt;p&gt;C++03/C++11開発で最初の月を越したころ、我々はよりよいコードを書くためにC++03コードベースのサポートを放棄した。このプレゼンテーションの第二部は、新しい標準によってもたらされる新しいコーディングスタイルについて述べる。また、それなしでは実装できなかったとんでもなくトリッキーなクラスや、可読性を上げるためにややトリッキーなことをしているクラスについても紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#refactoring-clang&#34; name=&#34;refactoring-clang&#34;&gt;ClangでC++のリファクタリング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Refactoring C++ with Clang&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/chandler-carruth/&#34; target=&#34;_blank&#34;&gt;Chandler Carruth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cxxnow2012_refactoring.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cxxnow2012_refactoring.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=yuIOGfcOH0k&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=yuIOGfcOH0k&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;十年来、C++開発者はJavaなどの言語が持っているツールをうらやましく思っていた。Clangでとうとう、我々は安全な自動変換を構築することができるほど簡便にC++コードの推論ができるようになる。このプレゼンテーションでは特殊なC++パターンの自動認識と変換をサポートする、Clang上に組まれた基盤について紹介する。また、古いAPIから新しい別のAPIへ更新するための、実際のソースコード変換ツールを実装するために必要な知識・技術についても示す。&lt;/p&gt;
&lt;p&gt;ライブラリの利用者が自身のコードを新しいAPIに置換するためのユーザー向けのスタンドアロンツールを組みあげることは、Boostのような広く利用されているライブラリでは非常に重要だが、C++11においては、新しい言語機能の利益を教授するために大量のインターフェースが更新されることになる。これらのインターフェースの採用を自動化することは、広く利用されているライブラリでは、長期にわたってサポートしなければならない非推奨APIの増加を抑える意味でも、急速な進歩をする上でも極めて重大なことである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#state-machine-coroutine&#34; name=&#34;state-machine-coroutine&#34;&gt;Boost.Coroutineを用いてステートマシンを解決する&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using Boost.Coroutine to untangle a state machine&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/nat-goodspeed/&#34; target=&#34;_blank&#34;&gt;Nat Goodspeed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/coroutine.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/coroutine.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションはイヴェント駆動型プログラムにおけるスタートアップのケーススタディである。このプログラムは外部サーバーへの一連のリクエストを生成し、それぞれ結果が返ってくるまで次のリクエストの生成を待機している。&lt;/p&gt;
&lt;p&gt;もともと、これはグローバルな&lt;code&gt;int&lt;/code&gt;状態変数を使って、巨大な&lt;code&gt;switch&lt;/code&gt;文として実装されていた。内在する関数はすべてのフレームで呼び出され、現在のステートロジックにジャンプし、結果を受けて状態を更新する。&lt;/p&gt;
&lt;p&gt;共同研究者がこれをBoost.Statechartを使って、ロジックをクラスのコレクションとして表現することで再実装した。&lt;/p&gt;
&lt;p&gt;どちらのケースでもロジックの構造は明確だった。実際の制御フローを解明するために、全てのコンポーネントの念入りな研究が必要だった。&lt;/p&gt;
&lt;p&gt;我々は同じロジックを、外部サーバーへのリクエストを結果が返ってくるまで待機する関数呼び出しとして表現するコルーチンとして再実装した。このような関数呼び出しはコルーチンだけを阻害する。すなわち、メインスタックの通常のフレーム毎の処理が継続する。実際のスタートアップ制御フローは、C++に精通していれば誰でも読める三重ループとして表現できる。さらに、メンテナンス(例えば、新しいリクエストを挿入するとか)は非常に容易である - これは前の実装ではとても言えなかったことであるが。&lt;/p&gt;
&lt;p&gt;このようなユースケースにおけるスレッドとコルーチンの対比を行う。&lt;/p&gt;
&lt;p&gt;coroutine オブジェクトの操作法について示す。&lt;/p&gt;
&lt;p&gt;Boost.Coroutineライブラリの微調整についても触れる。&lt;/p&gt;
&lt;p&gt;Boost.Contextがマージされたら、CoroutineをContextで再実装するつもりである。これこそまさにContextがサポートしようとしている種類のライブラリである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#metaprogramming-cpp11&#34; name=&#34;metaprogramming-cpp11&#34;&gt;C++11でのメタプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaprogramming in C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11で導入された新機能で、メタプログラマの世界は変化した。このプレゼンテーションでは、C++11メタプログラムをどう記述するかについての研究結果と、特にこの新しい言語にあわせたBoost.MPLの設計について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#numerical-problems-metaprogramming&#34; name=&#34;numerical-problems-metaprogramming&#34;&gt;メタプログラミングの数学的問題への適用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaprogramming Applied to Numerical Problems&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/karsten-ahnert/&#34; target=&#34;_blank&#34;&gt;Karsten Ahnert&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mario-mulansky/&#34; target=&#34;_blank&#34;&gt;Mario Mulansky&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/generic_stepper.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/generic_stepper.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ルンゲ=クッタ法と呼ばれるメソッドの高速かつ汎用的な実装をつくるために、現代的テンプレートメタプログラミングの手法をつかう。ルンゲ=クッタ法は常微分方程式(ODE: Ordinary Differential Equation)の初期値問題の近似解を探索する数値アルゴリズムである。常微分方程式を解くのは化学者、物理学者、生物学者にとっては日常のことである…&lt;/p&gt;
&lt;p&gt;今日、異なる一連のパラメータ値をとり、近似解の精度が違う、様々なルンゲ=クッタ法が存在する。そこで、これらのルンゲ=クッタ法を汎用的に実装し、テンプレートメタプログラミングを利用することで、非常に汎用的な実装であるにもかかわらず、非常に高いパフォーマンスを達成した。これは数値計算アルゴリズムの領域においてもテンプレートメタプログラミングの力を印象づける事例である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#tr2-boost&#34; name=&#34;tr2-boost&#34;&gt;TR2に向けたBoostライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boosting Libraries for TR2&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/boosting_libraries_for_standardization.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/boosting_libraries_for_standardization.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準委員会のLibrary Working Group(LWG)は新しいライブラリの技術報告、TR2に向けたライブラリ提案を待っている。開発者以外の方でも、BoostライブラリをTR2に提案できる。&lt;/p&gt;
&lt;p&gt;このセッションはまず、TR2にBoost ライブラリをうまく提案し、委員会を通して提案を導いていく方法についてのチュートリアルから入る。話す予定のトピックは以下の通り：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;どうしてわざわざこんなことを - 経験から得られるもの&lt;/li&gt;
&lt;li&gt;標準化プロセスの概略&lt;/li&gt;
&lt;li&gt;提案募集&lt;/li&gt;
&lt;li&gt;委員会ウェブサイトの案内&lt;/li&gt;
&lt;li&gt;システム - 提案はどのようなものか、 いつどこで提出するのか&lt;/li&gt;
&lt;li&gt;初期の提案 - 何を詳細に見て、何を詳細に見るべきではないかについて - 演習つき&lt;/li&gt;
&lt;li&gt;提案の用語と標準の記述&lt;/li&gt;
&lt;li&gt;ドラフトとレヴューを手伝ってもらう&lt;/li&gt;
&lt;li&gt;提案提出 - のるかそるか&lt;/li&gt;
&lt;li&gt;委員会からのフィードバックへの対応&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;セッションの後ろ半分はTR2にむけて実際にBoostライブラリの提案を一緒にやるワークショップを開く。まず提案のテンプレートの空欄を埋めていくところから始める。このワークショップにはLWGメンバが何人かいらっしゃるので、彼らに助言をもらったり、意見を聞いたりするといいだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#how-i-code-and-why&#34; name=&#34;how-i-code-and-why&#34;&gt;どうしてそう書くの？なんで？&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How I Code and Why&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/how_i_code_and_why.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/how_i_code_and_why.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost委員会の方々(まだ未定。だが以前のBoostConで参加していただける旨をうかがった方の暫定リストはある)に、日々のコーディングで従っている原則について、なぜこの原則を適用していうのか、どのあたりに価値があると思っているかについて説明していただこうと思う。&lt;/p&gt;
&lt;p&gt;(例えば、私は、なぜ自分の好きなコミットワードが&#39;otherwise&#39;なのか、以前聞いたり読んだりされているかもしれないが、これに関連するどのようなアドヴァイスがあるか、この天啓に至った事件は何かを説明するつもりだ)
このプレゼンテーションの目的は、現実世界の話を時として書籍や講義で語られる高尚な理念に引き上げることである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#preparation-cppnow-2013&#34; name=&#34;preparation-cppnow-2013&#34;&gt;C++Now! 2013に向けた準備&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preparation of C++ Now! 2013&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来年の会合の準備委員会は早期に動きだす。提案があったり、支援していただける方はぜひご参加いただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;winrt&#34;&gt;WinRTにむけたC++コンポーネント拡張&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Component Extensions for WinRT&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/ale-contenti/&#34; target=&#34;_blank&#34;&gt;Ale Contenti&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/cpp_component_extensions_for_winrt_upload_version.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/cpp_component_extensions_for_winrt_upload_version.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は他のプログラミング言語やテクノロジー(例えば、 iOSのObjective-C、AndroidのJava、Windowsの.NETなど)を適用するプラットフォームにおいても活用されている。異種プログラミングプロジェクトがもたらす課題の一つに、C++の外部オブジェクトモデルとの結合という要求がある。CORBAやCOMといった既存の方法は一定の成功を収めているが、開発者は複雑性の増大というツケを払う羽目になる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、この問題に対処するために、Microsoftが取った二つのアプローチの詳細について述べる。最初のアプローチは、同じアプリケーションの中に、C++と非C++コンポーネント(外部オブジェクトモデル)が 混在するという複雑性に対処するためにC++抽象化レイヤを採用するというものである。この抽象化レイヤ(例えば Boostユーザーや開発者の方々にはおなじみの今日的C++テクニックをがっつり使ったWRLライブラリとか)はCOMコンポーネントの実装を単純化したが、このソリューションにある一般概念は他のいかなる異種混在環境においても拡張可能である。二つ目のアプローチは、異種言語で記述されたピア(訳註： 同格のコンポーネント)とやりとりするコンポーネントの宣言と定義ができるように、その構文にいくつかの拡張を追加して、C++自身の境界を押し上げることである。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではこれら二つのアプローチについて、長所と短所、利点と注意事項についてそれぞれ説明していく。最後に、これらの設計が、C++の進化にとって潜在的にどのような影響を与えるかについてお話しする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#value-semantics&#34; name=&#34;value-semantics&#34;&gt;値のセマンティクスとConceptベースの多態&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Value Semantics and Concepts-based Polymorphism&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sean-parent/&#34; target=&#34;_blank&#34;&gt;Sean Parent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/fri/value_semantics/value_semantics.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/fri/value_semantics/value_semantics.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プレゼンターであるSeanは先のキーノートの &lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#now-what&#34;&gt;&#34;Now What? A vignette in 3 parts.&#34;&lt;/a&gt; で話した値のセマンティクスとConceptベースの多態コンセプトについて、更に深めていくつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Boostの将来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Future of Boost&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostとC++Now!の発起人であるお三方が将来について語り、どう考えているのかお答えする。&lt;/p&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi、zak、DigitalGhost&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2013 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/cppnow/2013.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:cppnow/2013.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;C++Now! 2013&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://cppnow.org/schedule-table/&#34; target=&#34;_blank&#34;&gt;http://cppnow.org/schedule-t&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2013&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2013&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#doe&#34;&gt;キーノート： DOEによるC++の高性能コンピューティング - 過去と未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#survey-of-mt&#34;&gt;C++11とBoostにおけるマルチスレッドプログラミングサポートの概説&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#qt-eventloop&#34;&gt;Qtのイベントループ、ネットワーク、入出力API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#container-boost&#34;&gt;Boostのコンテナ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#low-level-threading&#34;&gt;C++11での低レベルスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#zephyr-cpp11&#34;&gt;&#39;優しきそよ風&#39;の見たC++11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#proto-0x&#34;&gt;Proto-0x初お披露目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#nonalloc-future&#34;&gt;アロケートしない&lt;code&gt;std::future&lt;/code&gt;／&lt;code&gt;promise&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#debug-tmp&#34;&gt;C++テンプレートメタプログラムのデバッグとプロファイリング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#optimize-structure&#34;&gt;キーノート： C++の創発的構造を最適化する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#small-stuff&#34;&gt;おいしい小さな機能たち： 波カッコ初期化、共用体、列挙型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#agda&#34;&gt;Agdaへの知識向上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#hpx&#34;&gt;HPX: 非同期並列と分散コンピューティングのためのC++標準準拠ランタイムシステム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#scaling-cpp11&#34;&gt;C++11でスケールさせる！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#charm&#34;&gt;Charm++を使った並列プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#easy-binary-compatible&#34;&gt;C++の複数コンパイラ間バイナリ互換インタフェースを簡単に作る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#transactional-memory&#34;&gt;C++でのトランザクショナルメモリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#libcppa&#34;&gt;libcppa - C++11でのアクターセマンティックな設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#binary-compatibility&#34;&gt;ライブラリ開発者が知るべきバイナリ互換性について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#yet-another-paradigm-shift&#34;&gt;さらなるパラダイムシフト? (並行のMeta4モデル)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#spirit-x3&#34;&gt;Inside Spirit X3: C++11で再設計されたBoost.Spirit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#weak-hiding&#34;&gt;C++コンセプトのための弱い隠蔽: プログラミング言語の名前バインディングについて推論するフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cpp11-qt5&#34;&gt;Qt5でC++11を使う： 課題と解法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#thread-safe-bag&#34;&gt;スレッドセーフでスレッド中立なbag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#practical-cpp11-odb&#34;&gt;実践C++11：ODBへのC++11サポート追加で学んだこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#bloomberg&#34;&gt;応用階層的再利用: Bloomberg基盤ライブラリの利用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#boost-dispatch&#34;&gt;Boost.Dispatch - 汎用タグディスパッチ基盤ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#vienna&#34;&gt;計算科学向けViennaライブラリについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#alignment&#34;&gt;C++のアラインメント: 利用法、制限、および拡張法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#community-dev&#34;&gt;C++ コミュニティの発展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#dynamic&#34;&gt;動的なC++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#debruijn&#34;&gt;DeBruijn Bind: シンプルさを維持するより強力なbind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#multi-threading&#34;&gt;C++11とBoostを利用したマルチスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#concept-lite&#34;&gt;軽量コンセプト: 述語による制約テンプレート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#html5&#34;&gt;ママ見て “C++を使ってデータベース更新からHTML5が生成されたよ”, 自動化して!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#odb&#34;&gt;C++(11)のためのORマッパー：ODB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#fusion&#34;&gt;Fusionで世界の謎を解く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#dds&#34;&gt;モダンなC++向けのデータ分散サーヴィス(DDS: Data Distribution Service)の標準化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#member-access-operator&#34;&gt;メンバーアクセス演算子のオーヴァーロード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cern&#34;&gt;CERNでの対話的で内省的なC++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#haskell&#34;&gt;Haskellの力でMPLを強化しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#object-transmission&#34;&gt;Boost.AsioとBoost.Serialization: オブジェクト受け渡しのデザインパターン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cppnow-2014&#34;&gt;C++Now 2014の準備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#hetero&#34;&gt;静的型付け言語における、動的で再帰的なヘテロ型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#projucer&#34;&gt;Projucer: C++とLLVM JIT エンジンを利用したライブコーディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#matrix&#34;&gt;EigenとBoost Protoライブラリを用いた有限要素マトリックス式の組み立て&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#deadlock-prevention&#34;&gt;侵入的動的解析を使用したリソースデッドロック防止システム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#future-of-boost&#34;&gt;Boostの未来&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#doe&#34; name=&#34;doe&#34;&gt;キーノート： DOEによるC++の高性能コンピューティング - 過去と未来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: C++ Use in High Performance Computing Within DOE: Past and Future&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/daniel-quinlan/&#34; target=&#34;_blank&#34;&gt;Daniel Quinlan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=zZGYfM1iM7c&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=zZGYfM1iM7c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#survey-of-mt&#34; name=&#34;survey-of-mt&#34;&gt;C++11とBoostにおけるマルチスレッドプログラミングサポートの概説&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Survey of Multi-Threaded Programming Support in C++11 and Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/rob-stewart/&#34; target=&#34;_blank&#34;&gt;Rob Stewart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルではBoostとC++11によるマルチスレッドプログラミング向けのツールについて概説します。&lt;/p&gt;
&lt;p&gt;このセッションの内容に取り入れる事が明らかな項目としては、例えば &lt;code&gt;std::thread&lt;/code&gt; や &lt;code&gt;boost::thread&lt;/code&gt; 、またより先進的な機能、 例えば &lt;code&gt;std::async&lt;/code&gt; 、それに、これらを実現する為のより基本的な部品として、例えばミューテックス(&lt;code&gt;std::mutex&lt;/code&gt;)、条件変数(&lt;code&gt;std::condition_variable&lt;/code&gt;)、アトミック(&lt;code&gt;std::atomic&lt;/code&gt;) などが挙げられる。&lt;/p&gt;
&lt;p&gt;つまるところこのセッションでは全体として、BoostやC++11が如何に皆さんのマルチスレッドプログラムのコーディングを助けてくれるのかについて概説します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#qt-eventloop&#34; name=&#34;qt-eventloop&#34;&gt;Qtのイベントループ、ネットワーク、入出力 API&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Qt event loop, networking and I/O API&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Qtフレームワークが誕生したのは1990年台始めの頃の事、その時Qtはまだ、単純な目的の為だけに開発されたんだ。そう、グラフィカルプリケーションを作る為のクロスプラットフォームなAPI（それもその当時はせいぜいデスクトップとワークステーション程度を対象にね）としてね。それからQtはその目標を遥かに超えてよく成長してくれました。今日ではGUIツールキットの枠を超えて他の多くのサブシステム群、データベース接続、WEB技術との統合、そしてパワフルな非同期I/Oとネットワーク周りの機能等々を提供するに至っている。このセッションではそれらの中から、QtのI/Oとネットワーク周りについてチュートリアル形式で紹介します。&lt;/p&gt;
&lt;p&gt;Qtの全ての非同期的なメカニズム群はイベントループないしメインループによるセントラルイベントハンドリングのループから呼び出されています。そうしてQtが提供する非同期I/Oによる子プロセスの動作や、TCP接続群のアクセプト、TCP接続群の発信の生成、TCPとUDPのI/Oハンドリング、その他のタスク群が構築されています。もちろんそれはHTTPとFTPのダウンロードとアップロードと言った高レベルなイベントにも至ります。このセッションではそれら全てのサブシステム群についてを取り上げ、どうやってアプリケーションにそれらを組み込んで使うのかについて、例示をしたり、それに一緒に議論をしたいと考えています。このセッションを通じてライブラリー開発者とアプリケーション開発者、双方の理解をQtを通して深める機会として頂ければ幸いです。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#container-boost&#34; name=&#34;container-boost&#34;&gt;Boostのコンテナ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Containers in Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-schaeling/&#34; target=&#34;_blank&#34;&gt;Boris Schäling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostライブラリは、多くの便利なコンテナと、標準コンテナの素敵な拡張を提供している。このセッションでは、Boostにある以下のコンテナ群を見ていく： Boost.Multiindex、Boost.Bimap、Boost.CircularBuffer、Boost.PropertyTree、Boost.DynamicBitset、Boost.PointerContainer、Boost.Intrusive。開発者は、自分のプロジェクトに恩恵をもたらすコンテナを選択できるようになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#low-level-threading&#34; name=&#34;low-level-threading&#34;&gt;C++11での低レベルスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Low Level Threading with C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は現在、「メモリモデル」を持っている。それは何を意味するのか、それはなぜあるのか、それが必要ならなぜこれまでなかったのか？これがあると我々は何ができるのか？これは新しく入ったアトミック操作と多少関連があるようだ。うーん・・・。&lt;/p&gt;
&lt;p&gt;(これは昨年やったチュートリアル「C++11の新たなメモリモデルとアトミック」のアップデートである。)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#zephyr-cpp11&#34; name=&#34;zephyr-cpp11&#34;&gt;&#39;優しきそよ風&#39;の見たC++11&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Zephyr Overview of C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/leor-zolman/&#34; target=&#34;_blank&#34;&gt;Leor Zolman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;去年の事、私はC++11の殆どの機能について、たった90分だけの&#34;嵐の様な&#34;セッションで質問に答える間も無く、その可能性について示すに留まった。&lt;/p&gt;
&lt;p&gt;そして今年、私は1本90分のセッション枠を拡大して、2本分のセッションを使える事になった。参加してくれるみんな（それに私自身も含めて）、今回はきちんと息をする余裕もあるよ。だから今回は質問に答えたり、それにひょっとしたらライブコーディングをできるチャンスもあるかもしれないね。&lt;/p&gt;
&lt;p&gt;内容については凡そ去年のそれと同じにするつもりだけど、去年は時間が無くて扱えなかった言語とライブラリーの機能、それと実装例なんかも用意したいね。&lt;/p&gt;
&lt;p&gt;(訳者註: Zephyr(ゼファー)はギリシア神話の風の神様の中で最も温和で春の訪れを告げる豊穣の優しいそよ風の神様のこと。)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#proto-0x&#34; name=&#34;proto-0x&#34;&gt;Proto-0x初お披露目&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A First Look at Proto-0x&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/eric-niebler/&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Protoは、C++に組み込みドメイン特化言語(EDSL)を構築するためのライブラリである。Boostでは、Spirit、Phoenix、Xpressive、MSM、それと提案中ではあるがBoost.SIMDのようなライブラリが、Protoによる式テンプレートベースで構築されている。Protoで定義されたEDSLは、手間のかかるテンプレートメタプログラミングの雑用からライブラリ作者を解放し、構文やセマンティックアクションといった面で、高レベルに表現できる。&lt;/p&gt;
&lt;p&gt;Boost.Protoの現在利用可能なバージョンは、C++03言語の限界を押し上げてはいるが、言語によって課せられる制約で苦しんでいる。このトークでは、C++11で再設計されたProtoの新バージョンについて話す。これは、EDSLの設計を、これまで以上に簡単かつ安全にできる。&lt;/p&gt;
&lt;p&gt;このトークでは、Proto-0xによる小さなEDSL定義の基本をカバーする。新しいProtoは、古いProtoと異なるポイントはあるが、その事前知識は必要ない。C++11の新機能がProtoの設計にどのような影響をもたらしたか、また、それらの機能が一般的なライブラリ設計を、根本的なところでより良くすることを紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#nonalloc-future&#34; name=&#34;nonalloc-future&#34;&gt;アロケートしないstd::future／promise&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Non-Allocating &lt;code&gt;std::future&lt;/code&gt;/&lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共有状態 - mutex/convarが待ち合わせるように別スレッドの処理の結果を置く場所 - は、&lt;code&gt;future&lt;/code&gt;と&lt;code&gt;promise&lt;/code&gt;はいつでもムーヴ、破棄され得るので、&lt;code&gt;future&lt;/code&gt;と&lt;code&gt;promise&lt;/code&gt;で別々にアロケートされる必要があると予想される。故に共有状態には別個のメモリ配置が必要である。&lt;/p&gt;
&lt;p&gt;本当にそうだろうか？&lt;/p&gt;
&lt;p&gt;このセッションでは、等式の右辺、左辺ともにムーヴ中もしくは破棄されようとしていても、アロケートなしで状態を共有するために細心の注意を払ってロックフリーの技術を用いる&lt;code&gt;std::future&lt;/code&gt;／&lt;code&gt;promise&lt;/code&gt;の草案について説明する。&lt;/p&gt;
&lt;p&gt;このセッションは非常にインタラクティヴなものになるだろう。聴者諸氏は実装に漏れがなくなるまで、実装のどのステップについても問題点を指摘していただきたい。このセッションでは、ロックフリーテクニックを現実のコードにどう適用したらいいか、感覚がつかめるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#debug-tmp&#34; name=&#34;debug-tmp&#34;&gt;C++テンプレートメタプログラムのデバッグとプロファイリング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Debugging and Profiling C++ Template Metaprograms&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/zoltan-porkolab/&#34; target=&#34;_blank&#34;&gt;Zoltan Porkolab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++テンプレートメタプログラミングは、テンプレートの巧妙な定義によって、C++コンパイラにコンパイル時にアルゴリズムを実行させる、よく知られた手法である。アプリケーションにおけるテンプレートメタプログラムには、式テンプレート、静的なインタフェースチェック、アダプトによるコード最適化、組み込みドメイン特化言語とアクティブライブラリなどがある。C++11の新機能は、テンプレートメタプログラミングをさらに魅力的にする。&lt;/p&gt;
&lt;p&gt;その重要性にもかかわらず、C++テンプレートメタプログラミングの設計、保守、分析を支援するためのツールは、驚くほど少ない。テンプレートの重いコードを使用することでプログラムに増加されるコンパイル時間は、その分野への挑戦が少なくなっている理由のひとつである。利用できるデバッガ、プロファイラといったツールの欠如は、テンプレートメタプログラミングの広い使用を妨げている。&lt;/p&gt;
&lt;p&gt;我々は、これまでの経験に基づいて、テンプレートメタプログラムのデバッガとプロファイラのプロトタイプツールセットを開発している。このツールセットの目的は、C++テンプレートの使用率が高い、大きなコードベースで作業している、開発者やメンテナのためのサポートを提供することだ。このツールセットは、C++テンプレートメタプログラムのバグやコンパイルボトルネックを調査するという、おもしろいことができる。&lt;/p&gt;
&lt;p&gt;このツールセットは、LLVM/ClangオープンソースC++コンパイラインフラストラクチャ上に構築されている。テンプレートに関連するコンパイラアクションの最も重要なキャプチャは、プログラムの「インスタンス化スタック」を記録し、XML形式のトレースファイルを出力する。このファイル内の全てのエントリは、テンプレートインスタンス化の最初か最後を表す。エントリには、Clang仕様のイベントの型が含まれる。さらにくわしい情報は、テンプレートの名前へのインスタンス化、およびインスタンス化によるコードの位置(通常は、呼び出し元)である。プロファイルに関連する情報は、インスタンス化の時間(これは実行時間:wall time)と実際のメモリ使用量が含まれるタイムスタンプである。時間とリソース消費のメモリプロファイリングは、オフにすることができる。プロファイリングの歪み(distortion)を最小限に抑えるには、XMLトレースファイルの内部バッファと生成の遅延を行う。我々の計測では、時間の歪みは3%未満だった。&lt;/p&gt;
&lt;p&gt;また、我々はトレースファイルに格納されている結果を資格する、Qtベースのフロントエンドも開発した。このフロントエンドは、実行時デバッガと同様、ユーザーがブレークポイントを設定でき、ステップバイステップでインスタンス化を再生できる、ソースコードビューを持っている。興味のないインスタンス化は、正規表現を使用して可視化から除外できる。他のビューとしては、インスタンス化にかかる時間と、オプショナルなメモリ使用量のプロファイル情報がある。最後に、インスタンス化の依存関係を表現し、インスタンス化手順のアニメーション化とグラフ化を行う。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#optimize-structure&#34; name=&#34;optimize-structure&#34;&gt;キーノート： C++の創発的構造を最適化する&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Optimizing the Emergent Structures of C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/chandler-carruth/&#34; target=&#34;_blank&#34;&gt;Chandler Carruth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=eR34r7HOU14&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=eR34r7HOU14&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日、C++ソフトウェアの複雑さはいや増している。この複雑さを管理し、大規模アプリケーションやシステムを構築するべく、C++は、シンプルなパターンを組み合わせて非常に複雑かつ強力なシステムをつくりだす創発的構造(自然界ではよく見られる、雪の結晶のような対象構造)をつくりだすべく努力している。このような構造により、各コンポーネントの複雑性を制限し、ソフトウェア開発する上で信頼できるスケーラビリティが得られる。&lt;/p&gt;
&lt;p&gt;手持ちのディヴァイスからウェアハウス級データセンターまで、よりディヴァイスを小さくしようとしたりと電力消費を抑えようとして、C++を利用すると、効率と複雑さが相応しないシステムになってしまうことは疑いない。今日も最適化がすすむC++コンパイラはかつてないほどその重要性が高まっているが、現役プログラマにはほとんどそれが伝わっていない。これらのことを鑑みると、高度創発的構造はC++システムを拡大し、しばしば最適化に関する独創的で未解決の問題を提起することがある。&lt;/p&gt;
&lt;p&gt;このセッションでは、今日の最適化されたコンパイラがC++コードをいかに高度にコンパイルするか、という概観から始める。次に、C++コードの創発的構造を単純かつエレガントに形成する鍵となる特殊な構造とパターンについて概説する。さらに、このような相互作用をいかに効率的にモデル化し解析できるかについて、効率的な完成プログラムを作るためのコンパイラを使って検証する。実際のケーススタディを例としてとりあげ、最新のC++コードベースで表現され、広く適用可能であることを示す。これらのパターンによる意味に気付いていただくために、最適化されたコンパイラとC++コード双方の相互作用を理解するためのフレームワークを示すことが目的である。最後に、特にそれぞれのコンポーネントが単純さを保持し、組み合わせによって力を発揮する、今日の最適化向けの方法を示すため、C++プログラムやライブラリの設計上、実装上の技術および原理について示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#small-stuff&#34; name=&#34;small-stuff&#34;&gt;おいしい小さな機能たち： 波カッコ初期化、共用体、列挙型&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sweating the Small Stuff: Brace Initialization, Unions and Enums&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11は多くの派手な新機能がある： ラムダ式、ムーブコンストラクタみたいな。このようなカッコイイ機能に比べてセクシーさでは劣るが、便利な変更がいくつか入った。このトークでは、初心者から中級レベルの専門家に向けて、C++11の波カッコ初期化(一様初期化とも呼ばれる)、共用体、列挙型について話す。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;agda&#34;&gt;Agdaへの知識向上&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Intellectual Ascent to Agda&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/david-sankel/&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数学とコンピュータサイエンスについて考えていると、漸近解析と物理シミュレーションのビックリするようなアルゴリズムが思いつくことがある。これらはいつも見過ごされがちな表示的意味論であり、構文と意味論の数学である。&lt;/p&gt;
&lt;p&gt;表示的設計(denotative design)、表示的意味論の実践は、シンプルで、合成可能で、信じられないほどパワフルなライブラリを作るトップダウン設計の方法論である。これは全く異なる文化のものだが、一般的に使用できる。そのパワフルなテンプレートエンジンは、C++に特に適している。&lt;/p&gt;
&lt;p&gt;このセッションでは、純粋関数型で依存型言語であるAgdaの構文を使用して、ドメイン固有の数学的エンティティからC++プログラムに派生させる表示的設計を、以下にして適用するかを学ぶ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#hpx&#34; name=&#34;hpx&#34;&gt;HPX: 非同期並列と分散コンピューティングのためのC++標準準拠ランタイムシステム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HPX: A C++ Standards Compliant Runtime System For Asynchronous Parallel And Distributed Computing&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/hartmut-kaiser/&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/vinay-amatya/&#34; target=&#34;_blank&#34;&gt;Vinay Amatya&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マルチコアとマルチスレッディングは、新しい計算手法であり、科学分野か非科学分野かに関わらず、システムの継続的なスケーラビリティを得るためには、ノード内だけでなくノード間もスケールさせる必要がある。新しいアーキテクチャにおける計算量やサイズ増加といったものは、スタベーション、レイテンシー、オーバーヘッド、競合解決待ちと呼ばれ、これらはシングルコアマシンでも存在はしていたが、表面化しにくかった。Exaflopレベルにシステムを拡張すると、この大幅に少ないリソース使用率の面でコストが増加する。その間、スケーリングシステムであっても、特定クラスのアプリケーションは従来の計算モデルを使用してスケールすることはできない。&lt;/p&gt;
&lt;p&gt;HPXは、新たな計算モデルに対する新たなランタイムシステムである(ParalleXは、上述した問題への挑戦である)。HPXはC++で実装され、最新のC++標準とBoostに準拠している。HPXは、新たな計算モデルに対する新たなランタイムシステムである(ParalleXは、上述した問題への挑戦である)。HPXは、様々な実績あるソフトウェア技術とアルゴリズムを、理解しやすくすることができます。HPX APIは、マルチコア・マルチスレッド化された混在アークテキチャとユーザーレベルソフトウェアアプリケーションのシームレスな統合のためのインタフェースを提供し、学ぶのを容易にする。&lt;/p&gt;
&lt;p&gt;非同期と計算、通信、それらを組み合わせることは、新たなマルチコア混在アーキテクチャをサポートする、新たな計算モデル要件のひとつとして重要である。非同期タスク(アクションという形式でのローカル関数やリモート関数)は、HPXの主要設計機能のひとつである。HPXは最新のC++標準がサポートしているローカル非同期関数だけでなく、リモート非同期関数も実装している：Actionという。これに加えて、非同期をサポートするのに本質的な、タスク実行中にFutureやDataFlowとしてデータを構築することができる。&lt;/p&gt;
&lt;p&gt;マルチコアドメインはシステムアーキテクチャ分野での巨大な飛躍にも関わらず、数十コアを超えたスケーラビリティ制限の課題がある。したがって、高パフォーマンスシステムでは、我々は複数ノードのBeowulfタイプのクラスターに依存している。通信の待ち時間が大幅に増加するようなシステムでは、非同期が大きな役割を果たしている。これに加えて、コアを数万を超えて拡張すると、新たなアドレッシングシステムが必要となり、アクティブアプリケーションのリモートスレッドオブジェクトを一時的に停止するのを許可するだけでなく、リソースの必要性(システム的な失敗やビジー状態)に従ってタスクを移動する必要がある。このアクティブなアドレッシングスキームは、HPXではActive Global Address Space(AGAS)として実装されている。このアドレッシングスキームは、HPXを、アプリケーションの必要性に応じた正しいリソース配置のためのリソースマネージャーをサポートすることを可能にする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#scaling-cpp11&#34; name=&#34;scaling-cpp11&#34;&gt;C++11でスケールさせる！&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scaling with C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/edouard-alligand/&#34; target=&#34;_blank&#34;&gt;Edouard Alligand&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プロセッサのコア数が増加するにつれて、ソフトウェアはムーアの法則からの恩恵を受けるために、複数のタスクを実行できるようにする必要がでてきます。これは並列アルゴリズムを書くという問題だけではなく、スレッド間の依存関係を正しく減らす、アプリケーション設計の問題でもあります。これらの依存関係を見つけることは、シリアルプログラミングの数十年の結果から見ても、非常に難しいことです。したがって、真にスケーラブルなソフトウェアを書くことは、精神状態を適切に適応させることよりも小さな、技術的な専門知識の問題です。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、超スケーラブルなデータベースである「quasardb」を書いたチームによって使用されている、設計、手法、ツールについて話します。具体的なスケーラビリティの課題として、典型的なマルチスレッドプログラミングのアンチパターンと、それを避ける方法を紹介します。説明するトピックは、以下のものをカバーします：アトミック、マイクロロック、Lock-freeとwait-freeなコンテナ、メモリ管理戦略(copy on write、スマートポインタ、完全転送)、スレッドローカル記憶域、非同期I/I、その他いろいろ！&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、システムプログラミングとC++11(ラムダと右辺値参照)の十分な知識を想定しています。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#charm&#34; name=&#34;charm&#34;&gt;Charm++を使った並列プログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Programming using Charm++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/phil-miller/&#34; target=&#34;_blank&#34;&gt;Phil Miller&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/axmikant-kale/&#34; target=&#34;_blank&#34;&gt;Laxmikant Kale&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/ramprasad-venkataraman/&#34; target=&#34;_blank&#34;&gt;Ramprasad Venkataraman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Charm++は、20年の実績があり、シングルワークステーションから世界最大のスーパーコンピュータまでカヴァーするハイパフォーマンスなC++ベースの並列プログラミングフレームワークである。このフレームワークは共有メモリシステムと分散メモリシステムを、双方のシステムで共通な技術で横断できる並列実行機能を備える。&lt;/p&gt;
&lt;p&gt;並列の単位としてオブジェクトを利用することで、Charm++は、関連するオブジェクトのコレクションによる並列アプリケーションロジックが表現できる。これにより、現存するハードウェアを十分効率的に利用する、結合可能な並列ソフトウェアが作成できる。実行中、Charm++のランタイムシステムはアプリケーションの挙動とシステムの状態を観測し、その結果に応じて、オブジェクトとプロセッサのマッピングを行なう。そうすることで、ランタイムシステムは効率よくロードバランスやエネルギー管理といったドメインに依存しない要求を自動化できる。それゆえ、アプリケーション開発者は、アプリケーションやユーザーからのそういった要求に取り組むことから解放される。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではCharm++での並列アプリケーション開発の原理について示す。このパラダイムを使った並列アルゴリズムを記述する利点についても述べる。高速でスケーラブルなソフトウェアを作成するためにCharm++をどのように使うかという例もいくつか紹介する。Charm++を使って、自身の並列プログラムを構築するための並列ロジックをどう組みあげるかについて学習する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#easy-binary-compatible&#34; name=&#34;easy-binary-compatible&#34;&gt;C++の複数コンパイラ間バイナリ互換インタフェースを簡単に作る&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Easy Binary Compatible C++ Interfaces Across Compilers&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/johnbandela/&#34; target=&#34;_blank&#34;&gt;John Bandela&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は他の生産性が高い言語から、使うのが難しいと認識されています。その理由のひとつに、バイナリコンポーネントの互換運用性の欠如があります。ライブラリを使用するとそのうち、ソースから構築したり、複数のバイナリを配布したりする必要が出てきます。たとえばWindowsでは、GCC Mingw、Visual C++ 2010(のリリース、デバッグ、静的と動的のCRT)、Visual C++ 2012などのバイナリを配布する必要があります。この問題を回避するための試みがいくつかある。たとえば、選択肢のひとつとしてextern Cを拡張してCOMやXPCOM、C++/CXといったものを追加することが考えられるが、このオプションにはコンパイラの拡張機能を必要とするとともに、現代のC++では低レベルであるように感じる。&lt;/p&gt;
&lt;p&gt;C++11を実装している多くのコンパイラは、ラムダ式や可変引数テンプレートといった便利な機能を持っており、これらを使用して簡単に複数のコンパイラ間で動作するバイナリインタフェースを実装できます。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、以下の恩恵を受けるための、ライブラリの設計と実装について議論します：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部ツールを必要としない&lt;/li&gt;
&lt;li&gt;インタフェースを一度だけ定義し、その定義を実装とユーザーコードで使用する&lt;/li&gt;
&lt;li&gt;インタフェースは、簡単に実装でき、一度だけ定義すればよい&lt;/li&gt;
&lt;li&gt;そのインタフェースで&lt;code&gt;std::string&lt;/code&gt;、&lt;code&gt;std::vector&lt;/code&gt;、&lt;code&gt;std::pair&lt;/code&gt;を使用する&lt;/li&gt;
&lt;li&gt;現実的な戻り値で使用する(エラーコードではない)&lt;/li&gt;
&lt;li&gt;例外を使用する実装と使い方&lt;/li&gt;
&lt;li&gt;COMとバイナリ互換性を持つ&lt;/li&gt;
&lt;li&gt;インタフェースの継承をサポートする&lt;/li&gt;
&lt;li&gt;実装の継承をサポートする&lt;/li&gt;
&lt;li&gt;実装は、WindowsのVisual C++の実行ファイルとGCCの.dllでテストした&lt;/li&gt;
&lt;li&gt;実装は、LinuxのGCCの実行ファイルと、Clangの.soでテストした&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、上記の機能の実装について議論し、そのいくつかのトレードオフを見ていきます。私は、参加者との、異なるアプローチでこれよりうまく作る方法について議論するのを待ちわびている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#transactional-memory&#34; name=&#34;transactional-memory&#34;&gt;C++でのトランザクショナルメモリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Transactional Memory in C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準のSG5は、2種類のトランザクションに基いて&lt;a href=&#34;https://sites.google.com/site/tmforcplusplus/&#34; target=&#34;_blank&#34;&gt;V1.1 of the Draft Transactional Memory for C++&lt;/a&gt;を4年間取り組んでいる。&lt;/p&gt;
&lt;p&gt;この提案は、2種類のトランザクションをサポートする：&lt;/p&gt;
&lt;p&gt;分離トランザクション(isolated transaction)はいくつかの種類の安全性アノテーションを通じて、非トランザクションコード(と同様のトランザクション)と通常のトランザクションを通信できる。&lt;/p&gt;
&lt;p&gt;我々はさらに、完全なコンパイル時チェックから動的チャックまで、様々なレベルの安全性アノテーションをサポートするための異なる手法を示し、プログラマの負担を軽減させる。&lt;/p&gt;
&lt;p&gt;これがSG5の技術仕様としてのBrisol 2013の提案意図である。&lt;/p&gt;
&lt;p&gt;現在あるいくつかのTMは、時期尚早だと考えているが、ハードウェアサポートが間もなく来るだろう、ということを言わせてほしい。Intelは最近Haswellを発表したし、IBMのBG/Q、それ以前にはSunのRockもある。ソフトウェアTMサポートとしては、IntelはSTMのDraft 1.0をかなり前からサポートしているし、直近ではGCC 4.7がほぼ完全なDraft 1.1をサポートしている。&lt;/p&gt;
&lt;p&gt;それでもまだ早すぎると思う場合は、Hans Boehmの発見のひとつが、ロックはジェネリックプログラミングでは実用的ではない、ということだったと言わせてほしい。なぜなら、ロックの順序は一般的にインスタンス化されるまで見えないからだ。C++11で導入されたロック(とアトミック)では、この問題を回避するのが困難だ。トランザクショナルメモリは、この問題を解決するひとつの方法である。それは不規則なデータ構造や、読み取りを主に行うデータ構造(read-mostly structure)に対して細粒度ロックするのにも役立つ。&lt;/p&gt;
&lt;p&gt;このトークでは、我々は使用経験やパフォーマンスデータを含む、標準C++への提案を紹介する。&lt;/p&gt;
&lt;p&gt;トランザクショナルメモリが十分に速いことに、まだ疑問を持っている？多くのソフトウェアトランザクショナルメモリシステムは異なるパフォーマンス特性を持っているので、どれかはあなたのニーズを満たすと思う。&lt;/p&gt;
&lt;p&gt;TMは様々な形(ハードウェア、ソフトウェア、ハイブリッドシステム、ロック省略)で到来している。すでに多くの言語がTMをサポートしているので、C++にこれを提案するのはいい時期だろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#libcppa&#34; name=&#34;libcppa&#34;&gt;libcppa - C++11でのアクターセマンティックな設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;libcppa - Designing an Actor Semantic for C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/dominik-charousset/&#34; target=&#34;_blank&#34;&gt;Dominik Charousset&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/matthias-vallentin/&#34; target=&#34;_blank&#34;&gt;Matthias Vallentin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;並列ハードウェアで効率的にプログラムを実行させるには、並行性は必須である。しかし、並行ソフトウェアを書くことは、挑戦的であり、エラーが起こりやすい。C++はマルチスレッドプログラミングの標準的な設備、acquire/relaseセマンティクスによるアトミック操作とRAIIのミューテックスロッキングを提供するが、これらのプリミティブはあまりにも低レベルである。それらを正しくかつ効率的に使用するには、まだ専門的な知識と手作りが必要だ。アクターモデルは、暗黙的な通信を、明示的なメッセージパッシングメカニズムによる共有で置き換える。これは分散的な並行性として適用でき、事前に次元が決定されたスレッドプール内の全てのアクターをスケジュールした軽量アクターモデルの実装は、スレッドベースアプリケーションと同等のパフォーマンスを出すことができる。しかしアクターモデルは、ネイティブプログラミング言語のベンダー固有のソリューションには入れない。オープンソースライブラリであるlibcppaで我々は、C++11のパフォーマンスとリソース効率を持つアクターモデルによって、信頼性の高い分散システムを構築する能力を統合したい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/dominik_charousset_paper_cppnow2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#binary-compatibility&#34; name=&#34;binary-compatibility&#34;&gt;ライブラリ開発者が知るべきバイナリ互換性について&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Binary compatibility for library developers&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C標準のように、C++標準はコンパイラの重要なふるまいと、合法なプログラムを構成するものを規定している。しかし、ABIとバイナリ互換性に関する問題については、意図的にうまく避けられている。今でさえ、それぞれ独自に管理されるモジュールやダイナミックリンクに関する問題や経験について、あまり議論されていない。Cよりもはるかに複雑かつ強力なので、コンパイラはCよりもはるかにややこしいC++ABIを作る。(原文: Because it is much more complex and powerful than C, compilers implement a C++ ABI that is an order of magnitude more complex than C++. 訳註: Cのtypoか)また、Cとは異なり、単一のプラットフォーム(オペレーティングシステムとアーキテクチャ)であっても、C++のABIはコンパイラごとに異なる。&lt;/p&gt;
&lt;p&gt;未だライブラリ開発者はしばしばCやC++標準に定義されていないこの種の問題について、理解したり解決したりする必要に迫られる。これは決して不可能なことではなく、リリース間のバイナリ互換性を保証するための信頼できる単純なガイドラインやチェックリスト、ツールや作業が存在する。これらを利用して、複数のリリースにわたって、大きなライブラリの長期間以前のヴァージョンとの互換性を維持することが可能である。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、この種の現実にある問題と主にQtやKDEで使われた解法について述べる。特に、Qt4がどうやって7年間にわたり、9つの機能リリースと数十個のパッチリリースをしてなおリリースバイナリの互換性を維持したのかについて示す。また、間違いとその修正についても示す。その後、どのようにコンパイラがABIを作るのかについて詳細な議論をしたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#yet-another-paradigm-shift&#34; name=&#34;yet-another-paradigm-shift&#34;&gt;さらなるパラダイムシフト? (並行のMeta4モデル)&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: yet another paradigm shift (yaps) ? (A Meta4 model of concurrency)   &lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/stanley-lippman/&#34; target=&#34;_blank&#34;&gt;Stanley Lippman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=SLLOSAm-OS0&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=SLLOSAm-OS0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特にC++の話として、C++の後ろに見え隠れする非常に先進的なアイデア/技術の兆候から、同型の多細胞生物の受精を例にとって、進化でも革新でもなく、単にmeta4layersの同期をとるだけというさらなるパラダイムシフトの提案に至るまでの言語のライフサイクルについて議論したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#spirit-x3&#34; name=&#34;spirit-x3&#34;&gt;Inside Spirit X3: C++11で再設計されたBoost.Spirit&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Inside Spirit X3: Redesigning Boost.Spirit for C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/joel-de-guzman/&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon ’07、’08、’09、’10で行ったSpiritの使い方に関するチュートリアルは、大きな成功を収めた。この時間では、Spiritの設計と実装に焦点を当てたプレゼンテーションを行う。さらなる挑戦として、C++11の新機能のアドバンテージを活かして、Boost.Spiritを大きく再設計した。この実験的なバージョン(X3)の、ひとつの大きな目標は、C++の言語機能不足のために失われた「Classic」のエレガントなシンプルさを取り戻すことだ。この90分のプレゼンテーションでは、現代的なC++11コードで今汚いポイントに挑み、私の経験に基づくC++11の欠点を共有した上でC++1yの希望について話したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#weak-hiding&#34; name=&#34;weak-hiding&#34;&gt;C++コンセプトのための弱い隠蔽: プログラミング言語の名前バインディングについて推論するフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Weak Hiding for C++ Concepts: via a Framework for Reasoning about Name Binding in Programming Languages&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/larisse-voufo/&#34; target=&#34;_blank&#34;&gt;Larisse Voufo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の名前探索とオーバーロード解決の規則は複雑で(伝統的なスコープ、ADL、テンプレート引数の推論とSFINAE、オーバーロード、それらの組み合わせ)、コンセプトを言語に追加すると、これらの規則がさらに複雑になります。コンセプト付きC++のために名前探索とオーバーロード解決の規則の最高の代替設計を行うことは、現在の規則が不透明であることから困難です。&lt;/p&gt;
&lt;p&gt;現在のものと提案中のもの、両方の規則を解説するために、プログラミング言語の名前探索(名前バインディングとも言う)のための解説システムのための統合フレームワークを紹介します。このフレームワークは、現在の規則を説明できるだけでなく、名前探索(とオーバーロード解決)に対してコンセプトの提案がどのような影響を与えるのか理解するのを用意にするためにも使用できます。このモデルは、異なる言語の微妙な違いや潜在的な拡張機能、ADLの複雑さ、演算子を使用する際の標準的な規則の誤解といったものを表現します。さらに、Clangの拡張であるConceptClangなどの既存のコンパイラに対して、C++のコンセプトの実装を調査することも可能にします。&lt;/p&gt;
&lt;p&gt;たとえば、C++にコンセプトが含まれていた最後のドラフト(N2914)での名前探索とオーバーロード解決の仕様では、制約テンプレートのところで、現在の規則の元で正しいコードを無効にしてしまいます。この問題が起きる原因は、制約名が、テンプレートの外で定義された名前と同じように扱われるからです。&lt;/p&gt;
&lt;p&gt;我々が提案するフレームワークは、「弱い隠蔽(Weak Hiding)」という別な選択肢をとります。これは周囲のスコープ(と関連する名前空間)にある名前が、テンプレート制約の名前のみを使用してオーバーロード解決に成功した場合のみ隠す、という中間のアプローチです。名前バインディングのための我々の統合フレームワークでは、このモデルは、名前バインディング、バインディングなし、(ADLのために)開く、弱い隠蔽という、4つのスコープの関係で表現され、そして関連するその他のアイディアは、言語と設計抽象的な最小限の2つの概念です。このプレゼンテーションでは、名前バインディングインフラストラクチャと主要な調査結果の要約をし、制約テンプレートを定義するための、弱い隠蔽の導入に焦点を当てます。はじめに、初心者と専門家両方の視点から、問題に対する実用的な例として、弱い隠蔽の必要性を示します。その後、我々のConceptClangが行ったいくつかの設計上の決定を説明します。このセッションが終わったあと、参加者は、現在のものと拡張案、両方のC++の名前探索のルールについてより良い理解が得られるでしょう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cpp11-qt5&#34; name=&#34;cpp11-qt5&#34;&gt;Qt5でC++11を使う： 課題と解法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11 use in Qt5: Challanges and Solutions&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Qt5は昨年12月にリリースされた、有名なQtフレームワークの最新メジャー版である。C++フレームワークであるので、Qtの開発はもちろんC++11に大きな影響を受け、C++11のおもしろい機能、特に高速なコードの作成や可読性を向上させるような機能を利用しようとした。コンパイラがC++11の機能を実装するほどには、Qtのようなフレームワークは早く実装できなかった。加えて、Qtは二つの問題に直面した。一つ目は、まだ利用しているユーザーがいるので昔のコンパイラとツールチェインをサポートする必要があったこと。二つ目は、Qt4と可能な限りソース互換性を維持するというのが、Qt5の目標ひとつだったことである。このような要求に応えるために、当面のあいだ、C++11の大規模な採用は見送ることなった。&lt;/p&gt;
&lt;p&gt;それゆえ、Qt開発者はどのC++11機能を使うべきでないか、どの機能を使うべきか、C++98/03コンパイラ互換をどうやって維持するかについて考える必要性にせまられた。このセッションでは、結局どういう決定を下したのか、また、C++98/03とC++11モードそれぞれでさまざまなコンパイラをサポートする措置について話そうと思う。Qtで適用した解決法、およびC++11とC++03で利用可能である巨大なC++クラスライブラリ構築を試みる際の一般的な考えかたについて知見が得られるだろう。このプレゼンテーションでは、ようするに我々のように、C++03コンパイラ互換性を維持したまま、ライブラリやアプリケーションをC++11に移植する必要にせまられた、C++開発者向けの実践的ガイドラインを示すことが狙いである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#thread-safe-bag&#34; name=&#34;thread-safe-bag&#34;&gt;スレッドセーフでスレッド中立なbag&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Thread-safe and Thread-neutral Bags&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/richard-saunders/&#34; target=&#34;_blank&#34;&gt;Richard Saunders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bagは多数のスレッドが処理を実行するために継続的かつ非同期にbagからデータを取り出すようなスレッドシステムで使う基本的なコンテナである。bagはキー操作(get)を持ち、概念上はシンプルであるが、スレッドセーフ(bagの状態は複数のスレッドからアクセスされても一貫性を保持する)かつスレッド中立(スレッド同士が競合しない)に実装しようとするととてつもなく難しくなる。&lt;/p&gt;
&lt;p&gt;このセッションではスレッド環境下でのbagの実装について、さまざまな角度から、特に、多数のスレッドがbagに絶えまないアクセスや、作業の性質、マシンに積んでいるプロセッサの数とタイプ、高速な生産者/消費者関係などについて見ていく。ただ一種類のbagではあらゆる要求を満足できないのは明らかだ。この論文ではbagに関して、アプリケーションの性質に応じて引き出しと戸棚という二つの抽象化を紹介している。これらの新しい抽象化を、スレッドセーフでスレッド中立なbagを担保しうるC++11のマルチスレッドまわりの機能を利用して実装する。いずれの実装についても人工のベンチマークと実際のアプリケーションで利用し十分な吟味を行った。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/04/saunders_paper_cppnow2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#practical-cpp11-odb&#34; name=&#34;practical-cpp11-odb&#34;&gt;実践C++11：ODBへのC++11サポート追加で学んだこと&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Practical C++11: What I Learned Adding C++11 Support to ODB&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-kolpackov/&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ORMにC++11サポートを加えていく過程で、新しい言語機能や他のコンパイラのサポート状況といった実践的な経験が得られた。また、想像できるかもしれないが、これは大変な仕事だった。このセッションでは、新しい言語機能について利用できる経験則について議論したい。&lt;/p&gt;
&lt;p&gt;このセッションでは、完全転送とオーヴァーロードはとても相性が悪い(また、その対処方法)、値渡しと参照渡し(また、左辺値参照か右辺値参照か)の使いわけ、範囲forループの内側について話すつもりである。また、C++98とC++11をサポートするクロスプラットフォームライブラリで、実際に遭遇した実装面での問題についても取りあげたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#bloomberg&#34; name=&#34;bloomberg&#34;&gt;応用階層的再利用: Bloomberg基盤ライブラリの利用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Applied Hierarchical Reuse: Capitalizing on Bloomberg’s Foundation Libraries&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/john-lakos/&#34; target=&#34;_blank&#34;&gt;John Lakos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ライブラリの設計は大変な仕事である。特に、相互運用性のある組み換え可能なライブラリセットの設計ともなるといっそう困難である。複数のライブラリを機能面で分割すれば、それ固有の課題がでてくる。すなわち、ライブラリの機能はわかりやすく、冗長性は排除しなければならず、コンポーネントとライブラリにまたがるインターフェースと契約関係は、高性能なIDEがなくても容易に理解できるようにしなければならない、ということだ。さらに、ライブラリ間の依存性にはよく気をつけなければならない - ライブラリは首尾一貫して機能し、よく精査された語彙を定義、利用しながら、クライアントが必要とする機能分だけのコンパイル時間やリンク時間、実行ファイルサイズで済むものでなければならない。&lt;/p&gt;
&lt;p&gt;複数の相互運用可能なライブラリセット作成にも、それぞれのライブラリ作成と同様に多くの課題がある。そのライブラリセットは理解しやすく、利用しやすく、高性能で信頼性がなければならない。さらに、ライブラリ全体が共通の構造を取り、表現を根拠なく変えず、一貫した用語を使っていなければならない。ライブラリ全体でこのような高度な一貫性や性能、信頼性を達成することで、個々のライブラリにおける部分的な信頼性は非常に高くなる。さらに、単一のライブラリを作成する際にも、このような手法を採用すれば、かなりの恩恵にあずかれるだろう。&lt;/p&gt;
&lt;p&gt;小-中規模プロジェクト向けのソフトウェア方法論は多くあるが、これらをごく単純には大規模な開発にスケールすることはできない。このセッションでは、大規模開発における問題点や、実績のあるコンポーネントベースの方法論ではどうにもならない問題に対処すべく見いだし、Bloombergの実用的なアプリケーション開発を通じて洗練された関連技術について述べる。これらの方法論 - 三階層集約、非循環依存性、名詞句結合、高粒度機能分解、クラスカテオゴリ、限定的契約、コンポーネントレヴェルテスティングなど - の現実的応用については、最近リリースされたばかりのオープンソースディストリビューションであるBloomberg基盤ライブラリを利用して紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#boost-dispatch&#34; name=&#34;boost-dispatch&#34;&gt;Boost.Dispatch - 汎用タグディスパッチ基盤ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Dispatch - Generalized Tag Dispatching Infrastructure Library&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/joel-falcou/&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mathias-gaunard/&#34; target=&#34;_blank&#34;&gt;Mathias Gaunard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型制約を自由に組み合わせる種の関数特殊化を規定するのは、C++ではめんどうな仕事である。というのも、そのような制約はすぐにどんどん増えるし、どんどんややこしくなるからだ。この問題を解決するために、SFINAEやタグディスパッチなど様々なイディオムが利用されてきた。&lt;/p&gt;
&lt;p&gt;このセッションではBoost.Dispatchを紹介する。これは、タグやその関連性を定義するプロトコルを備え、任意のタグの組み合わせと関数実装とをマップし、自由で結合可能な方法で前述の特殊化リストを拡張できる、タグディスパッチの利用や管理を容易にする基盤ライブラリである。Boost.Dispatchの新しい利点は、関数の特性や型特性のより古典的な用法に加えてディスパッチを導くための構造上の情報を分類できる機能だ。&lt;/p&gt;
&lt;p&gt;このセッションではまずSFINAEや、C++でのオーヴァーロードとタグディスパッチの意味と、その限界についてざっと説明する。単純なライブラリ設計から、自明でない構造に依存する情報に基づいて、関数の最適な実装を選択するためのライブラリを利用する、実際の高効率コンピューティングコードにわたるサンプルとともに、Boost.Dispatchを紹介していく。さらに、ライブラリの実装についての詳細を見ていただき、未解決の課題について概説したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#vienna&#34; name=&#34;vienna&#34;&gt;計算科学向けViennaライブラリについて&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Discussion of Selected Vienna-Libraries for Computational Science&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/karl-rupp/&#34; target=&#34;_blank&#34;&gt;Karl Rupp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CUDA、OpenCL、OpenMPが利用可能な線型代数ライブラリであるViennaCL、メッシュデータ構造ライブラリであるViennaGrid、データ保存を受けもつViennaData、シンボリック計算カーネルであるViennaMathといった直交するライブラリ群を紹介することで、計算科学のとっつきにくさに取り組む。結びに、有限要素法パッケージであるViennaFEM内で、これら直交するライブラリ群がどのように相互作用しているか考察する。このセッションの主眼は様々なプログラミング技法の適用について、またC++がいかに計算科学向けの言語になりうるかについてである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/karl.rupp_.paper_.2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#alignment&#34; name=&#34;alignment&#34;&gt;C++のアラインメント: 利用法、制限、および拡張法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Alignment in C++: Use, Limitations, and Extension&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-spencer/&#34; target=&#34;_blank&#34;&gt;Michael Spencer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションではC++におけるアラインメントを調査する。まず最初に、C++11でのアラインメントまわりの変更について概説し、効果的な利用法について述べる。次にその制限について述べる。その次に、それら問題点に対処するために、アラインメントを型システムに載せることで解決する方法を提案する。最後に型安全性と実行時効率の恩恵について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#community-dev&#34; name=&#34;community-dev&#34;&gt;C++コミュニティの発展&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Community Development&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/jens-weller/&#34; target=&#34;_blank&#34;&gt;Jens Weller&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JensとJonは両名ともC++コミュニティの発展に意欲があり、C++カンファレンスに出席した経験がある。彼らはコミュニティの発展にはローカルグループこそがC++コミュニティ発展の鍵であると感じている。&lt;/p&gt;
&lt;p&gt;Jensは、ヨーロッパのC++Nowとも言えるMeeting C++の主催者として、またデュッセルドルフとベルリンのC++ユーザーグループを立ちあげた経験について紹介する。&lt;/p&gt;
&lt;p&gt;JonはシリコンバレーのACCU支部での経験や、シリコンバレーコードキャンプでのC++プログラミング経歴、C++Nowでの活動について紹介する。&lt;/p&gt;
&lt;p&gt;その後、パネルディスカッションスタイルで、質問やコメントを受けつけたり、聴講者の経験についてうかがう。&lt;/p&gt;
&lt;p&gt;ローカルでグループを立ちあげるコツや、個人的人脈やソーシャルメディアを通じてスピーカーや聴講者を募る方法、他のグループと連携する方法についても述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#dynamic&#34; name=&#34;dynamic&#34;&gt;動的なC++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/alex-fabijanic/&#34; target=&#34;_blank&#34;&gt;Alex Fabijanic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外部ソースから取り込むべき様々な型のデータには、データ型変換がつきものです。C++プログラマの皆さんは、リレーショナル・データベースやXMLデータベースからJSON形式やHTMLへのデータ変換をC++の型チェックという障壁を越えて、正確かつ効率的に、どのように変換されていますか？答えは型消去というテクニックを使用する事にあります。この講義では、最も一般的な C++型消去の手法について、列挙探査と比較を行います。&lt;/p&gt;
&lt;p&gt;上記の問題と同様に与えられた、歴史的なライブラリ（ANSI Cの共用体、&lt;code&gt;void*&lt;/code&gt;、マイクロソフト COMの&lt;code&gt;Variant&lt;/code&gt;型、&lt;code&gt;boost::variant&lt;/code&gt;、&lt;code&gt;boost::any&lt;/code&gt;、&lt;code&gt;boost::lexical_cast&lt;/code&gt;)と最近のライブラリ(&lt;code&gt;boost::type_erasure&lt;/code&gt;、Facebook &lt;code&gt;folly::dynamic&lt;/code&gt;)といった、開発トレンド(保留中の &lt;code&gt;boost::any&lt;/code&gt; というC++標準案を含む)、それは、C++言語の静的な型システムという性質を回避する手法が必要であることを示唆しています。この問題に関する解決法は複数存在します。この講義では、&lt;code&gt;boost::variant&lt;/code&gt;、&lt;code&gt;boost::any&lt;/code&gt;、&lt;code&gt;boost::type_erasure&lt;/code&gt;、&lt;code&gt;folly::dynamic&lt;/code&gt;、&lt;code&gt;Poco::Dynamic&lt;/code&gt;、これらに焦点を当てて掘り下げます。設計デザインと機能だけでなく、各ライブラリの長所と短所についても検討します。パフォーマンスベンチマークの比較も同様に検討されます。&lt;/p&gt;
&lt;p&gt;型安全はC++の重要な要素です。型消去は、現代のソフトウェア開発のために必要なテクニックです。この講義では、これら重要な型消去のライブラリの比較検討を行います。&lt;/p&gt;
&lt;p&gt;＊ Type Erasure を型消去と訳してます&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#debruijn&#34; name=&#34;debruijn&#34;&gt;DeBruijn Bind: シンプルさを維持するより強力なbind&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DeBruijn Bind: A more powerful bind that retains its simplicity&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/david-sankel/&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.LambdaやBoost.Phoenixのような、より強力なライブラリがあるなかでも、Boost.Bindはその非常に単純な構文と、学習のハードルが低いという点でその立ち位置を守っている。その構文はBoost.MPLのなかでコンパイル時variantとして利用されている。&lt;/p&gt;
&lt;p&gt;しかし、テンプレート実引数とともに使うため、または、&lt;code&gt;boost::protect&lt;/code&gt;を使いはじめるために、&lt;code&gt;boost::bind&lt;/code&gt;のネストに手を染めると、この単純さは&lt;code&gt;boost::bind&lt;/code&gt;のセマンティクスとその限界については不鮮明になってしまう。&lt;/p&gt;
&lt;p&gt;このセッションでは、解析を行ない、Boost.Bindのセマンティクスとは何かについて数学的に正しい理解に到達することを目的とする。ひととおりセマンティクスについて学べば、Boost.Bindがカヴァーしている要求を満たし、再帰可能であり、学習のハードルが低い単純な構文を維持する、説得力のある代替案の設計についての見識が得られるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#multi-threading&#34; name=&#34;multi-threading&#34;&gt;C++11とBoostを利用したマルチスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Multi-Threading With C++11 and Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/rob-stewart/&#34; target=&#34;_blank&#34;&gt;Rob Stewart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルでは、マルチスレッドコードを記述するためのC++11とBoostの機能を利用した多くの例をもとに、より深くその効用についいて段階的に学んでいく。&lt;/p&gt;
&lt;p&gt;例としてスレッドセーフキューについても取りあげ、独立したスケジュール上で並列タスクを実行するためにスレッドを利用したり、長時間実行中の並列タスクに割り込みを掛けてみる。これらの例をもとにスレッドやミューテックス、条件変数などの利用法を示す。C++11とBoostの機能的相違点についても議論するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#concept-lite&#34; name=&#34;concept-lite&#34;&gt;軽量コンセプト: 述語による制約テンプレート&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Concepts Lite: Constraining Templates with Predicates&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/andrew-sutton/&#34; target=&#34;_blank&#34;&gt;Andrew Sutton&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このトークでは、C++14に提案されている新言語機能である「テンプレート制約(またの名を軽量コンセプト)」について話します。制約は、テンプレートにおいてテンプレート引数が使えるかどうかを判定するための述語です。&lt;/p&gt;
&lt;p&gt;制約を使用して要件を直接示すことによって、テンプレートの宣言を改善できます。もちろん、制約に基いて関数オーバーロードすることもできます。制約は、型のエラーを使用時にすぐ捕捉できるため、コンパイルエラーのスタックを短いスクロールで確認できるようになることを意味します。&lt;/p&gt;
&lt;p&gt;言語機能としては、テンプレート制約は最小限で複雑でないものに抑え、テンプレート使用の正確さではなく、テンプレート定義の正確さを強化します。これは段階的かつ簡単に、既存のコードベースに採用できることを意味します。&lt;/p&gt;
&lt;p&gt;このトークは一般的なデータ構造、メンバ関数とコンストラクタ、オーバーロード、クラステンプレートの特殊化、制約の定義といった例を通して、制約をどのように使用するかを説明します。また、私が普段のプログラミングで制約を使用してきた経験についても説明します。これは制約のいいアイデアと、それほどよくないアイデアの両方を含みます。&lt;/p&gt;
&lt;p&gt;GCC 4.8ベースの実験的なコンパイラは、みなさんがすでに使えるよう公開してあります。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#html5&#34; name=&#34;html5&#34;&gt;ママ見て “C++を使ってデータベース更新からHTML5が生成されたよ”, 自動化して!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Look ma, “update DB to HTML5 using C++”, no hands!&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/alex-fabijanic/&#34; target=&#34;_blank&#34;&gt;Alex Fabijanic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ウェブを取り巻く環境は急速に変化しています。AJAXや非同期JSONの登場により、ユーザ・インタフェイスの応答性は、大幅に改善されてきました。この流れの基礎となるデータ・トランスポートのメカニズムは、まだ、リクエスト/レスポンスによるポーリング（プル）・モデルに基づいています。WebSocket規格は、ネットの先のストレージから標準となるHTML5インタフェイスへ、イベント・ドリブンなプッシュ・モデルというシームレスな接続の最後の障壁を取り除きました。流れとして、データ転送はイベント・ドリブン・モデルを使用し、リクエスト/レスポンス・モデルで行われていたネットワークおよびウェブサーバのオーバーヘッドを下げ、パフォーマンスの改善を標準規格に準拠して行う事ができます。講義の最初に、POCOフレームワーク・ネット・ライブラリを使用して、WebSocket HTML5ページを生成するHTTPサーバを構築します。次に、POCOデータ・ライブラリを使用して、SQLデータベースと連帯する機能をHTTPサーバに追加し、コールバック・フックを確立します。そのフックは、透過的にデータベースのデータ更新からウェブ・ページ変更を引き起こすためにパスを開きます。このソリューション・電子ブロックの構成要素である、データ型消去のための &lt;code&gt;Poco::Dynamic&lt;/code&gt;モジュール、動的フォーマット出力のための&lt;code&gt;Poco::Data::RowFormatter&lt;/code&gt;クラス、を詳細に説明します。&lt;/p&gt;
&lt;p&gt;この講義は、いくつかの鋭い問題に現実的解決案を提示します - 効率的かつ独立して転送されたデータ型からエンドユーザにシームレスウェブにネットワーク経由でストレージからデータを提供します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#odb&#34; name=&#34;odb&#34;&gt;C++(11)のためのORマッパー：ODB&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ODB, an ORM for C++(11)&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-kolpackov/&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ODBは、C++によるオブジェクト・リレーショナル・マッピング(ORM)システムのライブラリで、クロス・プラットフォームかつクロス・データベースなオープンソースです。&lt;/p&gt;
&lt;p&gt;このライブラリを使用すると、テーブル・カラム・SQLや、リレーショナル・マッピングのコードを手作業で書く事なく、C++のオブジェクトをリレーショナル・データベースに格納できます。&lt;/p&gt;
&lt;p&gt;Boostカンファレンス2011より数ヶ月前に、私はODBを導入しました。今回は我々が過去2年間に行った成果をお見せしたいと思います。講義の最初では、ODBの助けを借りて、リレーショナルデータベースにC++のオブジェクトを格納することが、いかに簡単できるかを話します。次に多様な興味深いトピック、C++11サポート、BoostとQtプロファイル、ポリモーフィズム、楽観的な同時実行制御、およびマルチデータベースサポートについて話します。私は、これからも、データベース・スキーマ革命！という野心的な困難に取り組むつもりです。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#fusion&#34; name=&#34;fusion&#34;&gt;Fusionで世界の謎を解く&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Solving World Problems with Fusion&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンパイル時MPLと実行時タプルの融合。Boost.Fusionはメタプログラミング世界のSTLである。FusionはBoostライブラリの内部的な機構を提供し、私たち自身のソースの一般的な要素となっている。&lt;/p&gt;
&lt;p&gt;この90分のセッションでは、Boost.Fusionライブラリの現実世界でのユースケースを探求する。具体的には、ライブラリインタフェースのシンプル化、宣言的なユーザーエクスペリエンス、効率的で非侵入的なハンドリングの例を見ていく。&lt;/p&gt;
&lt;p&gt;参加者は、いくつかの実用的な使用パターンの理解を得てさらなる先に進んで行くでしょう。ぜひSpirit、Xpressive、Geometry、Accumulators、odeint、Proto、Phoenix、MSMを自分のソースに取り入れる方法を学んでみてほしい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#dds&#34; name=&#34;dds&#34;&gt;モダンなC++向けのデータ分散サーヴィス(DDS: Data Distribution Service)の標準化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Standardizing the Data Distribution Service (DDS) API for Modern C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/sumant-tambe/&#34; target=&#34;_blank&#34;&gt;Sumant Tambe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++復権は多くの工業分野で広まっている。アプリケーション移植性の視点からC++を対象にした国際的なコンピュータシステム標準は、迅速にモダンなC++を導入してきている。国際標準化機構のObject Management Group(OMG)では、DDS-PSM-CxxとIDL2C++11標準が時代の先を行っている。DDS-PSM-Cxxは、高性能な分散リアルタイムシステム開発向けの主要なデータ分散サーヴィス(DDS)標準の関連標準である。正式には&#34;ISO/IEC C++ 2003 Language Platform Specific Mapping (PSM) for DDS&#34;として知られるDDS-PSM-Cxx標準は、2012/12に策定完了した。DDS-PSM-Cxxはモダンで、自然で、STLと親和性があり、表現力が高く、安全で、効率的なDDSプログラミング向けに可搬性のあるC++APIを提供している。DDS-PSM-CxxはC++03をターゲットにしており、C++11環境移行を可能にすべく特別な準備をしている。このセッションではDDS-PSM-Cxx標準の&#34;なぜ&#34; &#34;どうして&#34;について述べる。OMG標準化作業部会の投票委員と主要な貢献者が登壇する予定である。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションはDDS - リアルタイム分散システム向けのデータ中心の出版-購読型アーキテクチャの基礎を説明するところから始める。DDSと組み合わせたモダンなC++で記述した&#34;Hello World!&#34;アプリケーションとともに、DDS-PSM-Cxx標準の動機や問題点、高次構造について示す。また、規格に合致しているベンダー実装の当分の代替のサポートやベンダー固有拡張のための文脈的手掛かりといった、標準の興味深い点について深く掘りさげていく。この標準はBoostを直接的に利用していないものの、いくつかのBoostライブラリからアイディアを拝借している。このプレゼンテーションでは、DDSアプリケーション向けのクリーンで安全かつ効率的なAPIを提供するための、種々のC++03イディオム(例えば、RAII、型消去、型安全列挙、メソッドチェイン)の利用についても詳しく説明していく。さらに、聴者の興味を引くであろう、APIを構築する上で重要な点である例外安全の考慮についても述べる。特に、例外安全なAPIを設計する上で、ムーヴセマンティクスが如何に有用かご覧いただけるだろう。最後に、C++03規格に合致しているアプリケーションが、C++11環境でも合法となるように、標準に加えた特別なルールについて議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#member-access-operator&#34; name=&#34;member-access-operator&#34;&gt;メンバーアクセス演算子のオーヴァーロード&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Overloading the Member Access Operator&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/sebastian-redl/&#34; target=&#34;_blank&#34;&gt;Sebastian Redl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接メンバーアクセス演算子(&lt;code&gt;operator.&lt;/code&gt;)のオーヴァーロードは通常またはメタプログラミングでおもしろいユースケースがある。この演算子のオーヴァーロードの古典的な利用法は、アロー演算子のオーヴァーロードと同じく、別のオブジェクトを参照させたい場合に利用することである。&lt;/p&gt;
&lt;p&gt;このセッションでは、メタプログラミングを利用してプログラマが別の名前を利用できるようにする別の方法を紹介する。Clangコンパイラを利用したこの機能の実験的実装を紹介し、この実装のユースケースや、この機能の有用性、問題点、これを実装するにあたって得られた知見について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cern&#34; name=&#34;cern&#34;&gt;CERNでの対話的で内省的なC++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interactive, Introspected C++ at CERN&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/vassil-vassilev/&#34; target=&#34;_blank&#34;&gt;Vassil Vassilev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CERNは、世界最大の素粒子物理学研究所である。そのような科学的ブレイクスルーを作るために、約15PB/yearを処理している。ROOTフレームワークのユニークな能力は物理学者がデータ解析するのをより効率的で、計算的で、賢いストレージを可能にする。ROOTの最新バージョンのコアはClingである。これは対話的なC++インタプリタで、C++11もサポートしている。Clingは、以前まで使用していたROOTの伝統的なメインユーザーインタフェースを置き換える。Clingは、Clang/LLVMインフラストラクチャ上に構築される。このインタプリタはそれだけでなく、ROOTのシリアライズ、デシリアライズ、C++のオブジェクト指向データの操作にも使用され、それでいて初心者がC++をより早く学ぶのを支援してくれる。&lt;/p&gt;
&lt;p&gt;C++のような静的言語のインタプリタを構築するのは、決して簡単ではない。私はClingの要件を説明し、その後コンパイラフレームワーク上にインタプリタを実装することに挑戦する。C++をより対話的な言語に変えるために、C++標準のいくつかの概念を説明する。インタプリタを使用して、型のイントロスペクション機構を簡単に説明する。C++の文脈解析で、ランタイムの力を改善する方法を提案する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#haskell&#34; name=&#34;haskell&#34;&gt;Haskellの力でMPLを強化しよう&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boosting MPL with Haskell elements&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/abel-sinkovics/&#34; target=&#34;_blank&#34;&gt;Abel Sinkovics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HaskellとC++テンプレートメタプログラミングの類似性が指摘されている[1,2]一方で、Haskellのほとんどの要素がテンプレートに導入されていない。これらをいくらかでも導入すれば、メタプログラミングはより使いやすくなり、テンプレートメタプログラミングツールセットであるBoost.MPLの強化につながるだろう。&lt;/p&gt;
&lt;p&gt;Haskellを含む関数プログラミング言語で利用されている式を、コードを読みやすくするために、そして構築しやすくするために利用してみよう。これはC++テンプレートメタプログラミングに対しても同じ目的で適用できるはずである。&lt;/p&gt;
&lt;p&gt;関数型プログラムを記述するとき、とりわけ、Haskellのdo notationとMonadの組み合わせは、書かなければならない鋳型コードの量を削減できる強力なツールである。コンパイル時計算にこの要素を導入すれば、これを利用したテンプレートメタプログラムの可読性の向上に寄与するだろう。&lt;/p&gt;
&lt;p&gt;多くのプログラミング言語について、リスト内包表記はリスト変換の理解に寄与する。リスト内包表記を実装するためにHaskellのList monadとdo notationを利用が利用されるように、テンプレートメタプログラミングでも同様にこれらを使って実装できる。&lt;/p&gt;
&lt;p&gt;エラーハンドリングはEither monadを利用すれば単純化できる。構文糖を混ぜることで、monadや例外ハンドリングがC++テンプレートメタプログラムで実装されていることを意識せずに、テンプレートメタプログラムにおいてもこのような例外ハンドリングが理解でき、利用可能である。&lt;/p&gt;
&lt;p&gt;これらのツールはBoost.MPL ライブラリを基礎として構築され、その拡張として利用されるので、既にBoost.MPLを利用しているメタプログラムに容易に展開可能である。&lt;/p&gt;
&lt;p&gt;このセッションで紹介するツールはMetamonadライブラリの構成要素である。Metamonadライブラリについては以下のリンクを参照すること:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://abel.web.elte.hu/mpllibs/metamonad&#34; target=&#34;_blank&#34;&gt;http://abel.web.elte.hu/mpllibs/metamonad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sabel83/mpllibs&#34; target=&#34;_blank&#34;&gt;https://github.com/sabel83/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションは高度なので、Boost.MPLに精通していることが望ましい。&lt;/p&gt;
&lt;p&gt;参考文献:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;[1] Stuart Golodetz – Functional programming using c++ templates (part 1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://accu.org/index.php/journals/1422&#34; target=&#34;_blank&#34;&gt;http://accu.org/index.php/journals/1422&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[2] Bartosz Milewski – What does Haskell have to do with C++?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/&#34; target=&#34;_blank&#34;&gt;http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#object-transmission&#34; name=&#34;object-transmission&#34;&gt;Boost.AsioとBoost.Serialization: オブジェクト受け渡しのデザインパターン&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Asio and Boost.Serialization: Design Patterns for Object Transmission&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bryce-adelstein-lelbach/&#34; target=&#34;_blank&#34;&gt;Bryce Adelstein-Lelbach&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jeroen-habraken/&#34; target=&#34;_blank&#34;&gt;Jeroen Habraken&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++でネットワークプログラミングするには、他のネットワーク終端へ受けわたしできる、再構築可能なバイトシーケンスとして、C++オブジェクトを表現する方法が必要である。PODのような単純なオブジェクトなら、シリアライズするのが一般的だろう。&lt;/p&gt;
&lt;p&gt;多態オブジェクトのような、より複雑なC++構造については、シリアライズする方法はより困難になる。このセッションでは、Boostにある二つの強力なライブラリであるAsioとSerializationについて、巨大な配列を扱えるC++ネットワークコードを構築するという観点から、その有用性について議論していく。&lt;/p&gt;
&lt;p&gt;このセッションではBoost.MPIとHPX(分散/並列プログラミング用のC++ランタイムシステム)を使って、Boost.AsioとBoost.Serializationを利用したオブジェクト変換を行う方法についても議論する。また、ほんの少しだが、別の解法についても議論するつもりだ。&lt;/p&gt;
&lt;p&gt;このセッションは、ネットワークプログラミングに従事している、もしくは興味がある(けれどもBoost.AsioやBoost.Serializationについてよく知らない)方を対象にしている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cppnow-2014&#34; name=&#34;cppnow-2014&#34;&gt;C++Now 2014の準備&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preparation of C++Now 2014&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participants/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participants/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来年の会議にむけた計画委員会を早期に発足させる。もしご提案や、ご支援いただける方はぜひご参加ください。&lt;/p&gt;
&lt;p&gt;このセッションにはスライドはない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#hetero&#34; name=&#34;hetero&#34;&gt;静的型付け言語における、動的で再帰的なヘテロ型&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic, Recursive, Heterogeneous Types in Statically-Typed Languages&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/richard-saunders/&#34; target=&#34;_blank&#34;&gt;Richard Saunders&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/clinton-jeffery/&#34; target=&#34;_blank&#34;&gt;Clinton Jeffery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のソフトウェアはいろいろな言語で記述されている。すなわち Python、C++、Perl、Java、Javascript、Lua、Unicon、C言語などが、複雑なシステムの別個のコンポーネントを構成する環境のなかに混在している。このような言語の急激な拡散により、動的型づけ言語のコンセプトが静的型づけ言語に流入していく。&lt;/p&gt;
&lt;p&gt;動的言語によく見られる要素として、動的で、再帰的な、ヘテロな辞書構造が挙げられる。たとえば、Pythonのdict、Perlのhash、Javascriptのobject、Luaのtable、JSONにおけるIcon/Unicon tableはこの種の抽象化の実現であるし、より低水準なものとしては、XMLは言語に依存しない動的辞書構造と言えるだろう。C++やJavaのような静的型づけ言語は、スジがいい動的辞書構造の設計と実装に苦労してきた。さて、このセッションでは、C++言語の静的型に特有の機能を &lt;em&gt;採用&lt;/em&gt; し、動的構築を行なうためのシンプルで新規性のある解法で、いかにC++で辞書構造を表現するかについて考察する。その機能とは型推論、ユーザー定義の型変換、型選択、オーヴァーロードである。&lt;/p&gt;
&lt;p&gt;これらのこと組みあわせて、動的言語における動的辞書の操作性に近づけるべく、逆説的だがこれらの静的な機能から、C++からの操作が非常に容易な動的辞書構造を構築する。&lt;/p&gt;
&lt;p&gt;注意：これらのテクニックには特別なリフレクション機能やライブラリを必要としない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/saunders-jeffery.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#projucer&#34; name=&#34;projucer&#34;&gt;Projucer: C++とLLVM JIT エンジンを利用したライブコーディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Projucer: Live coding with C++ and the LLVM JIT engine&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/julian-storer/&#34; target=&#34;_blank&#34;&gt;Julian Storer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それぞれのクラスを連続的にリコンパイルし実行するために、Projucer IDE がいかにしてClangとLLVM JITエンジンを利用したC++コードのリファクタリングとリアルタイム実行を成しとげたのか、その裏側からごらんいただこう。&lt;/p&gt;
&lt;p&gt;JUCE GUI toolkitライブラリを利用しているこのProjucerは、C++プロジェクトの編集やアセンブルを行なうためのIDEである。Projucerは、Clangを利用してコンパイルを行ない、ユーザーコードベースのAST(Abstract Syntax Tree: 抽象構文木)を走査することで、適切なGUIクラスを決定し、スタンドアロンの実体としてインスタンス化する。このインスタンスはそのコードが編集された際、即座に更新される。これらのGUIクラスを動的に生成されるコードにラップすることで、ドラッグやリサイズといった一般的なGUI操作は、元のコードを動的にリファクタリングすることによって機能しその上で実行される。&lt;/p&gt;
&lt;p&gt;実際の動作についてのムービーは&lt;a href=&#34;http://youtu.be/imkVkRg-geI&#34; target=&#34;_blank&#34;&gt;こちら&lt;/a&gt;。より詳細については&lt;a href=&#34;http://rawmaterialsoftware.com/viewtopic.php?f=12&amp;amp;t=9793&#34; target=&#34;_blank&#34;&gt;私のサイト&lt;/a&gt;を参照のこと。&lt;/p&gt;
&lt;p&gt;C++通向きに、もっと細かいことや、諸問題、このシステムを効率的にするために使った狡猾なトリック、そしてClangやLLVMの特徴について掘り下げてみるつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#matrix&#34; name=&#34;matrix&#34;&gt;EigenとBoost Protoライブラリを用いた有限要素マトリックス式の組み立て&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Building finite-element matrix expressions with Boost Proto and the Eigen library&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bart-janssens/&#34; target=&#34;_blank&#34;&gt;Bart Janssens&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルでは、我々がドメイン特化言語を開発するにあたり障害となった二つの問題、すなわちBoost.Proto内での外部Expression Template Library(ここではEigen)の利用と、ユーザー定義関数の導入についていかに解決したかを示す。&lt;/p&gt;
&lt;p&gt;どちらの話についても、我々の有限要素マトリックスのコードとは関係のない、一般的な計算機様のプログラムで紹介するつもりである。これはステップバイステップ方式のBoost.Protoのチュートリアルになるだろう。最後に&lt;a href=&#34;http://coolfluid.github.com/&#34; target=&#34;_blank&#34;&gt;Coolfluid 3 code&lt;/a&gt;にあるアプリケーションを例にとって、Protoのようなライブラリが、実際のコードにどのような利点をもたらすかを示す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/janssens.abstract.pdf&#34; target=&#34;_blank&#34;&gt;Extended Abstract&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#deadlock-prevention&#34; name=&#34;deadlock-prevention&#34;&gt;侵入的動的解析を使用したリソースデッドロック防止システム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A system for resource deadlock prevention using intrusive dynamic analysis&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/louis-dionne/&#34; target=&#34;_blank&#34;&gt;Louis Dionne&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ミューテックス等を使用して共有データへ同期にアクセスするという旧来の方法は、2つ以上のスレッドがお互いに再帰的にブロックをしてしまう、リソースのデッドロックを可能にしてしまう。&lt;/p&gt;
&lt;p&gt;このようなバグは特定の状況下でしか発生しないため、多くの場合、その摘発は困難なものとなる。&lt;/p&gt;
&lt;p&gt;このトークでは、intrusive dynamic analysis(侵入的動的解析?)を使用して潜在的なリソースデッドロックを事前に発見するシンプルなフレームワークを、私達がどのように実装したかを説明する。&lt;/p&gt;
&lt;p&gt;また、そのフレームワークを既存のコードとどのように統合するかも説明する。&lt;/p&gt;
&lt;p&gt;そして最終的には、このプロジェクトをC++のより汎用的なdynamic analysisフレームワークにする可能性をもつ、プロジェクトの進化について議論しよう。&lt;/p&gt;
&lt;p&gt;マルチスレッドあるいはdynamic analysisについて興味のあるプログラマ向け。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Boostの未来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Future of Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participants/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participants/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostとC++ Now!のリーダー達が将来どうなるかについて話し、質問に答える。&lt;/p&gt;
&lt;p&gt;このセッションにスライドはない。&lt;/p&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, Usagi Ito, hotwatermorning, Miyuki OKI, zak&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mem_fn.hpp -- mem_fn : composeへのリンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html"/>
      <id>9857e008c50abe964c2735ee330e487f60e005b5:archive/boost_docs/libs/mem_fn.md</id>
      <updated>2015-01-17 00:25:04 +0900</updated>
      
        <content type="html">&lt;h1&gt;mem_fn.hpp&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34;&gt;FAQ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34;&gt;インタフェース&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34;&gt;実装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34;&gt;ファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34; name=&#34;purpose&#34;&gt;目的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::mem_fn&lt;/code&gt; は、標準関数である&lt;code&gt;std::mem_fun&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt;の一般化である。&lt;code&gt;mem_fn&lt;/code&gt;は、2つ以上の引数をとる メンバ関数へのポインタをサポートし、また&lt;code&gt;mem_fn&lt;/code&gt;の戻す関数オブジェクトは第一引数に、 (訳注: そのメンバ関数の属するクラスのインスタンスを指すような) ポインタ、参照、スマートポインタをとることができる。 &lt;code&gt;mem_fn&lt;/code&gt;は、メンバ変数へのポインタも、引数をとらず自身への定数参照を 戻す関数とみなすことによってサポートする。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;の目的は2つある。一つ目は、コンテナにスマートポインタが格納されている場合であっても、 次のような&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;見慣れた文法によって、メンバ関数の呼び出しを可能にすることである。&lt;/p&gt;
&lt;p&gt;二つ目は、メンバ関数へのポインタを関数オブジェクトのように取り扱いたいライブラリ開発者に、 実装の道具として使用して貰うことである。例えば、あるライブラリは次のようにしてより便利な &lt;code&gt;for_each&lt;/code&gt;アルゴリズムを提供することができ、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;It&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; for_each(It first, It last, R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(first, last, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(pmf));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムは次のようにして手軽に利用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;for_each(v.begin(), v.end(), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムの機能を文書化する際には、単に次のように書けば良い：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;template&amp;lt;class It, class R, class T&amp;gt;&lt;/code&gt;
&lt;code&gt;void for_each(It first, It last, R (T::*pmf) ());&lt;/code&gt;
&lt;strong&gt;結果:&lt;/strong&gt; &lt;code&gt;std::for_each(first, last, boost::mem_fn(pmf));&lt;/code&gt; と同等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ここで、 &lt;code&gt;boost::mem_fn&lt;/code&gt; の部分はこのページへのリンクとするとよいだろう。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bindのドキュメント&lt;/a&gt; にそのような例があるので参照のこと。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; は1つの引数(メンバ関数へのポインタ)をとり、標準あるいは独自の アルゴリズムに渡すのに適した関数オブジェクトを戻す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X
{
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f();
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;h&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X &lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;k&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;戻される関数オブジェクトは、引数のメンバ関数ポインタと同じ引数をとることに加え、 インスタンスを表すための「柔軟な」第一引数をとる。&lt;/p&gt;
&lt;p&gt;関数オブジェクトが、適切なクラス(上の例では &lt;code&gt;X&lt;/code&gt;)を指すポインタでも参照でも ない第一引数&lt;code&gt;x&lt;/code&gt;をもって呼ばれた場合、関数オブジェクトは&lt;code&gt;get_pointer(x)&lt;/code&gt; を用いて&lt;code&gt;x&lt;/code&gt;からポインタを得ようとする。 スマートポインタの作者は、自分たちのスマートポインタ向けの適切な&lt;code&gt;get_pointer&lt;/code&gt;関数 を定義(overload)しておくことで、それを&lt;code&gt;mem_fn&lt;/code&gt;対応とすることができる。&lt;/p&gt;
&lt;p&gt;[注意: &lt;code&gt;get_pointer&lt;/code&gt; の戻り値はポインタでなくともよい。 &lt;code&gt;(x-&amp;gt;*pmf)(...)&lt;/code&gt;という形式でメンバ関数が呼び出せるなら、どんなオブジェクトでも問題ない。]&lt;/p&gt;
&lt;p&gt;[注意: ライブラリは、&lt;code&gt;get_pointer&lt;/code&gt; の非限定的 (訳注:名前空間を明示しない) 呼び出しを行なう。 そのため、引数依存検索の過程では、オーバーロードされた&lt;code&gt;boost::get_pointer&lt;/code&gt;関数群に加えて、 そのスマートポインタが定義された名前空間内の&lt;code&gt;get_pointer&lt;/code&gt;関数群も検索対象になる。]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;が戻す全ての関数オブジェクトは、&lt;code&gt;result_type&lt;/code&gt;なる&lt;code&gt;typedef&lt;/code&gt;を開示する。 この&lt;code&gt;typedef&lt;/code&gt;は、メンバ関数の戻り型を表す。メンバ変数を渡した場合には、&lt;code&gt;result_type&lt;/code&gt; はそのメンバ変数の型の定数参照として定義される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34; name=&#34;faq&#34;&gt;FAQ&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34; name=&#34;Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。単純な使い方では、&lt;code&gt;mem_fn&lt;/code&gt; は標準のアダプタが提供しないいくつかの機能を提供する。 &lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;Boost.Compose&lt;/a&gt; と標準のアダプタを組み合わせるような複雑な使い方をしている場合は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;&lt;code&gt;boost::bind&lt;/code&gt;&lt;/a&gt; を使用するように書き換えることで、&lt;code&gt;mem_fn&lt;/code&gt;の恩恵を自動的に受けることができる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34; name=&#34;Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いいえ。そうする強い理由がないならすべきではない。&lt;code&gt;mem_fn&lt;/code&gt; は、標準のアダプタに 非常に良く似ているが、100%の互換性があるわけではない。特に、&lt;code&gt;mem_fn&lt;/code&gt;は、標準の アダプタとは違って &lt;code&gt;std::[const_]mem_fun[1][_ref]_t&lt;/code&gt; 型のオブジェクトを戻さないので、 標準の &lt;code&gt;argument_type&lt;/code&gt; 及び &lt;code&gt;first_argument_type&lt;/code&gt; という (nested) &lt;code&gt;typedef&lt;/code&gt; を 用いて第一引数の型を記述することが (完全には) できない。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。&lt;code&gt;#define BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; とすれば可能である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;特定のベンダへの依存を避けるため、可搬性のない拡張は、一般にデフォルトでオフにされるべきである。 もし &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; がデフォルトで有効であったなら、あなたはそうとは気づかずに その拡張を使ってしまい、結果としてあなたのコードの可搬性が損なわれるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34; name=&#34;interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34; name=&#34;synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost
{

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ());

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt;&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-5&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-6&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 実際には、より多くの引数をとるような関数が、更にいくつかオーバーロードされている&lt;/span&gt;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34; name=&#34;requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Synopsis で述べられた全ての &lt;em&gt;unspecified-N&lt;/em&gt; 型は &lt;code&gt;CopyConstructible&lt;/code&gt; (コピーコンストラクト可能) かつ &lt;code&gt;Assignable&lt;/code&gt; (代入可能) であること。そのためのコピーコンストラクタ及び代入演算子 は例外を送出しないこと。 &lt;em&gt;unspecified-N&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;mem_fn&lt;/code&gt; に渡されたメンバ関数ポインタの戻り型、と定義されること (Synopsis での &lt;code&gt;R&lt;/code&gt;)。 &lt;em&gt;unspecified-2-1&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;R const &amp;amp;&lt;/code&gt; 、と定義されること。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34; name=&#34;get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34; name=&#34;mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt;あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2-1&lt;/span&gt;&lt;/i&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;t.*pm&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;get_pointer(t)-&amp;gt;*pm&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-5&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-6&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34; name=&#34;implementation&#34;&gt;実装&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34; name=&#34;files&#34;&gt;ファイル&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;boost/mem_fn.hpp (メインヘッダ)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_cc.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_vw.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_template.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_test.cpp (テスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_derived_test.cpp (派生オブジェクトでのテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_fastcall_test.cpp (&lt;code&gt;__fastcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_stdcall_test.cpp (&lt;code&gt;__stdcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_void_test.cpp (戻りが&lt;code&gt;void&lt;/code&gt;であるケースのテスト)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34; name=&#34;dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Config&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34; name=&#34;number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;この実装では、8つまでの引数をとるメンバ関数がサポートされている。これは、設計に固有の 制限という訳ではなく、実装の詳細である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34; name=&#34;stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いくつかのプラットフォームでは、 &lt;strong&gt;呼び出し規則&lt;/strong&gt; (どのように関数が起動されるかの規則: 引数はどのように渡されるのか、戻り値はどのように扱われるのか、もしスタックを使用したなら、 誰がそれを奇麗にするのか) の異なるような何種類かのメンバ関数を作成できる。&lt;/p&gt;
&lt;p&gt;例えば、Windows API の関数と、COMインタフェースのメンバ関数は、 &lt;code&gt;__stdcall&lt;/code&gt; という呼び出し規則を用いるし、 Borland の VCL コンポーネントは &lt;code&gt;__fastcall&lt;/code&gt; を用いる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__stdcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__fastcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_FASTCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;[注意: これは可搬性のない拡張であり、インタフェースの一部ではない。]&lt;/p&gt;
&lt;p&gt;[注意: いくつかのコンパイラは、 &lt;code&gt;__stdcall&lt;/code&gt; キーワードに対して最小限のサポートしか提供していない。]&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get_pointer&lt;/code&gt;ベースの設計は、Rene Jageによる、特性クラスを用いて &lt;code&gt;mem_fn&lt;/code&gt;を ユーザ定義のスマートポインタに適合させるという提案に影響されたものである。&lt;/p&gt;
&lt;p&gt;フォーマルレビューの期間に、Richard Crossley、 Jens Maurer、 Ed Brey、その他の方々の示唆によって、たくさんの 改良があった。レビューマネージャは Darin Adler であった。&lt;/p&gt;
&lt;p&gt;Steve Anichini は、COMインタフェースが &lt;code&gt;__stdcall&lt;/code&gt; を使用していることを指摘した。&lt;/p&gt;
&lt;p&gt;Dave Abrahams は、不完全なコンパイラにおいても &#34;戻り値なし&#34; をサポートすべく、&lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;mem_fn&lt;/code&gt; を改良した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2001, 2002 by Peter Dimov and Multi Media Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 SATO Yusuke &lt;a href=&#34;mailto:y-sato@y-sa.to&#34;&gt;y-sato@y-sa.to&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェックの利用 -- concept_check : リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html"/>
      <id>72303f86627d5f6317602edde95035bc6bff0acf:archive/boost_docs/libs/concept_check/using_concept_check.md</id>
      <updated>2015-01-17 00:24:31 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンセプト・チェックの利用&lt;/h1&gt;
&lt;p&gt;各コンセプトに対して、与えられた型 (あるいは型の集合) がコンセプトをモデル化していることを確かめるために使用することができる、何らかのコンセプト・チェック用クラスが存在する。 Boost コンセプト・チェック・ライブラリ (BCCL) は、C++ 標準ライブラリの中で使用される全てのコンセプト＋αを対象とした、コンセプト・チェック用クラスを含んでいる。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt; セクションに、このコンセプト・チェック用クラスをリストしてある。 さらに、他の Boost ライブラリも、ライブラリ独自の特別なコンセプトに対応するコンセプト・チェック用クラスを付随している。 例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.md.nolink&#34;&gt;graph concept&lt;/a&gt; および &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/property_map.md.nolink&#34;&gt;property map concept&lt;/a&gt; がある。 さらに、クラス・テンプレートや関数テンプレートを記述する者は、既存のコンセプトでカバーされていない要求事項を表現する必要のある場合は常に、新しいコンセプト・チェック用クラスを作成すべきである。 その方法は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt; セクションで説明する。&lt;/p&gt;
&lt;p&gt;BCCL のコンセプト・チェック用クラスの例として、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; クラスを挙げる。 このクラスは、C++ 標準 20.1.1 に記述されている &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) 要求事項および、SGI STL で文書化されている &lt;a href=&#34;http://www.sgi.com/tech/stl/EqualityComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;EqualityComparable&lt;/code&gt;&lt;/a&gt; (等値比較可能) コンセプトに相当する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EqualityComparableConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;テンプレート引数 &lt;code&gt;T&lt;/code&gt; はチェック対象の型と意図されている。 すなわち、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; の目的は、&lt;code&gt;T&lt;/code&gt; に対して与えられたテンプレート引数が 等値比較可能コンセプトをモデル化しているかどうか確認することである。&lt;/p&gt;
&lt;p&gt;個々のコンセプト・チェック用クラスには、該当するコンセプトにおいて有効な式を内包する &lt;code&gt;constraints()&lt;/code&gt; という名前のメンバー関数がある。 ある型が &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) であるかどうかチェックするためには、その型でコンセプト・チェック用クラスのインスタンスを生成し、次に、コンパイラに、実際に &lt;code&gt;constraints()&lt;/code&gt; 関数を実行することなくコンパイルさせる方法を見つける必要がある。 Boost コンセプト・チェック・ライブラリは、これを容易にする2つのユーティリティ： &lt;code&gt;function_requires()&lt;/code&gt; と &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; を定義している。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;function_requires()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;function_requires()&lt;/code&gt; 関数は関数本体の中で使用できる。また、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロはクラス定義本体で使用できる。 &lt;code&gt;function_requires()&lt;/code&gt; 関数は引数をとらないが、コンセプト・チェック用クラスを受けるためのテンプレート・パラメータを有する。 これは、以下に示すように、インスタンス化されたコンセプト・チェック用クラスを明示的にテンプレート引数として与えられなければならないことを意味する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; generic_library_function(T x)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; EqualityComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  foo f;
  generic_library_function(f);
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロは、ある型がコンセプトをモデル化しているかどうかチェックするために、クラス定義の内部で使用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; generic_library_class
{
  BOOST_CLASS_REQUIRE(T, boost, EqualityComparableConcept);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  generic_library_class&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; glc;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;以前の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating_example&#34;&gt;動機の例&lt;/a&gt; に対してコンセプト・チェックを応用する場合、良いやり方として、テンプレート・パラメータ型が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデル化していることを確認するために &lt;code&gt;std::stable_sort()&lt;/code&gt; の一番上に &lt;code&gt;function_requires()&lt;/code&gt; を挿入することが一つ挙げられる。 さらに、&lt;code&gt;std::stable_sort()&lt;/code&gt; は、イレテータの &lt;code&gt;value_type&lt;/code&gt; が&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;LessThanComparable&lt;/code&gt; (未満比較可能)&lt;/a&gt; を満足することが必要であるから、これをチェックするために、重ねて &lt;code&gt;function_requires()&lt;/code&gt; を使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIter first, RandomAccessIter last)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; RandomAccessIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type value_type;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; LessThanComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;value_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンセプトによっては複数の型を処理するものがある。 この場合、対応するコンセプト・チェック用クラスは複数のテンプレート・パラメータを持つことになる。 以下の例は、&lt;code&gt;function_requires()&lt;/code&gt; を、２つの型パラメータ（プロパティ・マップ型とそのキーとなる型）をとる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; コンセプトに対して使用する方法を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;IncidenceGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor Vertex;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ReadWritePropertyMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ColorMap, Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; の使用例として、&lt;code&gt;std::vector&lt;/code&gt; が有すべきコンセプト・チェックを考察する。 要素型に対して当てはめる要求事項の一つは、それが &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Assignable&lt;/code&gt; (割当可能)&lt;/a&gt;でなければならない、ということである。 これは、&lt;code&gt;std::vector&lt;/code&gt; の定義の一番上に&lt;code&gt;BOOST_CLASS_REQUIRE(T, boost, AssignableConcept)&lt;/code&gt;を挿入することにより、チェックすることができる。&lt;/p&gt;
&lt;p&gt;コンセプト・チェックは、ジェネリック・ライブラリの実装者が使用するために設計されているが、エンドユーザーにおいても有用である。 往々にして、ある型が特定のコンセプトをモデル化しているかどうか、不明確な場合がある。 こういうケースでは、問題の型とコンセプトを対象として &lt;code&gt;function_requires()&lt;/code&gt; を使用する、小さなプログラムを作成することで容易にチェックできる。 ファイル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/stl_concept_check.cpp.html&#34;&gt;stl_concept_checks.cpp&lt;/a&gt; は、STL コンテナにコンセプト・チェックを適応する実例となっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;次へ：「コンセプト・チェック用クラスの作成」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;前へ：「はじめに」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Distjoint Sets（互いに素な集合） -- disjoint_sets : リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html"/>
      <id>0876aae3f9108a6832681a1e3c182fa8d8448f4e:archive/boost_docs/libs/disjoint_sets.md</id>
      <updated>2015-01-17 00:22:20 +0900</updated>
      
        <content type="html">&lt;h1&gt;Distjoint Sets（互いに素な集合）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、互いに素な集合（素集合）の演算に 順位による和集合 および パス圧縮 を提供する。disjoint-sets のデータ構造は、素集合の S = {S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ..., S&lt;sub&gt;k&lt;/sub&gt;} というコレクションを維持する。 各集合は、集合のいくつかの要素である 代表値 によって識別される。 集合は、Parent プロパティマップの中の符号化された有向木によって表わされる。 2つの発見的手法: 「順位による和集合」 および 「パス圧縮」 は、 演算を高速化するのに使われる  [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#tarjan83&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#clr90&#34;&gt;2&lt;/a&gt;]。&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;boost/disjoint_sets.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Rank&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値型が整数型で、キー型が集合の要素型と等しい &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Parent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルで、かつ、キー型および値型は集合の要素型と等しくなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;disjoint_sets&lt;/code&gt; に対する典型的な使用法の手本は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/kruskal_minimum_spanning_tree.md.nolink&#34;&gt;&lt;code&gt;kruskal_minimum_spanning_tree()&lt;/code&gt;&lt;/a&gt; アルゴリズムで見ることができる。 この例では、&lt;code&gt;union_set()&lt;/code&gt; の代わりに &lt;code&gt;link()&lt;/code&gt; を呼び出す。 なぜなら、&lt;code&gt;u&lt;/code&gt; および &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;find_set()&lt;/code&gt; から得られ、したがって、既にそれら集合の代表値であるからだ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;...
disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; dsets(rank, p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (ui  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G).first; ui &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vertices(G).second; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ui)
  dsets.make_set(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ui);
...
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; ( &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;Q.empty() ) {
  e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Q.front();
  Q.pop();
  u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(source(e));
  v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(target(e));
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( u &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v ) {
    &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;out&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; e;
    dsets.link(u, v);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(Rank r, Parent p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(const disjoint_sets&amp;amp; x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void make_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Element x&lt;/code&gt; を含む単集合を作成する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void link(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; で表わされる 2つの集合を結合する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void union_set(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; を含む 2つの集合を結合する。 これは、&lt;code&gt;link(find_set(x),find_set(y))&lt;/code&gt; に相当する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Element find_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; を含む集合のための代表値を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;std::size_t count_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;素集合の個数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void compress_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;すべての要素の親がその代表値であるように親ツリーを平滑化する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Complexity&lt;/h2&gt;
&lt;p&gt;時間計算量は、O(m alpha(m,n)) である。alpha は逆アッカーマン関数、 m は disjoint-set の演算（&lt;code&gt;make_set()&lt;/code&gt;、&lt;code&gt;find_set()&lt;/code&gt;、および &lt;code&gt;link()&lt;/code&gt;）の総数、n は要素数である。 alpha 関数はとても遅く、log 関数よりもはるかに遅くなる。&lt;/p&gt;
&lt;p&gt;参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_connected_components.md.nolink&#34;&gt;&lt;code&gt;incremental_connected_components()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ID,InverseID,FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、順位および親のプロパティのための記憶領域を内部で管理する。 記憶領域は、要素IDにより索引付けされた配列の中にある。ゆえに、ID および InverseID ファンクタを必要とする。 順位および親のプロパティは、構築中に初期化される、 したがって、各要素は自動的に集合の中にある（従って、このクラスのオブジェクトを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.md.nolink#sec:initialize-incremental-components&#34;&gt;&lt;code&gt;initialize_incremental_components()&lt;/code&gt;&lt;/a&gt; 関数で初期化することは必要でない。）。 このクラスは、頂点プロパティを格納する場所を提供しない &lt;code&gt;edge_list&lt;/code&gt; グラフの（動的）接続している構成要素を計算する場合に特に有用である。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0からN（集合中の要素の総数）までの整数に要素を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;InverseID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素に整数を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;representative_with_full_path_compression&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;p&gt;このクラスは、以下のメンバだけでなく &lt;code&gt;disjoint_sets&lt;/code&gt; のすべてのメンバも持っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage(size_type n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
                           ID id &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ID(),
                           InverseID inv &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; InverseID())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンストラクタ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ElementIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;
  normalize_sets(ElementIterator first, ElementIterator last)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;各集合の代表値が最も小さな ID を備えた要素になるように代表値を再整理する。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事後条件: &lt;code&gt;v &amp;gt;= parent[v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事前条件: 素集合の構造は圧縮されていなければならない。 &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_path_halving&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; と同じ構成要素のための代表的な頂点を検索するファンクタである。 代表値木を横断している間、ファンクタは、さらに木の高さを短くするためにパス二分技術を適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_full_path_compression&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; が属する集合のための代表的な要素を検索するファンクタである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~llee1&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:llee1@lsc.nd.edu&#34;&gt;llee1@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:lums@lsc.nd.edu&#34;&gt;lums@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 IKOMA Yoshiki &lt;a href=&#34;mailto:ikoma@mb.i-chubu.ne.jp&#34;&gt;ikoma@mb.i-chubu.ne.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Improved Function Object Adapters -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Improved Function Object Adapters&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/functional/&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/functional/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準ライブラリの関数オブジェクトアダプタ(セクション 20.3.5 から 20.3.8)を強化する。この強化は主に二つの変更を行う。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我々は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;参照の参照&lt;/a&gt; 問題を回避し、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#args&#34;&gt;引数渡し&lt;/a&gt; の効率を良くするために、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; テンプレートを使う。&lt;/li&gt;
&lt;li&gt;我々は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html&#34;&gt;&lt;code&gt;ptr_fun&lt;/code&gt;&lt;/a&gt; の必要性を回避するために、このライブラリのアダプタとともに、ふたつの&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を使う。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;p&gt;このヘッダは以下の関数・クラステンプレートを含む:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分類&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;Function object traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_traits&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binary_traits&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクトや関数の引数型を決定するために使われる。&lt;code&gt;ptr_fun&lt;/code&gt;の必要性を除去する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html&#34;&gt;Negators&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binary_negate&lt;/code&gt;&lt;br /&gt; &lt;code&gt;not1&lt;/code&gt;&lt;br /&gt; &lt;code&gt;not2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.5 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html&#34;&gt;Binders&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;binder1st&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binder2nd&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bind1st&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bind2nd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.6 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html&#34;&gt;Adapters for pointers to functions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pointer_to_unary_function&lt;/code&gt;&lt;br /&gt; &lt;code&gt;pointer_to_binary_function&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptr_fun&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.7 に基づく。このライブラリとともに使用する場合はバインダやネゲータは関数に適合できるので不要である。しかし、サードパーティのアダプタに必要とされるかもしれない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html&#34;&gt;Adapters for pointers to member functions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mem_fun_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun1_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun1_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun1_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun1_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun_ref&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.8 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;これらのアダプタの使い方は標準関数オブジェクトアダプタの使い方にとてもよく似ている。唯一の違いは、&lt;code&gt;std::&lt;/code&gt; の代わりに &lt;code&gt;boost::&lt;/code&gt; と書く必要があることだけである。そうすればあなたの頭痛は軽減される。&lt;/p&gt;
&lt;p&gt;例えば、あなたが &lt;code&gt;set_name&lt;/code&gt; 関数を持つ&lt;code&gt;Person&lt;/code&gt;クラスを持っていると考えてほしい:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Person&lt;/span&gt;
{
  &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set_name(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;name);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;あなたは以下のように書くことによって、コレクション &lt;code&gt;c&lt;/code&gt; 中の &lt;code&gt;Person&lt;/code&gt; の束を改名できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Person&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set_name), &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Fred&#34;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もし代わりに標準アダプタが使われていれば、このコードは普通、コンパイルに失敗する。それは、&lt;code&gt;set_name&lt;/code&gt; が参照引数を取るからである。何故こうなるかを解明したければ、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;バインダのドキュメント&lt;/a&gt; の中のコメントを参照するとよい。&lt;/p&gt;
&lt;h2&gt;Compiler Compatibility&lt;/h2&gt;
&lt;p&gt;このヘッダと &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_test.cpp.html&#34;&gt;テストプログラム&lt;/a&gt; は以下のコンパイラでコンパイルされる:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;コンパイラ&lt;/th&gt;
&lt;th&gt;コメント&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Borland C++Builder 4 Update 2&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Borland C++ 5.5&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g++ 2.95.2&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft Visual C++ Service Pack 3&lt;/td&gt;
&lt;td&gt;コンパイラが部分特殊化版を欠いているため、このライブラリは標準アダプタによって提供されるより、少しだけしか多くの機能を提供しない。&lt;br /&gt; ・参照の参照問題を回避するための &lt;code&gt;call_traits&lt;/code&gt; メカニズムが使えない。それゆえ、このライブラリのアダプタはより少ない状況でしか使えないだろう。&lt;br /&gt; ・関数の引数や返り値型を特定するための &lt;code&gt;function_traits&lt;/code&gt; メカニズムが使えない。それゆえ、関数を適合させるため、&lt;code&gt;ptr_fun&lt;/code&gt; が引き続き必要になる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Future Directions&lt;/h2&gt;
&lt;p&gt;このライブラリの第一目的は、できる限り多くの標準ライブラリの互換性を 持つ、参照の参照問題に対する解である。これによって本や雑誌で読む技術を 今日のたくさんのコンパイラで使うことができる。&lt;/p&gt;
&lt;p&gt;長期的には、より良い解は以下のようなものだろう:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;幾人かの Boost のメンバは式テンプレートのライブラリを作成し ている。これらによって、関数の結合や適合が自然な文法で行えるだろう。 これは新しい技術なので、それが熟して、有名なコンパイラに広くサポートされるまでに時間がかかるかもしれないが、大きな成功となるだろう。それまでは、この functional.hpp ライブラリがギャップを埋める。&lt;/li&gt;
&lt;li&gt;標準委員会はテンプレートの実体化に際して参照の参照問題が起きることを認識していて、標準を修正する気になっている( &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Author&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/mark_rodgers.htm&#34; target=&#34;_blank&#34;&gt;Mark Rodgers&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/john_maddock.htm&#34; target=&#34;_blank&#34;&gt;John Maddock&lt;/a&gt; for suggesting the mechanism that allowed the function objects traits to work correctly. &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jens_maurer.htm&#34; target=&#34;_blank&#34;&gt;Jens Maurer&lt;/a&gt; provided invaluable feedback during the &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/more/formal_review_process.htm&#34; target=&#34;_blank&#34;&gt;formal review process&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Binders -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional/binders.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Binders&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.6): 由来のバインダ関数オブジェクトアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binder1st&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binder2nd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bind1st&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind2nd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準ライブラリにあるそれらの代わりに、これらのアダプタを使う主な便益は、それらが &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;参照の参照&lt;/a&gt; 問題を回避することにある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い方は標準バインダと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Foo&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34; name=&#34;refref&#34;&gt;References to References&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下の使用例を考えなさい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Foo&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これがもし &lt;code&gt;std::bind2nd&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt; を使って書かれているならば、コンパイルできないだろう。&lt;/p&gt;
&lt;p&gt;この問題は &lt;code&gt;bar&lt;/code&gt; が参照引数を取ることが原因で起こる。標準は &lt;code&gt;std::mem_fun_ref&lt;/code&gt; を &lt;code&gt;second_argument_type&lt;/code&gt; が &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; である関数オブジェクトを作るように定義する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind2nd&lt;/code&gt; 呼び出しは &lt;code&gt;binder2nd&lt;/code&gt; を作り、それは標準が以下のように定義している:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Operation&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;binder2nd&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;first_argument_type,
                            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;result_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
...
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  binder2nd(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x,
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;second_argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; y);
  ...
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々の &lt;code&gt;Operation&lt;/code&gt; の &lt;code&gt;second_argument_type&lt;/code&gt; は &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; であるから、コンストラクタの中の &lt;code&gt;y&lt;/code&gt; の型は &lt;code&gt;std::ostream&amp;amp;&amp;amp;&lt;/code&gt; となるだろう。参照の参照を作ることはできないから、参照の参照は C++ では非合法であるとしてこの時点でコンパイルエラーになる。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;このライブラリのバインダは Boost &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; テンプレートを使うことによってこの問題を回避している。&lt;/p&gt;
&lt;p&gt;コンストラクタは以下のように宣言される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;binder2nd(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x,
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
             &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; binary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;second_argument_type
          &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type y)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;結果、&lt;code&gt;y&lt;/code&gt; は &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; 型を持つ。そして、我々の例はコンパイルされる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Member Function Adapters -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional/mem_fun.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Member Function Adapters&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準ライブラリ (§ 20.3.8): 由来のメンバ関 数アダプタの全ての強化バージョンを含んでいる:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem_fun_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun1_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun1_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun1_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun1_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem_fun&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun_ref&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準のアダプタそれぞれから、以下の変更がなされている:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;first_argument_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; は &lt;code&gt;const_&lt;/code&gt; ファミリーのメンバ関数アダプタのために 修正されている。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#firstarg&#34;&gt;以下&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fun1_t&lt;/code&gt;やその変種に渡される引数は、メンバ関数の引数型として、&lt;code&gt;call_traits::param_type&lt;/code&gt; を用いて渡される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#firstarg&#34; name=&#34;firstarg&#34;&gt;first_argument_type&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;const_mem_fun1_t&lt;/code&gt; を例えば、以下のように指定する:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;S&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;const_mem_fun1_t&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;, A, S&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;const_mem_fun1_t&lt;/span&gt;(S (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;p)(A) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);
  S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, A x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;binary_function&lt;/code&gt; への第一引数が実際には &lt;code&gt;const T*&lt;/code&gt; であるにも関わらず、 &lt;code&gt;T*&lt;/code&gt; になっている点に注意しなさい。&lt;/p&gt;
&lt;p&gt;これはどういうことか？さて、我々が以下のように書くとき何が起こるかを考えなさい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Foo { &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;; };
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;cp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Foo;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind1st(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), cp);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は以下のようなものを効果的に含む &lt;code&gt;const_mem_fun1_t&lt;/code&gt; オブジェクトを作成した。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Foo&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; first_argument_type;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次に &lt;code&gt;bind1st&lt;/code&gt; はこの &lt;code&gt;typedef&lt;/code&gt; を &lt;code&gt;cp&lt;/code&gt; によって初期化されるメンバ型として用いる &lt;code&gt;binder1st&lt;/code&gt; オブジェクトを作成する。言い換えれば、我々は &lt;code&gt;Foo*&lt;/code&gt; メンバを &lt;code&gt;const Foo*&lt;/code&gt; メンバで初期化する必要がある！ 明らかに これは不可能であるので、標準ライブラリのベンダはこれを実装するために &lt;code&gt;cp&lt;/code&gt; の定数性を、おそらく &lt;code&gt;bind1st&lt;/code&gt; の本体の中で、キャストして取り除かなければならなかっただろう。&lt;/p&gt;
&lt;p&gt;このハックは改良された &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html&#34;&gt;バインダ&lt;/a&gt; とともに用いる場合十分ではないので、我々はメンバ関数アダプタの修正されたバージョンも同様に提供しなければならなかった。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;mem_fun1_t&lt;/code&gt; を例えば以下のように定義する (§20.3.8 ¶2):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;S&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;mem_fun1_t&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;, A, S&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;mem_fun1_t&lt;/span&gt;(S (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;p)(A));
  S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, A x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; の第二引数はメンバ関数の引数と全く同じであることに注意しなさい。もしこれが値型であれば、引数は二度値渡しされてコピーされる。&lt;/p&gt;
&lt;p&gt;しかしながら、もし我々が引数を代わりに &lt;code&gt;const A&amp;amp;&lt;/code&gt; として宣言することによってこの非効率性を削除しようとするならば、もし &lt;code&gt;A&lt;/code&gt; が参照型であれば、我々は参照の参照を持ってしまう。そしてそれは現在のところ非合法である。 (ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;operator()&lt;/code&gt; の引数を宣言する望ましい方法は、メンバ関数の引数が参照であるかないかに依っている。もしそれが参照であるならば、単純に &lt;code&gt;A&lt;/code&gt; と宣言したいのであり、もし値であれば &lt;code&gt;const A&amp;amp;&lt;/code&gt; と宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特殊化版を用いて正確にこの判断をを行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;call traits テンプレートはこの改良を実現するために使われる関数オブジェ クト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化の機能を持つコンパイラでのみ有効である。そうでないコンパイラでは、メンバ関数に渡される引数は(&lt;code&gt;mem_fun1_t&lt;/code&gt; ファミリの中で) 常に参照渡しとなるので、参照の参照の可能性を生みだすことになる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Negators -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional/negators.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Negators&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.5) 由来のネゲータアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binary_negate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;not1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このライブラリのネゲータは標準バージョンを二つの方法で改良する。&lt;/p&gt;
&lt;p&gt;適合関数オブジェクトではなく関数を否定する時、それらは &lt;code&gt;ptr_fun&lt;/code&gt; の必要を回避するために、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を用いる。&lt;/p&gt;
&lt;p&gt;それらは引数や適合された関数に渡す引数を宣言する最上の方法を決するため、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;call traits&lt;/a&gt; を用いる。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34;&gt;下記&lt;/a&gt;参照)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い型は標準ネゲータと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++ 標準 (§20.3.5) は unary negate をこのように定義 している。(binary negate も似ている):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type,&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; unary_negate(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; pred);
  &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であった場合、 &lt;code&gt;operator()&lt;/code&gt; の引数の型は参照の参照になることに注意しなさい。これは、現在の C++ では非合法である。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;しかしながら、もし代わりに &lt;code&gt;operator()&lt;/code&gt; を &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; を変更せずにそのまま採用して定義すると、それが値型であった場合不必要に非効率になってしまう。それは引数が二度コピーされることによる。一度は &lt;code&gt;unary_negate&lt;/code&gt; の &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時、さらに適合された関数で &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時にもう一度である。&lt;/p&gt;
&lt;p&gt;つまり&lt;code&gt;operator()&lt;/code&gt; を宣言する望ましい方法は、 &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であるか否かに依 る。もしそれが参照であれば、単純に &lt;code&gt;argument_type&lt;/code&gt; として宣言したいし、それが値であれば &lt;code&gt;const argument_type&amp;amp;&lt;/code&gt; として宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.html&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特 殊化版を用いて正確にこの判断を行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。実のところ、実際の宣言は関数オブジェクト特性を使うためもう少し複雑である。しかし効果は同様である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;この関数オブジェクト特性の両方と call traits はこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化版の機能を持つコンパイラでのみ有効である。 そうでないコンパイラでは、このライブラリのネゲータは標準内のそれらと非常に似た振る舞いをする - 関数に適合するために &lt;code&gt;ptr_fun&lt;/code&gt; が必要であるし、参照の参照は避けられないだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Function Pointer Adapters -- functional : リンク切れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html"/>
      <id>33db5f4ead7c5da7d67359dd6a59080353afaac9:archive/boost_docs/libs/functional/ptr_fun.md</id>
      <updated>2015-01-17 00:21:05 +0900</updated>
      
        <content type="html">&lt;h1&gt;Function Pointer Adapters&lt;/h1&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§ 20.3.7): 由来の関数ポインタアダプ タの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointer_to_unary_function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointer_to_binary_function&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ptr_fun&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;しかし、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を使用しているおかげで、このライブラリのアダプタと接続する場合、このアダプタを使う必要はない。しかしながら、あなたの実装が我々の特性クラスとともにきちんと働かない場合 (部分特殊化版が欠けていることによる) や、サードパーティの関数オブジェクトアダプタとともに使いたい場合に、使う必要があるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;これらのアダプタを使う必要がある場合、使い方は標準関数ポインタアダプタと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it
     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ptr_fun(bad)));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかしながら、このライブラリは関数オブジェクト特性をサポートする、強化された &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html&#34;&gt;ネゲータ&lt;/a&gt; を含んでいることに注意しなさい。それで、以上のソースと同様に以下のように書ける。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it
     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;pointer_to_unary_function&lt;/code&gt; をこのように定 義する(§20.3.8 ¶2):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Result&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;pointer_to_unary_function&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Arg, Result&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; pointer_to_unary_function(Result (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; f)(Arg));
  Result &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Arg x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; の引数はラップされる関数の引数と厳密に等しい型であることに注意しなさい。もしこれが値型であれば、引数は値渡しされ、二度コピーされる。&lt;code&gt;pointer_to_binary_function&lt;/code&gt; も同様の問題を持っている。&lt;/p&gt;
&lt;p&gt;しかしながら、引数を代わりに &lt;code&gt;const Arg&amp;amp;&lt;/code&gt; と宣言することによって非効率を削除しようとすると、&lt;code&gt;Arg&lt;/code&gt; が参照型であった場合、現 在では非合法な (ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)、参照の参照ができてしまう。&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;operator()&lt;/code&gt; の引数を宣言する望ましい方法は、ラップされる関数の引数が参照であるかないかに依っている。もしそれが参照であるならば、単純に &lt;code&gt;Arg&lt;/code&gt; と宣言したいのであり、もし値であれば &lt;code&gt;const Arg&amp;amp;&lt;/code&gt; と宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特殊化版を用いて正確にこの判断をを行う。&lt;code&gt;operator()&lt;/code&gt; を以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Result &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Arg&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;call traits テンプレートはこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化の機能を持つコンパイラでのみ有効である。そうでないコンパイラでは、関数に渡される引数は常に参照渡しとなるので、参照の参照の可能性を生みだすことになる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>