<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2014-11-27T23:50:06.749184</updated>
  <id>f5c094c3-2cd7-4228-8e17-91b69a86c314</id>

  
    <entry>
      <title>ジェネリックコンポーネントにおける例外安全性 -- 英文での斜体を、日本語では太字にした。 これは英語から日本語への翻訳で一般的な手法。日本語文章中の斜体は目立たない。</title>
      <link href="http://boostjp.github.io/archive/boost_docs/document/generic_exception_safety.html"/>
      <id>febe350aad0ebfbefa50221e17d30e36bb728a5d:archive/boost_docs/document/generic_exception_safety.md</id>
      <updated>2014-11-27 23:49:45 +0900</updated>
      
        <content type="html">&lt;h1&gt;ジェネリックコンポーネントにおける例外安全性&lt;/h1&gt;
&lt;p&gt;C++標準ライブラリのために規定した例外安全性の経験から学んだこと&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;David Abrahams&lt;/li&gt;
&lt;li&gt;david.abrahams@rcn.com&lt;/li&gt;
&lt;li&gt;翻訳元：&lt;a href=&#34;http://www.boost.org/community/exception_safety.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/community/exception_safety.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;この文書は実世界の必要性に対する応答の中で蓄積された知識を表す: つまり、 C++ 標準テンプレートライブラリは、役立つ、そして明確な例外との相互作用を示し、 エラー捕捉の機構は C++ 言語の中核に組み込まれている。 この文書では、例外安全性の意味を探求し、例外と汎用性についての驚くべき神話を明らかにし、 プログラムの正当性を理由付けるための価値ある道具について述べ、 例外安全性を実証するための自動化されたテストの手続きを概説する。&lt;/p&gt;
&lt;p&gt;Keywords: exception-safety, exceptions, STL, C++&lt;/p&gt;
&lt;h2&gt;1 例外安全性とは何か&lt;/h2&gt;
&lt;p&gt;簡単に言えば、コンポーネントの例外安全性とは、 実行中に例外が投げられたとき、正当な振る舞いを示すことを意味する。 ほとんどの人にとって、「正当な」という用語は、エラー捕捉に対する通常の例外全てを含む: つまり、資源は漏れるべきではないし、プログラムは実行を継続できるように、 明確な状態であり続けるべきである。多くのコンポーネントにとって、 これはまた、エラーに出会った時に呼び出し元に報告されるような例外も含む。&lt;/p&gt;
&lt;p&gt;より公式に言えば、コンポーネントの中から例外が投げられたときに、 もしその不変性が損なわれないなら、そのコンポーネントは最小限の例外安全性を持っていると言える。 後に見るが、通常、少なくとも3種類の異なる例外安全性が区別されている。 これらの区別は巨大なシステムの振る舞いについて記述し、理由付けるのに役立つのである。&lt;/p&gt;
&lt;p&gt;汎用コンポーネントでは、通常我々は、さらに、 &lt;strong&gt;例外中立性&lt;/strong&gt; という期待をもつ。 これは、コンポーネントの型パラメータによって投げられた例外は、 そのコンポーネントの呼び出し元まで、変わることなく伝えられるべきである、 ということを意味する。&lt;/p&gt;
&lt;h2&gt;2 神話と迷信&lt;/h2&gt;
&lt;p&gt;例外安全性は、これまでのところ簡単なものに見える: それは、より伝統的なエラー捕捉の技術を使ったコードに期待する以上のことを、 何も構築したりはしない。しかし、心理学的な観点からこの用語を調べてみることは、価値があるだろう。 C++ が例外を持つ以前は、誰も「エラー安全性」について語らなかった。&lt;/p&gt;
&lt;p&gt;まるで例外は、正しいコードに対する &lt;strong&gt;ミステリアスな攻撃&lt;/strong&gt; であり、 我々が自らをその攻撃から守らなければいけないようなものであると見なされているかのようである。 言うまでもなく、これはエラー捕捉との健全な関係に繋がらない! 標準化の間、変更に対する幅広いサポートを要求する民主的な過程で、 私は広く支持された多くの迷信に出会った。 汎用コンポーネントにおける例外安全性の議論を始めるために、 それらのいくつかを見ておくことは意味のあることだろう。&lt;/p&gt;
&lt;p&gt;「テンプレートと例外の相互作用は、良く理解できない。」 これら両方が言語の新しい特徴であると考える人々から良く聞かれるこの神話は、 簡単に却下できる: そこには、相互作用はないのである。 テンプレートは、一度実体化されれば、全ての面で通常のクラスや関数と同じように機能する。 例外と関連したテンプレートの振る舞いを考えるための単純な方法は、 そのテンプレートの特別版の実体化がどう機能するかについて考えることである。 最後に、テンプレートの汎用性は、何も特別なことを引き起こさない。 コンポーネントのクライアントは操作の一部を提供するが(この操作は、もし特別版でないなら、 任意の例外を投げるだろう)、我々が良く親しんだ仮想関数や、 単純な関数ポインタを使った操作についても、同じことなのである。&lt;/p&gt;
&lt;p&gt;「例外安全性をもつ汎用コンテナを書くのが不可能であることは、 良く知られている」 この主張は、Tom Cargill による文書、 [^4] に関連してよく聞かれる。そこで彼は、汎用スタックテンプレートに対する例外安全性の問題について探求している。 彼の文書で、 Cargill は多くの役立つ問題を掲げているが、 残念ながらそれらの問題に対する解決法を提供できていない。彼は解決は不可能である、と提案して結論付けている。不幸にも彼の文書は、 多くの人に、そのような空論の 「証拠」 として読まれてしまった。 しかしこの文書が出版されてから、例外安全な汎用コンテナの多くの実例があったのである。 C++ 標準ライブラリコンテナもその中にはいる。&lt;/p&gt;
&lt;p&gt;「例外を扱うとコードは遅くなり、テンプレートは本質的に 可能な限りのパフォーマンスを得るために使われる。」 C++ の優れた実装は、例外が投げられるまでにその例外を扱うひとつの命令サイクルを費やすことはしないで、 例外は関数呼び出しの同じようなスピードで捕捉可能である [^7]。 それだけで、例外を使ったプログラムに、 エラーの可能性を無視したプログラムと同等のパフォーマンスを提供している。 例外を使うと実際は、結果的に別の理由で「伝統的な」エラー捕捉の方法よりも早くなる。 まず、 catch 節はコンパイラに、どのコードがエラー捕捉に費やされるかを明確に示す。 このため、通常の実行パスから分離することが可能であり、参照の局所性が改善する。 次に、「伝統的な」エラー捕捉を使ったコードは典型的に、単一の関数を呼び出した後、いつも返り値を検査しなければならない。 例外を使えば、このオーバヘッドは完全に消える。&lt;/p&gt;
&lt;p&gt;「例外はプログラムの振る舞いを推論することを難しくしてしまう」 通常、この神話が支持されて引用されるのは、 スタック巻き戻しの間に「隠れた」実行パスを通る、という意味においてである。 隠れた実行パスはローカル変数が関数から戻る前に破棄されることを期待している C++ プログラマにとっては、なにも新しいものではない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;ErrorCode &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;( &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; result )         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1 &lt;/span&gt;
{                                  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2 &lt;/span&gt;
    X x;                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3 &lt;/span&gt;
    ErrorCode err &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.g( result ); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4 &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( err &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; kNoError )         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5 &lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; err;                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 6 &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...More code here... &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; kNoError;               &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 7 &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

上の例では、6行目と7行目に &lt;code&gt;X::~X&lt;/code&gt; の「隠れた」呼び出しがある。 そう考えれば、例外を使うことで、エラー捕捉に対して、明白なコードの無駄は存在しない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;()                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1 &lt;/span&gt;
{                       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2 &lt;/span&gt;
    X x;                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3 &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; result &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.g(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4 &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...More code here... &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; result;      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5 &lt;/span&gt;
} 
&lt;/pre&gt;&lt;/div&gt;

例外をより良く知っている多くのプログラマにとって、2番目の例は実際は最初の例よりも、 読みやすく理解しやすい。 「隠れた」コードパスは同じくローカル変数のデストラクタを呼び出している。 更にこれは、冷害が起こった場合にそれぞれの関数呼び出しの後に、 潜在的なリターン文があるかのような、正確に振る舞う単純なパターンに従うのである。 通常の実行パスはエラー捕捉によって分かりにくくならないので、可読性は向上し、 返り値は自然なやり方で使えるように解放されるのである。 例外が正確さを向上することが出来る、さらに重要なやり方がある: それは、 単純なクラス不変性を可能にすることによる。 最初の例では、もし &lt;code&gt;X&lt;/code&gt; のコンストラクタが資源を確保する必要があるなら、 失敗を報告する手だてはない: C++ ではコンストラクタは返り値を持てないからである。 例外を使わない場合は通常、資源を要求するクラスが構築の仕事を完了する、 別の初期化関数を含まなければならない、という結果になる。 プログラマはそのため、クラス &lt;code&gt;X&lt;/code&gt; のオブジェクトが使われるとき、 完全な &lt;code&gt;X&lt;/code&gt; を手にしたのか、それともどこかで構築に失敗したものを手にしたのか、 決して確信をもてない(或いは更に悪いことに、誰かが単に初期化関数を呼び忘れたのかもしれない。)&lt;/p&gt;
&lt;h2&gt;3 例外安全性の契約的原則&lt;/h2&gt;
&lt;p&gt;非汎用的なコンポーネントは例外安全として記述することが出来るが、 汎用的なコンポーネントの場合は、クライアントによる構造化が可能なので、 例外安全性は通常、コンポーネントとクライアントの契約に依存する。 例えば、汎用的コンポーネントの設計者はコンポーネントのデストラクタで使われる演算が、 どんな例外も投げないことを要求するだろう。汎用的コンポーネントはその代わり、次の保証のうちのひとつを提供するだろう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本的保証&lt;/strong&gt; : コンポーネントの不変性は保持され、資源漏れはない。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;強い保証&lt;/strong&gt; : 演算は成功して完了するか、例外を投げるかのどちらかである。 例外を投げる場合、プログラムの状態は演算が始まる前の状態と全く同じである。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例外不送出保証&lt;/strong&gt; : 演算は例外を投げない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基本的保証&lt;/strong&gt; は、全てのコンポーネントに負わせることの出来る、 例外安全性に対する単純で最小限の基準である。 例外の後でもまだコンポーネントは以前のように使うことが出来ると述べているに過ぎない。 重要なことだが、不変性の保持によって、スタック巻き戻しの一部として潜在的に、 コンポーネントを破棄することが出来るのである。 この保証は実際には、見た目ほど役立つものではない。 もしコンポーネントが多くの有効状態を持つなら、例外の後にコンポーネントの状態が、 またはその状態だけが有効な状態なのかどうか知ることは出来ない。 この場合、回復のための選択肢は限られている: コンポーネントの破棄か、 さらに使う前に、ある既知の状態にコンポーネントをリセットするかである。 次の例を考えてみよう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; print_random_sequence() 
{ 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// A vector of 10 items &lt;/span&gt;
    try { 
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Provides only the basic guarantee &lt;/span&gt;
        v.insert( v.begin(), X() ); 
    } 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...) {} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ignore any exceptions above &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// print the vector&#39;s contents &lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v.size() &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;) &#34;&lt;/span&gt;; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;copy( v.begin(), v.end(), 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;( std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; &#34;&lt;/span&gt; ) ); 
} 
&lt;/pre&gt;&lt;/div&gt;

我々はみんな、例外後に v が有効であることを知っているので、 この関数は &lt;code&gt;X&lt;/code&gt; のどんなランダムなシーケンスでも出力することが出来る。これはクラッシュしないと言う意味で「安全」ではあるが、出力の内容は予想できないものである。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;強い保証&lt;/strong&gt; は、「責任を持つか、巻き戻すか」という意味論を完全に提供する。 C++ 標準コンテナの場合、これは例えばもし例外が投げられても全てのイテレータは有効なままであることを意味する。 我々はまた、コンテナが例外が投げられる前と全く同じ要素を持っていることも知っている。 失敗したら、なんの効果も及ぼさない処理は、明らかに利点がある: 例外が発生した場合でも、 プログラムの状態は単純で予測可能なのである。 C++ 標準ライブラリでは、ノードを使うコンテナ、&lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;multiset&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;multimap&lt;/code&gt; のほとんど全ての演算が強い保証を提供している。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例外不送出保証&lt;/strong&gt; は最も強いものであり、演算は例外を投げないことを保証されている、 というものである: これは常に成功して完了する。 この保証はほとんどのデストラクタにとって必要なものであり、 C++ 標準ライブラリコンポーネントのデストラクタは実際にすべて、 例外を投げないことを保証されている。 例外不送出保証、他の理由で重要となることを我々は見るだろう。&lt;/p&gt;
&lt;h2&gt;4 法的論争&lt;/h2&gt;
&lt;p&gt;契約がより複雑になることは避けられない: その代わり整理することが可能である。 C++ 標準ライブラリには、任意の型引数にひとつの保証を与え、 例外を投げないというクライアント型からの約束が追加されれれば、より強い保証を与えているものもある。 例えば、標準コンテナ操作 &lt;code&gt;vector&amp;lt;T&amp;gt;::erase&lt;/code&gt; はどんな &lt;code&gt;T&lt;/code&gt; にも &lt;strong&gt;基本的保証&lt;/strong&gt; を与えるが、コピーコンストラクタとコピー代入演算子が例外を投げないなら、 &lt;strong&gt;例外不送出保証&lt;/strong&gt; を与えている。&lt;/p&gt;
&lt;h2&gt;5 コンポーネントはどのレベルの例外安全性を規定する必要があるか&lt;/h2&gt;
&lt;p&gt;クライアントの観点から、可能な限り最も強いレベルの安全性が理想的である。 もちろん &lt;strong&gt;例外不送出保証&lt;/strong&gt; は多くの演算に対して不可能であるが、 強い保証についてはどうだろうか? 例えば、 &lt;code&gt;vector&amp;lt;T&amp;gt;::insert&lt;/code&gt; に対してちょっとした振る舞いが欲しいと仮定しよう。  &lt;code&gt;vector&lt;/code&gt; の中間への挿入は、新しい要素のための場所を作るために、 挿入点以降の要素を、次の位置にコピーする必要がある。 もし要素のコピーが失敗に終われば、操作の巻き戻しは既に行われたコピーの「取り消し」を必要とする。&lt;/p&gt;
&lt;p&gt;ひとつの可能な選択肢は、新しい配列の内容を、毎回新しいメモリで構築して、 成功したときのみ古い内容を破棄するように &lt;code&gt;insert&lt;/code&gt; を再定義することである。 残念ながら、このアプローチにはコストがかかる: &lt;code&gt;vector&lt;/code&gt; の終端付近での挿入は、 以前ではほとんどコピーを行う必要がなかったが、 このアプローチでは全ての要素をコピーしなければいけない。 &lt;strong&gt;基本的保証&lt;/strong&gt; はこの操作に対する「自然な」水準の安全性である。 パフォーマンスを脅かすことなく保証を与えているのである。 実際ライブラリの全ての演算は、層のような「自然な」水準の安全性を提供している。&lt;/p&gt;
&lt;p&gt;パフォーマンスの要求は基準の草案の中では、確立した部分であり、 パフォーマンスは STL の基本的な目的であるので、 これらの要求の中で提供されうる、より強い安全性を明記する試みは為されなかった。 全てのライブラリが &lt;strong&gt;強い保証&lt;/strong&gt; を与えているわけではないが、 &lt;strong&gt;基本的保証&lt;/strong&gt; を提供する、標準コンテナほとんどの演算は、上に述べた、 「新たなコピーを作る」という戦略を使うことで、強い保証を持つことが出来る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Container&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BasicOp&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; MakeOperationStrong( Container&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; c, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; BasicOp&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; op ) 
{ 
    Container tmp(c); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Copy c &lt;/span&gt;
    op(tmp); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Work on the copy &lt;/span&gt;
    c.swap(tmp); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Cannot fail&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

この技は、より強い保証を提供する(そして異なるパフォーマンス特性を提供する)、 似たようなコンテナを作るためのラッパクラスに導入することが出来る。&lt;/p&gt;
&lt;h2&gt;6 私たちは、私たちが得ることができる全てを得るべきか&lt;/h2&gt;
&lt;p&gt;特殊な実装を考えれば、安全性についての自然な水準を判断することを望めるだろう。 コンポーネントに対する要求を確立するのにこれを使うことで、 実装が制限されるという危険性が生じる。 我々が使いたくなるような、より効率的な実装を誰かが作り上げても、 それが我々の持つ例外安全性への要求を満たしていないことに気づくかもしれない。 STL が扱っているデータ構造とアルゴリズムという、よく研究された領域では、 このようなことに誰も期待を寄せないかもしれないが、 それでも実際、より優れたものが作られている。最近の &lt;strong&gt;introsort&lt;/strong&gt; アルゴリズムは、その良い例である [^6]。 これは、既に確立した &lt;strong&gt;quicksort&lt;/strong&gt; に対して、最悪の計算量を必要とするような場合での、 大幅な改善を示している。 実際に標準コンポーネントの要求がどの程度のものなのかを決定するために、 実世界の典型的な場合を考えた。 選ばれたテストケースは 「合成コンテナ」である。 2つ以上の標準コンテナの合成である、そのコンテナは広く必要とされているだけでなく、 巨大なシステムで不変性を維持することについての単純で代表的な事例である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// SearchableStack - A stack which can be efficiently searched &lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// for any value. &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SearchableStack&lt;/span&gt; 
{ 
 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; 
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; push(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;pop&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; contains(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; top() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(1) &lt;/span&gt;
 &lt;span style=&#34;color: #A0A000&#34;&gt;private:&lt;/span&gt; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; set_impl; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; list_impl; 
}; 
&lt;/pre&gt;&lt;/div&gt;

ここでは、&lt;code&gt;list&lt;/code&gt; は &lt;code&gt;set&lt;/code&gt; のイテレータのスタックとして振る舞う: 全ての要素は最初に &lt;code&gt;set&lt;/code&gt; に入り、その結果その位置が &lt;code&gt;list&lt;/code&gt; に入れられる。 不変性というのは、簡単なことである: &lt;code&gt;set&lt;/code&gt; と &lt;code&gt;list&lt;/code&gt; は常に、 同じ要素数を持ち、&lt;code&gt;set&lt;/code&gt; 全ての要素は &lt;code&gt;list&lt;/code&gt; の要素により参照されている、ということである。 以下の &lt;code&gt;push&lt;/code&gt; 関数の実装は、 &lt;code&gt;set&lt;/code&gt; と &lt;code&gt;list&lt;/code&gt; によって提供される自然な水準の例外安全性で、 &lt;strong&gt;強い保証&lt;/strong&gt; を提供するために設計されたものである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;                                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; SearchableStack&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;push(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t)         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2&lt;/span&gt;
{                                                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3&lt;/span&gt;
    set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; set_impl.insert(t);      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4&lt;/span&gt;
    try                                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5&lt;/span&gt;
    {                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 6&lt;/span&gt;
        list_impl.push_back(i);                   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 7&lt;/span&gt;
    }                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 8&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...)                                    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 9&lt;/span&gt;
    {                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 10&lt;/span&gt;
        set_impl.erase(i);                        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 11&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;throw&lt;/span&gt;;                                    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 12&lt;/span&gt;
    }                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 13&lt;/span&gt;
}                                                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

このコードは実際に、ライブラリの何を要求するだろうか? 非 &lt;code&gt;const&lt;/code&gt; 演算が行われる行を調べてみる必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4行目: 挿入が失敗したが、 &lt;code&gt;set_impl&lt;/code&gt;がその過程で変更されている場合、 不変性は保たれない。そこで、&lt;code&gt;set&amp;lt;T&amp;gt;::insert&lt;/code&gt; からの &lt;strong&gt;強い保証&lt;/strong&gt; に頼ることが出来なければならない。&lt;/li&gt;
&lt;li&gt;7行目: 同様に &lt;code&gt;push_back&lt;/code&gt; が失敗して &lt;code&gt;list_impl&lt;/code&gt; がその過程で変更されているなら、不変性は保たれない。 そこで、&lt;code&gt;list&amp;lt;T&amp;gt;::insert&lt;/code&gt; からの &lt;strong&gt;強い保証&lt;/strong&gt; に頼ることが出来なければならない。&lt;/li&gt;
&lt;li&gt;11行目: ここで4行目の挿入を「巻き戻し」ている。もしこの操作が失敗すれば、 不変性を回復することは出来ないだろう。結局 &lt;code&gt;set&amp;lt;T&amp;gt;::erase&lt;/code&gt; からの &lt;strong&gt;例外不送出保証&lt;/strong&gt; に頼ることになる。&lt;/li&gt;
&lt;li&gt;11行目: 同じ理由で、 &lt;code&gt;i&lt;/code&gt; を &lt;code&gt;erase&lt;/code&gt; 関数に渡すことが出来るということにも、 頼らなければならない: &lt;code&gt;set&amp;lt;T&amp;gt;::iterator&lt;/code&gt; からの、 &lt;strong&gt;例外不送出保証&lt;/strong&gt; に頼る必要があるのである。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は標準化の際にこの方法で問題を扱うことで、多くを学んだ。 まず、合成コンテナに対して明示された保証は、実際はそのコンポーネントからのより強い保証 (11行目の &lt;strong&gt;例外不送出保証&lt;/strong&gt; )に依存するということである。 また、この単純な例を実装するために、自然な水準の例外安全性を全ての面で利用した。 そして、この分析は、以前私が、演算をそれぞれ独立したものと考えていたときには見逃していた、 イテレータへの要求を明らかにした。 結論は、可能な限り自然な水準の例外安全性を提供すべきだ、ということである。 より速く、しかしより安全ではない実装は常に、標準コンポーネントの拡張として提供されるべきである。&lt;/p&gt;
&lt;h2&gt;7 例外安全性の自動テスト&lt;/h2&gt;
&lt;p&gt;標準化の過程の一部として、私は STL での例外安全な参照の実装を作った。 エラー捕捉コードは実際にかなり厳密にテストされたが、 エラー状態を起こすことが難しいので、そのテストは部分的である。 初めて実行されたときにクラッシュしたエラー捕捉コードを考えるというのは、 とても一般的である-出荷される製品では。実装が実際に宣伝通りに動くという確信を強めるために、 私は自動化されたテストスイートを設計した。これは同僚の Matt Arnold の精緻な技術に基づいている。&lt;/p&gt;
&lt;p&gt;テストプログラムは基本的なところから始まった: 特にグローバル演算子 &lt;code&gt;new&lt;/code&gt; と&lt;code&gt;delete&lt;/code&gt;についての強化と計測である。 出来る限り多くの潜在的な問題を明らかにするために選ばれた型引数で、 コンポーネント(コンテナとアルゴリズム)の実体が作られた。 例えば、全ての型引数にはヒープ領域にメモリを割り当てられるポインタが与えられた。 そのため、コンテナに格納されたオブジェクトをリークさせることは、 メモリリークとして検出された。&lt;/p&gt;
&lt;p&gt;最後に、ポインタが間違って示す可能性のある場合に、その都度、 演算に例外を投げさせることが出来るような仕組みを設計した。 クライアントが提供し、例外を投げることが許されている全ての演算の最初に、 &lt;code&gt;ThisCanThrow&lt;/code&gt; の呼び出しが加えられた。 &lt;code&gt;ThisCanThrow&lt;/code&gt; の呼び出しはまた、 テストされる汎用的演算が例外を投げるかもしれない全ての場所にも加えられた。 例えば、より機能を強化したものに置き換えられた、グローバル演算子 &lt;code&gt;new&lt;/code&gt; である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Use this as a type parameter, e.g. vector&amp;lt;TestClass&amp;gt; &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; TestClass 
{ 
    TestClass( &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; ) 
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; p( ThisCanThrow(), &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;( v ) ) {} 
    TestClass( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; p( ThisCanThrow(), &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;( &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p ) ) {} 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        { ThisCanThrow(); &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p; } 
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt;( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        { ThisCanThrow(); &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p; } 
    ...etc... 
    &lt;span style=&#34;color: #666666&#34;&gt;~&lt;/span&gt;TestClass() { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;delete&lt;/span&gt; p; } 
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThisCanThrow&lt;/code&gt; は単に、「throw カウンタ」をデクリメントするだけであり、 もしそれが &lt;code&gt;0&lt;/code&gt; になったら、例外を投げる。 テスト毎に、外側のループで、徐々に大きな値にカウンターを設定して開始し、 演算のテストが完了するまで繰り返し試す、という形を取った。 結果は、失敗する可能性がある実行パスに沿って、連続的なステップで、オペレーションが例外を投げた。 例えば、 &lt;strong&gt;強い保証&lt;/strong&gt; をテストするのに使われた関数の単純なバージョンがある:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; gThrowCounter; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// The throw counter&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;ThisCanThrow&lt;/span&gt;() 
{ 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (gThrowCounter&lt;span style=&#34;color: #666666&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) 
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; 
} 

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Operation&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; StrongCheck(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; op) 
{ 
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; succeeded &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;false&lt;/span&gt;; 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;long&lt;/span&gt; nextThrowCount &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;succeeded; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;nextThrowCount) 
    { 
        Value duplicate &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; v; 
        try 
        { 
            gThrowCounter &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; nextThrowCount; 
            op( duplicate ); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Try the operation &lt;/span&gt;
            succeeded &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; 
        } 
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Catch all exceptions &lt;/span&gt;
        { 
            &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; unchanged &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; duplicate &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; v; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Test strong guarantee &lt;/span&gt;
            assert( unchanged ); 
        } 
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Specialize as desired for each container type, to check &lt;/span&gt;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// integrity. For example, size() == distance(begin(),end()) &lt;/span&gt;
        CheckInvariant(v); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Check any invariant &lt;/span&gt;
    } 
}
&lt;/pre&gt;&lt;/div&gt;

注意すべきは、この種のテストは非汎用的なコンポーネントより、汎用的なものの方が 遙かに簡単で、煩わしさのないものである、ということである。 これは、テストに特化した型引数を、 テストされるコンポーネントのソースコードを変更することなく使うことが出来るからである。 また上の &lt;code&gt;StrongCheck&lt;/code&gt; のような汎用関数が広範な値と演算のテストを行うのに役立つ。&lt;/p&gt;
&lt;h2&gt;8 さらにくわしく知るための資料&lt;/h2&gt;
&lt;p&gt;私が知る限り、現在 STL の利用可能な例外安全性には2種類の記述しかない。 STL の例外安全の実装のリファレンスでの、オリジナルの仕様 [^2] は、非公式な仕様であり、単純で自明(そして冗長)である。 そこでは、この文書で概説してきた、基本的と強い保証の区別が使われている。 それは明らかに、資源漏れを禁止していて、最終的な C++ 標準と比べ、多くの面で同じなのだが、 保証という点では実質的に異なる。 私はこの文書の改訂版が速やかに作られることを望んでいる。 C++ 標準での例外安全性の記述[^1] はほんの少しだけ公式なものであるが、読みにくい「規格化」 で構成されていて、ウェブ上ではほとんど見ることが出来ない。とくに、資源漏れについては直接は全く扱われていない。 それが規格であるという利点を持っているに過ぎない。&lt;/p&gt;
&lt;p&gt;例外安全の実装[^5] に関するオリジナルのリファレンスは、SGI STL の古いバージョンである。 これは限られた能力の C++ コンパイラのために設計された。 これは完全な STL の実装ではないが、コードは読みやすいし、 役立つ基底クラスのテクニックを、コンストラクタでの例外捕捉をなくすために説明している。 参照の実装を検証するために使われた完全なテストスイート&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/document/実践としては、この関数はあまりにも貧弱なランダムシーケンス製作器である!&#34;&gt;^3&lt;/a&gt; は、引き続き SGI STL の最近のバージョン全てで使われている。 そして他のベンダの実装をテスト(通らなかった)するのにも使われている。 文書で注記されているように、それは隠れたコンパイラのバグを明らかにするのに、特に最適化と例外捕捉コードが相互作用するような場所では、強力であるだろう。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;International Standard ISO/IEC 14882, Information Technology-Programming Languages-C++, Document Number ISO/IEC 14882-1998, available from &lt;a href=&#34;http://webstore.ansi.org/ansidocstore/default.asp&#34; target=&#34;_blank&#34;&gt;http://webstore.ansi.org/ansidocstore/default.asp&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. Abrahams, Exception Safety in STLport, available at &lt;a href=&#34;http://www.stlport.org/doc/exception_safety.html&#34; target=&#34;_blank&#34;&gt;http://www.stlport.org/doc/exception_safety.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. Abrahams and B. Fomitchev, Exception Handling Test Suite, available at &lt;a href=&#34;http://www.stlport.org/doc/eh_testsuite.html&#34; target=&#34;_blank&#34;&gt;http://www.stlport.org/doc/eh_testsuite.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Tom Cargill, &#34;Exception Handling: A False Sense of Security,&#34; C++ Report, Nov-Dec 1994, also available at &lt;a href=&#34;http://www.awl.com/cp/mec++-cargill.html&#34; target=&#34;_blank&#34;&gt;http://www.awl.com/cp/mec++-cargill.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;B. Fomitchev, Adapted SGI STL Version 1.0, with exception handling code by D. Abrahams, available at &lt;a href=&#34;http://www.metabyte.com/~fbp/stl/old.html&#34; target=&#34;_blank&#34;&gt;http://www.metabyte.com/~fbp/stl/old.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. R. Musser, &#34;Introspective Sorting and Selection Algorithms,&#34; Software-Practice and Experience 27(8):983-993, 1997.&lt;/li&gt;
&lt;li&gt;Bjarne Stroustrup, The Design And Evolution of C++. Addison Wesley, Reading, MA, 1995, ISBN 0-201-54330-3, Section 16.9.1.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;脚注&lt;/h2&gt;
&lt;p&gt;[^1]: おそらく Cargill の場合、解決に対する最も大きな障害は、 彼が、不幸な組み合わせの選択をしてしまったということであった: 彼がコンテナのために選んだインタフェースは、彼が要求する安全性の特徴と一致しないものだったのだ。 どちらかを変更すれば、彼は問題を解決できただろう。&lt;/p&gt;
&lt;p&gt;[^2]: C++ でデストラクタから例外が投げられることは通常進められない。 デストラクタは、それ自身他の例外によって引き起こされるスタック巻き戻しの途中で呼び出されるかもしれないからである。 2番目の例外がデストラクタを越えて伝えられることが可能なら、 問題はすぐに解決する。&lt;/p&gt;
&lt;p&gt;[^4]: 変更操作を行うアルゴリズムが通常、 &lt;strong&gt;強い保証&lt;/strong&gt; を提供できないことは、 注目に値する: ある範囲の変更された要素を巻き戻すために、 例外を投げるかもしれない &lt;code&gt;operator=&lt;/code&gt; を使って、以前の状態に戻さなければならないのである。 C++ 標準ライブラリでは、この規則はほとんど守られていて、 巻き戻しの振る舞いは破棄だけで成立している: 例外は、&lt;code&gt;uninitialized_copy&lt;/code&gt;, &lt;code&gt;uninitialized_fill&lt;/code&gt;, &lt;code&gt;uninitialized_fill_n&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;[^5]: C++ 標準ライブラリのクライアントが提供する全ての型引数は、 デストラクタが例外を投げないことを要求される。 その代わりに、 C++ 標準ライブラリの全てのコンポーネントは少なくとも &lt;strong&gt;基本的保証&lt;/strong&gt; を提供するのである。&lt;/p&gt;
&lt;p&gt;[^6]: 変更操作を行う多くのアルゴリズムに対して C++ 規格では 似たような整理が為されている。しかし規格化の過程で時間の制約は全く考えられていない。&lt;/p&gt;
&lt;p&gt;[^7]: 要素の &lt;code&gt;Compare&lt;/code&gt; がコピー時に例外を投げるかもしれないような連想コンテナは、この技を使っていない。 スワップ関数が失敗するかもしれないからである。&lt;/p&gt;
&lt;p&gt;[^8]: これは、たびたび望まれ、しかしまだ見知らぬ &lt;code&gt;container_traits&amp;lt;&amp;gt;&lt;/code&gt; テンプレートのもう一つの潜在的な利用を示している。 例外安全性の制約を満たす、コンテナの自動選択である。&lt;/p&gt;
&lt;p&gt;[^9]: &lt;code&gt;set&amp;lt;T&amp;gt;&lt;/code&gt; に対する要求を減らし、 例外時の問題を減らすために、 &lt;code&gt;erase&lt;/code&gt; を &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; ブロックに入れようとするかもしれない。 しかし結局、問題なのである。 まず、&lt;code&gt;erase&lt;/code&gt; は失敗し、この場合必要な結果を産み出すための実行可能な代替案は存在しない。 また、より一般には、型引数が多様なので、汎用コンポーネントにたいして、 どんな選択肢も成功する保証はめったになされるものではない。&lt;/p&gt;
&lt;p&gt;[^10]: STL の設計の有力な哲学は、全ての利用にとって基本的でない機能は、その機能が必要なときに、基本のコンポーネントを適応することで得られる限り、 効率を求めないでいく、ということである。 これはそのような哲学に端を発しているが、 &lt;strong&gt;基本的保証&lt;/strong&gt; でさえ、 既にその保証を持っていない基本のコンポーネントを適応して、そのような保証を得ることは難しいか、不可能である。&lt;/p&gt;
&lt;p&gt;[^11]: メモリシステムをどのようにして守るかについての素晴らしい議論が、 次のものに書かれている: Steve Maguire, Writing Solid Code, Microsoft Press, Redmond, WA, 1993, ISBN 1-55615- 551-4.&lt;/p&gt;
&lt;p&gt;[^12]: この技は、テストされる操作が例外中立であることを必要とすることに注意すること。 もし操作が例外から回復して、処理を続けようとするなら、&lt;code&gt;throw&lt;/code&gt; カウンタは負の値になるだろう。 そしてその後の失敗するかもしれない操作は、例外安全性に対してテストされない。&lt;/p&gt;
&lt;p&gt;[^13]: 例外安全性を導入した規格草案に対する変更は、 変更される単語の数が多いという理由だけで修正が拒否されるような、 草案作成の過程のかなり遅い時期に為された。 不幸にも、この結果、簡潔さを求める余り、ある程度妥協したものとなった。 Greg Colvin はこれらの変更の範囲を最小化するために必要な、 賢い言語-法実務についての責任がある。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>The Boost Format library -- Boost.Format : Examplesまで移植</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/format/format.html"/>
      <id>230486187b9792b352bfa4231828c861c0075611:archive/boost_docs/libs/format/format.md</id>
      <updated>2014-11-26 17:37:22 +0900</updated>
      
        <content type="html">&lt;h1&gt;The Boost Format library&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;boost/format.hpp&amp;gt;&lt;/code&gt; &lt;code&gt;format&lt;/code&gt;クラスは &lt;code&gt;printf&lt;/code&gt; に似た、ユーザ定義型も扱える型安全な書式化処理を提供する。 &lt;/p&gt;
&lt;p&gt;(このライブラリは他の &lt;code&gt;boost&lt;/code&gt; ライブラリに依存しない)&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#hot-it-works&#34;&gt;How it works&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Syntax&lt;ul&gt;
&lt;li&gt;printf format-specification syntax&lt;/li&gt;
&lt;li&gt;Incompatibilities with printf&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Manipulators and the internal stream state&lt;/li&gt;
&lt;li&gt;User-defined types&lt;/li&gt;
&lt;li&gt;Exceptions&lt;/li&gt;
&lt;li&gt;Alternatives&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/synopsis&#34; name=&#34;synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;format&lt;/code&gt; オブジェクトは書式文字列から構築され、その後 &lt;code&gt;operator%&lt;/code&gt; を繰り返し呼び出されることで引数を与えられる。 &lt;/p&gt;
&lt;p&gt;それぞれの引数は文字列に変換され、書式文字列に従って順に一つの文字列へと結合される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;writing %1%,  x=%2% : %3%-th try&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;toto&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;40.23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; 
     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#34;writing toto,  x=40.230 : 50-th try&#34;と表示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/hot-it-works&#34; name=&#34;hot-it-works&#34;&gt;How it works&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1.書式文字列 &lt;code&gt;s&lt;/code&gt; を伴って &lt;code&gt;format(s)&lt;/code&gt; を呼び出すと、あるオブジェクトが構築される。このオブジェクトは、書式文字列を構文解析してすべての命令を探し、次のステップのために内部構造を準備する。
2.そして、すぐに&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt; )
&lt;/pre&gt;&lt;/div&gt;

のようにするか、あるいは後で、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;);
fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt;; fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

とすることで、フォーマッタに変数を食わせることができる。 &lt;/p&gt;
&lt;p&gt;変数は内部のストリームにダンプされる。ストリームの状態は、与えられた書式文字列の書式化オプション(あれば)によってセットされる。 &lt;code&gt;format&lt;/code&gt; オブジェクトは最後のステップのための結果文字列を保持する。&lt;/p&gt;
&lt;p&gt;3.すべての引数を与えてしまえば、その &lt;code&gt;format&lt;/code&gt; オブジェクトをストリームにダンプしたり、メンバ関数 &lt;code&gt;str()&lt;/code&gt; か名前空間 &lt;code&gt;boost::io&lt;/code&gt; にある &lt;code&gt;str(const format&amp;amp;)&lt;/code&gt; 関数で文字列を取り出すことができる。結果の文字列は、別の引数が与えられて再初期化されるまで、 &lt;code&gt;format&lt;/code&gt; オブジェクトの中にアクセス可能な状態で残る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 先ほど作って引数を与えた fmter の結果を表示:&lt;/span&gt;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter ;  

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 結果の文字列を取り出せる:&lt;/span&gt;
string s  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fmter.str();

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 何度でも:&lt;/span&gt;
s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fmter.str( );

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// すべてのステップを一度に行うこともできる:&lt;/span&gt;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt;; 
string s2 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;str( format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%2% %1%&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;36&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;77&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;

4.ステップ３の後で &lt;code&gt;format&lt;/code&gt; オブジェクトを再利用し、ステップ２からやり直すこともできる: &lt;code&gt;fmter % 18 % 39;&lt;/code&gt;
新しい変数を同じ書式文字列で書式化する際は、こうすることでステップ１で生じる高価な処理を節約できる。&lt;/p&gt;
&lt;p&gt;結局のところ、 &lt;code&gt;format&lt;/code&gt; クラスは、書式文字列(&lt;code&gt;printf&lt;/code&gt; に似た命令を用いる)を内部のストリームへの操作に翻訳する。そして最終的に、その書式化の結果を文字列として、あるいは直接に出力ストリームへと返す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/examples&#34; name=&#34;examples&#34;&gt;Examples&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;format;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;group;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;io&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;str;
&lt;/pre&gt;&lt;/div&gt;

- 並べ替えありの単純な出力:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1% %2% %3% %2% %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;11&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;22&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;333&#34;&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &#39;単純な&#39;形式。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

表示はこうなる : &lt;code&gt;&#34;11 22 333 22 11 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POSIX 版 &lt;code&gt;printf&lt;/code&gt; の位置指定命令を用いた、より精細な書式化:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%1$+5d,%2$+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// POSIX版Printf形式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

表示はこうなる : &lt;code&gt;&#34;(x,y) = ( -23, +35) \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;並べ替えのない、古典的な &lt;code&gt;printf&lt;/code&gt; の命令:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;writing %s,  x=%s : %d-th step &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;toto&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;40.23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;50&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;

表示はこうなる : &lt;code&gt;&#34;writing toto, x=40.23 : 50-th step \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同じことを表現するにもいろいろな方法がある:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%+5d,%+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%|+5|,%|+5|) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;

cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%1$+5d,%2$+5d) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(x,y) = (%|1$+5|,%|2$+5|) &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;-23&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;35&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

表示はどれも : &lt;code&gt;&#34;(x,y) = ( -23, +35) \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;マニピュレータによる書式文字列の修飾:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1$+5d_ %1$d &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;);

format &lt;span style=&#34;color: #0000FF&#34;&gt;fmter2&lt;/span&gt;(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1%_ %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;);
fmter2.modify_item(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, group(showpos, setw(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;)) ); 

cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt; ;
cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; fmter2 &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt; ;
&lt;/pre&gt;&lt;/div&gt;

どちらも同じように表示する : &lt;code&gt;&#34;_ +101_ 101 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引数を伴うマニピュレータ:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;_%1%_ %1% &lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; group(showpos, setw(&lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;), &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

マニピュレータは、 &lt;code&gt;%1%&lt;/code&gt; が現れるたびに適用されるので、出力はこうなる : &lt;code&gt;&#34;_ +101_ +101 \n&#34;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しいフォーマット機能「絶対桁送り(absolute tabulations)」はループの中で使うと便利である。これはあるフィールドを各行の同じ位置に出力する機能で、たとえ直前の引数の幅が大きく変化したとしても、同じ位置に出力することを保証してくれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color: #666666&#34;&gt;=0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; names.size(); &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
    cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; format(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;%1%, %2%, %|40t|%3%&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; names[i] &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; surname[i] &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; tel[i];
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;names&lt;/code&gt; 、 &lt;code&gt;surnames&lt;/code&gt; 、そして &lt;code&gt;tel&lt;/code&gt; などのベクタ(sample_new_features.cpp を参照)は次のように表示される :&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;Marc-Françis Michel, Durand,           +33 (0) 123 456 789
Jean, de Lattre de Tassigny,           +33 (0) 987 654 321
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>各ライブラリの翻訳ドキュメント -- Boost.Format : ドキュメントのトップページを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs.html"/>
      <id>90a124cd2f90e94591e51293e702854787a1b170:archive/boost_docs/libs.md</id>
      <updated>2014-11-25 19:01:30 +0900</updated>
      
        <content type="html">&lt;h1&gt;各ライブラリの翻訳ドキュメント&lt;/h1&gt;
&lt;p&gt;ここでは、Boost 1.31.0時点での各ライブラリの翻訳ドキュメントを掲載する。&lt;/p&gt;
&lt;p&gt;最新バージョンへの追従は行っていないことに注意されたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/array.html&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL に準拠した定数サイズの配列のラッパコンテナ。Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bind&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html&#34;&gt;mem_fn&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;関数、オブジェクト、ポインタ、メンバ関数のための汎用的なバインダ。 Peter Dimov 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compatibility.html&#34;&gt;compatibility&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;標準に準拠しないプラットフォームでのライブラリの利用に役立つ。Ralf Grosse-Kunstleve and Jens Maurer 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;compose&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;STL の為の関数合成アダプタ Nicolai Josuttis 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;concept_check&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ジェネリックプログラミングのためのツール群。 Jeremy Siek 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/conversion.html&#34;&gt;conversion&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数学的、多相的、辞書的キャスト Dave Abrahams and Kevlin Henney 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;date_time&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;日付/時間ライブラリ Jeff Garland 作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html&#34;&gt;disjoint_sets&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;互いに素な集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format.html&#34;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;型安全な printf 風の書式化操作。Samuel Krempp 作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost Format library -- Boost.Format : ドキュメントのトップページを追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/format.html"/>
      <id>90a124cd2f90e94591e51293e702854787a1b170:archive/boost_docs/libs/format.md</id>
      <updated>2014-11-25 19:01:30 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost Format library&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/format/&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/format/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;format ライブラリは、書式文字列に従って引数を書式化するクラスを提供する。これは &lt;code&gt;printf&lt;/code&gt; と同様に動作するが、二つの大きな違いがある： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;format は引数を内部のストリームに送る。そのため完全に型安全であり、また自ずとあらゆるユーザ定義型をサポートする。&lt;/li&gt;
&lt;li&gt;強く型付けされた format の文脈では省略記号 (&lt;code&gt;...&lt;/code&gt;) を正しく使うことができない。そのため、任意の個数の引数を伴う関数呼び出しは、引数を食わせる &lt;code&gt;operator%&lt;/code&gt; を繰り返し呼び出すことに置き換えられた。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;詳細は以下を参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/format/format.html&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Headers&lt;ul&gt;
&lt;li&gt;format.hpp : ユーザフロントエンド。&lt;/li&gt;
&lt;li&gt;format_fwd.hpp : ユーザ先行宣言。&lt;/li&gt;
&lt;li&gt;format_class.hpp : クラスインターフェイス&lt;/li&gt;
&lt;li&gt;format_implementation.hpp: メンバ関数の実装&lt;/li&gt;
&lt;li&gt;feed_args.hpp : 引数フィーディング補助関数&lt;/li&gt;
&lt;li&gt;free_funcs.hpp : 自由関数定義&lt;/li&gt;
&lt;li&gt;parsing.hpp : 書式文字列パージングのコード&lt;/li&gt;
&lt;li&gt;group.hpp : グループ引数およびマニピュレータのための補助的な構造体&lt;/li&gt;
&lt;li&gt;exceptions.hpp : ライブラリで使用する例外&lt;/li&gt;
&lt;li&gt;internals.hpp : 補助的な構造体stream_format_stateおよびformat_item&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テストプログラム example ディレクトリ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このライブラリは &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/samuel_krempp.htm&#34; target=&#34;_blank&#34;&gt;Samuel Krempp&lt;/a&gt; により提供された。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプトの充当化と原型 -- cpprefjpへのリンクをGoogle SitesからGitHub Pagesに置き換え。 置き換えのスクリプト： https://gist.github.com/faithandbrave/0b908961dc9d88afde4b</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html"/>
      <id>3a89b275d4469da213c4e9eae2fa1c9a2881b129:archive/boost_docs/libs/concept_check/concept_covering.md</id>
      <updated>2014-11-21 17:40:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンセプトの充当化と原型&lt;/h1&gt;
&lt;p&gt;これまで、コンポーネントへの入力に対して、最小限の要求事項(コンセプト)を選択することの重要性を議論してきた。 しかし、選択したコンセプトが対象のアルゴリズムを「充当 &#34;cover&#34;」していることを確認するのも、同様に重要である。 すなわち、発生する可能性のあるユーザ・エラーは全てコンセプト・チェックによって漏れなく捕らえられるべきである。 コンセプト充当性は、「原型クラス &#34;archetype class&#34;」を使用することで確認可能だ。 原型クラスとは、特定のコンセプトに関連するインタフェースの正確な実装である。 原型クラスの実行時の振舞いに重要性はなく、そのメンバ関数本体は空文のままでかまわない。 そうすれば、コンポーネントへの入力として原型クラスを与えてコンパイルするだけで、簡単なテスト・プログラムが作成できる。 そのプログラムがコンパイル可能であれば、対応するコンセプトがそのコンポーネントを充当していることが確認できたことになる。&lt;/p&gt;
&lt;p&gt;以下のコードは、&lt;a href=&#34;http://www.sgi.com/tech/stl/trivial.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;TrivialIterator&lt;/code&gt;&lt;/a&gt; コンセプトに対する原型クラスである。 原型が対応するコンセプトと正確に一致していることを保証するために、いくつかの点で注意しなければならないことがある。 例えば、コンセプトは &lt;code&gt;operator*()&lt;/code&gt; の戻り値型が値型に変換可能でなければならない。 だからといって、これはその戻り値型として、より厳格に &lt;code&gt;T&amp;amp;&lt;/code&gt; あるいは &lt;code&gt;const T&amp;amp;&lt;/code&gt; を要求している訳ではない。 それは、原型クラスの戻り値型として &lt;code&gt;T&amp;amp;&lt;/code&gt; あるいは &lt;code&gt;const T&amp;amp;&lt;/code&gt; を使用することが、誤りとなることを意味する。 正しいアプローチは、&lt;code&gt;T&lt;/code&gt; 型に変換可能なユーザー定義の戻り値型を作成することで、この例では &lt;code&gt;input_proxy&lt;/code&gt; として処理している。 原型クラスを用いたテストの妥当性は、完全にコンセプトとの正確な一致に依存しており、それを確認するためには慎重な（人手による）検査を必要とする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; input_proxy {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;() {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; static_object&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;get(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get a reference without constructing&lt;/span&gt;
  }
};
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;trivial_iterator_archetype&lt;/span&gt;
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; trivial_iterator_archetype self;
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  trivial_iterator_archetype() { }
  trivial_iterator_archetype(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { }
  self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; }
  input_proxy&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;() { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; input_proxy&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); }
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; std {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; trivial_iterator_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; T value_type;
  };
}
&lt;/pre&gt;&lt;/div&gt;

ジェネリック・アルゴリズムのテストとして、一般的な複数の入力型に対してインスタンスの生成を行う場合が往々にしてある。 一例として、&lt;code&gt;std::stable_sort()&lt;/code&gt; に対して、イテレータとして組み込みのポインタ型を適用することが考えられる。 これは、アルゴリズムの実行時の振る舞いをテストするには適切であるが、コンセプト充当性の保証には有用ではない。 なぜなら、C++ の組み込み型は特定のコンセプトとー致を見ることは決してなく、たいていの場合、それが提供する機能は何らかのコンセプトが単独で必要とする最小のそれを上回っている。 すなわち、たとえ与えられた型で関数テンプレートがコンパイルできたとしても、そのコンセプトの要求事項は、その関数を充当する実際の要求事項に及ばないことがありうる。 それ故に、一般的な入力型でテストすることに加えて、原型クラスでコンパイルすることは重要である。&lt;/p&gt;
&lt;p&gt;以下は、記載されている &lt;a href=&#34;http://cpprefjp.github.io/reference/algorithm/stable_sort.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::stable_sort()&lt;/code&gt;&lt;/a&gt; の要求事項をチェックするために原型を使用する方法を示す、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/stl_concept_covering.cpp.html&#34;&gt;stl_concept_covering.cpp&lt;/a&gt; からの抜粋である。 この場合、&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;CopyConstructible&lt;/code&gt;（コピー・コンストラクト可能）&lt;/a&gt; と &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/Assignable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Assignable&lt;/code&gt;（割り当て可能）&lt;/a&gt; 要求事項が、SGI STL 文書から無視されているように見える (試しに、その原型を削除してみるとよい) 。 Boost の原型クラスは、階層構造が取れるように設計されている。 この例において、イテレータの値型は３つの原型から構成される。 下記で参照されている原型クラスでは、&lt;code&gt;Base&lt;/code&gt; という名前のテンプレート・パラメータが、階層化された原型を使用可能であることを示している。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; less_than_comparable_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; 
      sgi_assignable_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ValueType;
  random_access_iterator_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ValueType&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ri;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;stable_sort(ri, ri);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;次へ：「コンセプトを用いたプログラミング」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;前へ：「コンセプト・チェック用クラスの作成」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンパイラ間の差を吸収する -- cpprefjpへのリンクをGoogle SitesからGitHub Pagesに置き換え。 置き換えのスクリプト： https://gist.github.com/faithandbrave/0b908961dc9d88afde4b</title>
      <link href="http://boostjp.github.io/tips/config.html"/>
      <id>3a89b275d4469da213c4e9eae2fa1c9a2881b129:tips/config.md</id>
      <updated>2014-11-21 17:40:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンパイラ間の差を吸収する&lt;/h1&gt;
&lt;p&gt;ここでは、コンパイラ間の差を吸収するための方法を挙げる。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/support-cpp11&#34;&gt;コンパイラが、あるC++11の機能をサポートしているかどうかでコードを変更する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#deduced-typename&#34;&gt;コンパイラによって、テンプレート中の &lt;code&gt;hoge&amp;lt;T&amp;gt;::type x;&lt;/code&gt; や &lt;code&gt;fuga.f();&lt;/code&gt; がコンパイルエラーになったりならなかったりする問題を回避する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#nested-template&#34;&gt;メンバ関数テンプレートの呼び出しでコンパイルエラーになる問題を回避する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/support-cpp11&#34; name=&#34;support-cpp11&#34;&gt;コンパイラが、あるC++11の機能をサポートしているかどうかでコードを変更する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下は可変長テンプレート引数をサポートしているコンパイラならそれを使い、そうでなければ Boost.Preprocessor などでエミュレートする例&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/config.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#if defined BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/repetition/enum_params.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/repetition/enum_binary_params.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/facilities/intercept.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 他色々&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  if !defined MAX_PARAM_LIMIT&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#    define MAX_PARAM_LIMIT 10&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  endif&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#endif&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#if !defined BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ...T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T ...x) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// fの定義&lt;/span&gt;
}

&lt;span style=&#34;color: #BC7A00&#34;&gt;#else&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// fの定義（長くなるので省略）&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;boost/config.hpp&lt;/code&gt; をインクルードすると、コンパイラやバージョンに応じて &lt;code&gt;BOOST_NO_&lt;/code&gt;&lt;em&gt;FEATURE_NAME&lt;/em&gt; が定義される。定義されているマクロ名に対応した機能は、そのコンパイラでは使えない。&lt;/p&gt;
&lt;p&gt;以下はそのマクロ一覧である。C++11の新機能については各々で調べたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;マクロ名&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ALIGNAS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の&lt;code&gt;alignas&lt;/code&gt;キーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ALLOCATOR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11バージョンの&lt;code&gt;std::allocator&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ATOMIC_SP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11のスマートポインタがアトミック操作をサポートしているか&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_ARRAY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/array.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CHRONO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/chrono.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CODECVT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/codecvt.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CONDITION_VARIABLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/condition_variable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;condition_variable&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FORWARD_LIST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/forward_list.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FUNCTIONAL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11バージョンと互換のある&lt;a href=&#34;http://cpprefjp.github.io/reference/functional.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FUTURE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/future.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;future&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_INITIALIZER_LIST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/initializer_list.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;initializer_list&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ。 変数の初期化を &lt;code&gt;{1, 2, 3}&lt;/code&gt; のような記述で行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_MUTEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/mutex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;mutex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_RANDOM&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/random.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_RATIO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/ratio.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_REGEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/regex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_SYSTEM_ERROR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/system_error.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_THREAD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/thread.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;thread&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TUPLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/tuple.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;tuple&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TYPEINDEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/typeindex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;typeindex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TYPE_TRAITS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/type_traits.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_UNORDERED_MAP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/unordered_map.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_UNORDERED_SET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/unordered_set.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_INLINE_NAMESPACES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;inline namespace&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_SMART_PTR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11のスマートポインタ、&lt;code&gt;shared_ptr&lt;/code&gt;と&lt;code&gt;unique_ptr&lt;/code&gt;を提供しているか&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_AUTO_DECLARATIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto&lt;/code&gt; による変数の型の自動決定&lt;br /&gt; &lt;code&gt;// x の型は初期化式 expr から自動的に決定する&lt;/code&gt;&lt;br /&gt; &lt;code&gt;auto x = expr;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto&lt;/code&gt; での宣言で、一度に複数の変数を宣言する&lt;br /&gt; &lt;code&gt;auto x = expr1, y = expr2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CHAR16_T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;組み込み型 &lt;code&gt;char16_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CHAR32_T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;組み込み型 &lt;code&gt;char32_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_TEMPLATE_ALIASES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;template&lt;/code&gt; による別名宣言。&lt;br /&gt; &lt;code&gt;template&amp;lt;typename T&amp;gt; using my_vector = std::vector&amp;lt;T, my_allocator&amp;lt;T&amp;gt; &amp;gt;;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;my_vector&amp;lt;T&amp;gt; v;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CONSTEXPR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に計算して定数に畳み込むことが可能なことを示す修飾子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DECLTYPE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boost.Typeof のように式から型を取得する&lt;br /&gt; &lt;code&gt;// x は expr1 の型として宣言され、&lt;/code&gt;&lt;br /&gt; &lt;code&gt;// expr2 で初期化される&lt;/code&gt;&lt;br /&gt;&lt;code&gt;decltype(expr1) x = expr2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DECLTYPE_N3276&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;N3276仕様の&lt;code&gt;decltype&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DEFAULTED_FUNCTIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ、コピー代入演算子、デストラクタをデフォルト実装で宣言する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DELETED_FUNCTIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の &lt;code&gt;delete&lt;/code&gt; 宣言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型変換演算子に対する &lt;code&gt;explicit&lt;/code&gt; 宣言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_EXTERN_TEMPLATE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートのインスタンス化をその翻訳単位では行わないようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数テンプレートのテンプレートパラメータにデフォルト引数を指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_LAMBDAS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ローカルクラスをテンプレートパラメータに指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_LONG_LONG&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(unsigned) long long&lt;/code&gt; 型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_NOEXCEPT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;noexcept&lt;/code&gt;キーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_NULLPTR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ヌルポインタを示すキーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_RANGE_BASED_FOR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲&lt;code&gt;for&lt;/code&gt;文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`BOOST_NO_CXX11_RAW_LITERALS&lt;/td&gt;
&lt;td&gt;文字列リテラルの新しい表記法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_RVALUE_REFERENCES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右辺値参照型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_SCOPED_ENUMS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スコープ付きの列挙型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_STATIC_ASSERT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条件式によってコンパイルエラーにするための &lt;code&gt;static_assert&lt;/code&gt; 文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_STD_UNORDERD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unordered_set&lt;/code&gt;, &lt;code&gt;unordered_multiset&lt;/code&gt;, &lt;code&gt;unordered_map&lt;/code&gt;, &lt;code&gt;unordered_multimap&lt;/code&gt; の4つのコンテナクラステンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_TRAILING_RESULT_TYPES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値型を後置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_UNICODE_LITERALS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unicode 文字・文字列リテラル(&lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタの呼び出しを初期化子リストと同じ構文で記述する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_USER_DEFINED_LITERALS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ユーザー定義リテラル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変引数テンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_VARIADIC_MACROS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変引数マクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/deduced-typename&#34; name=&#34;deduced-typename&#34;&gt;コンパイラによって、テンプレート中の &lt;code&gt;hoge&amp;lt;T&amp;gt;::type x;&lt;/code&gt; や &lt;code&gt;fuga.f();&lt;/code&gt; がコンパイルエラーになったりならなかったりする問題を回避する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; hoge {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; type;
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T x) {
    T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;type x; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a)&lt;/span&gt;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g() {
    hoge x;
    f(x); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この部分をコンパイルしようとすると (a) でコンパイルエラーが起きる&lt;/span&gt;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

関数テンプレートもしくはクラステンプレート内で、上の &lt;code&gt;f&lt;/code&gt; のように内部でテンプレートパラメータの内部で宣言された型名を利用する場合、(a) の箇所では、&lt;code&gt;T::type&lt;/code&gt; が型名であることを示す必要がある。具体的には &lt;code&gt;typename&lt;/code&gt; キーワードを使って、 &lt;code&gt;typename T::type x;&lt;/code&gt; のように記述する。しかし古いコンパイラなどでは、&lt;code&gt;typename&lt;/code&gt; を付けずとも空気を読んで &lt;code&gt;T::type&lt;/code&gt; が型であると判断することで、&lt;code&gt;typename&lt;/code&gt; キーワードそのものをサポートしていない場合がある。次のように記述することで、この問題は回避可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f() {
    BOOST_DEDUCED_TYPENAME T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;type x;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;BOOST_DEDUCED_TYPENAME&lt;/code&gt; マクロは、普通 &lt;code&gt;typename&lt;/code&gt; になるが、かかる位置での &lt;code&gt;typename&lt;/code&gt; をサポートしていないコンパイラでは空に展開される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/nested-template&#34; name=&#34;nested-template&#34;&gt;メンバ関数テンプレートの呼び出しでコンパイルエラーになる問題を回避する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上記の &lt;code&gt;typename&lt;/code&gt; と似たような問題で、次のようなコードがコンパイラによって通ったり通らなかったりする：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; hoge {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f() {}
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; fuga {};
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a)&lt;/span&gt;
    T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b)&lt;/span&gt;
}

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; h() {
    hoge x;
    g(x); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この関数呼び出しをコンパイルしようとすると (a) や (b) の箇所でコンパイルエラーが起きる&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

(a) は &lt;code&gt;int&lt;/code&gt; で実体化したメンバ関数テンプレートの呼び出しとは認識されず、(b) もメンバクラステンプレートを &lt;code&gt;int&lt;/code&gt; で実体化した型の変数の宣言とは見なされない。次のように記述する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a’)&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b’)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

(a’) では &lt;code&gt;f&lt;/code&gt; の前に &lt;code&gt;template&lt;/code&gt; キーワードを付けて、&lt;code&gt;f&lt;/code&gt; がテンプレートであることを明記している。(b’) も同様に &lt;code&gt;fuga&lt;/code&gt; がテンプレートであると示しているが、同時に &lt;code&gt;T::template fuga&amp;lt;int&amp;gt;&lt;/code&gt; が型であることも示すために &lt;code&gt;typename&lt;/code&gt; も付けている。しかし上の &lt;code&gt;typename&lt;/code&gt; の問題と同様に、この &lt;code&gt;template&lt;/code&gt; キーワードの使い方をサポートしないコンパイラが存在する。これについては &lt;code&gt;BOOST_NESTED_TEMPLATE&lt;/code&gt; マクロを使うことで解決する。次のように使う：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.BOOST_NESTED_TEMPLATE f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a&#39;)&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;BOOST_NESTED_TEMPLATE fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b&#39;)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

この &lt;code&gt;template&lt;/code&gt; キーワードの使い方をサポートするコンパイラでは &lt;code&gt;template&lt;/code&gt; と展開され、そうでないコンパイラでは空に展開される。&lt;/p&gt;
&lt;p&gt;documented boost version is 1.51.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>動的型 -- cpprefjpへのリンクをGoogle SitesからGitHub Pagesに置き換え。 置き換えのスクリプト： https://gist.github.com/faithandbrave/0b908961dc9d88afde4b</title>
      <link href="http://boostjp.github.io/tips/dynamic_type.html"/>
      <id>3a89b275d4469da213c4e9eae2fa1c9a2881b129:tips/dynamic_type.md</id>
      <updated>2014-11-21 17:40:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;動的型&lt;/h1&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/dynamic_type.html#assign&#34;&gt;あらゆる型の値を代入する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/dynamic_type.html#extract-value&#34;&gt;値を取り出す&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/dynamic_type.html#store-to-container&#34;&gt;あらゆる型の値をコンテナに入れる&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/assign&#34; name=&#34;assign&#34;&gt;あらゆる型の値を代入する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::any&lt;/code&gt;型には、あらゆる型の値を格納することができる。&lt;/p&gt;
&lt;p&gt;格納されている型のチェックには、&lt;code&gt;boost::any::type()&lt;/code&gt;メンバ関数を使用し、&lt;a href=&#34;http://cpprefjp.github.io/reference/typeinfo/type_info.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::type_info&lt;/code&gt;&lt;/a&gt;型で判定することができる。&lt;/p&gt;
&lt;p&gt;格納されている値を元の型に変換するには、&lt;code&gt;boost::any_cast()&lt;/code&gt;関数を使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/any.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int値を格納&lt;/span&gt;
    x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Hello&#34;&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// std::string値を格納&lt;/span&gt;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 格納されている型をチェック&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (x.type() &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typeid&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string)) {
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 元の型に変換&lt;/span&gt;
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any_cast&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(x) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;not string&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;

実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;Hello
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/extract-value&#34; name=&#34;extract-value&#34;&gt;値を取り出す&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::any&lt;/code&gt;に代入した値を取り出すには、&lt;code&gt;boost::any_cast()&lt;/code&gt;関数を使用する。&lt;/p&gt;
&lt;p&gt;この関数の使用方法は、コピーして取り出す、値を参照する、値へのポインタを取得する、の3つがある。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1. 値をコピーして取り出す。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any a;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
T x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any_cast&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(a);
&lt;/pre&gt;&lt;/div&gt;

この例のように、テンプレート引数に取り出す型&lt;code&gt;T&lt;/code&gt;を指定し、引数として&lt;code&gt;boost::any&lt;/code&gt;オブジェクトへの参照を渡すことで、&lt;code&gt;boost::any&lt;/code&gt;型に格納されている型Tのオブジェクトを、コピーで取り出すことができる。&lt;/p&gt;
&lt;p&gt;型&lt;code&gt;T&lt;/code&gt;のオブジェクトが格納されていない場合には、&lt;code&gt;boost::bad_any_cast&lt;/code&gt;例外が投げられる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法2. 値を参照する。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any a;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any_cast&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;gt;&lt;/span&gt;(a);
&lt;/pre&gt;&lt;/div&gt;

この例のように、テンプレート引数に&lt;code&gt;T&amp;amp;&lt;/code&gt;を指定した場合、&lt;code&gt;boost::any&lt;/code&gt;型に格納されている型Tのオブジェクトを参照することができる。&lt;/p&gt;
&lt;p&gt;型&lt;code&gt;T&lt;/code&gt;のオブジェクトが格納されていない場合には、&lt;code&gt;boost::bad_any_cast&lt;/code&gt;例外が投げられる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法3. 値へのポインタを取得する。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any a;
T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any_cast&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;a);
&lt;/pre&gt;&lt;/div&gt;

この例のように、テンプレート引数に型&lt;code&gt;T&lt;/code&gt;を指定し、引数として&lt;code&gt;boost::any&lt;/code&gt;オブジェクトへのポインタを渡すことで、&lt;code&gt;boost::any&lt;/code&gt;型に格納されている型Tのオブジェクトへのポインタを取得できる。&lt;/p&gt;
&lt;p&gt;型&lt;code&gt;T&lt;/code&gt;のオブジェクトが格納されていない場合には、ヌルポインタが返される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/store-to-container&#34; name=&#34;store-to-container&#34;&gt;あらゆる型の値をコンテナに入れる&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;std::vector&amp;lt;boost::any&amp;gt;&lt;/code&gt;のようにすれば、あらゆる型の値をコンテナに入れることができる。&lt;/p&gt;
&lt;p&gt;このようなコンテナは、ヘテロなコンテナ(heterogeneous containers)と呼ばれる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/any.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/foreach.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;
    v.push_back(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);
    v.push_back(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Hello&#34;&lt;/span&gt;));
    v.push_back(&lt;span style=&#34;color: #666666&#34;&gt;3.14&lt;/span&gt;);

    BOOST_FOREACH (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x, v) {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (x.type() &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typeid&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;)) {
            std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;int : &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any_cast&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(x) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
        }
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (x.type() &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typeid&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string)) {
            std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;string : &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any_cast&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(x) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
        }
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (x.type() &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typeid&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;double&lt;/span&gt;)) {
            std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;double : &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;any_cast&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(x) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
        }
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; {
            std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;unknown type&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
        }
    }
}

&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;実行結果：&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>多倍長浮動小数点数 -- cpprefjpへのリンクをGoogle SitesからGitHub Pagesに置き換え。 置き換えのスクリプト： https://gist.github.com/faithandbrave/0b908961dc9d88afde4b</title>
      <link href="http://boostjp.github.io/tips/multiprec-float.html"/>
      <id>3a89b275d4469da213c4e9eae2fa1c9a2881b129:tips/multiprec-float.md</id>
      <updated>2014-11-21 17:40:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;多倍長浮動小数点数&lt;/h1&gt;
&lt;p&gt;多倍長浮動小数点数を使用するには、&lt;a href=&#34;http://www.boost.org/libs/multiprecision/&#34; target=&#34;_blank&#34;&gt;Boost Multiprecision Library&lt;/a&gt;を使用する。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-float.html#basic-usage&#34;&gt;基本的な使い方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-float.html#variation&#34;&gt;多倍長浮動小数点数の種類&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-float.html#from-string&#34;&gt;文字列からの変換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-float.html#to-string&#34;&gt;文字列への変換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-float.html#convert-precision&#34;&gt;異なる精度間で型変換する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-float.html#math-functions&#34;&gt;サポートされている数学関数一覧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/basic-usage&#34; name=&#34;basic-usage&#34;&gt;基本的な使い方&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ここでは、Boost.Multiprecisionから提供される多倍長浮動小数点数の、基本的な使い方を示す。&lt;/p&gt;
&lt;p&gt;以下は、任意精度の符号あり多倍長整数である&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/cpp_dec_float.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::multiprecision::cpp_dec_float_100&lt;/code&gt;&lt;/a&gt;クラス型を使用して、2の平方根を求めるプログラムである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_dec_float.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; mp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 100は仮数部の桁数&lt;/span&gt;
    mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;cpp_dec_float_100 x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2.0f&lt;/span&gt;;&lt;/span&gt;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 平方根を100桁求める&lt;/span&gt;
    mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cpp_dec_float_100 result &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;sqrt(x);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 出力桁数を設定して出力&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;setprecision(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;decltype(x)&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;digits10 &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
              &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; result;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;cpp_dec_float_100&lt;/code&gt;は、Boost.Multiprecisionが独自実装した演算をバックエンドに持つ、100桁の仮数部を表現可能な多倍長浮動小数点数である。Boost.Multiprecisionが提供する全ての機能は、&lt;code&gt;boost::multiprecision&lt;/code&gt;名前空間以下で定義される。&lt;/p&gt;
&lt;p&gt;Boost.Multiprecisionの多倍長浮動小数点数は、以下の演算をサポートする。ビット演算は使用できない。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a + b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a += b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;加算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a - b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a -= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;減算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a * b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a *= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;乗算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a / b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a /= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;除算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号をプラスにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号をマイナスにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a++;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;++a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;インクリメント&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a--;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;--a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デクリメント&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a == b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等値比較&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a != b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非等値比較&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt; b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;より小さいかの判定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;以下かの判定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;gt; b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;より大きいかの判定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;gt;= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;以上かの判定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;os &amp;lt;&amp;lt; a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ストリームへの出力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;is &amp;gt;&amp;gt; a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ストリームからの入力&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/variation&#34; name=&#34;variation&#34;&gt;多倍長浮動小数点数の種類&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下に、Boost.Multiprecisionから提供される多倍長整数の種類を示す。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/cpp_dec_float.html&#34; target=&#34;_blank&#34;&gt;Boost Multiprecision独自実装の多倍長浮動小数点数&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_dec_float.hpp&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

| 型                  | 説明 |
|---------------------|--------------------|
| &lt;code&gt;cpp_dec_float_50&lt;/code&gt;  | 仮数部を50桁表現可能な浮動小数点数  |
| &lt;code&gt;cpp_dec_float_100&lt;/code&gt; | 仮数部を100桁表現可能な浮動小数点数 |&lt;/p&gt;
&lt;p&gt;以下は、ユーザー定義の固定精度浮動小数点数型を定義する例である：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 仮数部を1,000桁表現可能な浮動小数点数の定義&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; mp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;number&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt;cpp_dec_float&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;1000&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; cpp_dec_float_1000;
&lt;/pre&gt;&lt;/div&gt;

独自実装の多倍長浮動小数点数の特徴：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;デフォルト値は0である&lt;/li&gt;
&lt;li&gt;基数は10。基数2ベースとは異なる振る舞いが可能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;infinity&lt;/code&gt;と&lt;code&gt;NaN&lt;/code&gt;をサポートする。オーバーフローやゼロ割り時には、組み込みの浮動小数点数型と同じ振る舞いをする。&lt;/li&gt;
&lt;li&gt;全ての操作は、常に切り捨てを行う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/gmp_float.html&#34; target=&#34;_blank&#34;&gt;GMPバックエンドの多倍長浮動小数点数&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/gmp.hpp&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

| 型               | 説明 |
|------------------|---------------------------------------|
| &lt;code&gt;mpf_float_50&lt;/code&gt;   | 仮数部を50桁表現可能な浮動小数点数    |
| &lt;code&gt;mpf_float_100&lt;/code&gt;  | 仮数部を100桁表現可能な浮動小数点数   |
| &lt;code&gt;mpf_float_500&lt;/code&gt;  | 仮数部を500桁表現可能な浮動小数点数   |
| &lt;code&gt;mpf_float_1000&lt;/code&gt; | 仮数部を1,000桁表現可能な浮動小数点数 |
| &lt;code&gt;mpf_float&lt;/code&gt;      | 仮数部を任意長表現可能な浮動小数点数  |&lt;/p&gt;
&lt;p&gt;以下は、ユーザー定義の固定精度浮動小数点数型を定義する例である：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 仮数部を10,000桁表現可能な浮動小数点数の定義&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; mp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;number&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt;gmp_float&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;10000&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; mpf_dec_float_10000;
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;gmp_float&lt;/code&gt;のテンプレート引数として0を指定すると、任意長の仮数部が表現可能になる。&lt;/p&gt;
&lt;p&gt;GMP多倍長浮動小数点数の特徴：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;デフォルト値は0である&lt;/li&gt;
&lt;li&gt;GMPのグローバル設定を変更しない&lt;/li&gt;
&lt;li&gt;GMPは&lt;code&gt;infinity&lt;/code&gt;や&lt;code&gt;NaN&lt;/code&gt;といった概念を持たないため、可能な限りオーバーフローやゼロ割りは避けること。オーバーフロー時またはゼロ割り時には&lt;code&gt;std::overflow_error&lt;/code&gt;例外が送出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;MPFRバックエンドの多倍長浮動小数点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/mpfr.hpp&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

動的メモリ確保を行う多倍長浮動小数点数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/floats/mpfr_float.html&#34; target=&#34;_blank&#34;&gt;MPFRバックエンドの多倍長浮動小数点数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mpfr_float_50&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部を50桁表現可能な浮動小数点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mpfr_float_100&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部を100桁表現可能な浮動小数点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mpfr_float_500&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部を500桁表現可能な浮動小数点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mpfr_float_1000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部を1,000桁表現可能な浮動小数点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mpfr_float&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部を任意長表現可能な浮動小数点数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;動的メモリ確保を行わない多倍長浮動小数点数&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static_mpfr_float_50&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部を50桁表現可能な浮動小数点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static_mpfr_float_100&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部を100桁表現可能な浮動小数点数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以下は、ユーザー定義の、動的メモリ確保を行う固定精度浮動小数点数型を定義する例である：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 仮数部を10,000桁表現可能な浮動小数点数の定義&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; mp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;number&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt;mpfr_float_backend&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;10000&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; mpf_dec_float_10000;
&lt;/pre&gt;&lt;/div&gt;

&lt;code&gt;mpfr_float_backend&lt;/code&gt;の第2テンプレート引数として&lt;code&gt;boost::multiprecision::allocate_stack&lt;/code&gt;列挙値を指定することで、動的メモリ確保を行わない多倍長浮動小数点数型の定義ができる。&lt;/p&gt;
&lt;p&gt;MPFR多倍長浮動小数点数の特徴：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;デフォルト値は&lt;code&gt;NaN&lt;/code&gt;である&lt;/li&gt;
&lt;li&gt;全ての操作は、最近接値への丸めを使用する&lt;/li&gt;
&lt;li&gt;GMPとMPFRのグローバル設定を変更しない&lt;/li&gt;
&lt;li&gt;0で割ると&lt;code&gt;infinity&lt;/code&gt;になる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/from-string&#34; name=&#34;from-string&#34;&gt;文字列からの変換&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;文字列から多倍長浮動小数点数に変換するには、&lt;code&gt;explicit&lt;/code&gt;な変換コンストラクタ、もしくは&lt;code&gt;assign()&lt;/code&gt;メンバ関数を使用する。
文字列は、&lt;code&gt;char&lt;/code&gt;配列および&lt;a href=&#34;http://cpprefjp.github.io/reference/string/basic_string.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/a&gt;を受け取ることができる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;コンストラクタで文字列から変換&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_dec_float.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    cpp_dec_float_100 x(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;3.14&#34;&lt;/span&gt;);                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// char配列から変換&lt;/span&gt;
    cpp_dec_float_100 y(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;3.14&#34;&lt;/span&gt;));   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// std::stringから変換&lt;/span&gt;

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;3.14
3.14
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;assign()&lt;/code&gt;メンバ関数で文字列から変換&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_dec_float.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    cpp_dec_float_100 x;
    x.assign(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;3.14&#34;&lt;/span&gt;);

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;3.14
&lt;/code&gt;&lt;/pre&gt;
変換できない文字列が渡された場合は、&lt;a href=&#34;http://cpprefjp.github.io/reference/stdexcept.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::runtime_error&lt;/code&gt;&lt;/a&gt;例外が送出される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/to-string&#34; name=&#34;to-string&#34;&gt;文字列への変換&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;文字列への変換には、&lt;code&gt;str()&lt;/code&gt;メンバ関数を使用する。この関数は、&lt;code&gt;std::string&lt;/code&gt;型で多倍長浮動小数点数の文字列表現を返す。&lt;/p&gt;
&lt;p&gt;デフォルトでは固定小数点表記の文字列が返されるが、以下の引数を設定することで、精度と表記、その他出力方法を選択できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1引数： 出力する精度。0を指定した場合、できるだけ多くの桁数を出力する。&lt;/li&gt;
&lt;li&gt;第2引数： 出力フラグ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_dec_float.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cpp_dec_float_50;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    cpp_dec_float_50 x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3.14&lt;/span&gt;;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 固定小数点表記(デフォルト)&lt;/span&gt;
    {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.str();
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 固定小数点表記(明示的に指定)&lt;/span&gt;
    {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.str(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ios_base&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;fixed);
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 科学的表記&lt;/span&gt;
    {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.str(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ios_base&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;scientific);
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;3.140000000000000124344978758017532527446746826171875
3.1400000000000001243449787580175325274467468261718750000000000000000000000
3.1400000000000001243449787580175325274467468261718750000000000000000000000e+00
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/convert-precision&#34; name=&#34;convert-precision&#34;&gt;異なる精度間で型変換する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Multiprecisionの多倍長浮動小数点数は、異なる精度間での変換をサポートしている。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小さい精度から大きい精度への変換&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;float&lt;/code&gt;や&lt;code&gt;double&lt;/code&gt;型といった組み込みの浮動小数点数型から、&lt;code&gt;cpp_dec_float_50&lt;/code&gt;や&lt;code&gt;cpp_dec_float_100&lt;/code&gt;といった多倍長浮動小数点数への暗黙変換が可能である。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;cpp_dec_float_50&lt;/code&gt;から&lt;code&gt;cpp_dec_float_100&lt;/code&gt;へ、といったより大きい精度への暗黙変換が可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_dec_float.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// floatからcpp_dec_float_50への暗黙変換&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;float&lt;/span&gt; f &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3.14f&lt;/span&gt;;
    cpp_dec_float_50 f50 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; f; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// cpp_dec_float_50からcpp_dec_float_100への暗黙変換&lt;/span&gt;
    cpp_dec_float_100 f100 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; f50; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大きい精度から小さい精度への変換&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小さい精度への変換は、データが失われる可能性があるため、暗黙の型変換はサポートしない。&lt;/p&gt;
&lt;p&gt;明示的な型変換を使用する場合のみ変換可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_dec_float.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    cpp_dec_float_100 f100 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3.14&lt;/span&gt;;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  cpp_dec_float_50 f50 = f100; // コンパイルエラー！変換できない&lt;/span&gt;
    cpp_dec_float_50 f50 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;cpp_dec_float_50&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(f100); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/math-functions&#34; name=&#34;math-functions&#34;&gt;サポートされている数学関数一覧&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;標準関数サポート&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;標準ライブラリで定義される以下の関数は、Boost.Multiprecisionの多倍長浮動小数点数でも使用できる。&lt;/p&gt;
&lt;p&gt;これらの関数は、&lt;code&gt;boost::multiprecision&lt;/code&gt;名前空間で定義される。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T abs(T x);&lt;/code&gt;&lt;br /&gt; &lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/fabs&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T fabs(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;絶対値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/sqrt&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T sqrt(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;平方根&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T floor(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;床関数（引数より大きくない最近傍の整数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T ceil(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;天井関数（引数より小さくない最近傍の整数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T trunc(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T itrunc(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T ltrunc(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T lltrunc(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ゼロ方向への丸め&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T round(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T lround(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T llround(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;四捨五入による丸め&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/exp&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T exp(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;e (ネイピア数) を底とする指数関数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/log&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T log(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;e (ネイピア数) を底とする自然対数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/log10&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T log10(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;10 を底とする常用対数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/cos&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T cos(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;余弦関数（コサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/sin&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T sin(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;正弦関数（サイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/tan&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T tan(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;正接関数（タンジェント）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/acos&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T acos(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;逆余弦関数（アークコサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/asin&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T asin(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;逆正弦関数（アークサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/atan&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T atan(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;逆正接関数（アークタンジェント）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/cosh&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T cosh(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;双曲線余弦関数（ハイパボリックコサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/sinh&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T sinh(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;双曲線正弦関数（ハイパボリックサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/tanh&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T tanh(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;双曲線正接関数（ハイパボリックタンジェント）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T ldexp(T x, int);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2 の冪乗との乗算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T frexp(T x, int*);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部と 2 の冪乗への分解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/pow&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T pow(T x, T y);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;冪乗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T fmod(T x, T y);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点剰余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/atan2&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T atan2(T x, T y);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;対辺と隣辺からの逆正接関数（アークタンジェント）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;documented boost version is 1.53.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>多倍長整数 -- cpprefjpへのリンクをGoogle SitesからGitHub Pagesに置き換え。 置き換えのスクリプト： https://gist.github.com/faithandbrave/0b908961dc9d88afde4b</title>
      <link href="http://boostjp.github.io/tips/multiprec-int.html"/>
      <id>3a89b275d4469da213c4e9eae2fa1c9a2881b129:tips/multiprec-int.md</id>
      <updated>2014-11-21 17:40:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;多倍長整数&lt;/h1&gt;
&lt;p&gt;多倍長整数を使用するには、&lt;a href=&#34;http://www.boost.org/libs/multiprecision/&#34; target=&#34;_blank&#34;&gt;Boost Multiprecision Library&lt;/a&gt;を使用する。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html#basic-usage&#34;&gt;基本的な使い方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html#variation&#34;&gt;多倍長整数の種類&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html#from-string&#34;&gt;文字列からの変換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html#to-string&#34;&gt;文字列への変換&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html#convert-integer&#34;&gt;異なる大きさの整数間で型変換する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html#min&#34;&gt;最小値を取得する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html#max&#34;&gt;最大値を取得する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/multiprec-int.html#is-bounded&#34;&gt;有限かどうかを判定する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[サポートされている数学関数一覧]&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/basic-usage&#34; name=&#34;basic-usage&#34;&gt;基本的な使い方&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ここでは、Boost.Multiprecisionから提供される多倍長整数の、基本的な使い方を示す。&lt;/p&gt;
&lt;p&gt;以下は、任意精度の符号あり多倍長整数である&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::multiprecision::cpp_int&lt;/code&gt;&lt;/a&gt;クラスを使用して、100の階乗を求めるプログラムである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/&lt;span style=&#34;color:#ff0000&#34;&gt;cpp_int&lt;/span&gt;.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; mp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;cpp_int&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
       x &lt;span style=&#34;color: #666666&#34;&gt;*=&lt;/span&gt; i;

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;cpp_int&lt;/code&gt;は、Boost.Multiprecisionが独自実装した演算をバックエンドに持つ、任意精度の多倍長整数である。この型は、メモリが許す限り無限の桁数を扱える。Boost.Multiprecisionが提供する全ての機能は、&lt;code&gt;boost::multiprecision&lt;/code&gt;名前空間以下で定義される。&lt;/p&gt;
&lt;p&gt;Boost.Multiprecisionの多倍長整数は、組み込みの整数型と同じ演算をサポートする。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a + b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a += b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;加算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a - b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a -= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;減算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a * b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a *= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;乗算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a / b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a /= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;除算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a % b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a %= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;剰余算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号をプラスにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;符号をマイナスにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a++;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;++a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;インクリメント&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a--;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;--a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;デクリメント&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;amp; b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a &amp;amp;= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ビットAND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a | b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a |= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ビットOR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a ^ b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a ^= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ビットXOR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;&amp;lt; b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a &amp;lt;&amp;lt;= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左ビットシフト&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;gt;&amp;gt; b;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;a &amp;gt;&amp;gt;= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右ビットシフト&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a == b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等値比較&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a != b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非等値比較&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt; b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;より小さいかの判定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;lt;= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;以下かの判定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;gt; b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;より大きいかの判定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a &amp;gt;= b;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;が&lt;code&gt;b&lt;/code&gt;以上かの判定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;os &amp;lt;&amp;lt; a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ストリームへの出力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;is &amp;gt;&amp;gt; a;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ストリームからの入力&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/variation&#34; name=&#34;variation&#34;&gt;多倍長整数の種類&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下に、Boost.Multiprecisionから提供される多倍長整数の種類を示す。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html&#34; target=&#34;_blank&#34;&gt;Boost Multiprecision独自実装の多倍長整数&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

符号付きチェックなし整数：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cpp_int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意精度の符号付き多倍長整数。 メモリが許す限り、無限の桁数を扱える。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int128_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;128ビット精度の符号付き整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int256_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;256ビット精度の符号付き整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int512_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;512ビット精度の符号付き整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int1024_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1024ビット精度の符号付き整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;符号なしチェックなし整数：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;uint128_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;128ビット精度の符号なし整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;uint256_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;256ビット精度の符号なし整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;uint512_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;512ビット精度の符号なし整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;uint1024_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1024ビット精度の符号なし整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;符号付きチェック付き整数：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checked_cpp_int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意精度の符号付き多倍長整数。 メモリが許す限り、無限の精度を扱える。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checked_int128_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;128ビット精度の符号付き整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checked_int256_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;256ビット精度の符号付き整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checked_int512_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;512ビット精度の符号付き整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checked_int1024_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1024ビット精度の符号付き整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;符号なしチェック付き整数：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checked_uint128_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;128ビット精度の符号なし整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cheked_uint256_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;256ビット精度の符号なし整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checked_uint512_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;512ビット精度の符号なし整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checked_uint1024_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1024ビット精度の符号なし整数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;チェック付き整数は、値が不正になる演算を行った際に例外を送出する。&lt;/p&gt;
&lt;p&gt;チェックなし整数が送出する例外：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;条件&lt;/th&gt;
&lt;th&gt;送出する例外&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ゼロ割り時&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/stdexcept&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::overflow_error&lt;/code&gt;&lt;/a&gt;例外が送出される&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;チェック付き整数が送出する例外：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;条件&lt;/th&gt;
&lt;th&gt;送出する例外&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ゼロ割り時&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/stdexcept&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::overflow_error&lt;/code&gt;&lt;/a&gt;例外が送出される&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;符号なしなのにマイナス値になった&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/stdexcept&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::range_error&lt;/code&gt;&lt;/a&gt;例外が送出される&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;オーバーフロー時&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/stdexcept&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::overflow_error&lt;/code&gt;&lt;/a&gt;例外が送出される&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/gmp_int.html&#34; target=&#34;_blank&#34;&gt;GMPバックエンドの多倍長整数&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/gmp.hpp&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

符号ありチェックなし整数：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mpz_int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意精度の符号付き多倍長整数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/tut/ints/tom_int.html&#34; target=&#34;_blank&#34;&gt;libtommathバックエンドの多倍長整数&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/tommath.hpp&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

符号ありチェックなし整数：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tom_int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意精度の符号付き多倍長整数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/from-string&#34; name=&#34;from-string&#34;&gt;文字列からの変換&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;文字列から多倍長整数に変換するには、&lt;code&gt;explicit&lt;/code&gt;な変換コンストラクタ、もしくは&lt;code&gt;assign()&lt;/code&gt;メンバ関数を使用する。&lt;/p&gt;
&lt;p&gt;文字列は、&lt;code&gt;char&lt;/code&gt;配列および&lt;a href=&#34;http://cpprefjp.github.io/reference/string/basic_string.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/a&gt;を受け取ることができる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;コンストラクタで文字列から変換&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    cpp_int x(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123&#34;&lt;/span&gt;);              &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// char配列から変換&lt;/span&gt;
    cpp_int y(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;456&#34;&lt;/span&gt;)); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// std::stringから変換&lt;/span&gt;

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;123
456
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;assign()&lt;/code&gt;メンバ関数で文字列から変換&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    cpp_int x;
    x.assign(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123&#34;&lt;/span&gt;);

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;123
&lt;/code&gt;&lt;/pre&gt;
変換できない文字列が渡された場合は、&lt;a href=&#34;http://cpprefjp.github.io/reference/stdexcept.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::runtime_error&lt;/code&gt;&lt;/a&gt;例外が送出される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/to-string&#34; name=&#34;to-string&#34;&gt;文字列への変換&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;文字列への変換には、&lt;code&gt;str()&lt;/code&gt;メンバ関数を使用する。この関数は、&lt;code&gt;std::string&lt;/code&gt;型で多倍長整数の文字列表現を返す。&lt;/p&gt;
&lt;p&gt;デフォルトでは10進数表現の文字列が返されるが、以下の引数を設定することで、精度と基数、その他出力方法を選択できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1引数： 出力する精度。整数では単に無視されるので、0を指定すればよい。&lt;/li&gt;
&lt;li&gt;第2引数： 出力フラグ。基数の選択。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cpp_int;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    cpp_int x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;123&lt;/span&gt;;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 10進数&lt;/span&gt;
    {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.&lt;span style=&#34;color:#ff0000&#34;&gt;str&lt;/span&gt;();
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 8進数&lt;/span&gt;
    {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.&lt;span style=&#34;color:#ff0000&#34;&gt;str&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ios_base&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;oct);
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 16進数&lt;/span&gt;
    {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.&lt;span style=&#34;color:#ff0000&#34;&gt;str&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ios_base&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;hex);
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;123
173
7B
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/convert-integer&#34; name=&#34;convert-integer&#34;&gt;異なる大きさの整数間で型変換する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Multiprecisionの多倍長整数は、異なる精度間での変換をサポートしている。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小さい整数型から大きい整数型への変換&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int&lt;/code&gt;や&lt;code&gt;long&lt;/code&gt;型といった組み込みの整数型から、&lt;code&gt;int128_t&lt;/code&gt;や&lt;code&gt;cpp_int&lt;/code&gt;といった多倍長整数への暗黙変換が可能である。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;int128_t&lt;/code&gt;から&lt;code&gt;int256&lt;/code&gt;へ、といったより大きい精度への暗黙変換が可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// intからint128_tへの暗黙変換&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;;
    &lt;span style=&#34;color: #B00040&#34;&gt;int128_t&lt;/span&gt; i128 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int128_tからint256_tへの暗黙変換&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;int256_t&lt;/span&gt; i256 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i128; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大きい精度から小さい精度への変換&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小さい精度への変換は、データが失われる可能性があるため、暗黙の型変換はサポートしない。&lt;/p&gt;
&lt;p&gt;明示的な型変換を使用する場合のみ変換可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color: #B00040&#34;&gt;int256_t&lt;/span&gt; i256 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//  int128_t i128 = i256; // コンパイルエラー！変換できない&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;int128_t&lt;/span&gt; i128 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int128_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(i256); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/min&#34; name=&#34;min&#34;&gt;最小値を取得する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;多倍長整数の最小値を取得するには、&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::numeric_limits&lt;/code&gt;&lt;/a&gt;クラスの&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits/min.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;min()&lt;/code&gt;&lt;/a&gt;静的メンバ関数を使用する。&lt;/p&gt;
&lt;p&gt;任意精度整数である&lt;code&gt;cpp_int&lt;/code&gt;は無限の桁数を持つため、最小値は取得できなかったものとして、0を返す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; mp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cpp_int  x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cpp_int&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;min&lt;/span&gt;();  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 任意精度&lt;/span&gt;
    mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int128_t&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int128_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;min&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 固定精度&lt;/span&gt;

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;0
-340282366920938463463374607431768211455
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/max&#34; name=&#34;max&#34;&gt;最大値を取得する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;多倍長整数の最大値を取得するには、&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::numeric_limits&lt;/code&gt;&lt;/a&gt;クラスの&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits/max.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt;静的メンバ関数を使用する。&lt;/p&gt;
&lt;p&gt;任意精度整数である&lt;code&gt;cpp_int&lt;/code&gt;は無限の桁数を持つため、最大値は取得できなかったものとして、0を返す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; mp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cpp_int  x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cpp_int&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;max&lt;/span&gt;();  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 任意精度&lt;/span&gt;
    mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int128_t&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int128_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;max&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 固定精度&lt;/span&gt;

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;0
340282366920938463463374607431768211455
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/is-bounded&#34; name=&#34;is-bounded&#34;&gt;有限かどうかを判定する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;多倍長整数型の表す値が有限かどうかを判定するには、&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::numeric_limits&lt;/code&gt;&lt;/a&gt;クラスの&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits/is_bounded.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;is_bounded&lt;/code&gt;&lt;/a&gt;定数を取得する。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits/is_bounded.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;is_bounded&lt;/code&gt;&lt;/a&gt;は&lt;code&gt;bool&lt;/code&gt;型で定義され、有限であれば&lt;code&gt;true&lt;/code&gt;、無限であれば&lt;code&gt;false&lt;/code&gt;が設定される。&lt;/p&gt;
&lt;p&gt;任意精度整数である&lt;code&gt;cpp_int&lt;/code&gt;は無限の桁数を持つため、&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits/is_bounded.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;is_bounded&lt;/code&gt;&lt;/a&gt;は&lt;code&gt;false&lt;/code&gt;となる。&lt;/p&gt;
&lt;p&gt;固定精度整数の&lt;code&gt;int128_t&lt;/code&gt;、&lt;code&gt;int256_t&lt;/code&gt;といった型の場合、&lt;a href=&#34;http://cpprefjp.github.io/reference/limits/numeric_limits/is_bounded.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;is_bounded&lt;/code&gt;&lt;/a&gt;は&lt;code&gt;true&lt;/code&gt;となる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/multiprecision/cpp_int.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; mp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;multiprecision;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    constexpr &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cpp_int&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;is_bounded&lt;/span&gt;;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 任意精度&lt;/span&gt;
    constexpr &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;mp&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int128_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;is_bounded&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 固定精度&lt;/span&gt;

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;boolalpha;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;false
true
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/math-functions&#34; name=&#34;math-functions&#34;&gt;サポートされている数学関数一覧&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;標準関数サポート&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;標準ライブラリで定義される以下の関数は、Boost.Multiprecisionの多倍長整数でも使用できる。&lt;/p&gt;
&lt;p&gt;これらの関数は、&lt;code&gt;boost::multiprecision&lt;/code&gt;名前空間で定義される。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T abs(T x);&lt;/code&gt;&lt;br /&gt; &lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/fabs&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T fabs(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;絶対値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/sqrt&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T sqrt(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;平方根&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T floor(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;床関数（引数より大きくない最近傍の整数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T ceil(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;天井関数（引数より小さくない最近傍の整数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T trunc(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T itrunc(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T ltrunc(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T lltrunc(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ゼロ方向への丸め&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T round(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T lround(T x);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;T llround(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;四捨五入による丸め&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/exp&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T exp(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;e (ネイピア数) を底とする指数関数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/log&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T log(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;e (ネイピア数) を底とする自然対数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/log10&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T log10(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;10 を底とする常用対数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/cos&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T cos(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;余弦関数（コサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/sin&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T sin(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;正弦関数（サイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/tan&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T tan(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;正接関数（タンジェント）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/acos&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T acos(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;逆余弦関数（アークコサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/asin&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T asin(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;逆正弦関数（アークサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/atan&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T atan(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;逆正接関数（アークタンジェント）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/cosh&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T cosh(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;双曲線余弦関数（ハイパボリックコサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/sinh&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T sinh(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;双曲線正弦関数（ハイパボリックサイン）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/tanh&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T tanh(T x);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;双曲線正接関数（ハイパボリックタンジェント）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T ldexp(T x, int);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2 の冪乗との乗算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T frexp(T x, int*);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仮数部と 2 の冪乗への分解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/pow&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T pow(T x, T y);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;冪乗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T fmod(T x, T y);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;浮動小数点剰余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/atan2&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T atan2(T x, T y);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;対辺と隣辺からの逆正接関数（アークタンジェント）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;整数に特化した数学関数サポート&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下の関数は、Boost.Multiprecisionで整数演算に特化したものとして、&lt;code&gt;boost::multiprecision&lt;/code&gt;名前空間で定義される。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/site/cpprefjp/reference/cmath/pow&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;T pow(T x, unsigned int y);&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;冪乗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T powm(T b, T p, T m);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;冪剰余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void divide_qr(T x, y, T&amp;amp; q, T&amp;amp; r);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;除算と剰余算を同時に行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Integer&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Integer integer_modulus(T x, Integer val);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;剰余の絶対値&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;unsigned int lsb(T x);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1に設定されている最下位ビットのインデックスを取得する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool bit_test(T val, unsigned index);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定されたインデックスのビットが1に設定されているかを判定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp; bit_set(T&amp;amp; val, unsigned index);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定されたインデックスのビットを1に設定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp; bit_unset(T&amp;amp; val, unsigned index);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定されたインデックスのビットを0に設定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp; bit_flip(T&amp;amp; val, unsigned index);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定されたインデックスのビットを反転する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Engine&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bool miller_rabin_test(T n, unsigned trials, Engine&amp;amp; gen);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bool miller_rabin_test(T n, unsigned trials);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ミラー・ラビン素数判定&lt;br /&gt; 参照： &lt;a href=&#34;http://d.hatena.ne.jp/faith_and_brave/20130222/1361516978&#34; target=&#34;_blank&#34;&gt;Boost.Multiprecision ミラー・ラビン法による素数判定 - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;参照： &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/boost_multiprecision/ref/number.html#boost_multiprecision.ref.number.integer_functions&#34; target=&#34;_blank&#34;&gt;Integer functions - Boost Multiprecision Library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;documented boost version is 1.53.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>優先順位を付けて並べ替える -- cpprefjpへのリンクをGoogle SitesからGitHub Pagesに置き換え。 置き換えのスクリプト： https://gist.github.com/faithandbrave/0b908961dc9d88afde4b</title>
      <link href="http://boostjp.github.io/tips/priority_sort.html"/>
      <id>3a89b275d4469da213c4e9eae2fa1c9a2881b129:tips/priority_sort.md</id>
      <updated>2014-11-21 17:40:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;優先順位を付けて並べ替える&lt;/h1&gt;
&lt;p&gt;ここでは、優先順位を付きのオブジェクト比較と、それによる並べ替えの方法を示す。優先順位付きの比較とは、Windowsのエクスプローラで言うところの「ファイル種別順に並べて、同じファイル種別のものはファイル名順に並べる」というようなものである。
このような比較方法は、一覧画面のようなものを作る場合に必要となる。&lt;/p&gt;
&lt;p&gt;優先順位付きの比較には、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/&#34; target=&#34;_blank&#34;&gt;Boost Fusion Library&lt;/a&gt;が提供するタプル型を使用する。タプルとは、異なる複数の型からなるシーケンスである。&lt;a href=&#34;http://boostjp.github.io/reference/utility/pair.html&#34;&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/a&gt;が2つの異なる型のオブジェクトを格納するのに対して、タプルは任意個のオブジェクトを格納できる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/&#34; target=&#34;_blank&#34;&gt;Boost.Fusion&lt;/a&gt;が提供するタプルは比較演算子を持っており、それがちょうど前述した「ファイル種別順に並べて、同じファイル種別のものはファイル名順に並べる」という意味論での比較を行う。&lt;/p&gt;
&lt;p&gt;クラスのメンバ変数をタプルに変換することにより、優先順位付きの比較が可能となる。&lt;/p&gt;
&lt;p&gt;以下がその例である：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;algorithm&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/fusion/include/comparison.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/fusion/include/&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; File {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string type;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string name;

    File(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; type, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; name)
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; type(type), name(name) {}
};

&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; a, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; b)
{
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ファイル種別、ファイル名の順番で優先順位を付けて比較&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; fusion &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;fusion;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; fusion&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;(a.type, a.name) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; fusion&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;(b.type, b.name);
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; main()
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;File&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; files &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;text&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;b.txt&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;application&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;b.exe&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;application&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;a.exe&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;text&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;a.txt&#34;&lt;/span&gt;}
    };

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 並べ替え&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;sort(files.begin(), files.end());

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; file &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; files) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; file.type &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;, &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; file.name &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;application, a.exe
application, b.exe
text, a.txt
text, b.txt
&lt;/code&gt;&lt;/pre&gt;
ファイルが、ファイル種別順に並んだ上で、種別が同じファイルは名前で並べ替えられていることがわかるだろう。&lt;/p&gt;
&lt;p&gt;このプログラムでは、&lt;code&gt;File&lt;/code&gt;クラスの&lt;code&gt;operator&amp;lt;()&lt;/code&gt;演算子において「ファイル種別でどちらが小さいかを比較し、同じであればファイル名がどちらが小さいかを比較する」という優先順位付き比較を行なっている。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/container/generation/functions/vector_tie.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::fusion::vector_tie()&lt;/code&gt;&lt;/a&gt;関数は、引数として受け取った変数への参照から、参照のタプル型を構築する。ここでは、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/container/vector.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::fusion::vector&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;const std::string&amp;amp;, const std::string&amp;amp;&amp;gt;&lt;/code&gt;という型のタプルオブジェクトを構築する。&lt;/p&gt;
&lt;p&gt;Boost.Fusionが提供するタプル型に対する比較演算子は、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/sequence/operator/comparison.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;boost/fusion/include/comparison.hpp&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダで定義されている。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参照：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/algorithm/lexicographical_compare.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::lexicographical_compare()&lt;/code&gt; - cpprefjp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ユーザー定義型を扱える型安全な共用体 -- cpprefjpへのリンクをGoogle SitesからGitHub Pagesに置き換え。 置き換えのスクリプト： https://gist.github.com/faithandbrave/0b908961dc9d88afde4b</title>
      <link href="http://boostjp.github.io/tips/variant.html"/>
      <id>3a89b275d4469da213c4e9eae2fa1c9a2881b129:tips/variant.md</id>
      <updated>2014-11-21 17:40:38 +0900</updated>
      
        <content type="html">&lt;h1&gt;ユーザー定義型を扱える型安全な共用体&lt;/h1&gt;
&lt;p&gt;ユーザー定義型を共用体で扱うには、&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/variant.html&#34; target=&#34;_blank&#34;&gt;Boost Variant Library&lt;/a&gt;を使用する。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/variant.html#basic-usage&#34;&gt;基本的な使い方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/variant.html#which-type&#34;&gt;どの型が格納されているかを判定する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/variant.html#get-value&#34;&gt;格納されている値を取り出す&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/variant.html#clear&#34;&gt;値をクリアする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/variant.html#recursive-variant&#34;&gt;variantを再帰的にする&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/basic-usage&#34; name=&#34;basic-usage&#34;&gt;基本的な使い方&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;まず、Boost.Variantの基本的な使い方を以下に示す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/variant.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; var_printer &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;static_visitor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
        { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; }

    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; s) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
        { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; s &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; }

    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #B00040&#34;&gt;double&lt;/span&gt; x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
        { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; }
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int, string, doubleのオブジェクトが格納されうる型&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;variant&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string, &lt;span style=&#34;color: #B00040&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;

    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int型の値を代入&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;apply_visitor(var_printer(), v); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// visitorで型ごとの処理を行う&lt;/span&gt;

    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;hello&#34;&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 文字列を代入&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;apply_visitor(var_printer(), v);
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;3
hello
&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/variant.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::variant&lt;/code&gt;&lt;/a&gt;クラステンプレートが、型安全に抽象化された共用体である。そのテンプレート引数として、格納されうる型を列挙する。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/variant.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::variant&lt;/code&gt;&lt;/a&gt;クラスは、テンプレートパラメータで指定された型のオブジェクトを、コピー／ムーブコンストラクタおよび代入演算子で代入できる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/apply_visitor.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::apply_visitor()&lt;/code&gt;&lt;/a&gt;関数に指定する関数オブジェクトは、&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/static_visitor.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::static_visitor&lt;/code&gt;&lt;/a&gt;クラスから派生したクラスであり、&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/variant.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::variant&lt;/code&gt;&lt;/a&gt;オブジェクトにどの型のオブジェクトが格納されているのかによって、関数呼び出し演算子を適切にオーバーロードしてくれる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/which-type&#34; name=&#34;which-type&#34;&gt;どの型が格納されているかを判定する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/variant.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::variant&lt;/code&gt;&lt;/a&gt;オブジェクトにどの型が格納されているか判定するには&lt;code&gt;which()&lt;/code&gt;メンバ関数、もしくは&lt;code&gt;type()&lt;/code&gt;メンバ関数を使用する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;which()&lt;/code&gt;メンバ関数は、格納されている型の、&lt;code&gt;0&lt;/code&gt;から始まるインデックスを返す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/variant.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;variant&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string, &lt;span style=&#34;color: #B00040&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 空の状態&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#ff0000&#34;&gt;which&lt;/span&gt;() &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int型の値を格納&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#ff0000&#34;&gt;which&lt;/span&gt;() &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3.14&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// double型の値を格納&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#ff0000&#34;&gt;which&lt;/span&gt;() &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;0
0
2
&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;type()&lt;/code&gt;メンバ関数は、格納されている型の&lt;a href=&#34;http://cpprefjp.github.io/reference/typeinfo/type_info.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::type_info&lt;/code&gt;&lt;/a&gt;オブジェクトへの&lt;code&gt;const&lt;/code&gt;左辺値参照を返す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/variant.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;variant&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string, &lt;span style=&#34;color: #B00040&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;

    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int型の値を格納&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (v.&lt;span style=&#34;color:#ff0000&#34;&gt;type&lt;/span&gt;() &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typeid&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;)) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;int&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }

    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3.14&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// double型の値を格納&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (v.&lt;span style=&#34;color:#ff0000&#34;&gt;type&lt;/span&gt;() &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typeid&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;double&lt;/span&gt;)) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;double&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;int
double
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/get-value&#34; name=&#34;get-value&#34;&gt;格納されている値を取り出す&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/variant.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::variant&lt;/code&gt;&lt;/a&gt;オブジェクトに格納されている値を取り出すには、&lt;a href=&#34;http://www.boost.org/doc/libs/1_52_0/doc/html/boost/get_id1950197.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::get()&lt;/code&gt;&lt;/a&gt;非メンバ関数を使用する。
この関数には参照版とポインタ版の2種類が用意されている。それぞれの特徴は以下の通り：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参照版 ： &lt;a href=&#34;http://www.boost.org/doc/libs/1_52_0/doc/html/boost/get_id1950197.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::get()&lt;/code&gt;&lt;/a&gt;非メンバ関数に&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/variant.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::variant&lt;/code&gt;&lt;/a&gt;オブジェクトへの参照を渡すと、格納されている値への参照を返す。指定された型が格納されている型と同じではない場合、&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/bad_get.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::bad_get&lt;/code&gt;&lt;/a&gt;型の例外を送出する。&lt;/li&gt;
&lt;li&gt;ポインタ版 ： &lt;a href=&#34;http://www.boost.org/doc/libs/1_52_0/doc/html/boost/get_id1950197.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::get()&lt;/code&gt;&lt;/a&gt;非メンバ関数に&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/variant.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::variant&lt;/code&gt;&lt;/a&gt;オブジェクトへのポインタを渡すと、格納されている値へのポインタを返す。指定された型が格納されている型と同じではない場合、ヌルポインタを返す。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/variant.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;variant&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string, &lt;span style=&#34;color: #B00040&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int型の値を格納&lt;/span&gt;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 参照版&lt;/span&gt;
    try {
        &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff0000&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;get&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(v);
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt; (boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bad_get&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; e) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; e.what() &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ポインタ版&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff0000&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;get&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;v)) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;int値は格納されていない&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;1
1
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/clear&#34; name=&#34;clear&#34;&gt;値をクリアする&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Variantには&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/variant/design.html#variant.design.never-empty&#34; target=&#34;_blank&#34;&gt;決して空にはならない保証&lt;/a&gt;という考え方があるため、他の値を入れることはできてもクリアはできない。&lt;code&gt;clear()&lt;/code&gt;関数は用意されておらず、&lt;code&gt;empty()&lt;/code&gt;メンバ関数は常に&lt;code&gt;false&lt;/code&gt;を返す。&lt;/p&gt;
&lt;p&gt;どうしてもクリアしたい場合は、&lt;code&gt;boost::blank&lt;/code&gt;という型を&lt;code&gt;variant&lt;/code&gt;に格納できるように指定する。これは単なる中身が空のクラスである。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;which()&lt;/code&gt;メンバ関数や&lt;code&gt;type()&lt;/code&gt;メンバ関数を使用して、&lt;code&gt;boost::blank&lt;/code&gt;オブジェクトが格納されているかどうかで、空かどうかを判定する。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/boost/variant.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::variant&lt;/code&gt;&lt;/a&gt;クラスは、そのデフォルトコンストラクタで第1テンプレートパラメータのオブジェクトを構築するので、&lt;code&gt;boost::blank&lt;/code&gt;は第1テンプレートパラメータとして指定することを推奨する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/variant.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;variant&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;blank&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff0000&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;blank&lt;/span&gt;();
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;;

    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff0000&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;blank&lt;/span&gt;();

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (v.type() &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typeid&lt;/span&gt;(&lt;span style=&#34;color:#ff0000&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;blank&lt;/span&gt;)) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;blank&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;no blank&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;

出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;blank
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/recursive-variant&#34; name=&#34;recursive-variant&#34;&gt;variantを再帰的にする&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;documentated boost version is 1.52.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>