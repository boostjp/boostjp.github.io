<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-03-09T16:04:29.005095</updated>
  <id>2c167f45-143e-4d1f-b00b-b7cd31c57f68</id>

  
    <entry>
      <title>リリースノート -- Boost 1.58.0リリースノート、および雛形ページへのリンクを追加。</title>
      <link href="http://boostjp.github.io/document/version.html"/>
      <id>5ca9b2aa003885cf82faf1088f049f825e4eeab5:document/version.md</id>
      <updated>2015-03-09 16:04:12 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;リリースノート&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;以下は、Boostの各バージョンのリリースノートを翻訳、情報補完したドキュメントです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/template.html&#34;&gt;雛形ページ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html&#34;&gt;1.58.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_57_0.html&#34;&gt;1.57.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_56_0.html&#34;&gt;1.56.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html&#34;&gt;1.55.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_54_0.html&#34;&gt;1.54.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_53_0.html&#34;&gt;1.53.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_52_0.html&#34;&gt;1.52.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_51_0.html&#34;&gt;1.51.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_50_0.html&#34;&gt;1.50.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_49_0.html&#34;&gt;1.49.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_48_0.html&#34;&gt;1.48.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html&#34;&gt;1.47.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_1.html&#34;&gt;1.46.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html&#34;&gt;1.46.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_45_0.html&#34;&gt;1.45.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.58.0リリースノート -- リリースノートのテンプレートと1.58のテンプレートを追加</title>
      <link href="http://boostjp.github.io/document/version/1_58_0.html"/>
      <id>0a6ce0e77dd03e170b0a58829dc04f1853016ab4:document/version/1_58_0.md</id>
      <updated>2015-03-09 10:01:28 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost 1.58.0リリースノート&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/website/blob/master/feed/history/boost_1_58_0.qbk&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/website/blob/master/feed/history/boost_1_58_0.qbk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_58_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_58_0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリからのビルド方法は、egtraさんのブログを参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「&lt;a href=&#34;http://dev.activebasic.com/egtra/2013/12/03/620/&#34; target=&#34;_blank&#34;&gt;Modularized Boost（GitHubへ移行したリポジトリ）を使用する&lt;/a&gt;」&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#one&#34;&gt;One&lt;/a&gt; # example&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#two&#34;&gt;Two&lt;/a&gt; # example&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#three&#34;&gt;Three&lt;/a&gt; # example&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#one&#34; name=&#34;One&#34;&gt;One&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;blahblahblah&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#two&#34; name=&#34;Two&#34;&gt;Two&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;改善&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;something&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解決したチケット&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/xxxx&#34; target=&#34;_blank&#34;&gt;#xxxx&lt;/a&gt; ticket&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/XXX/pull/XX&#34; target=&#34;_blank&#34;&gt;pull request XX&lt;/a&gt; GitHub PR&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#three&#34; name=&#34;Three&#34;&gt;Three&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Feature: &lt;code&gt;boost::xxx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trailing &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/xxxx&#34; target=&#34;_blank&#34;&gt;#xxxx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要なテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加して含まれるテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;GCC, C++11:&lt;/li&gt;
&lt;li&gt;GCC, C++14:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;Intel, C++11:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++11:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++14:&lt;/li&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;Clang, C++11:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Flast&#34; target=&#34;_blank&#34;&gt;Kohei Takahashi&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Kohei Takahashi</name>
        <email>flast@flast.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.xx.0リリースノート -- リリースノートのテンプレートと1.58のテンプレートを追加</title>
      <link href="http://boostjp.github.io/document/version/template.html"/>
      <id>0a6ce0e77dd03e170b0a58829dc04f1853016ab4:document/version/template.md</id>
      <updated>2015-03-09 10:01:28 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost 1.xx.0リリースノート&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/website/blob/master/feed/history/boost_1_xx_0.qbk&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/website/blob/master/feed/history/boost_1_xx_0.qbk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_xx_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_xx_0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリからのビルド方法は、egtraさんのブログを参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「&lt;a href=&#34;http://dev.activebasic.com/egtra/2013/12/03/620/&#34; target=&#34;_blank&#34;&gt;Modularized Boost（GitHubへ移行したリポジトリ）を使用する&lt;/a&gt;」&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/template.html#one&#34;&gt;One&lt;/a&gt; # example&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/template.html#two&#34;&gt;Two&lt;/a&gt; # example&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/template.html#three&#34;&gt;Three&lt;/a&gt; # example&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/template.html#one&#34; name=&#34;One&#34;&gt;One&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;blahblahblah&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/template.html#two&#34; name=&#34;Two&#34;&gt;Two&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;改善&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;something&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解決したチケット&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/xxxx&#34; target=&#34;_blank&#34;&gt;#xxxx&lt;/a&gt; ticket&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/XXX/pull/XX&#34; target=&#34;_blank&#34;&gt;pull request XX&lt;/a&gt; GitHub PR&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/template.html#three&#34; name=&#34;Three&#34;&gt;Three&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Feature: &lt;code&gt;boost::xxx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trailing &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/xxxx&#34; target=&#34;_blank&#34;&gt;#xxxx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要なテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加して含まれるテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;GCC, C++11:&lt;/li&gt;
&lt;li&gt;GCC, C++14:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;li&gt;Intel, C++11:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++11:&lt;/li&gt;
&lt;li&gt;Apple Clang, C++14:&lt;/li&gt;
&lt;li&gt;Clang:&lt;/li&gt;
&lt;li&gt;Clang, C++11:&lt;/li&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;li&gt;Intel:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw:&lt;/li&gt;
&lt;li&gt;Visual C++:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;Someone&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Kohei Takahashi</name>
        <email>flast@flast.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>Date-Time Build-Compiler Information -- 不正なリンクを解消</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html"/>
      <id>738a312268b17912e7d754acfa635e9de3173ba7:archive/boost_docs/libs/date_time/build_info.md</id>
      <updated>2015-01-19 23:02:36 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Date-Time Build-Compiler Information&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time.html&#34;&gt;全体のインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/gregorian.html&#34;&gt;Gregorianのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/posix_time.html&#34;&gt;Posix Timeのインデックスへ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Build-Compiler Information&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compilation-options&#34;&gt;Compilation Options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compiler-portability-notes&#34;&gt;Compiler/Portability Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#directory-structure&#34;&gt;Directory Structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#required-boost-libraries&#34;&gt;Required Boost Libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#overview&#34; name=&#34;overview&#34;&gt;Overview&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ライブラリ関数のいくつかはライブラリファイルを作成する必要がある。 これらの関数を含むライブラリ( &lt;strong&gt;libboost_date_time&lt;/strong&gt; )を作成するには、buildディレクトリにあるJamfileを使う。&lt;/p&gt;
&lt;p&gt;変数&lt;code&gt;DATE_TIME_INLINE&lt;/code&gt;は、ある特定のコア関数のインライン化を制御する。 デフォルトでこの変数はライブラリのコンパイル時に定義されている。 ライブラリを使っている全てのコンパイル単位でこの定義を含んでいなければ、リンクエラーになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compilation-options&#34; name=&#34;compilation-options&#34;&gt;Compilation Options&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;デフォルトでは &lt;code&gt;posix_time&lt;/code&gt; はナノ秒レベルの精度を提供するために内部で 64bit整数と32bit整数を使う。 選択肢として、一つの 64bit整数でマイクロ秒レベルの精度を提供することもできる。 この代替実装は、ナノ秒精度を必要としない多くのアプリケーションでパフォーマンスの向上と省メモリが期待できる。&lt;/p&gt;
&lt;p&gt;変数&lt;code&gt;BOOST_DATE_TIME_POSIX_TIME_STD_CONFIG&lt;/code&gt;はbuild/Jamfileで定義されており、これらのオプションを選択する。 64bit整数版を使う場合、単にJamfileからこの定義を削除する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#compiler-portability-notes&#34; name=&#34;compiler-portability-notes&#34;&gt;Compiler/Portability Notes&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost Date-Time libraryは、多くのコンパイラでビルドされテストされた。 しかしながら、いくつかのコンパイラと標準ライブラリで問題がある。 これらの問題のいくつかは回避可能であるが、回避できない問題も残っている。 以下のコンパイラはライブラリの機能を完全にサポートしている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 3.0.3 on Linux&lt;/li&gt;
&lt;li&gt;GCC 3.1 (cygwin)&lt;/li&gt;
&lt;li&gt;MSVC 7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特に、標準ロケールに対するサポートが完全でないと &lt;code&gt;iostream&lt;/code&gt; ベースの入出力サポートが制約される事がある。そういったコンパイラのために、より限定された文字列ベースの入出力を提供している。&lt;/p&gt;
&lt;p&gt;以下のコンパイラ及び標準ライブラリはこの制約を含む&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 2.9x on Linux&lt;/li&gt;
&lt;li&gt;Borland 5.1.1 and 5.6&lt;/li&gt;
&lt;li&gt;MSVC 6 SP5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ComeauやMetroworksといった他のコンパイラでは、ライブラリの初期バージョンでテストに成功している。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#directory-structure&#34; name=&#34;directory-structure&#34;&gt;Directory Structure&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;date_time&lt;/code&gt;のディレクトリ構成はBoostに合わせて変更された。&lt;/p&gt;
&lt;p&gt;ディレクトリ構成は次のようになっている&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ディレクトリ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time&lt;/td&gt;
&lt;td&gt;共通ヘッダ及びテンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time/gregoran&lt;/td&gt;
&lt;td&gt;グレゴリオ暦システムのヘッダファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/boost/date_time/posix_time&lt;/td&gt;
&lt;td&gt;Posix Time系のヘッダファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/build&lt;/td&gt;
&lt;td&gt;ビルドファイルと出力ディレクトリ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test&lt;/td&gt;
&lt;td&gt;ジェネリックコードに関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test/gregorian&lt;/td&gt;
&lt;td&gt;グレゴリオ暦に関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/examples/gregorian&lt;/td&gt;
&lt;td&gt;グレゴリオ暦に関する良いコード例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/src/gregorian&lt;/td&gt;
&lt;td&gt;libboost_date_time用のcppファイル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/test/posix_time&lt;/td&gt;
&lt;td&gt;Posix Time系に関するテスト一式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/examples/posix_time&lt;/td&gt;
&lt;td&gt;時間に関する良いコード例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/libs/date_time/src/posix_time&lt;/td&gt;
&lt;td&gt;空 (ファイルが一つあるが、ソースコードではない)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/date_time/build_info.html#required-boost-libraries&#34; name=&#34;required-boost-libraries&#34;&gt;Required Boost Libraries&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このライブラリは以下のライブラリに依存している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;boost.tokenizer&lt;/li&gt;
&lt;li&gt;boost.integer(cstdint)&lt;/li&gt;
&lt;li&gt;boost.operators&lt;/li&gt;
&lt;li&gt;boost::lexical_cast&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;よって、最低限これらのライブラリがインストールされている必要がある。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Last modified: Wed Aug 28 17:52:03 MST 2002 by &lt;a href=&#34;mailto:jeff@crystalclearsoftware.com&#34;&gt;Jeff Garland&lt;/a&gt; © 2000-2002 &lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:sshino@cppll.jp&#34;&gt;Shoji Shinohara&lt;/a&gt;.&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon</name>
        <email>melt@e-ml.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>Negators -- 不正なリンクを解消</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html"/>
      <id>738a312268b17912e7d754acfa635e9de3173ba7:archive/boost_docs/libs/functional/negators.md</id>
      <updated>2015-01-19 23:02:36 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Negators&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.5) 由来のネゲータアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binary_negate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;not1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このライブラリのネゲータは標準バージョンを二つの方法で改良する。&lt;/p&gt;
&lt;p&gt;適合関数オブジェクトではなく関数を否定する時、それらは &lt;code&gt;ptr_fun&lt;/code&gt; の必要を回避するために、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を用いる。&lt;/p&gt;
&lt;p&gt;それらは引数や適合された関数に渡す引数を宣言する最上の方法を決するため、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;call traits&lt;/a&gt; を用いる。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34;&gt;下記&lt;/a&gt;参照)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い型は標準ネゲータと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++ 標準 (§20.3.5) は unary negate をこのように定義 している。(binary negate も似ている):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type,&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; unary_negate(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; pred);
  &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であった場合、 &lt;code&gt;operator()&lt;/code&gt; の引数の型は参照の参照になることに注意しなさい。これは、現在の C++ では非合法である。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;しかしながら、もし代わりに &lt;code&gt;operator()&lt;/code&gt; を &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; を変更せずにそのまま採用して定義すると、それが値型であった場合不必要に非効率になってしまう。それは引数が二度コピーされることによる。一度は &lt;code&gt;unary_negate&lt;/code&gt; の &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時、さらに適合された関数で &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時にもう一度である。&lt;/p&gt;
&lt;p&gt;つまり&lt;code&gt;operator()&lt;/code&gt; を宣言する望ましい方法は、 &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であるか否かに依 る。もしそれが参照であれば、単純に &lt;code&gt;argument_type&lt;/code&gt; として宣言したいし、それが値であれば &lt;code&gt;const argument_type&amp;amp;&lt;/code&gt; として宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特 殊化版を用いて正確にこの判断を行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。実のところ、実際の宣言は関数オブジェクト特性を使うためもう少し複雑である。しかし効果は同様である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;この関数オブジェクト特性の両方と call traits はこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化版の機能を持つコンパイラでのみ有効である。 そうでないコンパイラでは、このライブラリのネゲータは標準内のそれらと非常に似た振る舞いをする - 関数に適合するために &lt;code&gt;ptr_fun&lt;/code&gt; が必要であるし、参照の参照は避けられないだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon</name>
        <email>melt@e-ml.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>ジェネリックコンポーネントにおける例外安全性 -- 不正なリンクを解消</title>
      <link href="http://boostjp.github.io/archive/boost_docs/document/generic_exception_safety.html"/>
      <id>e9236caa98d749eefe1bafbc33e247f2cba1afa1:archive/boost_docs/document/generic_exception_safety.md</id>
      <updated>2015-01-19 23:01:30 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ジェネリックコンポーネントにおける例外安全性&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;C++標準ライブラリのために規定した例外安全性の経験から学んだこと&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;David Abrahams&lt;/li&gt;
&lt;li&gt;david.abrahams@rcn.com&lt;/li&gt;
&lt;li&gt;翻訳元：&lt;a href=&#34;http://www.boost.org/community/exception_safety.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/community/exception_safety.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;この文書は実世界の必要性に対する応答の中で蓄積された知識を表す: つまり、 C++ 標準テンプレートライブラリは、役立つ、そして明確な例外との相互作用を示し、 エラー捕捉の機構は C++ 言語の中核に組み込まれている。 この文書では、例外安全性の意味を探求し、例外と汎用性についての驚くべき神話を明らかにし、 プログラムの正当性を理由付けるための価値ある道具について述べ、 例外安全性を実証するための自動化されたテストの手続きを概説する。&lt;/p&gt;
&lt;p&gt;Keywords: exception-safety, exceptions, STL, C++&lt;/p&gt;
&lt;h2&gt;1 例外安全性とは何か&lt;/h2&gt;
&lt;p&gt;簡単に言えば、コンポーネントの例外安全性とは、 実行中に例外が投げられたとき、正当な振る舞いを示すことを意味する。 ほとんどの人にとって、「正当な」という用語は、エラー捕捉に対する通常の例外全てを含む: つまり、資源は漏れるべきではないし、プログラムは実行を継続できるように、 明確な状態であり続けるべきである。多くのコンポーネントにとって、 これはまた、エラーに出会った時に呼び出し元に報告されるような例外も含む。&lt;/p&gt;
&lt;p&gt;より公式に言えば、コンポーネントの中から例外が投げられたときに、 もしその不変性が損なわれないなら、そのコンポーネントは最小限の例外安全性を持っていると言える。 後に見るが、通常、少なくとも3種類の異なる例外安全性が区別されている。 これらの区別は巨大なシステムの振る舞いについて記述し、理由付けるのに役立つのである。&lt;/p&gt;
&lt;p&gt;汎用コンポーネントでは、通常我々は、さらに、 &lt;strong&gt;例外中立性&lt;/strong&gt; という期待をもつ。 これは、コンポーネントの型パラメータによって投げられた例外は、 そのコンポーネントの呼び出し元まで、変わることなく伝えられるべきである、 ということを意味する。&lt;/p&gt;
&lt;h2&gt;2 神話と迷信&lt;/h2&gt;
&lt;p&gt;例外安全性は、これまでのところ簡単なものに見える: それは、より伝統的なエラー捕捉の技術を使ったコードに期待する以上のことを、 何も構築したりはしない。しかし、心理学的な観点からこの用語を調べてみることは、価値があるだろう。 C++ が例外を持つ以前は、誰も「エラー安全性」について語らなかった。&lt;/p&gt;
&lt;p&gt;まるで例外は、正しいコードに対する &lt;strong&gt;ミステリアスな攻撃&lt;/strong&gt; であり、 我々が自らをその攻撃から守らなければいけないようなものであると見なされているかのようである。 言うまでもなく、これはエラー捕捉との健全な関係に繋がらない! 標準化の間、変更に対する幅広いサポートを要求する民主的な過程で、 私は広く支持された多くの迷信に出会った。 汎用コンポーネントにおける例外安全性の議論を始めるために、 それらのいくつかを見ておくことは意味のあることだろう。&lt;/p&gt;
&lt;p&gt;「テンプレートと例外の相互作用は、良く理解できない。」 これら両方が言語の新しい特徴であると考える人々から良く聞かれるこの神話は、 簡単に却下できる: そこには、相互作用はないのである。 テンプレートは、一度実体化されれば、全ての面で通常のクラスや関数と同じように機能する。 例外と関連したテンプレートの振る舞いを考えるための単純な方法は、 そのテンプレートの特別版の実体化がどう機能するかについて考えることである。 最後に、テンプレートの汎用性は、何も特別なことを引き起こさない。 コンポーネントのクライアントは操作の一部を提供するが(この操作は、もし特別版でないなら、 任意の例外を投げるだろう)、我々が良く親しんだ仮想関数や、 単純な関数ポインタを使った操作についても、同じことなのである。&lt;/p&gt;
&lt;p&gt;「例外安全性をもつ汎用コンテナを書くのが不可能であることは、 良く知られている」 この主張は、Tom Cargill による文書、 [^4] に関連してよく聞かれる。そこで彼は、汎用スタックテンプレートに対する例外安全性の問題について探求している。 彼の文書で、 Cargill は多くの役立つ問題を掲げているが、 残念ながらそれらの問題に対する解決法を提供できていない。彼は解決は不可能である、と提案して結論付けている。不幸にも彼の文書は、 多くの人に、そのような空論の 「証拠」 として読まれてしまった。 しかしこの文書が出版されてから、例外安全な汎用コンテナの多くの実例があったのである。 C++ 標準ライブラリコンテナもその中にはいる。&lt;/p&gt;
&lt;p&gt;「例外を扱うとコードは遅くなり、テンプレートは本質的に 可能な限りのパフォーマンスを得るために使われる。」 C++ の優れた実装は、例外が投げられるまでにその例外を扱うひとつの命令サイクルを費やすことはしないで、 例外は関数呼び出しの同じようなスピードで捕捉可能である [^7]。 それだけで、例外を使ったプログラムに、 エラーの可能性を無視したプログラムと同等のパフォーマンスを提供している。 例外を使うと実際は、結果的に別の理由で「伝統的な」エラー捕捉の方法よりも早くなる。 まず、 catch 節はコンパイラに、どのコードがエラー捕捉に費やされるかを明確に示す。 このため、通常の実行パスから分離することが可能であり、参照の局所性が改善する。 次に、「伝統的な」エラー捕捉を使ったコードは典型的に、単一の関数を呼び出した後、いつも返り値を検査しなければならない。 例外を使えば、このオーバヘッドは完全に消える。&lt;/p&gt;
&lt;p&gt;「例外はプログラムの振る舞いを推論することを難しくしてしまう」 通常、この神話が支持されて引用されるのは、 スタック巻き戻しの間に「隠れた」実行パスを通る、という意味においてである。 隠れた実行パスはローカル変数が関数から戻る前に破棄されることを期待している C++ プログラマにとっては、なにも新しいものではない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;ErrorCode &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;( &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; result )         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1 &lt;/span&gt;
{                                  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2 &lt;/span&gt;
    X x;                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3 &lt;/span&gt;
    ErrorCode err &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.g( result ); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4 &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( err &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; kNoError )         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5 &lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; err;                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 6 &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...More code here... &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; kNoError;               &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 7 &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;上の例では、6行目と7行目に &lt;code&gt;X::~X&lt;/code&gt; の「隠れた」呼び出しがある。 そう考えれば、例外を使うことで、エラー捕捉に対して、明白なコードの無駄は存在しない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;f&lt;/span&gt;()                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1 &lt;/span&gt;
{                       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2 &lt;/span&gt;
    X x;                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3 &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; result &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; x.g(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4 &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...More code here... &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; result;      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5 &lt;/span&gt;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;例外をより良く知っている多くのプログラマにとって、2番目の例は実際は最初の例よりも、 読みやすく理解しやすい。 「隠れた」コードパスは同じくローカル変数のデストラクタを呼び出している。 更にこれは、冷害が起こった場合にそれぞれの関数呼び出しの後に、 潜在的なリターン文があるかのような、正確に振る舞う単純なパターンに従うのである。 通常の実行パスはエラー捕捉によって分かりにくくならないので、可読性は向上し、 返り値は自然なやり方で使えるように解放されるのである。 例外が正確さを向上することが出来る、さらに重要なやり方がある: それは、 単純なクラス不変性を可能にすることによる。 最初の例では、もし &lt;code&gt;X&lt;/code&gt; のコンストラクタが資源を確保する必要があるなら、 失敗を報告する手だてはない: C++ ではコンストラクタは返り値を持てないからである。 例外を使わない場合は通常、資源を要求するクラスが構築の仕事を完了する、 別の初期化関数を含まなければならない、という結果になる。 プログラマはそのため、クラス &lt;code&gt;X&lt;/code&gt; のオブジェクトが使われるとき、 完全な &lt;code&gt;X&lt;/code&gt; を手にしたのか、それともどこかで構築に失敗したものを手にしたのか、 決して確信をもてない(或いは更に悪いことに、誰かが単に初期化関数を呼び忘れたのかもしれない。)&lt;/p&gt;
&lt;h2&gt;3 例外安全性の契約的原則&lt;/h2&gt;
&lt;p&gt;非汎用的なコンポーネントは例外安全として記述することが出来るが、 汎用的なコンポーネントの場合は、クライアントによる構造化が可能なので、 例外安全性は通常、コンポーネントとクライアントの契約に依存する。 例えば、汎用的コンポーネントの設計者はコンポーネントのデストラクタで使われる演算が、 どんな例外も投げないことを要求するだろう。汎用的コンポーネントはその代わり、次の保証のうちのひとつを提供するだろう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本的保証&lt;/strong&gt; : コンポーネントの不変性は保持され、資源漏れはない。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;強い保証&lt;/strong&gt; : 演算は成功して完了するか、例外を投げるかのどちらかである。 例外を投げる場合、プログラムの状態は演算が始まる前の状態と全く同じである。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例外不送出保証&lt;/strong&gt; : 演算は例外を投げない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基本的保証&lt;/strong&gt; は、全てのコンポーネントに負わせることの出来る、 例外安全性に対する単純で最小限の基準である。 例外の後でもまだコンポーネントは以前のように使うことが出来ると述べているに過ぎない。 重要なことだが、不変性の保持によって、スタック巻き戻しの一部として潜在的に、 コンポーネントを破棄することが出来るのである。 この保証は実際には、見た目ほど役立つものではない。 もしコンポーネントが多くの有効状態を持つなら、例外の後にコンポーネントの状態が、 またはその状態だけが有効な状態なのかどうか知ることは出来ない。 この場合、回復のための選択肢は限られている: コンポーネントの破棄か、 さらに使う前に、ある既知の状態にコンポーネントをリセットするかである。 次の例を考えてみよう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; print_random_sequence() 
{ 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// A vector of 10 items &lt;/span&gt;
    try { 
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Provides only the basic guarantee &lt;/span&gt;
        v.insert( v.begin(), X() ); 
    } 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...) {} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ignore any exceptions above &lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// print the vector&#39;s contents &lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v.size() &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;) &#34;&lt;/span&gt;; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;copy( v.begin(), v.end(), 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;( std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; &#34;&lt;/span&gt; ) ); 
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々はみんな、例外後に v が有効であることを知っているので、 この関数は &lt;code&gt;X&lt;/code&gt; のどんなランダムなシーケンスでも出力することが出来る。これはクラッシュしないと言う意味で「安全」ではあるが、出力の内容は予想できないものである。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;強い保証&lt;/strong&gt; は、「責任を持つか、巻き戻すか」という意味論を完全に提供する。 C++ 標準コンテナの場合、これは例えばもし例外が投げられても全てのイテレータは有効なままであることを意味する。 我々はまた、コンテナが例外が投げられる前と全く同じ要素を持っていることも知っている。 失敗したら、なんの効果も及ぼさない処理は、明らかに利点がある: 例外が発生した場合でも、 プログラムの状態は単純で予測可能なのである。 C++ 標準ライブラリでは、ノードを使うコンテナ、&lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;multiset&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;multimap&lt;/code&gt; のほとんど全ての演算が強い保証を提供している。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例外不送出保証&lt;/strong&gt; は最も強いものであり、演算は例外を投げないことを保証されている、 というものである: これは常に成功して完了する。 この保証はほとんどのデストラクタにとって必要なものであり、 C++ 標準ライブラリコンポーネントのデストラクタは実際にすべて、 例外を投げないことを保証されている。 例外不送出保証、他の理由で重要となることを我々は見るだろう。&lt;/p&gt;
&lt;h2&gt;4 法的論争&lt;/h2&gt;
&lt;p&gt;契約がより複雑になることは避けられない: その代わり整理することが可能である。 C++ 標準ライブラリには、任意の型引数にひとつの保証を与え、 例外を投げないというクライアント型からの約束が追加されれれば、より強い保証を与えているものもある。 例えば、標準コンテナ操作 &lt;code&gt;vector&amp;lt;T&amp;gt;::erase&lt;/code&gt; はどんな &lt;code&gt;T&lt;/code&gt; にも &lt;strong&gt;基本的保証&lt;/strong&gt; を与えるが、コピーコンストラクタとコピー代入演算子が例外を投げないなら、 &lt;strong&gt;例外不送出保証&lt;/strong&gt; を与えている。&lt;/p&gt;
&lt;h2&gt;5 コンポーネントはどのレベルの例外安全性を規定する必要があるか&lt;/h2&gt;
&lt;p&gt;クライアントの観点から、可能な限り最も強いレベルの安全性が理想的である。 もちろん &lt;strong&gt;例外不送出保証&lt;/strong&gt; は多くの演算に対して不可能であるが、 強い保証についてはどうだろうか? 例えば、 &lt;code&gt;vector&amp;lt;T&amp;gt;::insert&lt;/code&gt; に対してちょっとした振る舞いが欲しいと仮定しよう。  &lt;code&gt;vector&lt;/code&gt; の中間への挿入は、新しい要素のための場所を作るために、 挿入点以降の要素を、次の位置にコピーする必要がある。 もし要素のコピーが失敗に終われば、操作の巻き戻しは既に行われたコピーの「取り消し」を必要とする。&lt;/p&gt;
&lt;p&gt;ひとつの可能な選択肢は、新しい配列の内容を、毎回新しいメモリで構築して、 成功したときのみ古い内容を破棄するように &lt;code&gt;insert&lt;/code&gt; を再定義することである。 残念ながら、このアプローチにはコストがかかる: &lt;code&gt;vector&lt;/code&gt; の終端付近での挿入は、 以前ではほとんどコピーを行う必要がなかったが、 このアプローチでは全ての要素をコピーしなければいけない。 &lt;strong&gt;基本的保証&lt;/strong&gt; はこの操作に対する「自然な」水準の安全性である。 パフォーマンスを脅かすことなく保証を与えているのである。 実際ライブラリの全ての演算は、層のような「自然な」水準の安全性を提供している。&lt;/p&gt;
&lt;p&gt;パフォーマンスの要求は基準の草案の中では、確立した部分であり、 パフォーマンスは STL の基本的な目的であるので、 これらの要求の中で提供されうる、より強い安全性を明記する試みは為されなかった。 全てのライブラリが &lt;strong&gt;強い保証&lt;/strong&gt; を与えているわけではないが、 &lt;strong&gt;基本的保証&lt;/strong&gt; を提供する、標準コンテナほとんどの演算は、上に述べた、 「新たなコピーを作る」という戦略を使うことで、強い保証を持つことが出来る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Container&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BasicOp&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; MakeOperationStrong( Container&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; c, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; BasicOp&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; op ) 
{ 
    Container tmp(c); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Copy c &lt;/span&gt;
    op(tmp); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Work on the copy &lt;/span&gt;
    c.swap(tmp); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Cannot fail&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この技は、より強い保証を提供する(そして異なるパフォーマンス特性を提供する)、 似たようなコンテナを作るためのラッパクラスに導入することが出来る。&lt;/p&gt;
&lt;h2&gt;6 私たちは、私たちが得ることができる全てを得るべきか&lt;/h2&gt;
&lt;p&gt;特殊な実装を考えれば、安全性についての自然な水準を判断することを望めるだろう。 コンポーネントに対する要求を確立するのにこれを使うことで、 実装が制限されるという危険性が生じる。 我々が使いたくなるような、より効率的な実装を誰かが作り上げても、 それが我々の持つ例外安全性への要求を満たしていないことに気づくかもしれない。 STL が扱っているデータ構造とアルゴリズムという、よく研究された領域では、 このようなことに誰も期待を寄せないかもしれないが、 それでも実際、より優れたものが作られている。最近の &lt;strong&gt;introsort&lt;/strong&gt; アルゴリズムは、その良い例である [^6]。 これは、既に確立した &lt;strong&gt;quicksort&lt;/strong&gt; に対して、最悪の計算量を必要とするような場合での、 大幅な改善を示している。 実際に標準コンポーネントの要求がどの程度のものなのかを決定するために、 実世界の典型的な場合を考えた。 選ばれたテストケースは 「合成コンテナ」である。 2つ以上の標準コンテナの合成である、そのコンテナは広く必要とされているだけでなく、 巨大なシステムで不変性を維持することについての単純で代表的な事例である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// SearchableStack - A stack which can be efficiently searched &lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// for any value. &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SearchableStack&lt;/span&gt; 
{ 
 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; 
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; push(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t);           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;pop&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; contains(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(log n) &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; top() &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// O(1) &lt;/span&gt;
 &lt;span style=&#34;color: #A0A000&#34;&gt;private:&lt;/span&gt; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; set_impl; 
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; list_impl; 
}; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここでは、&lt;code&gt;list&lt;/code&gt; は &lt;code&gt;set&lt;/code&gt; のイテレータのスタックとして振る舞う: 全ての要素は最初に &lt;code&gt;set&lt;/code&gt; に入り、その結果その位置が &lt;code&gt;list&lt;/code&gt; に入れられる。 不変性というのは、簡単なことである: &lt;code&gt;set&lt;/code&gt; と &lt;code&gt;list&lt;/code&gt; は常に、 同じ要素数を持ち、&lt;code&gt;set&lt;/code&gt; 全ての要素は &lt;code&gt;list&lt;/code&gt; の要素により参照されている、ということである。 以下の &lt;code&gt;push&lt;/code&gt; 関数の実装は、 &lt;code&gt;set&lt;/code&gt; と &lt;code&gt;list&lt;/code&gt; によって提供される自然な水準の例外安全性で、 &lt;strong&gt;強い保証&lt;/strong&gt; を提供するために設計されたものである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;                                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 1&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; SearchableStack&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;push(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; t)         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2&lt;/span&gt;
{                                                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 3&lt;/span&gt;
    set&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; set_impl.insert(t);      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 4&lt;/span&gt;
    try                                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 5&lt;/span&gt;
    {                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 6&lt;/span&gt;
        list_impl.push_back(i);                   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 7&lt;/span&gt;
    }                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 8&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...)                                    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 9&lt;/span&gt;
    {                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 10&lt;/span&gt;
        set_impl.erase(i);                        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 11&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;throw&lt;/span&gt;;                                    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 12&lt;/span&gt;
    }                                             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 13&lt;/span&gt;
}                                                 &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このコードは実際に、ライブラリの何を要求するだろうか? 非 &lt;code&gt;const&lt;/code&gt; 演算が行われる行を調べてみる必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4行目: 挿入が失敗したが、 &lt;code&gt;set_impl&lt;/code&gt;がその過程で変更されている場合、 不変性は保たれない。そこで、&lt;code&gt;set&amp;lt;T&amp;gt;::insert&lt;/code&gt; からの &lt;strong&gt;強い保証&lt;/strong&gt; に頼ることが出来なければならない。&lt;/li&gt;
&lt;li&gt;7行目: 同様に &lt;code&gt;push_back&lt;/code&gt; が失敗して &lt;code&gt;list_impl&lt;/code&gt; がその過程で変更されているなら、不変性は保たれない。 そこで、&lt;code&gt;list&amp;lt;T&amp;gt;::insert&lt;/code&gt; からの &lt;strong&gt;強い保証&lt;/strong&gt; に頼ることが出来なければならない。&lt;/li&gt;
&lt;li&gt;11行目: ここで4行目の挿入を「巻き戻し」ている。もしこの操作が失敗すれば、 不変性を回復することは出来ないだろう。結局 &lt;code&gt;set&amp;lt;T&amp;gt;::erase&lt;/code&gt; からの &lt;strong&gt;例外不送出保証&lt;/strong&gt; に頼ることになる。&lt;/li&gt;
&lt;li&gt;11行目: 同じ理由で、 &lt;code&gt;i&lt;/code&gt; を &lt;code&gt;erase&lt;/code&gt; 関数に渡すことが出来るということにも、 頼らなければならない: &lt;code&gt;set&amp;lt;T&amp;gt;::iterator&lt;/code&gt; からの、 &lt;strong&gt;例外不送出保証&lt;/strong&gt; に頼る必要があるのである。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は標準化の際にこの方法で問題を扱うことで、多くを学んだ。 まず、合成コンテナに対して明示された保証は、実際はそのコンポーネントからのより強い保証 (11行目の &lt;strong&gt;例外不送出保証&lt;/strong&gt; )に依存するということである。 また、この単純な例を実装するために、自然な水準の例外安全性を全ての面で利用した。 そして、この分析は、以前私が、演算をそれぞれ独立したものと考えていたときには見逃していた、 イテレータへの要求を明らかにした。 結論は、可能な限り自然な水準の例外安全性を提供すべきだ、ということである。 より速く、しかしより安全ではない実装は常に、標準コンポーネントの拡張として提供されるべきである。&lt;/p&gt;
&lt;h2&gt;7 例外安全性の自動テスト&lt;/h2&gt;
&lt;p&gt;標準化の過程の一部として、私は STL での例外安全な参照の実装を作った。 エラー捕捉コードは実際にかなり厳密にテストされたが、 エラー状態を起こすことが難しいので、そのテストは部分的である。 初めて実行されたときにクラッシュしたエラー捕捉コードを考えるというのは、 とても一般的である-出荷される製品では。実装が実際に宣伝通りに動くという確信を強めるために、 私は自動化されたテストスイートを設計した。これは同僚の Matt Arnold の精緻な技術に基づいている。&lt;/p&gt;
&lt;p&gt;テストプログラムは基本的なところから始まった: 特にグローバル演算子 &lt;code&gt;new&lt;/code&gt; と&lt;code&gt;delete&lt;/code&gt;についての強化と計測である。 出来る限り多くの潜在的な問題を明らかにするために選ばれた型引数で、 コンポーネント(コンテナとアルゴリズム)の実体が作られた。 例えば、全ての型引数にはヒープ領域にメモリを割り当てられるポインタが与えられた。 そのため、コンテナに格納されたオブジェクトをリークさせることは、 メモリリークとして検出された。&lt;/p&gt;
&lt;p&gt;最後に、ポインタが間違って示す可能性のある場合に、その都度、 演算に例外を投げさせることが出来るような仕組みを設計した。 クライアントが提供し、例外を投げることが許されている全ての演算の最初に、 &lt;code&gt;ThisCanThrow&lt;/code&gt; の呼び出しが加えられた。 &lt;code&gt;ThisCanThrow&lt;/code&gt; の呼び出しはまた、 テストされる汎用的演算が例外を投げるかもしれない全ての場所にも加えられた。 例えば、より機能を強化したものに置き換えられた、グローバル演算子 &lt;code&gt;new&lt;/code&gt; である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Use this as a type parameter, e.g. vector&amp;lt;TestClass&amp;gt; &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; TestClass 
{ 
    TestClass( &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; ) 
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; p( ThisCanThrow(), &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;( v ) ) {} 
    TestClass( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; p( ThisCanThrow(), &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;( &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p ) ) {} 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        { ThisCanThrow(); &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p; } 
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt;( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; TestClass&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; rhs ) 
        { ThisCanThrow(); &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;rhs.p; } 
    ...etc... 
    &lt;span style=&#34;color: #666666&#34;&gt;~&lt;/span&gt;TestClass() { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;delete&lt;/span&gt; p; } 
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThisCanThrow&lt;/code&gt; は単に、「throw カウンタ」をデクリメントするだけであり、 もしそれが &lt;code&gt;0&lt;/code&gt; になったら、例外を投げる。 テスト毎に、外側のループで、徐々に大きな値にカウンターを設定して開始し、 演算のテストが完了するまで繰り返し試す、という形を取った。 結果は、失敗する可能性がある実行パスに沿って、連続的なステップで、オペレーションが例外を投げた。 例えば、 &lt;strong&gt;強い保証&lt;/strong&gt; をテストするのに使われた関数の単純なバージョンがある:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; gThrowCounter; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// The throw counter&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;ThisCanThrow&lt;/span&gt;() 
{ 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (gThrowCounter&lt;span style=&#34;color: #666666&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) 
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; 
} 

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Operation&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; StrongCheck(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; op) 
{ 
    &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; succeeded &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;false&lt;/span&gt;; 
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;long&lt;/span&gt; nextThrowCount &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;succeeded; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;nextThrowCount) 
    { 
        Value duplicate &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; v; 
        try 
        { 
            gThrowCounter &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; nextThrowCount; 
            op( duplicate ); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Try the operation &lt;/span&gt;
            succeeded &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; 
        } 
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;catch&lt;/span&gt;(...) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Catch all exceptions &lt;/span&gt;
        { 
            &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; unchanged &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; duplicate &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; v; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Test strong guarantee &lt;/span&gt;
            assert( unchanged ); 
        } 
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Specialize as desired for each container type, to check &lt;/span&gt;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// integrity. For example, size() == distance(begin(),end()) &lt;/span&gt;
        CheckInvariant(v); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Check any invariant &lt;/span&gt;
    } 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;注意すべきは、この種のテストは非汎用的なコンポーネントより、汎用的なものの方が 遙かに簡単で、煩わしさのないものである、ということである。 これは、テストに特化した型引数を、 テストされるコンポーネントのソースコードを変更することなく使うことが出来るからである。 また上の &lt;code&gt;StrongCheck&lt;/code&gt; のような汎用関数が広範な値と演算のテストを行うのに役立つ。&lt;/p&gt;
&lt;h2&gt;8 さらにくわしく知るための資料&lt;/h2&gt;
&lt;p&gt;私が知る限り、現在 STL の利用可能な例外安全性には2種類の記述しかない。 STL の例外安全の実装のリファレンスでの、オリジナルの仕様 [^2] は、非公式な仕様であり、単純で自明(そして冗長)である。 そこでは、この文書で概説してきた、基本的と強い保証の区別が使われている。 それは明らかに、資源漏れを禁止していて、最終的な C++ 標準と比べ、多くの面で同じなのだが、 保証という点では実質的に異なる。 私はこの文書の改訂版が速やかに作られることを望んでいる。 C++ 標準での例外安全性の記述[^1] はほんの少しだけ公式なものであるが、読みにくい「規格化」 で構成されていて、ウェブ上ではほとんど見ることが出来ない。とくに、資源漏れについては直接は全く扱われていない。 それが規格であるという利点を持っているに過ぎない。&lt;/p&gt;
&lt;p&gt;例外安全の実装[^5] に関するオリジナルのリファレンスは、SGI STL の古いバージョンである。 これは限られた能力の C++ コンパイラのために設計された。 これは完全な STL の実装ではないが、コードは読みやすいし、 役立つ基底クラスのテクニックを、コンストラクタでの例外捕捉をなくすために説明している。 参照の実装を検証するために使われた完全なテストスイート[^3] は、引き続き SGI STL の最近のバージョン全てで使われている。 そして他のベンダの実装をテスト(通らなかった)するのにも使われている。 文書で注記されているように、それは隠れたコンパイラのバグを明らかにするのに、特に最適化と例外捕捉コードが相互作用するような場所では、強力であるだろう。&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;International Standard ISO/IEC 14882, Information Technology-Programming Languages-C++, Document Number ISO/IEC 14882-1998, available from &lt;a href=&#34;http://webstore.ansi.org/ansidocstore/default.asp&#34; target=&#34;_blank&#34;&gt;http://webstore.ansi.org/ansidocstore/default.asp&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. Abrahams, Exception Safety in STLport, available at &lt;a href=&#34;http://www.stlport.org/doc/exception_safety.html&#34; target=&#34;_blank&#34;&gt;http://www.stlport.org/doc/exception_safety.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. Abrahams and B. Fomitchev, Exception Handling Test Suite, available at &lt;a href=&#34;http://www.stlport.org/doc/eh_testsuite.html&#34; target=&#34;_blank&#34;&gt;http://www.stlport.org/doc/eh_testsuite.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Tom Cargill, &#34;Exception Handling: A False Sense of Security,&#34; C++ Report, Nov-Dec 1994, also available at &lt;a href=&#34;http://www.awl.com/cp/mec++-cargill.html&#34; target=&#34;_blank&#34;&gt;http://www.awl.com/cp/mec++-cargill.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;B. Fomitchev, Adapted SGI STL Version 1.0, with exception handling code by D. Abrahams, available at &lt;a href=&#34;http://www.metabyte.com/~fbp/stl/old.html&#34; target=&#34;_blank&#34;&gt;http://www.metabyte.com/~fbp/stl/old.html&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;D. R. Musser, &#34;Introspective Sorting and Selection Algorithms,&#34; Software-Practice and Experience 27(8):983-993, 1997.&lt;/li&gt;
&lt;li&gt;Bjarne Stroustrup, The Design And Evolution of C++. Addison Wesley, Reading, MA, 1995, ISBN 0-201-54330-3, Section 16.9.1.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;脚注&lt;/h2&gt;
&lt;p&gt;[^1]: おそらく Cargill の場合、解決に対する最も大きな障害は、 彼が、不幸な組み合わせの選択をしてしまったということであった: 彼がコンテナのために選んだインタフェースは、彼が要求する安全性の特徴と一致しないものだったのだ。 どちらかを変更すれば、彼は問題を解決できただろう。&lt;/p&gt;
&lt;p&gt;[^2]: C++ でデストラクタから例外が投げられることは通常進められない。 デストラクタは、それ自身他の例外によって引き起こされるスタック巻き戻しの途中で呼び出されるかもしれないからである。 2番目の例外がデストラクタを越えて伝えられることが可能なら、 問題はすぐに解決する。&lt;/p&gt;
&lt;p&gt;[^3]: 実践としては、 この関数はあまりにも貧弱なランダムシーケンス製作器である!&lt;/p&gt;
&lt;p&gt;[^4]: 変更操作を行うアルゴリズムが通常、 &lt;strong&gt;強い保証&lt;/strong&gt; を提供できないことは、 注目に値する: ある範囲の変更された要素を巻き戻すために、 例外を投げるかもしれない &lt;code&gt;operator=&lt;/code&gt; を使って、以前の状態に戻さなければならないのである。 C++ 標準ライブラリでは、この規則はほとんど守られていて、 巻き戻しの振る舞いは破棄だけで成立している: 例外は、&lt;code&gt;uninitialized_copy&lt;/code&gt;, &lt;code&gt;uninitialized_fill&lt;/code&gt;, &lt;code&gt;uninitialized_fill_n&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;[^5]: C++ 標準ライブラリのクライアントが提供する全ての型引数は、 デストラクタが例外を投げないことを要求される。 その代わりに、 C++ 標準ライブラリの全てのコンポーネントは少なくとも &lt;strong&gt;基本的保証&lt;/strong&gt; を提供するのである。&lt;/p&gt;
&lt;p&gt;[^6]: 変更操作を行う多くのアルゴリズムに対して C++ 規格では 似たような整理が為されている。しかし規格化の過程で時間の制約は全く考えられていない。&lt;/p&gt;
&lt;p&gt;[^7]: 要素の &lt;code&gt;Compare&lt;/code&gt; がコピー時に例外を投げるかもしれないような連想コンテナは、この技を使っていない。 スワップ関数が失敗するかもしれないからである。&lt;/p&gt;
&lt;p&gt;[^8]: これは、たびたび望まれ、しかしまだ見知らぬ &lt;code&gt;container_traits&amp;lt;&amp;gt;&lt;/code&gt; テンプレートのもう一つの潜在的な利用を示している。 例外安全性の制約を満たす、コンテナの自動選択である。&lt;/p&gt;
&lt;p&gt;[^9]: &lt;code&gt;set&amp;lt;T&amp;gt;&lt;/code&gt; に対する要求を減らし、 例外時の問題を減らすために、 &lt;code&gt;erase&lt;/code&gt; を &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; ブロックに入れようとするかもしれない。 しかし結局、問題なのである。 まず、&lt;code&gt;erase&lt;/code&gt; は失敗し、この場合必要な結果を産み出すための実行可能な代替案は存在しない。 また、より一般には、型引数が多様なので、汎用コンポーネントにたいして、 どんな選択肢も成功する保証はめったになされるものではない。&lt;/p&gt;
&lt;p&gt;[^10]: STL の設計の有力な哲学は、全ての利用にとって基本的でない機能は、その機能が必要なときに、基本のコンポーネントを適応することで得られる限り、 効率を求めないでいく、ということである。 これはそのような哲学に端を発しているが、 &lt;strong&gt;基本的保証&lt;/strong&gt; でさえ、 既にその保証を持っていない基本のコンポーネントを適応して、そのような保証を得ることは難しいか、不可能である。&lt;/p&gt;
&lt;p&gt;[^11]: メモリシステムをどのようにして守るかについての素晴らしい議論が、 次のものに書かれている: Steve Maguire, Writing Solid Code, Microsoft Press, Redmond, WA, 1993, ISBN 1-55615- 551-4.&lt;/p&gt;
&lt;p&gt;[^12]: この技は、テストされる操作が例外中立であることを必要とすることに注意すること。 もし操作が例外から回復して、処理を続けようとするなら、&lt;code&gt;throw&lt;/code&gt; カウンタは負の値になるだろう。 そしてその後の失敗するかもしれない操作は、例外安全性に対してテストされない。&lt;/p&gt;
&lt;p&gt;[^13]: 例外安全性を導入した規格草案に対する変更は、 変更される単語の数が多いという理由だけで修正が拒否されるような、 草案作成の過程のかなり遅い時期に為された。 不幸にも、この結果、簡潔さを求める余り、ある程度妥協したものとなった。 Greg Colvin はこれらの変更の範囲を最小化するために必要な、 賢い言語-法実務についての責任がある。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon</name>
        <email>melt@e-ml.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>The Boost Concept Check Library (BCCL) -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;The Boost Concept Check Library (BCCL)&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/concept_check/concept_check.htm&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/concept_check/concept_check.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ヘッダーファイル： boost/concept_check.hpp と boost/concept_archetype.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ におけるジェネリック・プログラミングは、抽象データ型(あるいは「コンセプト」)を表現するためにテンプレート・パラメータを使用することを特徴としている。 しかし、C++ 言語には、クラス・テンプレートや関数テンプレートに対して、与えられたテンプレート引数がモデル化（もしくは順応）すべきコンセプトを明確に規定するためのメカニズムがない。 よく利用されているのは、必要とされるコンセプトのヒントとなるようにテンプレート・パラメータを命名し、付属文書においてコンセプトの要求事項を記述する方式である。 残念ながら、こういった要求事項の記述は、往々にして曖昧であったり不正確であったり、まったく存在しないこともある。 あるテンプレートが想定している引数の性質を、そのテンプレートのユーザーが正確に理解できなければ、それは由々しき問題となる。 さらに、以下の問題が起こりうる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不正なテンプレート引数に起因するコンパイラ・エラー・メッセージは、難解になることが多い。 大抵の場合、エラーの示す位置はテンプレートが使用された所ではなく、ユーザーが目にする必要のないテンプレートの実装内である。&lt;/li&gt;
&lt;li&gt;記述された要求事項が、テンプレートのコンセプトを完全に表現し切れていない場合、使用されたテンプレート引数が記述された要求事項を満足していたとしても、コンパイラ・エラーを受ける可能性がある。&lt;/li&gt;
&lt;li&gt;記述された要求事項が、テンプレートが実際に必要とするよりも厳格である場合がある。&lt;/li&gt;
&lt;li&gt;要求事項は、コードの中で明示的に記述されることは無い。 そのために、コードの理解がより困難になる。 さらに、コードと記述された要求事項が同期していない事態も生じる可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost コンセプト・チェック・ライブラリは、次のような手段を提供する：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テンプレート・パラメータのコンパイル時チェックを導入するためのメカニズム。&lt;/li&gt;
&lt;li&gt;コンセプト・チェック用クラスによって、要求事項を明確化するためのフレームワーク。&lt;/li&gt;
&lt;li&gt;コンセプトの要求事項が、該当テンプレートをカバーしていることを確認するためのメカニズム。&lt;/li&gt;
&lt;li&gt;C++ 標準ライブラリのコンセプト要求事項に対応する、コンセプト・チェック用クラスおよび原型クラス一式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このメカニズムは C++ 標準の機能のみを使用し、実行時オーバーヘッドを課さない。 メカニズムを導入するコストは、コンパイル時間の増大のみである。&lt;/p&gt;
&lt;p&gt;クラス・テンプレートや関数テンプレートを記述するプログラマは、全員が通常のコード作成作業の一環としてコンセプト・チェックを含めるべきである。 コンセプト・チェックは、コンポーネントへのインターフェイスとして公開されている、すべてのテンプレート・パラメータに対して導入すべきである。 利用したいコンセプトが標準ライブラリーで用いられているものであれば、BCCL の該当するコンセプト・チェック用クラスを、そのまま使用すればよい。 そうでなければ、新たにコンセプト・チェック用クラスを記述することになるが、普通は数行程度に収まるはずだ。 新しいコンセプトを用いるならば、対応する原型クラスも作成すべきである。原型クラスとはコンセプトを表す最小限のスケルトン実装である。&lt;/p&gt;
&lt;p&gt;この文書を、以下の通り構成する。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating-example&#34;&gt;動機の例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#history&#34;&gt;歴史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#publications&#34;&gt;公開資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;コンセプト・チェックの利用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html&#34;&gt;コンセプトの充当化と原型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;コンセプトを用いたプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html&#34;&gt;コンセプト・チェックの実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt; はこのライブラリを寄稿した。 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/beman_dawes.html&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt; が公式レビューを管理した。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#introduction&#34; name=&#34;introduction&#34;&gt;はじめに&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;コンセプト &#34;concept&#34; とは、ジェネリック・アルゴリズムに対する引数として与えられる型が、アルゴリズム内部で正しく使用されるために満足しなければならない要求事項(有効な式、関連型、セマンティクス不変、計算量保証など)の組み合わせである。 C++ では、コンセプトは関数テンプレート(ジェネリック・アルゴリズム)のテンプレート・パラメータとして表現される。 しかしながら、C++ にはコンセプトを表現するための明示的なメカニズムがない。テンプレート・パラメータはただのプレースホルダでしかないのだ。 慣例として、こういったパラメータには、必要とされるコンセプトに対応する名前を与える。しかし、テンプレート・パラメータを実際の型で確定するときに、C++ コンパイラはコンセプトへの遵守を強要しない。&lt;/p&gt;
&lt;p&gt;当然ながら、ジェネリック・アルゴリズムを、そのコンセプトの内、構文に関わる要求事項を満足していない型で呼び出した場合、コンパイル・エラーが生じる。 しかし、このエラーは、該当する型がコンセプトの要求事項すべてに適合していない事実を本質的に 反映したものではない。 それどころか、エラーはインスタンス化階層の深部で発生し、該当する型に対して式が有効でないか、想定された関連型が利用可能でないといったことが原因として挙げられることになるだろう。 こうして生じたエラーメッセージは、大抵において情報に乏しく、基本的に不可解である。&lt;/p&gt;
&lt;p&gt;必要とされるものは、インスタンス化位置(かその近傍)で「コンセプトセーフ」を強要するためのメカニズムである。 Boost コンセプト・チェック・ライブラリーは、早い段階でコンセプトの遵守を強要し、遵守していない場合のエラー・メッセージをより有用にするために C++ 標準の機能を使用する。&lt;/p&gt;
&lt;p&gt;注意すべき点は、この技術がコンセプトの要求事項のうち構文に関わる部分(有効な式および関連型)のみを扱うことである。 我々は、コンセプトの要求事項の一部であるセマンティクス不変あるいは計算量保証を扱わない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating-example&#34; name=&#34;motivating-example&#34;&gt;動機の例&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;テンプレート・ライブラリの不正な使用法と、その結果生じるエラーメッセージを例証するために単純なサンプルを示す。 下記のコードでは、標準テンプレート・ライブラリー (STL) のジェネリックな &lt;code&gt;std::stable_sort()&lt;/code&gt; アルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#generic-programming-and-the-stl&#34;&gt;3&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#stl-tutorial-and-reference-guide&#34;&gt;4&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#the-standard-template-library&#34;&gt;5&lt;/a&gt;] をリンクリストに適用している。&lt;/p&gt;
&lt;p&gt;bad_error_eg.cpp:&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;list&amp;gt;
#include &amp;lt;algorithm&amp;gt;

int main(int, char*[]) {
    std::list&amp;lt;int&amp;gt; v;
    std::stable_sort(v.begin(), v.end());
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;この場合、&lt;code&gt;std::stable_sort()&lt;/code&gt; アルゴリズムは以下のようなプロトタイプを有する：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIterator first, RandomAccessIterator last);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Gnu C++ でこのコードをコンパイルすると、以下のコンパイラ・エラーを生成する。他のコンパイラ出力は Appendix にリストしてある(訳注 : このバージョンのドキュメントには記載されていない)。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;stl_algo.h: In function `void __merge_sort_loop&amp;lt;_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;,
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int)&#39;:
stl_algo.h:1448:   instantiated from `__merge_sort_with_buffer
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(
   _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;,
   int *, int *)&#39;
stl_algo.h:1485:   instantiated from `__stable_sort_adaptive&amp;lt;
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int&amp;gt;(_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt;, _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, int *, int)&#39;
stl_algo.h:1524:   instantiated from here
stl_algo.h:1377: no match for `_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp; -
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;この場合、根本的なエラーの原因は、&lt;code&gt;std:list::iterator&lt;/code&gt; が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; コンセプトをモデル化していないことにある。 リストのイテレータは双方向でしかなく、(ベクタのイテレータのように) 完全なランダム・アクセスが可能なわけではない。 残念ながら、このエラーメッセージには、ユーザーにこの事実を示すものは何もない。&lt;/p&gt;
&lt;p&gt;C++ プログラマがテンプレート・ライブラリに十分な経験を持っていれば、この手のエラーに惑うことは無いかもしれない。 しかし未熟な者にとっては、次のような理由で、このメッセージが理解し難いものとなっている。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;エラーが生じる位置、bad_error_eg.cpp の６行目は、Gnu C++ がインスタンス化スタックを４レベルも深くまで探索して表示するという事実にもかかわらず、エラーメッセージで示されていない。&lt;/li&gt;
&lt;li&gt;エラーメッセージと、&lt;code&gt;std::stable_sort()&lt;/code&gt; および &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; に関する文書化された要求事項との間に、文面上の相関がない。&lt;/li&gt;
&lt;li&gt;エラーメッセージが過度に長く、ユーザーの知らない(かつ知るべきでない！) STL 内部実装用の関数がリストされている。&lt;/li&gt;
&lt;li&gt;エラーメッセージに、ライブラリ内部の実装用関数が数多くリストアップされているため、プログラマが、エラーの原因は自分のコードではなくライブラリ側にあるとの結論に、誤って飛びついてしまう可能性がある。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;次の例示は、より有用なメッセージとして斯くあるべきと我々が考えるものだ (また実際に Boost コンセプト・チェック・ライブラリが生成するものでもある)。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;boost/concept_check.hpp: In method `void LessThanComparableConcept
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;::constraints()&#39;:
boost/concept_check.hpp:334:   instantiated from `RandomAccessIteratorConcept
  &amp;lt;_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;::constraints()&#39;
bad_error_eg.cpp:6:   instantiated from `stable_sort&amp;lt;_List_iterator
  &amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;gt;(_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;, 
  _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt;)&#39;
boost/concept_check.hpp:209: no match for `_List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;
  &amp;lt; _List_iterator&amp;lt;int,int &amp;amp;,int *&amp;gt; &amp;amp;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このメッセージは、標準的なエラー・メッセージがもつ欠点をいくつかの点で改善する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エラーの生じた位置 (bad_error_eg.cpp:6）がエラーメッセージに明示されている。&lt;/li&gt;
&lt;li&gt;メッセージは、STL 文書に記述されているコンセプト (&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;RandomAccessIterator&lt;/a&gt;) を明示的に言及している。&lt;/li&gt;
&lt;li&gt;エラーメッセージははるかに短くなり、STL の内部実装用関数を露呈しない。&lt;/li&gt;
&lt;li&gt;エラーメッセージの中に concept_check.hpp および &lt;code&gt;constraints()&lt;/code&gt; が示されることで、ライブラリ実装の中にではなくユーザーのコードにエラーがあるという事実をユーザーに警告している。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#history&#34; name=&#34;history&#34;&gt;歴史&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;このコンセプト・チェック・システムの初期バージョンは、著者が SGI において、C++ コンパイラおよびライブラリ・グループの一員として勤務している間に開発された。 初期バージョンは今も SGI STL ディストリビューションの一部である。 Boost コンセプト・チェック・ライブラリは、エラーメッセージにおけるそれほど有用でない表現能力を犠牲にして、コンセプト・チェック用クラス定義を非常に単純化しており、その点で SGI STLのコンセプト・チェックとは異なっている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#publications&#34; name=&#34;publications&#34;&gt;公開資料&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oonumerics.org/tmpw00/&#34; target=&#34;_blank&#34;&gt;C++ テンプレート・ワークショップ2000&lt;/a&gt;、コンセプト・チェック。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;インスタンス化を引き起こすために関数ポインタを使用するアイディアは、Alexander Stepanov に拠る。 テンプレートの事前チェックに式を使用するアイディアに関して、その起源を確認できなかった。しかし、それは D&amp;amp;E[&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#design-and-evolution&#34;&gt;2&lt;/a&gt;] に記載されている。 STL コンセプトに関する優れた文書化と構造化を行った Matt Austern に感謝をささげる。このコンセプト・チェックは彼の仕事を基礎にしている。 有益なコメントとレビューを賜った Boost のメンバにも感謝を。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;次へ：「コンセプト・チェックの利用」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプトの充当化と原型 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/concept_covering.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;コンセプトの充当化と原型&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;これまで、コンポーネントへの入力に対して、最小限の要求事項(コンセプト)を選択することの重要性を議論してきた。 しかし、選択したコンセプトが対象のアルゴリズムを「充当 &#34;cover&#34;」していることを確認するのも、同様に重要である。 すなわち、発生する可能性のあるユーザ・エラーは全てコンセプト・チェックによって漏れなく捕らえられるべきである。 コンセプト充当性は、「原型クラス &#34;archetype class&#34;」を使用することで確認可能だ。 原型クラスとは、特定のコンセプトに関連するインタフェースの正確な実装である。 原型クラスの実行時の振舞いに重要性はなく、そのメンバ関数本体は空文のままでかまわない。 そうすれば、コンポーネントへの入力として原型クラスを与えてコンパイルするだけで、簡単なテスト・プログラムが作成できる。 そのプログラムがコンパイル可能であれば、対応するコンセプトがそのコンポーネントを充当していることが確認できたことになる。&lt;/p&gt;
&lt;p&gt;以下のコードは、&lt;a href=&#34;http://www.sgi.com/tech/stl/trivial.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;TrivialIterator&lt;/code&gt;&lt;/a&gt; コンセプトに対する原型クラスである。 原型が対応するコンセプトと正確に一致していることを保証するために、いくつかの点で注意しなければならないことがある。 例えば、コンセプトは &lt;code&gt;operator*()&lt;/code&gt; の戻り値型が値型に変換可能でなければならない。 だからといって、これはその戻り値型として、より厳格に &lt;code&gt;T&amp;amp;&lt;/code&gt; あるいは &lt;code&gt;const T&amp;amp;&lt;/code&gt; を要求している訳ではない。 それは、原型クラスの戻り値型として &lt;code&gt;T&amp;amp;&lt;/code&gt; あるいは &lt;code&gt;const T&amp;amp;&lt;/code&gt; を使用することが、誤りとなることを意味する。 正しいアプローチは、&lt;code&gt;T&lt;/code&gt; 型に変換可能なユーザー定義の戻り値型を作成することで、この例では &lt;code&gt;input_proxy&lt;/code&gt; として処理している。 原型クラスを用いたテストの妥当性は、完全にコンセプトとの正確な一致に依存しており、それを確認するためには慎重な（人手による）検査を必要とする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; input_proxy {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;() {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; static_object&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;get(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Get a reference without constructing&lt;/span&gt;
  }
};
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;trivial_iterator_archetype&lt;/span&gt;
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; trivial_iterator_archetype self;
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  trivial_iterator_archetype() { }
  trivial_iterator_archetype(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { }
  self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;;  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; self&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;true&lt;/span&gt;; }
  input_proxy&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;() { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; input_proxy&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); }
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; std {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; trivial_iterator_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; T value_type;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ジェネリック・アルゴリズムのテストとして、一般的な複数の入力型に対してインスタンスの生成を行う場合が往々にしてある。 一例として、&lt;code&gt;std::stable_sort()&lt;/code&gt; に対して、イテレータとして組み込みのポインタ型を適用することが考えられる。 これは、アルゴリズムの実行時の振る舞いをテストするには適切であるが、コンセプト充当性の保証には有用ではない。 なぜなら、C++ の組み込み型は特定のコンセプトとー致を見ることは決してなく、たいていの場合、それが提供する機能は何らかのコンセプトが単独で必要とする最小のそれを上回っている。 すなわち、たとえ与えられた型で関数テンプレートがコンパイルできたとしても、そのコンセプトの要求事項は、その関数を充当する実際の要求事項に及ばないことがありうる。 それ故に、一般的な入力型でテストすることに加えて、原型クラスでコンパイルすることは重要である。&lt;/p&gt;
&lt;p&gt;以下は、記載されている &lt;a href=&#34;http://cpprefjp.github.io/reference/algorithm/stable_sort.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::stable_sort()&lt;/code&gt;&lt;/a&gt; の要求事項をチェックするために原型を使用する方法を示す、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/stl_concept_covering.cpp.html&#34;&gt;stl_concept_covering.cpp&lt;/a&gt; からの抜粋である。 この場合、&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;CopyConstructible&lt;/code&gt;（コピー・コンストラクト可能）&lt;/a&gt; と &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/Assignable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Assignable&lt;/code&gt;（割り当て可能）&lt;/a&gt; 要求事項が、SGI STL 文書から無視されているように見える (試しに、その原型を削除してみるとよい) 。 Boost の原型クラスは、階層構造が取れるように設計されている。 この例において、イテレータの値型は３つの原型から構成される。 下記で参照されている原型クラスでは、&lt;code&gt;Base&lt;/code&gt; という名前のテンプレート・パラメータが、階層化された原型を使用可能であることを示している。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; less_than_comparable_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; 
      sgi_assignable_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ValueType;
  random_access_iterator_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ValueType&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; ri;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;stable_sort(ri, ri);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;次へ：「コンセプトを用いたプログラミング」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;前へ：「コンセプト・チェック用クラスの作成」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェック用クラスの作成 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/creating_concepts.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;コンセプト・チェック用クラスの作成&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;コンセプト・チェック用クラスを作成する方法の例証として、&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; コンセプトに対応するチェック用クラスを作成する方法を考察する。 最初に、命名規約として、コンセプト・チェック用クラスの名前を、対象コンセプトの名称に接尾辞として &#34;Concept&#34; を加えて生成する。 次に、コンセプトにおける有効式を試行する &lt;code&gt;constraints()&lt;/code&gt; という名のメンバ関数を定義しなければならない。 &lt;code&gt;function_requires()&lt;/code&gt; 関数は、この関数のシグネチャが正確に次に示すとおりであることを前提にしている：非 &lt;code&gt;const&lt;/code&gt; メンバ、パラメータ無し、戻り値型 &lt;code&gt;void&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constraints()&lt;/code&gt; 関数の最初の部分は、&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; と、それが基礎を置くコンセプト、&lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; 及び &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;LessThanComparable&lt;/code&gt;&lt;/a&gt; との間にある発展形 &#34;refinement&#34; の関係を表現する要求事項を含んでいる。 そうする代わりに、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロを使用して、クラス本体に要求事項を置くこともできる。しかし、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロは、C++ 言語機能としてはやや移植性に欠けるものを使用しているので、ここでは避けた。&lt;/p&gt;
&lt;p&gt;次に、イテレータの &lt;code&gt;iterator_category&lt;/code&gt; が &lt;code&gt;std::random_access_iterator_tag&lt;/code&gt; あるいはその派生クラスのいずれかであることをチェックする。 その後に、&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; コンセプトにおいて有効な式に当たるコードを書き加える。 &lt;code&gt;typedef&lt;/code&gt; も、関連型のコンセプトを強要するために付加することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; RandomAccessIterator_concept          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//（訳注１）&lt;/span&gt;
  {
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints() {
      function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; BidirectionalIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
      function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; LessThanComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
      function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ConvertibleConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator_category,
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;random_access_iterator_tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

      i &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; n;
      i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; n; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; i;
      i &lt;span style=&#34;color: #666666&#34;&gt;-=&lt;/span&gt; n;
      i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; n;
      n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; j;
      i[n];
    }
    Iter a, b;
    Iter i, j;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;difference_type n;
  };
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;(訳注１：いきなり命名規約に反してますが、ライブラリ内の正式版と被らないためだと思われます。よって、原文のまま。)&lt;/p&gt;
&lt;p&gt;コンセプト・チェック用クラスの設計中に陥りやすい潜在的な落し穴は、&lt;code&gt;constraint()&lt;/code&gt; 関数の中で必要よりも多くの式を使用することである。 例えば、式で必要なオブジェクトを作成するために、意図せずデフォルト・コンストラクタを使用してしまうのは良くあることだ（それに、すべてのコンセプトがデフォルト・コンストラクタを必要とするとは限らない)。 クラスのメンバ関数として我々が制約関数を記述するのは、この理由のためである。 式に関与するオブジェクトは、クラスのデータ・メンバとして宣言する。 制約クラス・テンプレートのオブジェクトはインスタンスとして生成されることは無いので、そのデフォルト・コンストラクタがインスタンス化されることはない。 従って、データ・メンバのデフォルト・コンストラクタもインスタンス化されない (C++ 標準 14.7.1 9)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html&#34;&gt;次へ：「コンセプトの充当化と原型」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html&#34;&gt;前へ：「コンセプト・チェックの利用」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェックの実装 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/implementation.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;コンセプト・チェックの実装&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;理想的には、実体化位置においてコンセプト侵害が捕らえられ、提示されるに及くはない。 D&amp;amp;E &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/bibliography.html#design-and-evolution&#34;&gt;[2]&lt;/a&gt; が言及するように、エラーは、関数テンプレートが必要とする要求事項すべてを試行することにより捕らえることができる。 コードをコンパイルするのみで――一切実行することなく ――済ませたいが故に、要求事項（とくに有効式）を行使する方法は、まさに扱いにくい問題である。 我々のアプローチは、関数ポインタに代入される個別の関数に要求事項を試行させることである。 この場合、コンパイラは関数を実体化するだろうが、実際にそれを起動することはない。 さらに、コンパイラの最適化によって「死んでいるコード」としてポインタ代入は削除されうだろう（代入によって課される実行時オーバヘッドは、どんな場合でも些細であろうが）。 まず第一に、コンパイラが制約関数のセマンティクス解析およびコンパイルをスキップすることは考えられるかもしれない。 そうなれば、関数ポインタ・テクニックは効力を失うだろう。 しかし、不必要なコードおよび関数の除去が、通常はコンパイルの後半の段階で行われるので、これはありそうもない。 関数ポインタ・テクニックは、GNU C++、Microsoft Visual C++、およびいくつかの EDG ベースのコンパイラ（KAI C++、SGI MIPSpro）で問題なく使用できた。 以下のコードは、このテクニックを&lt;code&gt;std::stable_sort()&lt;/code&gt; 関数に適用する方法を示す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort_constraints(RandomAccessIterator i)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;difference_type n;
  i &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; n;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// exercise the requirements for RandomAccessIterator&lt;/span&gt;
  ...
}
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIterator first, RandomAccessIterator last)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;fptr_type)(RandomAccessIterator);
  fptr_type x &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;stable_sort_constraints;
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;多くの場合、確認される必要のある要求事項の集合は多大なものとなる。 また、ライブラリ実装者にとって、すべての公開関数テンプレートのために &lt;code&gt;stable_sort_constraints()&lt;/code&gt; のような制約関数を書くのは煩わしいことだろう。 代わりに、対応するコンセプトの定義に従って、有効式の集合を一まとめにする。 各コンセプトに対して、テンプレート・パラメータがあるところでその型をチェックするために、コンセプト・チェック用クラステンプレートを定義する。 このクラスは、コンセプトの有効式をすべて試行する &lt;code&gt;contraints()&lt;/code&gt; メンバ関数を含んでいる。 &lt;code&gt;n&lt;/code&gt; や &lt;code&gt;i&lt;/code&gt; などのような制約関数の中で使用されるオブジェクトは、コンセプト・チェック用クラスのデータ・メンバとして宣言する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; RandomAccessIterator_concept
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints()
  {
    i &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; n;
    ...
  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;difference_type n;
  Iter i;
  ...
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これでメンバ関数ポインタを扱わなくてはならなくなったが、制約関数の実体化を引き起こすために関数ポインタ・メカニズムを使用することは、依然として可能である。 ライブラリ実装者がコンセプト・チェックを呼出すことを簡便にするために、&lt;code&gt;function_requires()&lt;/code&gt; という名前の関数の中に、メンバ関数ポインタ機構を隠蔽した。 以下のコード片は、イテレータが &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; であることを確かめるために &lt;code&gt;function_requires()&lt;/code&gt; を使用する方法を提示する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(Iter first, Iter last)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; RandomAccessIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;function_requires()&lt;/code&gt; の定義は以下のとおりである。 &lt;code&gt;Concept&lt;/code&gt; は、モデルとなる型によって実体化された、コンセプト・チェック用クラスである。 我々は、関数ポインタ &lt;code&gt;x&lt;/code&gt; に制約メンバ関数のアドレスを代入する。 そうすることで、制約関数の実体化およびコンセプトの有効式のチェックを行うことができる。 それから、変数が未使用であることを示すコンパイラ警告を回避するために、&lt;code&gt;x&lt;/code&gt; へ &lt;code&gt;x&lt;/code&gt; を代入し、名前衝突を防ぐために、全体を do-while ループで包む。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Concept&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; function_requires()
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; (Concept&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;x)() &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; BOOST_FPTR Concept&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;constraints;
  ignore_unused_variable_warning(x);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;クラス・テンプレートの型パラメータをチェックするために、クラス定義本体内で使用できる &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロを提供する（関数では本体内で &lt;code&gt;function_requires()&lt;/code&gt; のみを使用すればよいのと対照的である）。 このマクロは入れ子クラス・テンプレートを宣言し、そのテンプレート・パラメータは関数ポインタである。 それから、&lt;code&gt;typedef&lt;/code&gt; の中で、テンプレート引数として、制約関数への関数ポインタ型を渡して入れ子クラス型を使用する。 名前衝突を防ぐ支援として、入れ子クラスおよび &lt;code&gt;typedef&lt;/code&gt; 名において &lt;code&gt;type_var&lt;/code&gt; と&lt;code&gt;concept&lt;/code&gt;の名前を使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#define BOOST_CLASS_REQUIRE(type_var, ns, concept) \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;  typedef void (ns::concept &amp;lt;type_var&amp;gt;::* func##type_var##concept)(); \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;  template &amp;lt;func##type_var##concept _Tp1&amp;gt; \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;  struct concept_checking_##type_var##concept { }; \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;  typedef concept_checking_##type_var##concept&amp;lt; \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;    BOOST_FPTR ns::concept&amp;lt;type_var&amp;gt;::constraints&amp;gt; \&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;    concept_checking_typedef_##type_var##concept&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;さらに、２つ以上の型の相互作用を必要とするコンセプトを扱うために、より多くの引数をとる &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; のバージョンがある。 コンパイラの中には、関数ポインタ型のテンプレート・パラメータを実装しないものが複数あるため、BCCL コンセプト・チェックの実装においては&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; を使用していない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;次へ：「リファレンス」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html&#34;&gt;前へ：「コンセプトを用いたプログラミング」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Programming with Concepts -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/prog_with_concepts.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Programming with Concepts&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;要求事項をまとめてコンセプトにする方法の決定と、各アルゴリズムで使用するコンセプトを決定する過程は、恐らくジェネリック・ライブラリを構築する上で最も困難な(けれども最も重要な) 段階である。 この過程を勤しむ際に使用する指針を、要求事項最小化原理と呼んでいる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要求事項最小化原理&lt;/strong&gt;：より再利用しやすくなるように、コンポーネントの入力パラメータに対する要求事項を最小限にすること。&lt;/p&gt;
&lt;p&gt;この文言には、相反する問題が含まれている。 定義によれば、コンポーネントは課されたタスクを遂行するために、入力パラメータを使用しなければならない(ここで「コンポーネント」とは、関数テンプレートもしくはクラス・テンプレートを意味する)。 その上で、入力に関する仮定を最小に限定する(最小必要条件)ような方法でコンポーネントを実装することが求められる。&lt;/p&gt;
&lt;p&gt;抽象 という従来からある概念は、最小要求事項というアイディアに直接結び付いている。 入力が抽象的であるほど、要求事項は少なくなる。 よって、コンセプトは、C++ テンプレート・プログラミングにおけるジェネリックな抽象データ型の単純な具象化である。&lt;/p&gt;
&lt;p&gt;ある問題領域に対するコンセプトを設計する場合、すなわち、コンポーネントへの入力に関する要求事項を表現するためには、その目的を念頭においておくことが重要である。 要求事項最小化原理に関しては、これは、コンセプトの極小化を意味する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html#translate-note&#34;&gt;訳注1&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;コンセプトにおける極小性は、表現されている問題領域の基礎的なセマンティックスに関連したプロパティである。 基本コンテナの問題領域では、単一方向へのトラバースを必要とすることは、両方向へ必要とするより小さな要求事項である (つまりは &lt;a href=&#34;http://www.sgi.com/tech/stl/ForwardIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; の相違である) 。 セマンティクスの違いは、前方イテレータを有する具象データ型の集合と、双方向イテレータを持つ集合との間にある差異から、容易に見い出すことができる。 例えば、単方向リンク・リストは、双方向イテレータではなく前方イテレータを有するデータ構造の集合に含まれるだろう。 さらに、前方イテレータだけを使用して実装することができるアルゴリズムの集合は、双方向イテレータ無しにはインプリメントできないアルゴリズム集合とは全く重なることがない。 このために、要求事項の一群をある程度きめ細かくコンセプト別に分類することが重要である。 例えば、イテレータに対する要求事項は、STL における６つのイテレータ・コンセプト(自明、出力、入力、前方、双方向、ランダムアクセス)に分類される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html&#34;&gt;次へ：「コンセプト・チェックの実装」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/concept_covering.html&#34;&gt;前へ：「コンセプトの充当化と原型」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/prog_with_concepts.html#translate-note&#34; name=&#34;translate-note&#34;&gt;訳注1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ここには、重要な論点について記したパラグラフがありましたが、標準との整合性の理由からコメントアウトされています。コメントアウトされた内容を、以下に翻訳引用します：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;以下の文章は、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; の変更された標準定義およびニーズと一致しない。-Jeremy 

しかし、コンセプトの極小化が、コンセプト内で有効式の数を単純に減少させることに直結しないことは重要な注意点である。
例えば、std::stable_sort()関数は、値型のイテレータが &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; を満たすことを必要とするが、このコンセプトは operator&amp;lt;() だけでなく、operator&amp;gt;、operator&amp;lt;=()、operator&amp;gt;=() を含んでいる。
std::stable_sort() は operator&amp;lt;() のみを使用することが判明している。
そうなると、疑問が生じる：
std::stable_sort() の特殊化は、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; コンセプトに基づくべきなのか、あるいはただoperator&amp;lt;() のみを必要とするコンセプトに基づくべきなのだろうか。

operator&amp;lt;() から他の演算子をすべて自明な形で実装できるので、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; を用いても実際には要求事項最小化原理に触れてはいない、とまずは云うことができよう。
ここで「自明」が意味するのは、一行のコードと実行時に課される一定のコストに過ぎない。
とはいえ、より根源的に言えば、全ての比較演算子 (&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt;=) は (数学的な感覚において) 概念的に等価であるから、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; を用いたとしても要求事項最小化原理を犯すことにはならない。
概念的に等価な有効式を加えたとしても、セマンティクスの面からすれば、新しいものはなにも加わっていない――ただ新しい構文だけである――ので、要求事項最小化原理の侵害にはあたらない。
こういった構文の追加は再利用性を高めるのだ。

例えば、結局のところ比較演算子は等価であるから、std::stable_sort() の管理者がいつか operator&amp;lt;() の代わりに operator&amp;gt;() を使用するよう実装を変更するかもしれない。
要求事項は公開インタフェースの一部であるから、そのような変更は潜在的にクライアント・コードを破壊しかねない。
代わりに、&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;LessThanComparable&lt;/a&gt; がstd::stable_sort()の要求事項であれば、管理者がその仕事をこなす際に、妥当な程度の柔軟性を与えられることになる。
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>リファレンス -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/reference.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;リファレンス&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#functions&#34;&gt;関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#macros&#34;&gt;マクロ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#basic-concepts&#34;&gt;基本コンセプト･チェック用クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#iterator-concepts&#34;&gt;イテレータ･コンセプト･チェック用クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#function-object-concepts&#34;&gt;関数オブジェクト・コンセプト･チェック用クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#container-concepts&#34;&gt;コンテナ･コンセプト･チェック用クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#basic-archetype&#34;&gt;基本原型クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#iterator-archetype&#34;&gt;イテレータ原型クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#function-object-archetype&#34;&gt;関数オブジェクト原型クラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#container-archetype&#34;&gt;コンテナ原型クラス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#functions&#34; name=&#34;functions&#34;&gt;関数&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Concept&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; function_requires();
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#macros&#34; name=&#34;macros&#34;&gt;マクロ&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クラス定義内でコンセプト・チェックに適用する&lt;/span&gt;
BOOST_CLASS_REQUIRE(&lt;i&gt;type&lt;/i&gt;, &lt;i&gt;namespace&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;of&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;concept&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRE2(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;namespace&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;of&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;concept&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRE3(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;type&lt;/i&gt;3, &lt;i&gt;namespace&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;of&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;concept&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRE4(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;type&lt;/i&gt;3, &lt;i&gt;type&lt;/i&gt;4, &lt;i&gt;namespace&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;of&lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt;concept&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;推奨されないマクロ：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クラス定義内でコンセプト・チェックに適用する&lt;/span&gt;
BOOST_CLASS_REQUIRES(&lt;i&gt;type&lt;/i&gt;, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRES2(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRES3(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;type&lt;/i&gt;3, &lt;i&gt;concept&lt;/i&gt;);
BOOST_CLASS_REQUIRES4(&lt;i&gt;type&lt;/i&gt;1, &lt;i&gt;type&lt;/i&gt;2, &lt;i&gt;type&lt;/i&gt;3, &lt;i&gt;type&lt;/i&gt;4, &lt;i&gt;concept&lt;/i&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#basic-concepts&#34; name=&#34;basic-concepts&#34;&gt;基本コンセプト・チェック用クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; IntegerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// T は組み込み整数型であるか？&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SignedIntegerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// T は組み込み符号付き整数型であるか？&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; UnsignedIntegerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// T は組み込み符号無し整数型であるか？&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Y&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ConvertibleConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// X は Y へ変換可能か？&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AssignableConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SGIAssignableConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; DefaultConstructibleConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; CopyConstructibleConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 20.1.3 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EqualityComparableConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 20.1.1 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; LessThanComparableConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 20.1.2 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ComparableConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;SGI STL LessThanComparable&lt;/a&gt; コンセプト&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#iterator-concepts&#34; name=&#34;iterator-concepts&#34;&gt;イテレータ･コンセプト･チェック用クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; TrivialIteratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_TrivialIteratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; InputIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.1 Table 72参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; OutputIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.2 Table 73参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ForwardIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.3 Table 74参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_ForwardIteratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BidirectionalIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.4 Table 75参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_BidirectionalIteratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; RandomAccessIteratorConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格24.1.5 Table 76参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_RandomAccessIteratorConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#function-object-concepts&#34; name=&#34;function-object-concepts&#34;&gt;関数オブジェクト・コンセプト･チェック用クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; GeneratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; UnaryFunctionConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BinaryFunctionConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; UnaryPredicateConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BinaryPredicateConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Const_BinaryPredicateConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptableGeneratorConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptableUnaryFunctionConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptableBinaryFunctionConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptablePredicateConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Func&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;First&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Second&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdaptableBinaryPredicateConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#container-concepts&#34; name=&#34;container-concepts&#34;&gt;コンテナ･コンセプト･チェック用クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ContainerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1 Table 65 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_ContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ForwardContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_ForwardContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; ReversibleContainerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1 Table 66 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_ReversibleContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; RandomAccessContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Mutable_RandomAccessContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SequenceConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1.1 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; FrontInsertionSequenceConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BackInsertionSequenceConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AssociativeContainerConcept; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 規格 23.1.2 Table 69 参照&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; UniqueAssociativeContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; MultipleAssociativeContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SimpleAssociativeContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; PairAssociativeContainerConcept;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; SortedAssociativeContainerConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#basic-archetype&#34; name=&#34;basic-archetype&#34;&gt;基本原型クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;null_archetype&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// モデル化するコンセプトが無いことを示す型&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;default_constructible_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;assignable_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;copy_constructible_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;equality_comparable_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Base&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; null_archetype&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;convertible_to_archetype&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#iterator-archetype&#34; name=&#34;iterator-archetype&#34;&gt;イテレータ原型クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;trivial_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;mutable_trivial_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;input_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;forward_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;bidirectional_iterator_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ValueType&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;random_access_iterator_archetype&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#function-object-archetype&#34; name=&#34;function-object-archetype&#34;&gt;関数オブジェクト原型クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_function_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg2&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Return&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;binary_function_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;predicate_archetype&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;binary_predicate_archetype&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html#container-archetype&#34; name=&#34;container-archetype&#34;&gt;コンテナ原型クラス&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;構築中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;「はじめに」へ戻る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/implementation.html&#34;&gt;前へ：「コンセプト・チェックの実装」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェックの利用 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/concept_check/using_concept_check.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;コンセプト・チェックの利用&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;各コンセプトに対して、与えられた型 (あるいは型の集合) がコンセプトをモデル化していることを確かめるために使用することができる、何らかのコンセプト・チェック用クラスが存在する。 Boost コンセプト・チェック・ライブラリ (BCCL) は、C++ 標準ライブラリの中で使用される全てのコンセプト＋αを対象とした、コンセプト・チェック用クラスを含んでいる。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt; セクションに、このコンセプト・チェック用クラスをリストしてある。 さらに、他の Boost ライブラリも、ライブラリ独自の特別なコンセプトに対応するコンセプト・チェック用クラスを付随している。 例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.md.nolink&#34;&gt;graph concept&lt;/a&gt; および &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/property_map.md.nolink&#34;&gt;property map concept&lt;/a&gt; がある。 さらに、クラス・テンプレートや関数テンプレートを記述する者は、既存のコンセプトでカバーされていない要求事項を表現する必要のある場合は常に、新しいコンセプト・チェック用クラスを作成すべきである。 その方法は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt; セクションで説明する。&lt;/p&gt;
&lt;p&gt;BCCL のコンセプト・チェック用クラスの例として、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; クラスを挙げる。 このクラスは、C++ 標準 20.1.1 に記述されている &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) 要求事項および、SGI STL で文書化されている &lt;a href=&#34;http://www.sgi.com/tech/stl/EqualityComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;EqualityComparable&lt;/code&gt;&lt;/a&gt; (等値比較可能) コンセプトに相当する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EqualityComparableConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;テンプレート引数 &lt;code&gt;T&lt;/code&gt; はチェック対象の型と意図されている。 すなわち、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; の目的は、&lt;code&gt;T&lt;/code&gt; に対して与えられたテンプレート引数が 等値比較可能コンセプトをモデル化しているかどうか確認することである。&lt;/p&gt;
&lt;p&gt;個々のコンセプト・チェック用クラスには、該当するコンセプトにおいて有効な式を内包する &lt;code&gt;constraints()&lt;/code&gt; という名前のメンバー関数がある。 ある型が &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) であるかどうかチェックするためには、その型でコンセプト・チェック用クラスのインスタンスを生成し、次に、コンパイラに、実際に &lt;code&gt;constraints()&lt;/code&gt; 関数を実行することなくコンパイルさせる方法を見つける必要がある。 Boost コンセプト・チェック・ライブラリは、これを容易にする2つのユーティリティ： &lt;code&gt;function_requires()&lt;/code&gt; と &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; を定義している。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;function_requires()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;function_requires()&lt;/code&gt; 関数は関数本体の中で使用できる。また、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロはクラス定義本体で使用できる。 &lt;code&gt;function_requires()&lt;/code&gt; 関数は引数をとらないが、コンセプト・チェック用クラスを受けるためのテンプレート・パラメータを有する。 これは、以下に示すように、インスタンス化されたコンセプト・チェック用クラスを明示的にテンプレート引数として与えられなければならないことを意味する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; generic_library_function(T x)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; EqualityComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  foo f;
  generic_library_function(f);
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロは、ある型がコンセプトをモデル化しているかどうかチェックするために、クラス定義の内部で使用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; generic_library_class
{
  BOOST_CLASS_REQUIRE(T, boost, EqualityComparableConcept);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  generic_library_class&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; glc;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;以前の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating_example&#34;&gt;動機の例&lt;/a&gt; に対してコンセプト・チェックを応用する場合、良いやり方として、テンプレート・パラメータ型が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデル化していることを確認するために &lt;code&gt;std::stable_sort()&lt;/code&gt; の一番上に &lt;code&gt;function_requires()&lt;/code&gt; を挿入することが一つ挙げられる。 さらに、&lt;code&gt;std::stable_sort()&lt;/code&gt; は、イレテータの &lt;code&gt;value_type&lt;/code&gt; が&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;LessThanComparable&lt;/code&gt; (未満比較可能)&lt;/a&gt; を満足することが必要であるから、これをチェックするために、重ねて &lt;code&gt;function_requires()&lt;/code&gt; を使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIter first, RandomAccessIter last)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; RandomAccessIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type value_type;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; LessThanComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;value_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンセプトによっては複数の型を処理するものがある。 この場合、対応するコンセプト・チェック用クラスは複数のテンプレート・パラメータを持つことになる。 以下の例は、&lt;code&gt;function_requires()&lt;/code&gt; を、２つの型パラメータ（プロパティ・マップ型とそのキーとなる型）をとる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; コンセプトに対して使用する方法を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;IncidenceGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor Vertex;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ReadWritePropertyMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ColorMap, Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; の使用例として、&lt;code&gt;std::vector&lt;/code&gt; が有すべきコンセプト・チェックを考察する。 要素型に対して当てはめる要求事項の一つは、それが &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Assignable&lt;/code&gt; (割当可能)&lt;/a&gt;でなければならない、ということである。 これは、&lt;code&gt;std::vector&lt;/code&gt; の定義の一番上に&lt;code&gt;BOOST_CLASS_REQUIRE(T, boost, AssignableConcept)&lt;/code&gt;を挿入することにより、チェックすることができる。&lt;/p&gt;
&lt;p&gt;コンセプト・チェックは、ジェネリック・ライブラリの実装者が使用するために設計されているが、エンドユーザーにおいても有用である。 往々にして、ある型が特定のコンセプトをモデル化しているかどうか、不明確な場合がある。 こういうケースでは、問題の型とコンセプトを対象として &lt;code&gt;function_requires()&lt;/code&gt; を使用する、小さなプログラムを作成することで容易にチェックできる。 ファイル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/stl_concept_check.cpp.html&#34;&gt;stl_concept_checks.cpp&lt;/a&gt; は、STL コンテナにコンセプト・チェックを適応する実例となっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;次へ：「コンセプト・チェック用クラスの作成」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;前へ：「はじめに」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Distjoint Sets（互いに素な集合） -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/disjoint_sets.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Distjoint Sets（互いに素な集合）&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、互いに素な集合（素集合）の演算に 順位による和集合 および パス圧縮 を提供する。disjoint-sets のデータ構造は、素集合の S = {S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ..., S&lt;sub&gt;k&lt;/sub&gt;} というコレクションを維持する。 各集合は、集合のいくつかの要素である 代表値 によって識別される。 集合は、Parent プロパティマップの中の符号化された有向木によって表わされる。 2つの発見的手法: 「順位による和集合」 および 「パス圧縮」 は、 演算を高速化するのに使われる  [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#tarjan83&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#clr90&#34;&gt;2&lt;/a&gt;]。&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;boost/disjoint_sets.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Rank&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値型が整数型で、キー型が集合の要素型と等しい &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Parent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルで、かつ、キー型および値型は集合の要素型と等しくなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;disjoint_sets&lt;/code&gt; に対する典型的な使用法の手本は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/kruskal_minimum_spanning_tree.md.nolink&#34;&gt;&lt;code&gt;kruskal_minimum_spanning_tree()&lt;/code&gt;&lt;/a&gt; アルゴリズムで見ることができる。 この例では、&lt;code&gt;union_set()&lt;/code&gt; の代わりに &lt;code&gt;link()&lt;/code&gt; を呼び出す。 なぜなら、&lt;code&gt;u&lt;/code&gt; および &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;find_set()&lt;/code&gt; から得られ、したがって、既にそれら集合の代表値であるからだ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;...
disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; dsets(rank, p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (ui  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G).first; ui &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vertices(G).second; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ui)
  dsets.make_set(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ui);
...
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; ( &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;Q.empty() ) {
  e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Q.front();
  Q.pop();
  u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(source(e));
  v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(target(e));
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( u &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v ) {
    &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;out&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; e;
    dsets.link(u, v);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(Rank r, Parent p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(const disjoint_sets&amp;amp; x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void make_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Element x&lt;/code&gt; を含む単集合を作成する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void link(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; で表わされる 2つの集合を結合する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void union_set(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; を含む 2つの集合を結合する。 これは、&lt;code&gt;link(find_set(x),find_set(y))&lt;/code&gt; に相当する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Element find_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; を含む集合のための代表値を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;std::size_t count_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;素集合の個数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void compress_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;すべての要素の親がその代表値であるように親ツリーを平滑化する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Complexity&lt;/h2&gt;
&lt;p&gt;時間計算量は、O(m alpha(m,n)) である。alpha は逆アッカーマン関数、 m は disjoint-set の演算（&lt;code&gt;make_set()&lt;/code&gt;、&lt;code&gt;find_set()&lt;/code&gt;、および &lt;code&gt;link()&lt;/code&gt;）の総数、n は要素数である。 alpha 関数はとても遅く、log 関数よりもはるかに遅くなる。&lt;/p&gt;
&lt;p&gt;参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_connected_components.md.nolink&#34;&gt;&lt;code&gt;incremental_connected_components()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ID,InverseID,FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、順位および親のプロパティのための記憶領域を内部で管理する。 記憶領域は、要素IDにより索引付けされた配列の中にある。ゆえに、ID および InverseID ファンクタを必要とする。 順位および親のプロパティは、構築中に初期化される、 したがって、各要素は自動的に集合の中にある（従って、このクラスのオブジェクトを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.md.nolink#sec:initialize-incremental-components&#34;&gt;&lt;code&gt;initialize_incremental_components()&lt;/code&gt;&lt;/a&gt; 関数で初期化することは必要でない。）。 このクラスは、頂点プロパティを格納する場所を提供しない &lt;code&gt;edge_list&lt;/code&gt; グラフの（動的）接続している構成要素を計算する場合に特に有用である。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0からN（集合中の要素の総数）までの整数に要素を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;InverseID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素に整数を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;representative_with_full_path_compression&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;p&gt;このクラスは、以下のメンバだけでなく &lt;code&gt;disjoint_sets&lt;/code&gt; のすべてのメンバも持っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage(size_type n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
                           ID id &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ID(),
                           InverseID inv &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; InverseID())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンストラクタ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ElementIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;
  normalize_sets(ElementIterator first, ElementIterator last)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;各集合の代表値が最も小さな ID を備えた要素になるように代表値を再整理する。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事後条件: &lt;code&gt;v &amp;gt;= parent[v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事前条件: 素集合の構造は圧縮されていなければならない。 &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_path_halving&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; と同じ構成要素のための代表的な頂点を検索するファンクタである。 代表値木を横断している間、ファンクタは、さらに木の高さを短くするためにパス二分技術を適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_full_path_compression&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; が属する集合のための代表的な要素を検索するファンクタである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~llee1&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:llee1@lsc.nd.edu&#34;&gt;llee1@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:lums@lsc.nd.edu&#34;&gt;lums@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 IKOMA Yoshiki &lt;a href=&#34;mailto:ikoma@mb.i-chubu.ne.jp&#34;&gt;ikoma@mb.i-chubu.ne.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>参考文献 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/disjoint_sets/bibliography.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;参考文献&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#tarjan83&#34; nam=&#34;tarjan83&#34;&gt;1&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;R. E. Tarjan. &lt;/li&gt;
&lt;li&gt;Data Structures and Network Algorithms. &lt;/li&gt;
&lt;li&gt;Society for Industrial and Applied Mathematics, 1983.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#clr90&#34; name=&#34;clr90&#34;&gt;2&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;T. Cormen, C. Leiserson, and R. Rivest. &lt;/li&gt;
&lt;li&gt;Introduction to Algorithms. &lt;/li&gt;
&lt;li&gt;McGraw-Hill, 1990.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Improved Function Object Adapters -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Improved Function Object Adapters&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/functional/&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/functional/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;functional.hpp ヘッダは C++ 標準ライブラリの関数オブジェクトアダプタ(セクション 20.3.5 から 20.3.8)を強化する。この強化は主に二つの変更を行う。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我々は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;参照の参照&lt;/a&gt; 問題を回避し、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#args&#34;&gt;引数渡し&lt;/a&gt; の効率を良くするために、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; テンプレートを使う。&lt;/li&gt;
&lt;li&gt;我々は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html&#34;&gt;&lt;code&gt;ptr_fun&lt;/code&gt;&lt;/a&gt; の必要性を回避するために、このライブラリのアダプタとともに、ふたつの&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を使う。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;p&gt;このヘッダは以下の関数・クラステンプレートを含む:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分類&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;Function object traits&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_traits&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binary_traits&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数オブジェクトや関数の引数型を決定するために使われる。&lt;code&gt;ptr_fun&lt;/code&gt;の必要性を除去する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html&#34;&gt;Negators&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binary_negate&lt;/code&gt;&lt;br /&gt; &lt;code&gt;not1&lt;/code&gt;&lt;br /&gt; &lt;code&gt;not2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.5 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html&#34;&gt;Binders&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;binder1st&lt;/code&gt;&lt;br /&gt; &lt;code&gt;binder2nd&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bind1st&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bind2nd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.6 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html&#34;&gt;Adapters for pointers to functions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pointer_to_unary_function&lt;/code&gt;&lt;br /&gt; &lt;code&gt;pointer_to_binary_function&lt;/code&gt;&lt;br /&gt; &lt;code&gt;ptr_fun&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.7 に基づく。このライブラリとともに使用する場合はバインダやネゲータは関数に適合できるので不要である。しかし、サードパーティのアダプタに必要とされるかもしれない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html&#34;&gt;Adapters for pointers to member functions&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mem_fun_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun1_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun1_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun1_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;const_mem_fun1_ref_t&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun&lt;/code&gt;&lt;br /&gt; &lt;code&gt;mem_fun_ref&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;標準のセクション 20.3.8 に基づく。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;これらのアダプタの使い方は標準関数オブジェクトアダプタの使い方にとてもよく似ている。唯一の違いは、&lt;code&gt;std::&lt;/code&gt; の代わりに &lt;code&gt;boost::&lt;/code&gt; と書く必要があることだけである。そうすればあなたの頭痛は軽減される。&lt;/p&gt;
&lt;p&gt;例えば、あなたが &lt;code&gt;set_name&lt;/code&gt; 関数を持つ&lt;code&gt;Person&lt;/code&gt;クラスを持っていると考えてほしい:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Person&lt;/span&gt;
{
  &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; set_name(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;name);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;あなたは以下のように書くことによって、コレクション &lt;code&gt;c&lt;/code&gt; 中の &lt;code&gt;Person&lt;/code&gt; の束を改名できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Person&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;set_name), &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Fred&#34;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もし代わりに標準アダプタが使われていれば、このコードは普通、コンパイルに失敗する。それは、&lt;code&gt;set_name&lt;/code&gt; が参照引数を取るからである。何故こうなるかを解明したければ、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;バインダのドキュメント&lt;/a&gt; の中のコメントを参照するとよい。&lt;/p&gt;
&lt;h2&gt;Compiler Compatibility&lt;/h2&gt;
&lt;p&gt;このヘッダと &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_test.cpp.html&#34;&gt;テストプログラム&lt;/a&gt; は以下のコンパイラでコンパイルされる:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;コンパイラ&lt;/th&gt;
&lt;th&gt;コメント&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Borland C++Builder 4 Update 2&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Borland C++ 5.5&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g++ 2.95.2&lt;/td&gt;
&lt;td&gt;既知の問題はない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft Visual C++ Service Pack 3&lt;/td&gt;
&lt;td&gt;コンパイラが部分特殊化版を欠いているため、このライブラリは標準アダプタによって提供されるより、少しだけしか多くの機能を提供しない。&lt;br /&gt; ・参照の参照問題を回避するための &lt;code&gt;call_traits&lt;/code&gt; メカニズムが使えない。それゆえ、このライブラリのアダプタはより少ない状況でしか使えないだろう。&lt;br /&gt; ・関数の引数や返り値型を特定するための &lt;code&gt;function_traits&lt;/code&gt; メカニズムが使えない。それゆえ、関数を適合させるため、&lt;code&gt;ptr_fun&lt;/code&gt; が引き続き必要になる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Future Directions&lt;/h2&gt;
&lt;p&gt;このライブラリの第一目的は、できる限り多くの標準ライブラリの互換性を 持つ、参照の参照問題に対する解である。これによって本や雑誌で読む技術を 今日のたくさんのコンパイラで使うことができる。&lt;/p&gt;
&lt;p&gt;長期的には、より良い解は以下のようなものだろう:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;幾人かの Boost のメンバは式テンプレートのライブラリを作成し ている。これらによって、関数の結合や適合が自然な文法で行えるだろう。 これは新しい技術なので、それが熟して、有名なコンパイラに広くサポートされるまでに時間がかかるかもしれないが、大きな成功となるだろう。それまでは、この functional.hpp ライブラリがギャップを埋める。&lt;/li&gt;
&lt;li&gt;標準委員会はテンプレートの実体化に際して参照の参照問題が起きることを認識していて、標準を修正する気になっている( &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Author&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/mark_rodgers.htm&#34; target=&#34;_blank&#34;&gt;Mark Rodgers&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/john_maddock.htm&#34; target=&#34;_blank&#34;&gt;John Maddock&lt;/a&gt; for suggesting the mechanism that allowed the function objects traits to work correctly. &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jens_maurer.htm&#34; target=&#34;_blank&#34;&gt;Jens Maurer&lt;/a&gt; provided invaluable feedback during the &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/more/formal_review_process.htm&#34; target=&#34;_blank&#34;&gt;formal review process&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Binders -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/binders.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Binders&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.6): 由来のバインダ関数オブジェクトアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binder1st&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binder2nd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bind1st&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind2nd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準ライブラリにあるそれらの代わりに、これらのアダプタを使う主な便益は、それらが &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34;&gt;参照の参照&lt;/a&gt; 問題を回避することにある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い方は標準バインダと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Foo&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html#refref&#34; name=&#34;refref&#34;&gt;References to References&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下の使用例を考えなさい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Foo&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ostream &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(c.begin(), c.end(), 
              boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind2nd(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun_ref(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これがもし &lt;code&gt;std::bind2nd&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt; を使って書かれているならば、コンパイルできないだろう。&lt;/p&gt;
&lt;p&gt;この問題は &lt;code&gt;bar&lt;/code&gt; が参照引数を取ることが原因で起こる。標準は &lt;code&gt;std::mem_fun_ref&lt;/code&gt; を &lt;code&gt;second_argument_type&lt;/code&gt; が &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; である関数オブジェクトを作るように定義する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind2nd&lt;/code&gt; 呼び出しは &lt;code&gt;binder2nd&lt;/code&gt; を作り、それは標準が以下のように定義している:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Operation&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;binder2nd&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;first_argument_type,
                            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;result_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
...
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  binder2nd(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x,
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;second_argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; y);
  ...
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々の &lt;code&gt;Operation&lt;/code&gt; の &lt;code&gt;second_argument_type&lt;/code&gt; は &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; であるから、コンストラクタの中の &lt;code&gt;y&lt;/code&gt; の型は &lt;code&gt;std::ostream&amp;amp;&amp;amp;&lt;/code&gt; となるだろう。参照の参照を作ることはできないから、参照の参照は C++ では非合法であるとしてこの時点でコンパイルエラーになる。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;このライブラリのバインダは Boost &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; テンプレートを使うことによってこの問題を回避している。&lt;/p&gt;
&lt;p&gt;コンストラクタは以下のように宣言される。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;binder2nd(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x,
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
             &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; binary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;second_argument_type
          &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type y)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;結果、&lt;code&gt;y&lt;/code&gt; は &lt;code&gt;std::ostream&amp;amp;&lt;/code&gt; 型を持つ。そして、我々の例はコンパイルされる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Function Object Traits -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/function_traits.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Function Object Traits&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;functional.hpp ヘッダは関数と関数オブジェクトのための、二つの特性クラステンプレートを提供します:&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Contents&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;struct unary_traits&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;function_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクト自身の型 (例えば &lt;code&gt;T&lt;/code&gt;)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;param_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトをパラメータとして渡すために使われるべき型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの返り値の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;argument_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの引数の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;struct binary_traits&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;function_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクト自身の型 (例えば &lt;code&gt;T&lt;/code&gt;)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;param_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトをパラメータとして渡すために使われるべき型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの返り値の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;first_argument_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの第一引数の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;second_argument_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数や関数オブジェクトの第二引数の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;unary_traits&lt;/code&gt; は一引数を取る関数と適合一引数関数オブジェクト (例えば &lt;code&gt;std::unary_function&lt;/code&gt; を継承したクラス) や、同様の &lt;code&gt;typedef&lt;/code&gt; がなされたクラス)のどちらかとともに実体化されなければならない。(C++ 標準の §20.3.1 を参照せよ)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;binary_traits&lt;/code&gt; は二引数を取る関数と適合二引数関数オブジェクト (例えば &lt;code&gt;std::binary_function&lt;/code&gt; を継承したクラス) や、同様の &lt;code&gt;typedef&lt;/code&gt; がなされたクラス)のどちらかとともに実体化されなければならない。(C++ 標準の §20.3.1 を参照せよ)&lt;/p&gt;
&lt;p&gt;これらのテンプレートのもっとも一般的な使い方は、関数オブジェクトアダプタ内で、関数オブジェクトと同様に普通の関数を適合させることである。普段例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Operation&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;と書く所ならどこでも、代わりに&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;unary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Operation&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;argument_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;と書くだけで良い。&lt;/p&gt;
&lt;h2&gt;Additional Types Defined&lt;/h2&gt;
&lt;p&gt;標準の返り値と引数の &lt;code&gt;typedef&lt;/code&gt; に加えて、これらの特性テンプレートは二つの型を定義する。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;function_type&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;これは関数や関数オブジェクトの型である。そして、宣言の中で以下のように使われる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
{
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
  &lt;span style=&#34;color: #A0A000&#34;&gt;private:&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; unary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;function_type pred;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;もしこの &lt;code&gt;typedef&lt;/code&gt; がなければ、&lt;code&gt;unary_negate&lt;/code&gt;を関数型とともに実体化させることができる方法で、&lt;code&gt;pred&lt;/code&gt;を宣言することはできないだろう。(C++ 標準の §14.3.1 ¶3 を参照せよ)&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;param_type&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;これは関数や関数オブジェクトを他の関数に引数として渡すのに最適な型である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
{
  &lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; unary_negate(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; unary_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x)
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt;
        pred(x)
    {}
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;関数オブジェクトは定数参照で渡され、関数ポインタは値渡しされる。&lt;/p&gt;
&lt;h2&gt;Limitations&lt;/h2&gt;
&lt;p&gt;このライブラリは全てのアダプタ関数オブジェクトでこれらの特性を利用していて、理論的には、&lt;code&gt;ptr_fun&lt;/code&gt;を廃止されるようにする。しかし、サードパーティのアダプタは多分このメカニズムを利用しないだろうし、&lt;code&gt;ptr_fun&lt;/code&gt;は未だ必要である。このライブラリは標準関数ポインタアダプタの改善バージョンを提供する。&lt;/p&gt;
&lt;p&gt;これらの特性テンプレートも、テンプレートの部分特殊化版を提供できないコンパイラでは動かないだろう。これらのコンパイラでは、特性テンプレートは適合関数オブジェクトでのみ実体化され、このライブラリの関数オブジェクトとももに用いる場合でさえ、&lt;code&gt;ptr_fun&lt;/code&gt;を使う必要があるだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Member Function Adapters -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/mem_fun.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Member Function Adapters&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;functional.hpp ヘッダは C++ 標準ライブラリ (§ 20.3.8): 由来のメンバ関 数アダプタの全ての強化バージョンを含んでいる:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem_fun_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun1_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun1_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun1_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_mem_fun1_ref_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mem_fun&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem_fun_ref&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;標準のアダプタそれぞれから、以下の変更がなされている:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;first_argument_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; は &lt;code&gt;const_&lt;/code&gt; ファミリーのメンバ関数アダプタのために 修正されている。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#firstarg&#34;&gt;以下&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fun1_t&lt;/code&gt;やその変種に渡される引数は、メンバ関数の引数型として、&lt;code&gt;call_traits::param_type&lt;/code&gt; を用いて渡される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#firstarg&#34; name=&#34;firstarg&#34;&gt;first_argument_type&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;const_mem_fun1_t&lt;/code&gt; を例えば、以下のように指定する:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;S&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;const_mem_fun1_t&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;, A, S&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;const_mem_fun1_t&lt;/span&gt;(S (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;p)(A) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);
  S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, A x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;binary_function&lt;/code&gt; への第一引数が実際には &lt;code&gt;const T*&lt;/code&gt; であるにも関わらず、 &lt;code&gt;T*&lt;/code&gt; になっている点に注意しなさい。&lt;/p&gt;
&lt;p&gt;これはどういうことか？さて、我々が以下のように書くとき何が起こるかを考えなさい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Foo { &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; bar(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;; };
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;cp &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;new&lt;/span&gt; Foo;
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind1st(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fun(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bar), cp);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は以下のようなものを効果的に含む &lt;code&gt;const_mem_fun1_t&lt;/code&gt; オブジェクトを作成した。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; Foo&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; first_argument_type;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次に &lt;code&gt;bind1st&lt;/code&gt; はこの &lt;code&gt;typedef&lt;/code&gt; を &lt;code&gt;cp&lt;/code&gt; によって初期化されるメンバ型として用いる &lt;code&gt;binder1st&lt;/code&gt; オブジェクトを作成する。言い換えれば、我々は &lt;code&gt;Foo*&lt;/code&gt; メンバを &lt;code&gt;const Foo*&lt;/code&gt; メンバで初期化する必要がある！ 明らかに これは不可能であるので、標準ライブラリのベンダはこれを実装するために &lt;code&gt;cp&lt;/code&gt; の定数性を、おそらく &lt;code&gt;bind1st&lt;/code&gt; の本体の中で、キャストして取り除かなければならなかっただろう。&lt;/p&gt;
&lt;p&gt;このハックは改良された &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/binders.html&#34;&gt;バインダ&lt;/a&gt; とともに用いる場合十分ではないので、我々はメンバ関数アダプタの修正されたバージョンも同様に提供しなければならなかった。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;mem_fun1_t&lt;/code&gt; を例えば以下のように定義する (§20.3.8 ¶2):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;S&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;mem_fun1_t&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; binary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;, A, S&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;mem_fun1_t&lt;/span&gt;(S (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;p)(A));
  S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, A x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; の第二引数はメンバ関数の引数と全く同じであることに注意しなさい。もしこれが値型であれば、引数は二度値渡しされてコピーされる。&lt;/p&gt;
&lt;p&gt;しかしながら、もし我々が引数を代わりに &lt;code&gt;const A&amp;amp;&lt;/code&gt; として宣言することによってこの非効率性を削除しようとするならば、もし &lt;code&gt;A&lt;/code&gt; が参照型であれば、我々は参照の参照を持ってしまう。そしてそれは現在のところ非合法である。 (ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;operator()&lt;/code&gt; の引数を宣言する望ましい方法は、メンバ関数の引数が参照であるかないかに依っている。もしそれが参照であるならば、単純に &lt;code&gt;A&lt;/code&gt; と宣言したいのであり、もし値であれば &lt;code&gt;const A&amp;amp;&lt;/code&gt; と宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特殊化版を用いて正確にこの判断をを行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;S &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/mem_fun.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;call traits テンプレートはこの改良を実現するために使われる関数オブジェ クト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化の機能を持つコンパイラでのみ有効である。そうでないコンパイラでは、メンバ関数に渡される引数は(&lt;code&gt;mem_fun1_t&lt;/code&gt; ファミリの中で) 常に参照渡しとなるので、参照の参照の可能性を生みだすことになる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Negators -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/negators.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Negators&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§20.3.5) 由来のネゲータアダプタの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unary_negate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binary_negate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;not1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このライブラリのネゲータは標準バージョンを二つの方法で改良する。&lt;/p&gt;
&lt;p&gt;適合関数オブジェクトではなく関数を否定する時、それらは &lt;code&gt;ptr_fun&lt;/code&gt; の必要を回避するために、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を用いる。&lt;/p&gt;
&lt;p&gt;それらは引数や適合された関数に渡す引数を宣言する最上の方法を決するため、Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;call traits&lt;/a&gt; を用いる。(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34;&gt;下記&lt;/a&gt;参照)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使い型は標準ネゲータと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Foo &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;C++ 標準 (§20.3.5) は unary negate をこのように定義 している。(binary negate も似ている):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Predicate&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;unary_negate&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type,&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; unary_negate(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; pred);
  &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であった場合、 &lt;code&gt;operator()&lt;/code&gt; の引数の型は参照の参照になることに注意しなさい。これは、現在の C++ では非合法である。(ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)。&lt;/p&gt;
&lt;p&gt;しかしながら、もし代わりに &lt;code&gt;operator()&lt;/code&gt; を &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; を変更せずにそのまま採用して定義すると、それが値型であった場合不必要に非効率になってしまう。それは引数が二度コピーされることによる。一度は &lt;code&gt;unary_negate&lt;/code&gt; の &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時、さらに適合された関数で &lt;code&gt;operator()&lt;/code&gt; を呼ぶ時にもう一度である。&lt;/p&gt;
&lt;p&gt;つまり&lt;code&gt;operator()&lt;/code&gt; を宣言する望ましい方法は、 &lt;code&gt;Predicate&lt;/code&gt; の &lt;code&gt;argument_type&lt;/code&gt; が参照であるか否かに依 る。もしそれが参照であれば、単純に &lt;code&gt;argument_type&lt;/code&gt; として宣言したいし、それが値であれば &lt;code&gt;const argument_type&amp;amp;&lt;/code&gt; として宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.html&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特 殊化版を用いて正確にこの判断を行う。&lt;code&gt;operator()&lt;/code&gt; を 以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Predicate&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;argument_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。実のところ、実際の宣言は関数オブジェクト特性を使うためもう少し複雑である。しかし効果は同様である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;この関数オブジェクト特性の両方と call traits はこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化版の機能を持つコンパイラでのみ有効である。 そうでないコンパイラでは、このライブラリのネゲータは標準内のそれらと非常に似た振る舞いをする - 関数に適合するために &lt;code&gt;ptr_fun&lt;/code&gt; が必要であるし、参照の参照は避けられないだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Function Pointer Adapters -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/functional/ptr_fun.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Function Pointer Adapters&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;functional.hpp ヘッダは C++ 標準 (§ 20.3.7): 由来の関数ポインタアダプ タの両方の強化バージョンを提供する:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointer_to_unary_function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointer_to_binary_function&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同様に対応するヘルパ関数も提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ptr_fun&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;しかし、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/function_traits.html&#34;&gt;function object traits&lt;/a&gt; を使用しているおかげで、このライブラリのアダプタと接続する場合、このアダプタを使う必要はない。しかしながら、あなたの実装が我々の特性クラスとともにきちんと働かない場合 (部分特殊化版が欠けていることによる) や、サードパーティの関数オブジェクトアダプタとともに使いたい場合に、使う必要があるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#usage&#34; name=&#34;usage&#34;&gt;Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;これらのアダプタを使う必要がある場合、使い方は標準関数ポインタアダプタと同様である。例えば、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;bad&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string foo) { ... }
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; c;
...
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it
     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ptr_fun(bad)));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;しかしながら、このライブラリは関数オブジェクト特性をサポートする、強化された &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/negators.html&#34;&gt;ネゲータ&lt;/a&gt; を含んでいることに注意しなさい。それで、以上のソースと同様に以下のように書ける。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it
     &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(c.begin(), c.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;not1(bad));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#arguments&#34; name=&#34;arguments&#34;&gt;Argument Types&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;標準は &lt;code&gt;pointer_to_unary_function&lt;/code&gt; をこのように定 義する(§20.3.8 ¶2):&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Arg&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Result&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;pointer_to_unary_function&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; unary_function&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Arg, Result&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; pointer_to_unary_function(Result (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; f)(Arg));
  Result &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Arg x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator()&lt;/code&gt; の引数はラップされる関数の引数と厳密に等しい型であることに注意しなさい。もしこれが値型であれば、引数は値渡しされ、二度コピーされる。&lt;code&gt;pointer_to_binary_function&lt;/code&gt; も同様の問題を持っている。&lt;/p&gt;
&lt;p&gt;しかしながら、引数を代わりに &lt;code&gt;const Arg&amp;amp;&lt;/code&gt; と宣言することによって非効率を削除しようとすると、&lt;code&gt;Arg&lt;/code&gt; が参照型であった場合、現 在では非合法な (ただし &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#106&#34; target=&#34;_blank&#34;&gt;C++ 言語中核の問題点 106 番目&lt;/a&gt; を参照せよ)、参照の参照ができてしまう。&lt;/p&gt;
&lt;p&gt;つまり、&lt;code&gt;operator()&lt;/code&gt; の引数を宣言する望ましい方法は、ラップされる関数の引数が参照であるかないかに依っている。もしそれが参照であるならば、単純に &lt;code&gt;Arg&lt;/code&gt; と宣言したいのであり、もし値であれば &lt;code&gt;const Arg&amp;amp;&lt;/code&gt; と宣言したいのである。&lt;/p&gt;
&lt;p&gt;Boost の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/call_traits.md.nolink&#34;&gt;&lt;code&gt;call_traits&lt;/code&gt;&lt;/a&gt; クラステンプレートは &lt;code&gt;param_type&lt;/code&gt; &lt;code&gt;typedef&lt;/code&gt; を含んでいて、それは部分特殊化版を用いて正確にこの判断をを行う。&lt;code&gt;operator()&lt;/code&gt; を以下のように宣言することによって。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Result &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; call_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Arg&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;param_type x) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;我々は望ましい結果を引き出した - 参照の参照を生み出すことなく、効率性を得たのだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/functional/ptr_fun.html#limitations&#34; name=&#34;limitations&#34;&gt;Limitations&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;call traits テンプレートはこの改良を実現するために使われる関数オブジェクト特性と &lt;code&gt;call_traits&lt;/code&gt; の両方が部分特殊化版に頼っているので、この改良は部分特殊化の機能を持つコンパイラでのみ有効である。そうでないコンパイラでは、関数に渡される引数は常に参照渡しとなるので、参照の参照の可能性を生みだすことになる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 Cadenza New Zealand Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;p&gt;Revised 28 June 2000&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 shinichiro.h &lt;a href=&#34;mailto:g940455@mail.ecc.u-tokyo.ac.jp&#34;&gt;g940455@mail.ecc.u-tokyo.ac.jp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>the Boost Graph Library -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;the Boost Graph Library&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/table_of_contents.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/table_of_contents.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/bgl-cover.jpg&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;BGLへの序章&lt;/li&gt;
&lt;li&gt;歴史&lt;/li&gt;
&lt;li&gt;刊行物&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/acknowledgements.html&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;クイック・ツアー&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html&#34;&gt;基本的なグラフ理論の復習&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;チュートリアル&lt;ol&gt;
&lt;li&gt;Property Maps&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;adjacency_list&lt;/code&gt; class&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;例題&lt;ol&gt;
&lt;li&gt;ファイル依存関係の例&lt;/li&gt;
&lt;li&gt;Kevin Bacon の６次数&lt;/li&gt;
&lt;li&gt;Graph Coloring&lt;/li&gt;
&lt;li&gt;Sparse Matrix Ordering&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;BGL 拡張&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/constructing_algorithms.html&#34;&gt;BGLでグラフアルゴリズムを構築する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Converting Existing Graphs to BGL&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Boost Graph インタフェイス&lt;ol&gt;
&lt;li&gt;Graph&lt;/li&gt;
&lt;li&gt;Incidence Graph&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BidirectionalGraph.html&#34;&gt;Bidirectional Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;Adjacency Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vertex List Graph&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;Edge List Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vertex and Edge List Graph&lt;/li&gt;
&lt;li&gt;Mutable Graph&lt;/li&gt;
&lt;li&gt;Property Graph&lt;/li&gt;
&lt;li&gt;Mutable Property Graph&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The Property Map Library （専門的にはグラフ・ライブラリの部分ではないが、ここで使用される頻度が高い）&lt;/li&gt;
&lt;li&gt;ビジタ・コンセプト&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS （幅優先探査） Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS （深さ優先探査） Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;Bellman Ford Visitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;Event Visitor&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;EventVisitorList アダプタ&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html&#34;&gt;Event Visitor List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html&#34;&gt;&lt;code&gt;dijkstra_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html&#34;&gt;&lt;code&gt;bellman_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;イベント・ビジタ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・クラス&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・アダプタ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;subgraph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filtered_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector as Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Matrix as Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Leda Graph(アンドキュメント)&lt;/li&gt;
&lt;li&gt;Stanford GraphBase&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;イテレータ・アダプタ&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特性クラス&lt;ol&gt;
&lt;li&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bgl_named_params.html&#34;&gt;&lt;code&gt;bgl_named_params&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;核となるアルゴリズム・パターン&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html&#34;&gt;&lt;code&gt;breadth_first_visit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html&#34;&gt;&lt;code&gt;depth_first_visit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undirected_dfs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform_cost_search&lt;/code&gt; (非推奨、代わりに Dijkstra を使うこと)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;グラフ・アルゴリズム&lt;ol&gt;
&lt;li&gt;最短経路アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html&#34;&gt;&lt;code&gt;dijkstra_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html&#34;&gt;&lt;code&gt;bellman_ford_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html&#34;&gt;&lt;code&gt;dag_shortest_paths&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;johnson_all_pairs_shortest_paths&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最小全域木アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;code&gt;kruskal_minimum_spanning_tree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prim_minimum_spanning_tree&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/connected_components.html&#34;&gt;&lt;code&gt;connected_components&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strong_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Incremental Connected Components&lt;ol&gt;
&lt;li&gt;&lt;code&gt;initialize_incremental_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;incremental_components&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;same_component&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;component_index&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最大流アルゴリズム&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edmunds_karp_max_flow.html&#34;&gt;&lt;code&gt;edmunds_karp_max_flow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push_relabel_max_flow&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topological_sort&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transitive_closure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/copy_graph.html&#34;&gt;&lt;code&gt;copy_graph&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transpose_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isomorphism&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/cuthill_mckee_ordering.html&#34;&gt;&lt;code&gt;cuthill_mckee_ordering&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sequential_vertex_coloring&lt;/code&gt;(アンドキュメント)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minimum_degree_ordering&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;AT&amp;amp;T Graphviz フォーマット入出力ユーティリティ&lt;ol&gt;
&lt;li&gt;&lt;code&gt;write_graphviz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_graphviz&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;補助コンセプト、補助クラス、補助関数&lt;ol&gt;
&lt;li&gt;&lt;code&gt;property&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BasicMatrix.html&#34;&gt;BasicMatrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;incident&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opposite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;bandwidth&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;ith_bandwidth&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tools for random graphs&lt;ol&gt;
&lt;li&gt;&lt;code&gt;random_vertex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;random_edge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;generate_random_graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;randomize_property&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;目標と To-Do 項目&lt;/li&gt;
&lt;li&gt;トラブルシューティング&lt;/li&gt;
&lt;li&gt;既知の問題&lt;/li&gt;
&lt;li&gt;FAQ&lt;/li&gt;
&lt;li&gt;BGL Book Errata&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>AdjacencyGraph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/AdjacencyGraph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;AdjacencyGraph&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;AdjacencyGraph コンセプトは、グラフ中の頂点への隣接頂点の効率的なアクセス のためのインターフェースを供給する。これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; コンセプト (出辺の終点が隣接頂点である) と非常に良く似ている。 いくつかの状況では頂点への関心のみがあり、しかし一方、他の状況では辺も同様に重要になるため、両者のコンセプトが供給された。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフのモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;G&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このタグ型は &lt;code&gt;adjacency_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::adjacency_iterator&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;頂点 &lt;code&gt;v&lt;/code&gt; のための隣接イテレータは &lt;code&gt;v&lt;/code&gt; に隣接した頂点へのアクセスを提供する。そのため隣接イテレータの値型はそのグラフの頂点記述子型である。 隣接イテレータは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなければならない。&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;adjacent_vertices(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; に隣接している頂点へのアクセスを提供 するイテレータ範囲を返す。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html#note1&#34;&gt;[1]&lt;/a&gt;&lt;br /&gt; 返却型: &lt;code&gt;std::pair&amp;lt;adjacency_iterator, adjacency_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; 関数は定数時間内に終了するはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graphコンセプト&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdjacencyGraphConcept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
    adjacency_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IncidenceGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(v, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(v, g);
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator,adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor v;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;設計原理&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; が同じ (それ以上の) 機能を実際に含んでいるので、AdjacencyGraph コンセプトはいくぶん軽薄である。 &lt;code&gt;adjacent_vertices()&lt;/code&gt; が &lt;code&gt;out_edges()&lt;/code&gt; よりも使用すると便利な状況があるので AdjacencyGraph コンセプトは存在する。 グラフ・クラスを構築しており、隣接イテレータを作成する余分な仕事を行いたくない場合は、恐れを持たないでいただきたい。 出辺イテレータから隣接イテレータを作成するために使用できる&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_iterator.html&#34;&gt;&lt;code&gt;adjacency_iterator&lt;/code&gt;&lt;/a&gt;と名付けられたアダプタ・クラスがある。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html#note1&#34; name=&#34;note1&#34;&gt;[1]&lt;/a&gt; &lt;strong&gt;multigraph&lt;/strong&gt; (多数の辺が同じ二つの頂点を接続できる) の 場合は、&lt;code&gt;adjacent_vertices()&lt;/code&gt; 関数によって返されたイテレータが各隣接頂点を一度含む範囲にアクセスするかどうか、また &lt;code&gt;out_edges()&lt;/code&gt; 関数 のふるまいと一致し、二度以上隣接した頂点を含むことがある範囲にアクセスすべき かどうかとしての問題が持ち出される。 この決定はグラフ・アルゴリズムの実装と共により多くの経験を考慮して再検討される必要があるかもしれないが、今のところふるまいは &lt;code&gt;out_edges()&lt;/code&gt; のそれと一致すると定義される。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>AdjacencyMatrix -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyMatrix.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/AdjacencyMatrix.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;AdjacencyMatrix&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;AdjacencyMatrix コンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; コンセプトを精製し、始点と終点によって与えられるグラフ中の任意の辺への効率的なアクセスのために必要なものを付け加えている。今のところどの Boost の グラフ・ライブラリ・アルゴリズムもこのコンセプトを使っていない。しかしながらこのコンセプトを必要とするであろう Floyd-Warshall のようなまだ実装されていないアルゴリズムが存在する。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このタグ型は &lt;code&gt;adjacency_matrix_tag&lt;/code&gt; に変換可能でなければならない。&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返却値型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接の辺アクセス&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge(u,v,g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&amp;lt;edge_descriptor, bool&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; の間に辺が存在するかどうかを述べるフラグと、辺が見つかった場合に辺記述子から成るペアを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; AdjacencyMatrix
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor edge_descriptor;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edge(u, v, g);
  }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor u, v;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;, edge_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BFS（幅優先探査）Visitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/BFSVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;BFS（幅優先探査）Visitor Concept&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは BFS Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;breadth_first_search()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BFS Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Graph&lt;/code&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点がキューからポップされた時に実行される。これは、頂点 &lt;code&gt;u&lt;/code&gt; の各出力辺に対して &lt;code&gt;examine_edge()&lt;/code&gt; が実行される直前に起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各辺が、探索木を形成する辺の要素になった時に、その辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Non-Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有向グラフでは後退辺と交差辺に対して、無向グラフでは交差辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gray Target&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に灰色に塗られている頂点を終点とする、木でない辺の部分集合に対して実行される。灰色は、頂点が今キューにいることを示す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Black Target&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に黒に塗られている頂点を終点とする、木でない辺の部分集合に対して実行される。黒は、頂点がキューから除去されたことを示す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある頂点の全ての出力辺が探索木に追加され、全ての隣接する頂点が発見された後に、その頂点に対して実行される (ただし、隣接する頂点の出力辺を調査するよりは前に) 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BasicMatrix -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BasicMatrix.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/BasicMatrix.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;BasicMatrix&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;BasicMatrix のコンセプトは2次元のテーブルの要素にアクセスするための 最小限のインタフェースを提供する。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{M,I,V}&lt;/td&gt;
&lt;td&gt;行列, インデックス, 値の型 で、BasicMatrix のコンセプトをモデル化する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;M&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;I&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;A[i][j]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;インデックス &lt;code&gt;(i,j)&lt;/code&gt; にある要素オブジェクトへの参照を返す。&lt;br /&gt; 返値の型: mutable &lt;code&gt;A&lt;/code&gt; に対しては、&lt;code&gt;V&amp;amp;&lt;/code&gt;。 constant &lt;code&gt;A&lt;/code&gt; に対しては、&lt;code&gt;const V&amp;amp;&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;要素へのアクセスは定数時間で終了する。&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;M&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;I&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BasicMatrixConcept
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints() {
    V&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; elt &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; A[i][j];
    const_constraints(A);
    ignore_unused_variable_warning(elt);      
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; const_constraints(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; M&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; A) {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; V&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; elt &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; A[i][j];
    ignore_unused_variable_warning(elt);      
  }
  M A;
  I i, j;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 KANAHORI Toshihiro &lt;a href=&#34;mailto:kanahori@k.tsukuba-tech.ac.jp&#34;&gt;kanahori@k.tsukuba-tech.ac.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Bellman Ford Visitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/BellmanFordVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Bellman Ford Visitor Concept&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html&#34;&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは Bellman Ford Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Bellman Ford Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Graph&lt;/code&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ内の各辺に対して &lt;code&gt;num_vertices(g)&lt;/code&gt; 回実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、以下の条件が満たされれば、その辺は緩和される (距離が減らされる) 。この時、このメソッドが実行される。&lt;br /&gt; &lt;code&gt;tie(u,v) = incident(e, g);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;D d_u = get(d, u), d_v = get(d, v);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;W w_e = get(w, e);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;assert(compare(combine(d_u, w_e), d_v));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge_not_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、辺が緩和 (上を参照) されなければ、このメソッドが実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Minimized&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_minimized(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ内の各辺を調査する &lt;code&gt;num_vertices(g)&lt;/code&gt; 回の反復が終わった後に、各辺が最小化されたかをチェックするために最後の反復が行われる。辺が最小化されていれば、この関数が実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Minimized&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edge_not_minimized(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺が最小化されていなければ、この関数が呼ばれる。グラフ内に負の閉路が存在する時に、これが起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html&#34;&gt;&lt;code&gt;bellman_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BidirectionalGraph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/BidirectionalGraph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/BidirectionalGraph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;BidirectionalGraph&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;BidirectionalGraph コンセプトは、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; を精製し、各頂点の入辺への効率的なアクセスのために必要とされるものを付け加えている。 有向グラフにとって、入辺への効率的なアクセスは一般的により多くの記憶スペースを必要とし、多くのアルゴリズムは入辺へのアクセスを必要としないため、 このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; から分離されている。 無向グラフにとってはこれは問題とならない。というのは &lt;code&gt;in_edges()&lt;/code&gt; 関数 と &lt;code&gt;out_edges()&lt;/code&gt; 関数は同じであり、両方の関数は頂点に隣接した辺を返すからである。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;G&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このタグ型は &lt;code&gt;bidirectional_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::in_edge_iterator&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点 &lt;code&gt;v&lt;/code&gt; のための入辺イテレータは &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する。そのため入辺イテレータの値型はそのグラフの辺記述子型である。 入辺イテレータは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;in_edges(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺 (有向グラフ) または接続辺 (無向グラフ) へのアクセスを提供するイテレータ範囲を返す。 有向グラフと無向グラフの両方にとって、出辺の終点は頂点 &lt;code&gt;v&lt;/code&gt; で あることと、始点が &lt;code&gt;v&lt;/code&gt; に隣接している頂点であることが要求される。&lt;br /&gt; 返却値型: &lt;code&gt;std::pair&amp;lt;in_edge_iterator, in_edge_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;in_degree(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺の数 (有向グラフ) または 接続辺の数 (無向グラフ) を返す。&lt;br /&gt; 返却値型: &lt;code&gt;degree_size_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;degree(v, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺と出辺を足した数 (有向グラフ) または接続辺の数 (無向グラフ) を返す。&lt;br /&gt; 返却値型: &lt;code&gt;degree_size_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; で &lt;code&gt;Directed=bidirectionalS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; で &lt;code&gt;Directed=undirectedS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;in_edges()&lt;/code&gt; は定数時間であることを必要とする。 &lt;code&gt;in_degree()&lt;/code&gt; 関数と &lt;code&gt;degree()&lt;/code&gt; 関数は入辺の数 (有向グラフ) または接続辺の数 (無向グラフ) による線形時間であるはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; BidirectionalGraph_concept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;in_edge_iterator
    in_edge_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IncidenceGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; in_edges(v, g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; in_edges(v, g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor v;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor e;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Buffer Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/Buffer.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Buffer Concept&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;Buffer とは、その中に何かしらアイテムを書き込んだり、削除したりできるものである。 Buffer のコンセプトは、ほとんど要求を持たない。 アイテムが格納の仕方や削除される時に関して、いかなる特定の順序付けも要求してはいないが、例によって、ソートに関しては順序付けのポリシーがいくつかある。&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer のモデルである型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;B&lt;/code&gt; の値の型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;メンバ&lt;/h2&gt;
&lt;p&gt;Buffer をモデル化する型は、以下のメンバーを持たなければならない。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;value_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内に格納されるオブジェクトの型。 その値の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;Assignable&lt;/a&gt; でなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内のオブジェクトの数を表す符号無し整数型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void push(const T&amp;amp; t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt; を Buffer 内に挿入する。 &lt;code&gt;size()&lt;/code&gt; は 1 インクリメントされる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void pop()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer からオブジェクトを削除する。 &lt;code&gt;size()&lt;/code&gt; は 1 デクリメントされる。&lt;br /&gt; 事前条件: &lt;code&gt;empty()&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; であること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp; top()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内のあるオブジェクトへの非 &lt;code&gt;const&lt;/code&gt; な参照を返す。&lt;br /&gt; 事前条件: &lt;code&gt;empty()&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; であること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const T&amp;amp; top() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内のあるオブジェクトへの &lt;code&gt;const&lt;/code&gt; な参照を返す。&lt;br /&gt; 事前条件: &lt;code&gt;empty()&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; であること。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void size() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Buffer 内のオブジェクトの数を返す。&lt;br /&gt; 不変式: &lt;code&gt;size() &amp;gt;= 0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bool empty() const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;b.size() == 0&lt;/code&gt; と等価。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;push()&lt;/code&gt;、&lt;code&gt;pop()&lt;/code&gt; と &lt;code&gt;size()&lt;/code&gt; は Generalized Queue のサイズに関して、 高々線形時間の計算量でなければならない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;top()&lt;/code&gt; と &lt;code&gt;empty()&lt;/code&gt; は定数時間で終了しなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/stack.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::stack&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::mutable_queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University and C++ Library &amp;amp; Compiler Group/SGI (&lt;a href=&#34;mailto:jsiek@engr.sgi.com&#34;&gt;jsiek@engr.sgi.com&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>ColorValue -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/ColorValue.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;ColorValue&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このコンセプトは色付けを必要とする型として記述されており、グラフ中を探査する時に頂点が訪問済か色でマークするために利用される。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/EqualityComparable.html&#34; target=&#34;_blank&#34;&gt;EqualityComparable&lt;/a&gt; and &lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ColorValue モデルの型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型 &lt;code&gt;T&lt;/code&gt; のオブジェクト&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Get Color White&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::white()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;白色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Get Color Gray&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::gray()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;灰色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Get Color Black&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color_traits&amp;lt;T&amp;gt;::black()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;黒色を表すオブジェクトを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;default_color_type&lt;/code&gt; (boost/graph/properties.hpp の中に記述)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>DFS Visitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/DFSVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;DFS Visitor Concept&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースを定義する。ユーザは DFS Visitor インタフェースを持つクラスを定義して、そのクラスのオブジェクトを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡すことができ、それによってグラフ探索中に実行される動作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;DFS Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ探索の開始の前に、グラフの全ての頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Start Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.start_vertex(s, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;探索の前に 1 度、始点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tree Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各辺が、探索木を形成する辺の要素になった時に、その辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Back Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.back_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの後退辺に対して実行される。無向グラフでは、辺 &lt;code&gt;(u,v)&lt;/code&gt; と辺 &lt;code&gt;(v,u)&lt;/code&gt; が同じ辺なので、木の辺か後退辺か曖昧な場合がある。この時は &lt;code&gt;tree_edge()&lt;/code&gt; 関数と &lt;code&gt;back_edge()&lt;/code&gt; 関数が両方とも実行される。この曖昧さを解決する 1 つの方法は、木の辺を記録し、既に木の辺として記録された後退辺を無視することだ。木の辺を記録するためには、 &lt;code&gt;tree_edge&lt;/code&gt; イベントで先行点を記録するのが簡単だ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Forward or Cross Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.forward_or_cross_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの先行辺と交差辺に対して実行される。無向グラフでは、このメソッドは決して呼ばれない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;頂点 &lt;code&gt;u&lt;/code&gt; を根とする DFS 木の全ての頂点に対して &lt;code&gt;finish_vertex&lt;/code&gt; が呼ばれた後に、頂点 &lt;code&gt;u&lt;/code&gt; に対して実行される。頂点 &lt;code&gt;u&lt;/code&gt; が DFS 木の葉であれば、 &lt;code&gt;u&lt;/code&gt; の全ての出力辺が調査された後に、 &lt;code&gt;u&lt;/code&gt; に対して &lt;code&gt;finish_vertex&lt;/code&gt; が呼ばれる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Dijkstra Visitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/DijkstraVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Dijkstra Visitor Concept&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このコンセプトは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html&#34;&gt;&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt;&lt;/a&gt; 用のビジタのインタフェースと、関連するアルゴリズムを定義する。ユーザはこのインタフェースに一致するクラスを作って、そのクラスのオブジェクトを &lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; に渡すことで、探索中に実行される操作を追加できる。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dijkstra Visitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;,&lt;code&gt;u&lt;/code&gt;,&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WeightMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Initialize Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初期化される時に、グラフの各頂点に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点がキューからポップされる時に、その頂点に対して実行される。これは頂点 &lt;code&gt;u&lt;/code&gt; の各出力辺に対して &lt;code&gt;examine_edge()&lt;/code&gt; が実行される直前に起こる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Examine Edge&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点が発見された後に、その頂点の各出力辺に対して実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discover Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各頂点に初めて遭遇した時に実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、以下の条件が満たされれば、その辺は緩和される (距離が減らされる) 。この時、このメソッドが実行される。&lt;br /&gt; &lt;code&gt;tie(u,v) = incident(e, g);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;D d_u = get(d, u), d_v = get(d, v);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;W w_e = get(w, e);&lt;/code&gt;&lt;br /&gt; &lt;code&gt;assert(compare(combine(d_u, w_e), d_v));&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge Not Relaxed&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;調査時に、辺が緩和 (上を参照) されなければ、このメソッドが実行される。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Finish Vertex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ある頂点の全ての出力辺が探索木に追加され、全ての隣接する頂点が発見された後に、その頂点に対して実行される (ただし、隣接する頂点の出力辺を調査するよりは前に) 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html&#34;&gt;&lt;code&gt;dijkstra_visitor&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EdgeListGraph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/EdgeListGraph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;EdgeListGraph&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;EdgeListGraph コンセプトは Graph コンセプトを 精製し、グラフ中の全ての辺への効率的なアクセスに必要とされるものを付け加えている。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;EdgeListGraph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型が &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::traversal_category&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;このタグ型は &lt;code&gt;edge_list_graph_tag&lt;/code&gt; に変換可能でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_iterator&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;edges(g)&lt;/code&gt; を経由して得られる辺イテレータは、グラフ中の全ての辺へのアクセスを提供する。辺イテレータの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt; の要求を満たしていなけれはならない。辺イテレータの値型はグラフの辺記述子型と同じでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edges_size_type&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;符号なし汎整数型はグラフ中の辺の数を表すのに使われる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;返却値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edges(g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&amp;lt;edge_iterator, edge_iterator&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の全ての辺へのアクセスを提供するイテレータ範囲を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;num_edges(g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;edges_size_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;source(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt; によって表される辺 &lt;code&gt;(u,v)&lt;/code&gt; の &lt;code&gt;u&lt;/code&gt; のための頂点記述子を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;target(e, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt; によって表される辺 &lt;code&gt;(u,v)&lt;/code&gt; の &lt;code&gt;v&lt;/code&gt; のための頂点記述子を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; 関数、&lt;code&gt;source()&lt;/code&gt; 関数、そして &lt;code&gt;target()&lt;/code&gt; 関数は、すべて定数時間内に終了するはずである。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;G&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EdgeListGraphConcept
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator 
    edge_iterator;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;constraints&lt;/span&gt;() {
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; GraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; MultiPassInputIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();

    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edges(g);
    E &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_edges(g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; source(e, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; target(e, g);
    const_constraints(g);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;const_constraints&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; G&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g) {
    p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; edges(g);
    E &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_edges(g);
    e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;p.first;
    u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; source(e, g);
    v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; target(e, g);
  }
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator,edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; p;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor u, v;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor e;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;G&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edges_size_type E;
  G g;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Edge Mutable Graph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeMutableGraph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/EdgeMutableGraph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Edge Mutable Graph&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;Edge Mutable Graph コンセプトは、辺の追加と削除をサポートするグラフのためのインターフェースを定義する。&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;なし&lt;/p&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;add_edge(u, v, g)&lt;/code&gt; は &lt;code&gt;std::pair&amp;lt;edge_descriptor, bool&amp;gt;&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフ中に挿入することを試み、そして挿入された辺または多重辺、かつ辺が挿入されたかどうかを述べるフラグを返す。この操作はグラフの頂点記述子または頂点イテレータを無効にしないはずである。ただし、辺記述子または辺イテレータを無効にするかもしれない。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; がグラフ中の頂点であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;(u,v)&lt;/code&gt; がグラフの辺集合中にあること。返された辺記述子は &lt;code&gt;u&lt;/code&gt; を始点位置に、&lt;code&gt;v&lt;/code&gt; を終点位置に持つだろう。もしグラフが多重辺を許可しているなら、返されるフラグは常に &lt;code&gt;true&lt;/code&gt; である。もしグラフが多重辺を許可しておらず、辺 &lt;code&gt;(u,v)&lt;/code&gt; がすでにグラフ中にあったら返されるフラグは &lt;code&gt;false&lt;/code&gt; である。もし辺 &lt;code&gt;(u,v)&lt;/code&gt; がグラフ中になかったら返されるフラグは &lt;code&gt;true&lt;/code&gt; である。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから削除する。もしグラフが多重辺を許可しているなら、これは &lt;code&gt;(u,v)&lt;/code&gt; の全ての存在を削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;(u,v)&lt;/code&gt; がグラフの辺集合中にあること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;(u,v)&lt;/code&gt; がもはやグラフの辺集合中にないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 辺 &lt;code&gt;e&lt;/code&gt; をグラフから削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;e&lt;/code&gt; がグラフ中の辺であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;e&lt;/code&gt; はもはや &lt;code&gt;g&lt;/code&gt; のための辺集合中にないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;clear_vertex(u, g)&lt;/code&gt; は &lt;code&gt;void&lt;/code&gt; を返す。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意味: 頂点 &lt;code&gt;u&lt;/code&gt; への、そして頂点 &lt;code&gt;u&lt;/code&gt; からの全ての辺をグラフから削除する。&lt;/li&gt;
&lt;li&gt;事前条件: &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; の有効な頂点記述子であること。&lt;/li&gt;
&lt;li&gt;事後条件: &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; 中のどの辺の始点または終点としても現れないこと。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量の保証&lt;/h2&gt;
&lt;p&gt;工事中&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.html&#34;&gt;Graphコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EventVisitor Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/EventVisitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;EventVisitor Concept&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このコンセプトは単独イベントビジタのインタフェースを定義する。 EventVisitor は適用メンバ関数 (&lt;code&gt;operator()&lt;/code&gt;) を持つ。これは、 EventVisitor 内の &lt;code&gt;event_filter&lt;/code&gt; typedef で指定されるイベントが起きた時に、グラフアルゴリズム内で実行される。 EventVisitor を組み合わせて &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVistorList.html&#34;&gt;EventVistorList&lt;/a&gt; を作成できる。&lt;/p&gt;
&lt;p&gt;以下に、 BGL アルゴリズムによって実行されるイベントのタグのリストを示す。各タグは、アルゴリズムのビジタのメンバ関数と対応している。例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt; の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; には &lt;code&gt;cycle_edge()&lt;/code&gt; というメンバ関数がある。これに対応するタグは &lt;code&gt;on_cycle_edge&lt;/code&gt; だ。 &lt;code&gt;operator()&lt;/code&gt; の第1引数は、イベントタグによって決まる、辺か頂点の記述子でなければならない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_initialize_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_start_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_discover_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_examine_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_tree_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_cycle_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_finish_vertex { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_forward_or_cross_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_back_edge { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_relaxed { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_not_relaxed { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_minimized { };
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; on_edge_not_minimized { };
} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// namespace boost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Refinement of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;Copy Constructible&lt;/a&gt; (ビジタのコピーは軽い操作である方がいい)&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;識別子&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Graph のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;EventVisitor のモデルの型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::vertex_descriptor&lt;/code&gt; 型か &lt;code&gt;boost::graph_traits&amp;lt;G&amp;gt;::edge_descriptor&lt;/code&gt; 型のオブジェクト。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Event Filter&lt;/td&gt;
&lt;td&gt;&lt;code&gt;V::event_filter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;どのイベントによってビジタが実行されるかを指定するタグ構造体。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;有効な表現式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Apply Visitor&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vis(x, g)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;オブジェクト &lt;code&gt;x&lt;/code&gt; に対してビジタの操作を実行する。 &lt;code&gt;x&lt;/code&gt; はグラフの辺か頂点の記述子である。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/null_visitor.html&#34;&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html&#34;&gt;EventVisitorList&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>EventVisitorList Concept -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitorList.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/EventVisitorList.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;EventVisitorList Concept&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;EventVisitorList は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; そのものか、 &lt;code&gt;std::pair&lt;/code&gt; で結合された EventVisitor のリストである。各グラフアルゴリズムには、 EventVisitorList を、アルゴリズムに必要な独自のビジタに変換するアダプタが定義されている。 以下に、イベントビジタを &lt;code&gt;std::pair&lt;/code&gt; で結合してリストにする方法の例と、アルゴリズムのビジタアダプタクラスの使い方の例を示す。&lt;/p&gt;
&lt;p&gt;仮に、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;深さ優先探索&lt;/a&gt;で、各頂点の発見／呼び出しの前後関係を、括弧を使った構造で出力したいとする。これを達成するには、 BGL アルゴリズム &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt; と2つのイベントビジタを使えばよい。以下の例の完全なソースコードは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dfs_parenthesis.cpp.html&#34;&gt;examples/dfs_parenthesis.cpp&lt;/a&gt; にある。まず、 2 つのイベントビジタを定義する。使うイベントビジタとして、 DFSVisitor に詳述されたイベントのリストの中から &lt;code&gt;on_discover_vertex&lt;/code&gt; と &lt;code&gt;on_finish_vertex&lt;/code&gt; を選ぶ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; open_paren &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; base_visitor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;open_paren&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; on_discover_vertex event_filter;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Vertex&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Vertex v, Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G) {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;(&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v;
  }
};
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; close_paren &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;public&lt;/span&gt; base_visitor&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;close_paren&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; on_finish_vertex event_filter;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Vertex&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Vertex v, Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G) {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; v &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;)&#34;&lt;/span&gt;;
  }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次に2つのイベントビジタオブジェクトを作り、 &lt;code&gt;std::make_pair&lt;/code&gt; で作られる &lt;code&gt;std::pair&lt;/code&gt; を使って、この2つから EventVisitorList を作る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;次にこのリストを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡したいところだが、 &lt;code&gt;depth_first_search()&lt;/code&gt; が要求しているのは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; であって、 EventVisitorList ではない。そこで EventVisitor のリストを DFSVisitor に変換するアダプタ、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt; を使う。他のビジタアダプタ同様、 &lt;code&gt;dfs_visitor&lt;/code&gt; には &lt;code&gt;make_dfs_visitor()&lt;/code&gt; という作成関数がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;make_dfs_visitor(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren()))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;さあこれで、以下のように、生成されたビジタオブジェクトを &lt;code&gt;depth_first_search()&lt;/code&gt; に渡すことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフオブジェクト G を作る...&lt;/span&gt;

  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;default_color_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; color(num_vertices(G));

  depth_first_search(G, make_dfs_visitor(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(open_paren(), close_paren())),
                     color.begin());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;3つ以上のイベントビジタのリストを作りたければ、以下のように &lt;code&gt;std::make_pair&lt;/code&gt; をネストして呼び出せばいい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitor1,
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitor2,
    ...
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(visitorN&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;, visitorN)...));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>謝辞 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/acknowledgements.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/acknowledgements.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;謝辞&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;Boost Graph Library の開発において、我々に刺激を与え、励ましてくれた たくさんの人々に感謝したい。&lt;/p&gt;
&lt;p&gt;最も深い感謝を Alexander Stepanov に。彼のジェネリックプログラミングにおける 先駆的仕事と、励ましと、そして BGL に寄贈された彼のアルゴリズムに対して。 Matthew Austern には、 STL の概念を文書化する作業に対して感謝を。 それは BGL における概念を作る基盤となった。 Dietmar Kühl に感謝。彼のジェネリックなグラフアルゴリズムとデザインパターン、 とりわけプロパティマップの抽象化に。&lt;/p&gt;
&lt;p&gt;Dave Abrahams 、 Jens Maurer 、 Beman Dawes 、 Gary Powell 、 Greg Colvin 、 Valentin Bonnard 、 そして Boost の残りのグループは、 BGL インタフェースに有益なアドバイスを与え、 改善のための数多くのことを提案し、 ドキュメントの校正をして、 そしてコードを洗練する際に力を貸してくれた。 公式レビューのマネージメントしくれた Dave Abrahams に特に感謝したい。&lt;/p&gt;
&lt;p&gt;BGL の改良に役立つ質問をしてくれた BGL ユーザの Gordon Woodhull 、 Dave Longhorn 、 Joel Phillips 、そして Edward Luke にも感謝する。&lt;/p&gt;
&lt;p&gt;ドキュメントの編集と校正を担当してくれた Jeffrey Squyres に特別の感謝を。&lt;/p&gt;
&lt;p&gt;Boost Graph Library の当初の作業は、部分的に NSF 助成金 ACI-9982205 および 米国エネルギー省科学局 MICS プログラム (Director, Office of Science, Division of Mathematical, Information, and Computational Sciences of the U.S. Department of Energy) 契約番号 DE-AC03-76SF00098 の支援を受けた。&lt;/p&gt;
&lt;p&gt;また、米エネルギー省科学局が支援する 国立エネルギーリサーチ科学コンピューティングセンター (National Energy Research Scientific Computing Center) の資源も利用させて頂いた。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/adjacency_list.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;adjacency_list&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed,
               VertexProperties, EdgeProperties,
               GraphProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスは一般化された隣接リストグラフ構造を実装する。 テンプレート・パラメータは要求を最も満たすクラスのバージョンを選べるように多くの形態の選択肢を提供する。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34;&gt;adjacency-list&lt;/a&gt; は基本的に二次元の構造で、ここで最初の次元の各要素は頂点を表し、頂点の各々はその辺リストの一次元構造を含んでいる。 Figure 1 は有向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 1:有向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータは外部の二次元コンテナを表すためにどんな種類のコンテナが使われるかを制御する。 &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータは辺リストを表すためにどんな種類の コンテナが使われるかを制御する。&lt;code&gt;EdgeList&lt;/code&gt; と &lt;code&gt;VertexList&lt;/code&gt; の 選択はグラフ構造の空間計算量を決定するだろう、そして様々なグラフ操作の時間計算量を決定するだろう。可能な選択とトレード・オフは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#choosing-graph-type&#34;&gt;Choosing the Edgelist and VertexList&lt;/a&gt; 中で論じられる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータはグラフが有向か無向か、または 入辺と出辺の両方にアクセスする (これを双方向性と呼ぶ) 有向かを制御する。 双方向性グラフは各辺が出辺リストと入辺リストの両方に現れるため、辺当たり有向グラフの二倍の空間を取る。Figure 2 は無向グラフの隣接リスト表現を示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 2:無向グラフの隣接リスト表現&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; クラスの使い方のチュートリアルは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink&#34;&gt;Using &lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; にある。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/family-tree-eg.cpp.html&#34;&gt;&lt;code&gt;examples/family-tree-eg.cpp&lt;/code&gt;&lt;/a&gt; 中にある例は家族の木 (family tree) をグラフで表現する方法を示す。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各々の頂点の辺リストを表わすために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフの頂点リストを表すために使われるコンテナのための選択子。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向か、無向か、または双方向の辺アクセス (出辺と入辺の両方にアクセス する) の有向かを選ぶ選択子。選択肢は &lt;code&gt;directedS&lt;/code&gt;、&lt;code&gt;undirectedS&lt;/code&gt;、 そして &lt;code&gt;bidirectionalS&lt;/code&gt; である。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部のプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperties&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ・オブジェクトのためのプロパティの記憶領域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.md.nolink&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.md.nolink&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Vertex and Edge Properties&lt;/h2&gt;
&lt;p&gt;色、距離、重み、そしてユーザ定義のプロパティのようなプロパティは、プロパティ を用いてグラフの頂点と辺に結びつけることができる。プロパティの値はグラフに よって提供されるプロパティ・マップ経由で読み書きできる。プロパティ・マップ は get(property, g) 関数経由で得られる。プロパティの使い方は 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#adjacency-list-properties&#34;&gt;Internal Properties&lt;/a&gt; 内で述べられている。プロパティ・マップは章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.md.nolink&#34;&gt;Property Map Concepts&lt;/a&gt; 内で定義されているインターフェースを実装するオブジェクトである。 &lt;code&gt;adjacency_list&lt;/code&gt; クラスから得られるプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.md.nolink&#34;&gt;Lvalue Property Map&lt;/a&gt; コンセプトのモデルである。もし &lt;code&gt;adjacency_list&lt;/code&gt; が &lt;code&gt;const&lt;/code&gt; なら、 プロパティ・マップは定数である。さもなくばプロパティ・マップは変更可能である。&lt;/p&gt;
&lt;p&gt;もしグラフの &lt;code&gt;VertexList&lt;/code&gt; が &lt;code&gt;vecS&lt;/code&gt; なら、グラフは &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティのためのプロパティ・マップを経由して アクセスされた組み込みの頂点の添え字を持っている。添え字は &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲内に整列し、連続している。頂点が 削除される時、添え字はそれらのプロパティを持ち続けるよう調整される。 これらの添え字を外部のプロパティの記憶領域にアクセスするために使う際には いくらか気をつけなければならない。 頂点の添え字のためのプロパティ・マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;Readable Property Map&lt;/a&gt; のモデルである。&lt;/p&gt;
&lt;h2&gt;Iterator and Descriptor Stability/Invalidation&lt;/h2&gt;
&lt;p&gt;辺の追加や削除によってグラフの構造を変更する時はいくらか注意しなければならない。&lt;code&gt;adjacency_list&lt;/code&gt; の型と操作に依存して、グラフ内を指すイテレータや記述子オブジェクトのいくつかは無効になるかもしれない。 例えば、次のコードは未定義の (悪い) 振る舞いの結果となるだろう:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, vecS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=vecS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これでもまだ間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これが問題である理由は &lt;code&gt;remove_vertex()&lt;/code&gt; を呼び出しており、そしてそれが &lt;code&gt;VertexList=vecS&lt;/code&gt; の &lt;code&gt;adjacency_list&lt;/code&gt; とともに使われたとき、グラフのための全てのイテレータと記述子 (例えば &lt;code&gt;vi&lt;/code&gt; や &lt;code&gt;vi_end&lt;/code&gt;) を無効にするために、ループの次の繰り返し中に災難を引き起こす。&lt;/p&gt;
&lt;p&gt;もし異なる種類の &lt;code&gt;adjacency_list&lt;/code&gt; を使い、そして &lt;code&gt;VertexList=listS&lt;/code&gt; ならば、イテレータが削除された実際の頂点を指してなければ &lt;code&gt;remove_vertex&lt;/code&gt; を呼ぶことによってイテレータは無効にならない。次のコードはこれを説明する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;listS, listS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// VertexList=listS&lt;/span&gt;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;G&lt;/span&gt;(N);
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// グラフに書き込む...&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除しようとする試み。間違っている！&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 全ての頂点を削除する。これは大丈夫である&lt;/span&gt;
graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator vi, vi_end, next;
tie(vi, vi_end) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (next &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vi; vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vi_end; vi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; next) {
  &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;next;
  remove_vertex(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi, G);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;安定性の問題は更に頂点記述子と辺記述子に影響を及ぼす。例えば、最短経路木中の頂点の親 (または先行点) の過程を保持するために頂点記述子の &lt;code&gt;vector&lt;/code&gt; を使ったとしよう (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ)。&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; を呼んで親の &lt;code&gt;vector&lt;/code&gt; を作成し、 それからグラフから頂点を削除する。続いて親の &lt;code&gt;vector&lt;/code&gt; を使おうと試みるが、全ての頂点記述子は無効になっているので、結果は正しくない。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(num_vertices(G));
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(num_vertices(G));

dijkstra_shortest_paths(G, s, distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
  predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));

remove_vertex(s, G); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// まずい考えだ！親 vector 中の頂点記述子を無効にする&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 次は間違った結果を生じる&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt;(tie(vi, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); vi &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;vi)
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; p[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; is the parent of &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;vi &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この議論の中でイテレータと記述子の無効化は、操作によって &lt;strong&gt;直接影響を受けない&lt;/strong&gt; イテレータと記述子の無効化に携わっていることに注意しなさい。 例えば、&lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の実行は、&lt;code&gt;adjacency_list&lt;/code&gt; の種類に関係なく、いつも &lt;code&gt;(u,v)&lt;/code&gt; のためのどの辺記述子も、また&lt;code&gt;(u,v)&lt;/code&gt; を指すどの辺記述子も無効にするだろう。 このイテレータと記述子の無効化の議論中で、他の辺 (&lt;code&gt;(u,v)&lt;/code&gt; ではない) を指す辺記述子とイテレータにおける &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; の影響にのみ携わっている。&lt;/p&gt;
&lt;p&gt;一般的に頂点記述子と辺記述子を安定に (決して無効にならない) したければ、 &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; と &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;listS&lt;/code&gt; または &lt;code&gt;setS&lt;/code&gt; を使いなさい。もし記述子とイテレータの安定性に気をもまないけれどもメモリの 消費量とグラフの巡回速度をより心配するなら、&lt;code&gt;VertexList&lt;/code&gt; かつ／または &lt;code&gt;EdgeList&lt;/code&gt; テンプレート・パラメータのために &lt;code&gt;vecS&lt;/code&gt; を使いなさい。&lt;/p&gt;
&lt;p&gt;下記の表はどの操作が記述子とイテレータを無効にする原因となるかを要約する。 表中で、&lt;code&gt;EL&lt;/code&gt; は &lt;code&gt;EdgeList&lt;/code&gt; の省略形で &lt;code&gt;VL&lt;/code&gt; は &lt;code&gt;VertexList&lt;/code&gt; を意味する。 &lt;strong&gt;Adj Iter (隣接イテレータ)&lt;/strong&gt; カテゴリは &lt;code&gt;out_edge_iterator&lt;/code&gt;、&lt;code&gt;in_edge_iterator&lt;/code&gt;、そして &lt;code&gt;adjacency_iterator&lt;/code&gt; 型を含む。記述子とイテレータの無効化の より詳しい説明は各操作のドキュメント中で示されている。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;頂点記述子&lt;/th&gt;
&lt;th&gt;辺記述子&lt;/th&gt;
&lt;th&gt;頂点イテレータ&lt;/th&gt;
&lt;th&gt;辺イテレータ&lt;/th&gt;
&lt;th&gt;隣接イテレータ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS &amp;amp;&amp;amp;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Directed=directedS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_out_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_in_edge_if()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;td&gt;〃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove_vertex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;VL=vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Table: 記述子とイテレータの無効化の要約&lt;/p&gt;
&lt;h2&gt;Associated Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;adjacency_list_traits&amp;lt;EdgeList, VertexList, Directed&amp;gt;::vertex_descriptor
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた頂点記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_list&lt;/code&gt; と結びついた辺記述子の型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;VertexList=vecS&lt;/code&gt; なら &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;vertex_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 もし &lt;code&gt;EdgeList=vecS&lt;/code&gt; なら &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。そうでなければ &lt;code&gt;out_edge_iterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/BidirectionalIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; をモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 &lt;code&gt;adjacency_iterator&lt;/code&gt; は &lt;code&gt;out_edge_iterator&lt;/code&gt; と同じイテレータ・ コンセプトをモデルとする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフが有向 (&lt;code&gt;directed_tag&lt;/code&gt;) か、無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) かについての情報を提供する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これはグラフのクラスが多重辺 (同じ始点と終点を持つ辺) の挿入を許可するかどうかを述べる。二つのタグは &lt;code&gt;allow_parallel_edge_tag&lt;/code&gt; と &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;code&gt;setS&lt;/code&gt; と &lt;code&gt;hash_setS&lt;/code&gt; の亜種は多重辺を許可しない一方で他の型は多重辺を許可する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点に接続する辺の数を扱うのに使われる型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ中の頂点プロパティまたは辺プロパティのためのプロパティ・マップの型。 具体的なプロパティは &lt;code&gt;Property&lt;/code&gt; テンプレート引数で指定され、グラフのための &lt;code&gt;VertexProperties&lt;/code&gt; もしくは &lt;code&gt;EdgeProperties&lt;/code&gt; で指定されたプロパティのどちらか一つと一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Property&lt;/code&gt; タグで指定されたグラフのプロパティのためのプロパティの値型。&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;デフォルト・コンストラクタ。0 個の頂点と0 個の辺からなる空のグラフ・ オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コピー・コンストラクタ。辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーである新しいグラフを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;代入演算子。&lt;code&gt;this&lt;/code&gt; に 辺、頂点、そしてプロパティを含んでいるグラフ &lt;code&gt;x&lt;/code&gt; のコピーを入れる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list(vertices_size_type n, 
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と 0 個の辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;template &amp;lt;class EdgeIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               vertices_size_type n, 
               edges_size_type m = 0, 
               const GraphProperty&amp;amp; p = GraphProperty())&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;
`n` 個の頂点と、範囲 `[first, last)` で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 `EdgeIterator` は [`InputIterator`](http://www.sgi.com/tech/stl/InputIterator.html) のモデルでなければならない。`EdgeIterator` の値型は `std::pair` でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは `[0, n)` の範囲内に整列していなければならない。


***
```cpp
template &amp;lt;class EdgeIterator, class EdgePropertyIterator&amp;gt;
adjacency_list(EdgeIterator first, EdgeIterator last,
               EdgePropertyIterator ep_iter,
               vertices_size_type n,
               vertices_size_type m = 0,
               const GraphProperty&amp;amp; p = GraphProperty())
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 個の頂点と、範囲 &lt;code&gt;[first, last)&lt;/code&gt; で与えられた辺リストで指定された辺からなるグラフ・オブジェクトを作成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; と &lt;code&gt;EdgePropertyIterator&lt;/code&gt; は &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;code&gt;EdgeIterator&lt;/code&gt; の値型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、そしてペア中の型は汎整数型である。整数は頂点に該当し、それらは &lt;code&gt;[0, n)&lt;/code&gt; の範囲内に整列していなければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperties&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear()
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから全ての辺と頂点を削除する。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; swap(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; のグラフの頂点、辺、そしてプロパティと、グラフ&lt;code&gt;x&lt;/code&gt;の頂点、辺、そしてプロパティを交換する。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;h3&gt;Structure Access&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; の出辺へのアクセスを提供するイテレータ範囲を返す。もしグラフが無向グラフなら、このイテレータ範囲は 頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。 有向グラフと無向グラフの両方で、出辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; に隣接する頂点の場合は &lt;code&gt;source(e, g) == u&lt;/code&gt; かつ &lt;code&gt;target(e, g) == v&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;in_edge_iterator, in_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
in_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; の入辺へのアクセスを提供する イテレータ範囲を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに &lt;code&gt;bidirectionalS&lt;/code&gt; が指定されている場合にのみ利用できる。 入辺 &lt;code&gt;e&lt;/code&gt; にとって &lt;code&gt;v&lt;/code&gt; に隣接している何らかの頂点 &lt;code&gt;u&lt;/code&gt; に対して、グラフが有向であろうと無向であろうと、&lt;code&gt;target(e, g) == v&lt;/code&gt; かつ &lt;code&gt;source(e, g) == u&lt;/code&gt; である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; を出て行く辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
in_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; に入ってくる辺の数を返す。この操作は &lt;code&gt;Directed&lt;/code&gt; テンプレート・パラメータに&lt;code&gt;bidirectionalS&lt;/code&gt;が指定されている場合にのみ利用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type
num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type
num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の辺の数を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点リスト中の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の頂点 &lt;code&gt;u&lt;/code&gt; と頂点 &lt;code&gt;v&lt;/code&gt; を結ぶ辺を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge_range(vertex_descriptor u, vertex_descriptor v,
           &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; への全ての多重辺のための範囲を与える出辺イテレータのペアを返す。この関数は &lt;code&gt;adjacency_list&lt;/code&gt; 用の &lt;code&gt;EdgeList&lt;/code&gt; が終点に従って出辺をソートし、かつ多重辺を考慮するコンテナである時にのみ動作する。&lt;code&gt;multisetS&lt;/code&gt; 選択子はそのようなコンテナを選択する。&lt;/p&gt;
&lt;h3&gt;Structure Modification&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフに辺 &lt;code&gt;(u,v)&lt;/code&gt; を付け加え、新しい辺のための辺記述子を返す。 多重辺を許可しないグラフにとっては、もし辺がすでにグラフ中にあるなら、二重には付け加えられず、&lt;code&gt;bool&lt;/code&gt; フラグは &lt;code&gt;false&lt;/code&gt; になるだろう。同様に、もし &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; が 同じ頂点のための記述子 (ループを作っている) であり、かつグラフが無向グラフならば、辺は付け加えられずフラグは &lt;code&gt;false&lt;/code&gt; になるだろう。 フラグが &lt;code&gt;false&lt;/code&gt; の時は、返された辺記述子は既に存在している辺を指す。&lt;/p&gt;
&lt;p&gt;出辺リスト中の新しい辺の配置は一般に不定である。もっとも出辺リストの順序付けは &lt;code&gt;EdgeList&lt;/code&gt; の選択を通じて成し遂げられるが。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;VertexList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; でありかつ頂点記述子 &lt;code&gt;u&lt;/code&gt; または &lt;code&gt;v&lt;/code&gt; (それは整数である) がグラフ中の現在の頂点の数より大きな値を持っているなら、頂点の数が &lt;code&gt;std::max(u,v) + 1&lt;/code&gt; に なるようにグラフが拡大される。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; であれば、この操作によって頂点 &lt;code&gt;u&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; も無効になるだろう。 これはもし &lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;push(container, x)&lt;/code&gt; が呼び出されたときにそのイテレータを無効にするようなユーザ定義のコンテナ (章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/using_adjacency_list.md.nolink#custom-storage&#34;&gt;Customizing the Adjacency List Storage&lt;/a&gt; を見なさい) であれば同様にあてはまる。 もしグラフが同様に双方向であれば、&lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;in_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりに グラフが無向グラフならば &lt;code&gt;v&lt;/code&gt; のためのどの &lt;code&gt;out_edge_iterator&lt;/code&gt; もやはり無効にされる。もしその代わりにグラフが有向グラフならば、 &lt;code&gt;add_edge()&lt;/code&gt; は同様にどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフに付け加え、&lt;code&gt;p&lt;/code&gt; を辺の内部のプロパティの記憶領域の値として添える。さらなる詳細のために前の &lt;code&gt;add_edge()&lt;/code&gt; 非メンバ関数も見なさい。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフから取り除く。&lt;/p&gt;
&lt;p&gt;この操作は辺 &lt;code&gt;(u,v)&lt;/code&gt; を指すどの発行済みの辺記述子もイテレータも無効となる原因になる。加えて、もし &lt;code&gt;EdgeList&lt;/code&gt; の選択子が &lt;code&gt;vecS&lt;/code&gt; ならば無向と双方向のグラフの場合この操作は頂点 &lt;code&gt;u&lt;/code&gt; とまた頂点 &lt;code&gt;v&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; をグラフから取り除く。これは多重グラフの場合 &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数とは違う。この &lt;code&gt;remove_edge(e, g)&lt;/code&gt; 関数は一つの辺だけを取り除くのに対して &lt;code&gt;remove_edge(u, v, g)&lt;/code&gt; 関数は全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を取り除く。&lt;/p&gt;
&lt;p&gt;この操作は記述子 &lt;code&gt;e&lt;/code&gt; が指す同じ辺のためのどの発行済みの辺記述子も イテレータも無効にする。加えて、この操作は &lt;code&gt;target(e, g)&lt;/code&gt; のための辺リストを指すどのイテレータも無効にするだろう。さらに、有向グラフにとってこれはグラフのためのどの &lt;code&gt;edge_iterator&lt;/code&gt; も無効にする。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(out_edge_iterator iter, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;remove_edge(*iter, g)&lt;/code&gt; と同じ効果を持つ。違いはこの関数は有向グラフの場合定数の時間計算量を持つのに対し、&lt;code&gt;remove_edge(e, g)&lt;/code&gt; は O(E/V) の時間計算量を持つ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_out_edge_if(vertex_descriptor u, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                        adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;u&lt;/code&gt; の出辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_in_edge_if(vertex_descriptor v, &lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate,
                       adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての頂点 &lt;code&gt;v&lt;/code&gt; の入辺を取り除く。 すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向と双方向の &lt;code&gt;adjacency_list&lt;/code&gt; グラフに利用できるが、有向グラフには利用できない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge_if(&lt;a href=&#34;http://www.sgi.com/tech/stl/Predicate.html&#34; target=&#34;_blank&#34;&gt;Predicate&lt;/a&gt; predicate, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから &lt;code&gt;predicate&lt;/code&gt; を満たす全ての辺を取り除く。すなわち、もし述語が辺記述子に適用されたとき &lt;code&gt;true&lt;/code&gt; を返すならば、辺が取り除かれる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は削除された各辺において &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点をグラフに付け加え、新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
add_vertex(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexProperties&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
           adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;指定されたプロパティを持つ頂点をグラフに付け加える。新しい頂点のための頂点記述子を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; への、そして &lt;code&gt;u&lt;/code&gt; からの全ての辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点または終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_out_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての出辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を始点として 持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出す時のそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は無向グラフには適用できない (代わりに &lt;code&gt;clear_vertex()&lt;/code&gt; を使いなさい)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_in_edges(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; からの全ての入辺を取り除く。頂点は依然としてグラフの頂点集合中に現れる。&lt;/p&gt;
&lt;p&gt;記述子とイテレータの持続性に対する作用は &lt;code&gt;u&lt;/code&gt; を終点として持つ全ての辺にとって &lt;code&gt;remove_edge()&lt;/code&gt; を呼び出すときのそれと同じである。&lt;/p&gt;
&lt;p&gt;この操作は双方向グラフにのみ適用できる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_vertex(vertex_descriptor u, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; をグラフの頂点集合から取り除く。頂点が削除されるとき、 頂点 &lt;code&gt;u&lt;/code&gt; への、また頂点 &lt;code&gt;u&lt;/code&gt; への辺は存在しないものと仮定する。 これを確実にする一つの手段はあらかじめ &lt;code&gt;clear_vertex()&lt;/code&gt; を呼ぶことである。&lt;/p&gt;
&lt;p&gt;もし &lt;code&gt;adjacency_list&lt;/code&gt; の &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータが &lt;code&gt;vecS&lt;/code&gt; なら、グラフのための全ての頂点記述子、辺記述子、そしてイテレータ はこの操作によって無効にされる。各頂点のための組み込みの &lt;code&gt;vertex_index_t&lt;/code&gt; プロパティは操作の後もなお頂点の添え字が連続した範囲 &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; に配列しているように番号が付け直される。 もし組み込みの頂点の添え字に基づく外部のプロパティの記憶領域を使って いるなら、外部の記憶領域は調整される必要があるだろう。 他の選択は組み込みの頂点の添え字を使用せずに独自の頂点の添え字プロパティを付け加えるためにプロパティを代わりに使うことである。 もしたびたび &lt;code&gt;remove_vertex()&lt;/code&gt; 関数を使用する必要があるなら、 &lt;code&gt;VertexList&lt;/code&gt; テンプレート・パラメータには &lt;code&gt;listS&lt;/code&gt; 選択子が非常によい選択である。&lt;/p&gt;
&lt;h3&gt;Property Map Accessors&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, Tag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PropertyTag&lt;/code&gt; で指定される頂点プロパティのためのプロパティ・マップ・ オブジェクトを返す。&lt;code&gt;PropertyTag&lt;/code&gt; はグラフの &lt;code&gt;VertexProperty&lt;/code&gt; テンプレート引数中に指定されたプロパティの一つに一致しなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; が頂点記述子か辺記述子のどちらか一方である場合、これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;X&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink&#34;&gt;PropertyTag&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは &lt;code&gt;x&lt;/code&gt; のためのプロパティ値を &lt;code&gt;value&lt;/code&gt; にする。&lt;code&gt;x&lt;/code&gt; は頂点記述子か辺記述子のどちらか一方である。&lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_list, PropertyTag&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; と互換でなければならない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;GraphProperties&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_property&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_list, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyTag.md.nolink#GraphPropertyTag&#34;&gt;GraphPropertyTag&lt;/a&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ・オブジェクト &lt;code&gt;g&lt;/code&gt; に結びつけられた &lt;code&gt;GraphPropertyTag&lt;/code&gt; で指定されたプロパティを返す。&lt;code&gt;graph_property&lt;/code&gt; 特性クラスは &lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt; 中で定義されている。&lt;/p&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html&#34;&gt;&lt;code&gt;adjacency_list_traits&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.md.nolink&#34;&gt;&lt;code&gt;property_map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_traits.md.nolink&#34;&gt;&lt;code&gt;graph_traits&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_list_traits -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list_traits.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/adjacency_list_traits.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;adjacency_list_traits&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_list_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;EdgeList, VertexList, Directed&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは &lt;code&gt;adjacency_list&lt;/code&gt; クラスに結びついた型のいくつかをアクセスする代替方法を提供する。このクラスの主な理由は値が頂点記述子または辺記述子であるグラフ・プロパティを時々作成したいと思うからである。もしこのために &lt;code&gt;graph_traits&lt;/code&gt; を使おうと試みるならば、相互に再帰的な型の問題にぶつかるだろう。この問題を避けるために &lt;code&gt;adjacency_list_traits&lt;/code&gt; クラスが提供され、それはユーザにグラフのためのプロパティ型を提供する 要求をすることなしにユーザが頂点記述子型または辺記述型にアクセスできるようにする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;EdgeList&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexList&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Directed&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; adjacency_list_traits {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... vertex_descriptor;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... edge_descriptor;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... directed_category;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; ... edge_parallel_category;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost/graph/adjacency_list.hpp&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺コンテナの実装のための選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;頂点コンテナの実装のための選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vecS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有向であるか無向であるかの選択子型。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;Assignable&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Type Requirements&lt;/h2&gt;
&lt;p&gt;工事中&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vertex_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ中の頂点を識別するのに使われるオブジェクトのための型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edge_descriptor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフ中の辺を識別するのに使われるオブジェクトのための型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;directed_category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;これはグラフが無向 (&lt;code&gt;undirected_tag&lt;/code&gt;) であるか有向 (&lt;code&gt;directed_tag&lt;/code&gt;) であるかを述べる。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;edge_parallel_category&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;これはグラフが多重辺の挿入を許可する (&lt;code&gt;allow_parallel_edge_tag&lt;/code&gt;) か、または自動的に多重辺を取り除く (&lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt;) かを述べる。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;See Also&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>adjacency_matrix -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/adjacency_matrix.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;adjacency_matrix&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Directed, VertexProperty, 
                 EdgeProperty, GraphProperty,
                 Allocator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt; クラスは 従来からの隣接行列を用いて BGL グラフインタフェースを提供する。 頂点数 V のグラフに対して、 V x V 行列を用いる。 その行列では、各要素 a&lt;sub&gt;ij&lt;/sub&gt; は 頂点 &lt;em&gt;i&lt;/em&gt; から 頂点 &lt;em&gt;j&lt;/em&gt; への辺が存在するか否かを示すブール値のフラグである。 図 1 ではグラフの隣接行列表現が示されている。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/figs/adj-matrix-graph3.gif&#34; /&gt; &lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/figs/adj-matrix.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 1: 有向グラフの隣接行列表現。&lt;/p&gt;
&lt;p&gt;この隣接行列形式の隣接リストに対する利点は辺の挿入と削除が定数時間で終了するという点である。 いくつか不便な点もある。 まず1つ目は、使用するメモリの量が O(V + E) (ここで、E は辺の数) ではなく、 O(V2) である という点である。 2つ目は、全ての辺を辿る処理(例えば、幅優先探索)は、 O(V2) 時間内で実行されるが、 隣接リストでは O(V + E) 時間である。 つまり、密度の高い(E が V2に近い)グラフに対しては、 &lt;code&gt;adjacency_matrix&lt;/code&gt; の方がよく、 密度の低い(E が V2 よりもずっと小さい)グラフに対しては、 &lt;code&gt;adjacency_list&lt;/code&gt; の方がよい ということである。 &lt;code&gt;adjacency_matrix&lt;/code&gt; クラスはプロパティテンプレートパラメータを介して頂点と辺にオブジェクトを付与することを可能とすることで、 既存のデータ構造を拡張したものである。 第 XXX 章には内部プロパティの使用方法について説明がある。 無向グラフの場合には、 &lt;code&gt;adjacency_matrix&lt;/code&gt; クラスは V x V 行列を全て使用せず、 代わりに下の三角部分(対角成分とその下)を用いる。 それは、無向グラフの隣接行列は対称行列となるからである。 これによって使用するメモリは (V2)/2 へと軽減される。 図 2 で無向グラフの隣接行列表現を示している。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix-graph3.gif&#34; /&gt; &lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undir-adj-matrix2.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 2: 無向グラフの隣接行列表現。&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;図1のグラフを生成する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { A, B, C, D, E, F, N };
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; name &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;ABCDEF&#34;&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;directedS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; Graph;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(N);
add_edge(B, C, g);
add_edge(B, F, g);
add_edge(C, A, g);
add_edge(C, C, g);
add_edge(D, E, g);
add_edge(E, D, g);
add_edge(F, A, g);

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;vertex set: &#34;&lt;/span&gt;;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_vertices(g, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;edge set: &#34;&lt;/span&gt;;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_edges(g, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;out-edges: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_graph(g, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;vertex set: A B C D E F 

edge set: (B,C) (B,F) (C,A) (C,C) (D,E) (E,D) (F,A) 

out-edges: 
A --&amp;gt; 
B --&amp;gt; C F 
C --&amp;gt; A C 
D --&amp;gt; E 
E --&amp;gt; D 
F --&amp;gt; A 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;図2のグラフを生成する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { A, B, C, D, E, F, N };
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; name &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;ABCDEF&#34;&lt;/span&gt;;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;undirectedS&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; UGraph;
UGraph &lt;span style=&#34;color: #0000FF&#34;&gt;ug&lt;/span&gt;(N);
add_edge(B, C, ug);
add_edge(B, F, ug);
add_edge(C, A, ug);
add_edge(D, E, ug);
add_edge(F, A, ug);

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;vertex set: &#34;&lt;/span&gt;;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_vertices(ug, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;edge set: &#34;&lt;/span&gt;;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_edges(ug, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;incident edges: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;print_graph(ug, name);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力:&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;vertex set: A B C D E F 

edge set: (C,A) (C,B) (E,D) (F,A) (F,B) 

incident edges: 
A &amp;lt;--&amp;gt; C F 
B &amp;lt;--&amp;gt; C F 
C &amp;lt;--&amp;gt; A B 
D &amp;lt;--&amp;gt; E 
E &amp;lt;--&amp;gt; D 
F &amp;lt;--&amp;gt; A B 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;p&gt;boost/graph/adjacency_matrix.hpp&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Directed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフが有効か無向かを選ぶ選択子。オプションは &lt;code&gt;directedS&lt;/code&gt; と &lt;code&gt;undirectedS&lt;/code&gt;。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;directedS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VertexProperty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部プロパティ記憶域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeProperty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内部プロパティ記憶域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GraphProperty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフのオブジェクトの内部プロパティ記憶域を指定する。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;no_property&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Model Of&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexAndEdgeListGraph.html&#34;&gt;VertexAndEdgeListGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyMatrix.html&#34;&gt;AdjacencyMatrix&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutablePropertyGraph.html&#34;&gt;MutablePropertyGraph&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Assignable.html&#34;&gt;Assignable&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Associates Types&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt; と対応付けられた頂点記述子の型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt; と対応付けられた辺記述子の型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vertices()&lt;/code&gt; によって返されるイテレータの型。 この頂点イテレータは&lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;RandomAccessIterator&lt;/a&gt;のモデルである。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータの型。 この辺イテレータは&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt;のモデルである。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;out_edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;out_edges()&lt;/code&gt; によって返されるイテレータの型。 このイテレータは&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html&#34;&gt;MultiPassInputIterator&lt;/a&gt;のモデルである。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;adjacency_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;adjacent_vertices()&lt;/code&gt; によって返されるイテレータの型。 このイテレータは出辺イテレータと同じコンセプトのモデルである。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;AdjacencyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;directed_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフが 有向(&lt;code&gt;directed_tag&lt;/code&gt;)であるか無向(&lt;code&gt;undirected_tag&lt;/code&gt;)であるかに関する情報を提供する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_parallel_category
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;隣接行列は多重辺の挿入を許可しないので、 この型は常に &lt;code&gt;disallow_parallel_edge_tag&lt;/code&gt; である。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Graph.html&#34;&gt;Graph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点数を扱うための型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edges_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの辺数を扱うための型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;degree_size_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点からの出辺数を扱うための型。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, PropertyTag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, PropertyTag&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点もしくは辺のプロパティに対するマップの型。 具体的なプロパティはテンプレート引数 &lt;code&gt;PropertyTag&lt;/code&gt; によって指定され、 グラフの &lt;code&gt;VertexProperty&lt;/code&gt; もしくは &lt;code&gt;EdgeProperty&lt;/code&gt; で 指定されているプロパティの内の1つに適合していなければならない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyGraph.html&#34;&gt;PropertyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;h2&gt;Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;adjacency_matrix(vertices_size_type n,
                 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点数 &lt;code&gt;n&lt;/code&gt;、辺数 0 であるグラフのオブジェクトを生成する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; EdgeIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacency_matrix(EdgeIterator first,
                 EdgeIterator last,
                 vertices_size_type n,
                 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点数 &lt;code&gt;n&lt;/code&gt; で、辺が &lt;code&gt;[first, last)&lt;/code&gt; の範囲で 与えられたリストで指定された辺をもつグラフのオブジェクトを生成する。 EdgeIterator の値の型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、それは整数型の組である。 それら整数は頂点に対応し、&lt;code&gt;[0, n)&lt;/code&gt; の範囲になければならない。
(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IteratorConstructibleGraph.html&#34;&gt;IteratorConstructibleGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; EdgeIterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; EdgePropertyIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacency_matrix(EdgeIterator first, EdgeIterator last,
                 EdgePropertyIterator ep_iter,
                 vertices_size_type n,
                 &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; GraphProperty())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点数 &lt;code&gt;n&lt;/code&gt; で、辺が &lt;code&gt;[first, last)&lt;/code&gt; の範囲で与えられたリストで指定された辺をもつグラフのオブジェクトを生成する。 &lt;code&gt;EdgeIterator&lt;/code&gt; の値の型は &lt;code&gt;std::pair&lt;/code&gt; でなければならず、それは整数型の組である。 それら整数は頂点に対応し、&lt;code&gt;[0, n)&lt;/code&gt; の範囲になければならない。 &lt;code&gt;ep_iter&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;EdgeProperty&lt;/code&gt; であるべきである。&lt;/p&gt;
&lt;h2&gt;Non-Member Functions&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_iterator, vertex_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点集合へのアクセスを提供するイテレータの範囲を返す。 (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータの範囲を返す。 (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_iterator, adjacency_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
adjacent_vertices(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; で頂点 &lt;code&gt;v&lt;/code&gt; に隣接する頂点へのアクセスを提供するイテレータの範囲を返す。 (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyGraph.html&#34;&gt;AdjacencyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;out_edge_iterator, out_edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
out_edges(vertex_descriptor v, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; で頂点 &lt;code&gt;v&lt;/code&gt; の出辺へのアクセスを提供するイテレータの範囲を返す。 グラフが無向であれば、このイテレータの範囲は、頂点 &lt;code&gt;v&lt;/code&gt; に接続する全ての辺へのアクセスを提供する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;degree_size_type
out_degree(vertex_descriptor u, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; を出る辺の数を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertices_size_type num_vertices(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の頂点数を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edges_size_type num_edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺数を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor vertex(vertices_size_type n, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの頂点リスト内の &lt;code&gt;n&lt;/code&gt; 番目の頂点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edge(vertex_descriptor u, vertex_descriptor v,
     &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; で、頂点 &lt;code&gt;u&lt;/code&gt; を頂点 &lt;code&gt;v&lt;/code&gt; へ接続する頂点を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/AdjacencyMatrix.html&#34;&gt;AdjacencyMatrix&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフへ追加し、その新しい辺への辺記述子を返す。 すでに辺があれば二重には追加されず、&lt;code&gt;bool&lt;/code&gt; のフラグは&lt;code&gt;false&lt;/code&gt;となる。 この処理はグラフのいかなるイテレータ及び記述子を無効化することはない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_descriptor, &lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
add_edge(vertex_descriptor u, vertex_descriptor v,
         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; EdgeProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p,
         adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;(u,v)&lt;/code&gt; をグラフへ追加し、その新しい辺にその辺の内部プロパティ記憶域の値として、 &lt;code&gt;p&lt;/code&gt; を付与する。 さらなる詳細は前にある非メンバ関数 &lt;code&gt;add_edge()&lt;/code&gt; を見よ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(vertex_descriptor u, vertex_descriptor v,
                 adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから辺 &lt;code&gt;(u,v)&lt;/code&gt; を削除する。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; remove_edge(edge_descriptor e, adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから辺 &lt;code&gt;e&lt;/code&gt; を削除する。 この操作は &lt;code&gt;remove_edge(source(e, g), target(e, g), g)&lt;/code&gt; を呼び出すのと等価である。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; clear_vertex(vertex_descriptor u, adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフから頂点 &lt;code&gt;u&lt;/code&gt; に接続する全ての辺を削除する。 その頂点はグラフの頂点集合からは削除されない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type
get(Property, adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
get(Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Property&lt;/code&gt; で指定される頂点プロパティへのプロパティマップのオブジェクトを返す。 &lt;code&gt;Property&lt;/code&gt; はグラフのテンプレート引数 &lt;code&gt;VertexProperty&lt;/code&gt; で指定されるプロパティの1つと適合していなければならない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyGraph.html&#34;&gt;PropertyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
  typenamae property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;adjacency_matrix, Property&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;const_type
&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
get(Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;頂点もしくは辺の記述子 &lt;code&gt;x&lt;/code&gt; に対するプロパティ値を返す。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyGraph.html&#34;&gt;PropertyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; X, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
put(Property, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, X x, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Value&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;値&lt;code&gt;x&lt;/code&gt; をプロパティ値として &lt;code&gt;value&lt;/code&gt; にセットする。 &lt;code&gt;x&lt;/code&gt; は 頂点もしくは辺の記述子である。 &lt;code&gt;Value&lt;/code&gt; は &lt;code&gt;typename property_traits&amp;lt;property_map&amp;lt;adjacency_matrix, Property&amp;gt;::type&amp;gt;::value_type&lt;/code&gt; に変換可能でなければならない。&lt;/p&gt;
&lt;p&gt;(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/PropertyGraph.html&#34;&gt;PropertyGraph&lt;/a&gt; からの要求。)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphProperty, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_value&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;GraphProperty, GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, GraphProperty)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフのオブジェクト &lt;code&gt;g&lt;/code&gt; に付与された &lt;code&gt;GraphProperty&lt;/code&gt; で指定されたプロパティを返す。 特性クラス &lt;code&gt;property_value&lt;/code&gt; は boost/pending/property.hpp で定義される。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphProperty, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_value&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;GraphProperty, GraphProperty&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;
get_property(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; adjacency_matrix&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, GraphProperty)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフのオブジェクト &lt;code&gt;g&lt;/code&gt; に付与された &lt;code&gt;GraphProperty&lt;/code&gt; で指定されたプロパティを返す。 特性クラス &lt;code&gt;property_value&lt;/code&gt; は boost/pending/property.hpp で定義される。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 KANAHORI Toshihiro &lt;a href=&#34;mailto:kanahori@k.tsukuba-tech.ac.jp&#34;&gt;kanahori@k.tsukuba-tech.ac.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bandwidth -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bandwidth.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;bandwidth&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; VertexIndexMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, VertexIndexMap index_map)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;無向グラフの 帯域幅 (bandwidth) は二つの隣接頂点の間の最大距離 で、頂点が構成単位間隔に置かれた線上で測定された距離である。別の言い方を すると、 もし無向グラフの頂点 &lt;code&gt;G=(V,E)&lt;/code&gt; に各々 &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;|V| - 1&lt;/code&gt; までの &lt;code&gt;index[v]&lt;/code&gt; によって与えられる添え字が割り当てられているなら、&lt;code&gt;G&lt;/code&gt; の帯域幅は以下である：&lt;/p&gt;
&lt;p&gt;B(G) = max { |index[u] - index[v]|  | (u,v) in E }&lt;/p&gt;
&lt;h2&gt;Defined in&lt;/h2&gt;
&lt;p&gt;boost/graph/bandwidth.hpp&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;ith_bandwidth&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt; (&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
ith_bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor i,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Graph, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; VertexIndexMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
ith_bandwidth(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor i,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
      VertexIndexMap index)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフの &lt;code&gt;i&lt;/code&gt; 番目の帯域幅 (i-th bandwidth) は、 &lt;code&gt;i&lt;/code&gt; 番目の頂点とその隣接のいずれかとの間の最大距離である。&lt;/p&gt;
&lt;p&gt;B&lt;sub&gt;i&lt;/sub&gt;(G) = max { |index[i] - index[j]|  | (i,j) in E }&lt;/p&gt;
&lt;p&gt;それで帯域幅 B(G) は &lt;code&gt;i&lt;/code&gt; 番目の帯域幅 B&lt;sub&gt;i&lt;/sub&gt;(G) の最大値として表すことができる。&lt;/p&gt;
&lt;p&gt;B(G) = max { B&lt;sub&gt;i&lt;/sub&gt;(G)   | i=0...|V|-1 }&lt;/p&gt;
&lt;h2&gt;Defined in&lt;/h2&gt;
&lt;p&gt;boost/graph/bandwidth.hpp &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bellman_ford_shortest_paths -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bellman_ford_shortest_paths.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;bellman_ford_shortest_paths&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Size&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; bellman_ford_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, Size N, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Size&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;WeightMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredecessorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistanceMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;BinaryFunction&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;BinaryPredicate&lt;/a&gt;&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; bellman_ford_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, Size N, 
  WeightMap weight, PredecessorMap pred, DistanceMap distance, 
  &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;BinaryFunction&lt;/a&gt; combine, &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;BinaryPredicate&lt;/a&gt; compare, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; v)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Bellman-Ford アルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#bellman58&#34;&gt;4&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford62:_flows&#34;&gt;11&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#lawler76:_comb_opt&#34;&gt;20&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;8&lt;/a&gt;] は、正と負の両方の辺の重みを持つグラフの単一始点の最短経路問題を解く。最短経路問題の定義のために、 章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-paths-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。 もし正の辺の重みを持つ最短経路問題を解く必要があるだけなら、Dijkstra の アルゴリズムがより効率的な代替手段を提供する。もし全ての辺の重みが 1 に等しいなら幅優先探索がより一層効率的な代替手段を提供する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; 関数を呼ぶ前に、ユーザは始点に 0 の 距離を割り当て、他の全ての頂点に無限大の距離を割り当てなければならない。 Bellman-Ford アルゴリズムはグラフ中の全ての辺を通してループし、各辺に リラックス操作 (減らす操作) を適用することによって進められる。下記の擬似コード中で、 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;u&lt;/code&gt; の隣接頂点で、&lt;code&gt;w&lt;/code&gt; は辺にそれらの重みをマップし、 &lt;code&gt;d&lt;/code&gt; は今の所見られる各辺への最短経路の長さを記録する距離マップである。&lt;code&gt;p&lt;/code&gt; は各辺の親を記録する先行点マップで、それは結局最短経路木中で親となるであろう。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;RELAX(u, v, w, d, p)
  if (w(u,v) + d[u] &amp;lt; d[v]) 
    d[v] := w(u,v) + d[u]      辺をリラックスする (減らす) (u,v)
    p[v] := u
  else
    ...                        辺 (u,v) は リラックスされていない (減らされていない)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;アルゴリズムはグラフ中に負の閉路が存在しないならば、各辺への距離が可能な限り最小に減らされた事が保証された後にこのループを &lt;code&gt;|V|&lt;/code&gt; 回 繰り返す。もし負の閉路が存在するならば、グラフ中に適当に最小化されない 辺が存在する事になるだろう。つまり、&lt;code&gt;w(u,v) + d[u] &amp;lt; d[v]&lt;/code&gt; であるような 辺 &lt;code&gt;(u,v)&lt;/code&gt; が存在することになるだろう。 アルゴリズムは全ての辺が最小化されたかどうか最後に一回調べるためにグラフ中の辺をループし、もしよければ &lt;code&gt;true&lt;/code&gt; を返し、そうでなければ &lt;code&gt;false&lt;/code&gt; を返す。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;BELLMAN-FORD(G)
  for each vertex u in V        頂点 u の初期化
    d[u] := infinity
    p[u] := u
  end for
  for i := 1 to |V|-1
    for each edge (u,v) in E    辺 (u,v) の調査
      RELAX(u, v, w, d, p)
    end for
  end for
  for each edge (u,v) in E
    if (w(u,v) + d[u] &amp;lt; d[v])
      return (false, , )        辺 (u,v) は最小化されていない
    else
      ...                       辺 (u,v) は最小化されている
  end for
  return (true, p, d)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。 ユーザが &lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・マップを提供するならばグラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう (もし関数が &lt;code&gt;true&lt;/code&gt; を返すなら)。 二番目の選択は最短経路木を &lt;code&gt;predecessor_map()&lt;/code&gt; に記録することである。 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点 であるか、または始点からは到達不能な頂点である場合を除く)。 これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間、アクションを取れる独自のビジタをそこに提供することができる。&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;EdgeListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;Edge List Graph&lt;/a&gt; のモデルの有向グラフまたは無向グラフでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;Size N&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の頂点の数。型 &lt;code&gt;Size&lt;/code&gt; は汎整数型でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重み　(そして「長さ」もしくは「コスト」として知られる)。 &lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。このプロパティ・マップのキー型はグラフの辺記述子でなければならない。重みマップの値型は距離マップの値型を伴った Addable でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。 アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN/OUT: &lt;code&gt;distance_map(DistanceMap d)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。プロパティ・マップのキー型は グラフの頂点記述子型でなければならず、距離マップの値型は &lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;Less Than Comparable&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_distance, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BellmanFordVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ビジタ・オブジェクトで、その型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;Bellman-Ford Visitor&lt;/a&gt; のモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bellman_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(BinaryFunction combine)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数オブジェクトはリラックス (減少) 段階中で、加算の役割を置き換える。 第一引数の型は距離マップの値型に一致していなければならず、第二引数の型は重みマップの値型に一致していなければならない。 結果型は距離マップの値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト:&lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(BinaryPredicate compare)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数オブジェクトはリラックス (減少) 段階中で、距離を比較する less-than (&lt;code&gt;&amp;lt;&lt;/code&gt;) 演算子の役割を置き換える。引数の型は距離マップの値型に一致していなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間複雑性は O(V E) である。&lt;/p&gt;
&lt;h2&gt;Visitor Event Points&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、グラフ中の各辺において &lt;code&gt;|V|&lt;/code&gt; 回呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は終点のための距離ラベルが減じられた時に呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった 辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし終点のための距離ラベルが減じられなかった時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_minimized(e, g)&lt;/code&gt; は、アルゴリズムの第二段階の間、各辺が最小化されたかどうかの検査の間に呼び出される。もし辺が最小化されていればこの関数が呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_minimized(e, g)&lt;/code&gt; もまた、アルゴリズムの第二段階の間、各辺が最小化されたかどうかの検査の間に呼び出される。もし辺が最小化されていなければ、この関数が呼び出される。これはグラフ中に負の閉路が存在する時に起こる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;Bellman-Ford のアルゴリズムを用いた例が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bellman-example.cpp.html&#34;&gt;examples/bellman-example.cpp&lt;/a&gt; 中にある。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_ford_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われず ビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたは リファレンスによってこの状態をビジタに保持させる事を望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bellman_visitor&lt;EventVisitorList&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bellman_visitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bellman_visitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;bellman_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/bellman_ford_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.me&#34;&gt;BellmanFordVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが EventVisitorList の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bellman_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_bellman_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BellmanFordVisitor.html&#34;&gt;BellmanFordVisitor&lt;/a&gt; に適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.me&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bfs_visitor&lt;EventVisitorList&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bfs_visitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;bfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;以下は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs.cpp.html&#34;&gt;examples/bfs.cpp&lt;/a&gt; からの抜粋である。ここでは 3 つのイベントビジタを結合して BFS ビジタを作っている。関数 &lt;code&gt;boost::record_distances&lt;/code&gt; 、 &lt;code&gt;boost::record_predecessors&lt;/code&gt; 、 &lt;code&gt;copy_graph&lt;/code&gt; は全て、イベントビジタを作る関数だ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Construct graph G and obtain the source vertex s ...&lt;/span&gt;

boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;breadth_first_search(G, s, 
 boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_bfs_visitor(
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;record_distances(d, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_tree_edge()),
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_pair(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;record_predecessors(p.begin(), 
                                            boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_tree_edge()),
                 copy_graph(G_copy, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_examine_edge())))) );
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリスト。&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/null_visitor.html&#34;&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが EventVisitorList の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;bfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_bfs_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを BFS ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>bgl_named_params&lt;Param, Type, Rest&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bgl_named_params.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bgl_named_params.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;bgl_named_params&amp;lt;Param, Type, Rest&amp;gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;多くの Boost.Graph アルゴリズムは長いパラメータ列を持ち、その多くはデフォルト値を持つ。これがいくつかの問題を起こす。 1つは、 C++ がテンプレート関数のデフォルト値を扱う仕組みを持っていないことだ。しかし、異なる数のパラメータを持つ複数のバージョンのアルゴリズムを作り、各バージョンが一部のパラメータにデフォルト値を与えることで、この問題は克服される。これは Boost.Graph の以前のバージョンで使われていたアプローチだ。しかし、この解決法はまだ、いくつかの理由で不十分だ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パラメータのデフォルト値は特定の順序でしか使えない。デフォルト値の順序がユーザの状況に合わなければ、ユーザは全てのパラメータを与えるという手段をとらなければならない。&lt;/li&gt;
&lt;li&gt;パラメータ列が長いので、順序を忘れやすい。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;より良い解決法を与えるのが &lt;code&gt;bgl_named_params&lt;/code&gt; だ。このクラスを使えば、パラメータを任意の順序で与えることができ、パラメータ名によって引数をパラメータに適合できる。&lt;/p&gt;
&lt;p&gt;以下のコードで、名前付きパラメータのテクニックを使って &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; を呼び出す例を示す。各引数は、引数がどのパラメータに与えられるのかを示す名前を持つ関数に渡される。それぞれの名前付きパラメータは、カンマではなくピリオドで区切られる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), 
     boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;weight_map(weight).
     distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
     predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;引数が正しいパラメータ関数に適合される限り、引数が与えられる順序はどうでも良い。これは、上のコードと等価な &lt;code&gt;bellman_ford_shortest_paths()&lt;/code&gt; の呼び出しである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), 
   boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;predecessor_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
   distance_map(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;]).
   weight_map(weight));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;一般に、ユーザは &lt;code&gt;bgl_named_params&lt;/code&gt; クラスを直接使う必要はない。 &lt;code&gt;boost::weight_map&lt;/code&gt; のような &lt;code&gt;bgl_named_params&lt;/code&gt; のインスタンスを作る関数があるからだ。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>参考文献 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/bibliography.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;参考文献&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#aho83:_data_struct_algo&#34; name=&#34;aho83:_data_struct_algo&#34;&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. V. Aho, J. E. Hopcroft, and J. D. Ullman.&lt;/li&gt;
&lt;li&gt;Data Structures and Algorithms.&lt;/li&gt;
&lt;li&gt;Addison-Wesley, 1983.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#austern99:_gener_progr_stl&#34; name=&#34;austern99:_gener_progr_stl&#34;&gt;2&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M. H. Austern.&lt;/li&gt;
&lt;li&gt;Generic Programming and the STL.&lt;/li&gt;
&lt;li&gt;Professional computing series. Addison-Wesley, 1999.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#baumgartner95:_signatures&#34; name=&#34;baumgartner95:_signatures&#34;&gt;3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G. Baumgartner and V. F. Russo.&lt;/li&gt;
&lt;li&gt;Signatures: A language extension for improving type abstraction and subtype polymorphism in C++.&lt;/li&gt;
&lt;li&gt;Software-Practice and Experience, 25(8):863-889, August 1995.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#bellman58&#34; name=&#34;bellman58&#34;&gt;4&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R. Bellman.&lt;/li&gt;
&lt;li&gt;On a routing problem.&lt;/li&gt;
&lt;li&gt;Quarterly of Applied Mathematics, 16(1):87-90, 1958.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#bruce95&#34; name=&#34;bruce95&#34;&gt;5&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K. B. Bruce, L. Cardelli, G. Castagna, the Hopkins Objects Group, G. T. Leavens, and B. Pierce.&lt;/li&gt;
&lt;li&gt;On binary methods.&lt;/li&gt;
&lt;li&gt;Theory and Practice of Object Systems, 1:221-242, 1995.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman85:_algor&#34; name=&#34;coleman85:_algor&#34;&gt;6&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T. F. Coleman, B. S. Garbow, and J. J. Mor&#39;e.&lt;/li&gt;
&lt;li&gt;Algorithm 649: Fortran subroutines for estimating sparse hessian matrices.&lt;/li&gt;
&lt;li&gt;ACM Transactions on Mathematical Software, 11(4):378, December 1985.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman84:_estim_jacob&#34; name=&#34;coleman84:_estim_jacob&#34;&gt;7&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T. F. Coleman and J. J. Mor&#39;e.&lt;/li&gt;
&lt;li&gt;Estimation of sparse jacobian matrices and graph coloring problems.&lt;/li&gt;
&lt;li&gt;SIAM Journal on Numerical Analysis, 20:187-209,, 1984.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34; name=&#34;clr90&#34;&gt;8&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T. Cormen, C. Leiserson, and R. Rivest.&lt;/li&gt;
&lt;li&gt;Introduction to Algorithms.&lt;/li&gt;
&lt;li&gt;McGraw-Hill, 1990.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#curtis74:_jacob&#34; name=&#34;curtis74:_jacob&#34;&gt;9&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. Curtis, M. Powell, and J. Reid.&lt;/li&gt;
&lt;li&gt;On the estimation of sparse jacobian matrices.&lt;/li&gt;
&lt;li&gt;Journal of the Institute of Mathematics and its Applications, 13:117-119, 1974.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#dijkstra59&#34; name=&#34;dijkstra59&#34;&gt;10&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. Dijkstra.&lt;/li&gt;
&lt;li&gt;A note on two problems in connexion with graphs.&lt;/li&gt;
&lt;li&gt;Numerische Mathematik, 1:269-271, 1959.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford62:_flows&#34; name=&#34;ford62:_flows&#34;&gt;11&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L. R. Ford and D. R. Fulkerson.&lt;/li&gt;
&lt;li&gt;Flows in networks.&lt;/li&gt;
&lt;li&gt;Princeton University Press, 1962.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#gamma95:_design_patterns&#34; name=&#34;gamma95:_design_patterns&#34;&gt;12&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. Gamma, R. Helm, R. Johnson, and J. Vlissides.&lt;/li&gt;
&lt;li&gt;Design Patterns: Elements of Reusable Object-Oriented Software.&lt;/li&gt;
&lt;li&gt;Professional Computing. Addison-Welsey, 1995.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george93:graphtheory&#34; name=&#34;george93:graphtheory&#34;&gt;13&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. George, J. R. Gilbert, and J. W. Liu, editors.&lt;/li&gt;
&lt;li&gt;Graph Theory and Sparse Matrix Computation.&lt;/li&gt;
&lt;li&gt;Springer-Verlag New York, Inc, 1993.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george81:__sparse_pos_def&#34; name=&#34;george81:__sparse_pos_def&#34;&gt;14&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. George and J. W.-H. Liu.&lt;/li&gt;
&lt;li&gt;Computer Solution of Large Sparse Positive Definite Systems.&lt;/li&gt;
&lt;li&gt;Computational Mathematics. Prentice-Hall, 1981.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#graham85&#34; name=&#34;graham85&#34;&gt;15&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R. Graham and P. Hell.&lt;/li&gt;
&lt;li&gt;On the history of the minimum spanning tree problem.&lt;/li&gt;
&lt;li&gt;Annals of the History of Computing, 7(1):43-57, 1985.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#hart68&#34; name=&#34;hart68&#34;&gt;16&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P. E. Hart, N. J. Nilsson, and B. Raphael.&lt;/li&gt;
&lt;li&gt;A formal basis for the heuristic determination of minimum cost paths.&lt;/li&gt;
&lt;li&gt;IEEE Transactions on Systems Science and Cybernetics, 4(2):100-107, 1968.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#kruskal56&#34; name=&#34;kruskal56&#34;&gt;18&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;J. B. Kruskal.&lt;/li&gt;
&lt;li&gt;On the shortest spanning subtree of a graph and the traveling salesman problem.&lt;/li&gt;
&lt;li&gt;In Proceedings of the American Mathematical Sofiety, volume 7, pages 48-50, 1956.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#kuehl96:_design_patterns_for_graph_algo&#34; name=&#34;kuehl96:_design_patterns_for_graph_algo&#34;&gt;19&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Kühl.&lt;/li&gt;
&lt;li&gt;Design patterns for the implementation of graph algorithms.&lt;/li&gt;
&lt;li&gt;Master&#39;s thesis, Technische Universität Berlin, July 1996.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#lawler76:_comb_opt&#34; name=&#34;lawler76:_comb_opt&#34;&gt;20&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. L. Lawler.&lt;/li&gt;
&lt;li&gt;Combinatorial Opimization: Networks and Matroids.&lt;/li&gt;
&lt;li&gt;Holt, Rinehart, and Winston, 1976.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#LIU:MMD&#34; name=&#34;LIU:MMD&#34;&gt;21&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;J. W. H. Liu.&lt;/li&gt;
&lt;li&gt;Modification of the minimum-degree algorithm by multiple elimination.&lt;/li&gt;
&lt;li&gt;ACM Transaction on Mathematical Software, 11(2):141-153, 1985.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#mehlhorn99:_leda&#34; name=&#34;mehlhorn99:_leda&#34;&gt;22&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K. Mehlhorn and St. Näher.&lt;/li&gt;
&lt;li&gt;The LEDA Platform of Combinatorial and Geometric Computing.&lt;/li&gt;
&lt;li&gt;Cambridge University Press, 1999.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#meyer88:_object_soft_const&#34; name=&#34;meyer88:_object_soft_const&#34;&gt;23&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B. Meyer.&lt;/li&gt;
&lt;li&gt;Object-oriented Software Construction.&lt;/li&gt;
&lt;li&gt;Prentice Hall International Series in Computer Science. Prentice Hall, 1988.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#myers95:_trait&#34; name=&#34;myers95:_trait&#34;&gt;24&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N. C. Myers.&lt;/li&gt;
&lt;li&gt;Traits: a new and useful template technique.&lt;/li&gt;
&lt;li&gt;C++ Report, June 1995.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#prim57:_short&#34; name=&#34;prim57:_short&#34;&gt;25&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R. Prim.&lt;/li&gt;
&lt;li&gt;Shortest connection networks and some generalizations.&lt;/li&gt;
&lt;li&gt;Bell System Technical Journal, 36:1389-1401, 1957.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#saad96:imsms&#34; name=&#34;saad96:imsms&#34;&gt;26&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Y. Saad.&lt;/li&gt;
&lt;li&gt;Iterative Methods for Sparse Minear System.&lt;/li&gt;
&lt;li&gt;PWS Publishing Company, 1996.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#tarjan83:_data_struct_network_algo&#34; name=&#34;tarjan83:_data_struct_network_algo&#34;&gt;27&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R. E. Tarjan.&lt;/li&gt;
&lt;li&gt;Data Structures and Network Algorithms.&lt;/li&gt;
&lt;li&gt;Society for Industrial and Applied Mathematics, 1983.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#parter61:_gauss&#34; name=&#34;parter61:_gauss&#34;&gt;28&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Seymour Parter.&lt;/li&gt;
&lt;li&gt;The use of linear graphs in Gauss elimination.&lt;/li&gt;
&lt;li&gt;SIAM Review, 1961 3:119-130.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#matula72:_graph_theory_computing&#34; name=&#34;matula72:_graph_theory_computing&#34;&gt;29&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Matula, G. Marble, and J. Isaacson&lt;/li&gt;
&lt;li&gt;Graph coloring algorithms in Graph Theory and Computing.&lt;/li&gt;
&lt;li&gt;Academic Press, pp.104-122, 1972.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#garey79:computers-and-intractability&#34; name=&#34;garey79:computers-and-intractability&#34;&gt;30&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M.R. Garey and D.S. Johnson&lt;/li&gt;
&lt;li&gt;Computers and Intractibility: A Guide to the Theory of NP-Completeness&lt;/li&gt;
&lt;li&gt;W.H. Freeman, New York, 1979.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#welsch67&#34; name=&#34;welsch67&#34;&gt;31&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Welsch and M. B. Powel&lt;/li&gt;
&lt;li&gt;An upper bound for the chromatic number of a graph and its application to timetabling problems Computer Journal, 10:85-86, 1967.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#brelaz79:_new&#34; name=&#34;brelaz79:_new&#34;&gt;32&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D. Br&#39;elaz&lt;/li&gt;
&lt;li&gt;New methods to color the vertices of a graph&lt;/li&gt;
&lt;li&gt;Communications of the ACM, vol. 22, 1979, pp. 251-256.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#heber99:_saw&#34; name=&#34;heber99:_saw&#34;&gt;33&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G. Heber, R. Biswas, G.R. Gao&lt;/li&gt;
&lt;li&gt;Self-Avoiding Walks over Adaptive Unstructured Grids&lt;/li&gt;
&lt;li&gt;Parallel and Distributed Processing, LNCS 1586, Springer-Verlag, 1999, pp. 968-977&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ng-raghavan&#34; name=&#34;ng-raghavan&#34;&gt;34&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Esmond G. Ng amd Padma Raghavan&lt;/li&gt;
&lt;li&gt;Performance of greedy ordering heuristics for sparse {C}holesky factorization&lt;/li&gt;
&lt;li&gt;SIAM Journal on Matrix Analysis and Applications (To appear)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#George:evolution&#34; name=&#34;George:evolution&#34;&gt;35&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alan George and Joseph W. H. Liu&lt;/li&gt;
&lt;li&gt;The Evolution of the Minimum Degree Ordering Algorithm&lt;/li&gt;
&lt;li&gt;SIAM Review, March 1989, vol. 31, num. 1, pp. 1-19.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford56:_maxim&#34; name=&#34;ford56:_maxim&#34;&gt;36&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L. R. Ford and D. R. Fulkerson&lt;/li&gt;
&lt;li&gt;Maximal flow through a network.&lt;/li&gt;
&lt;li&gt;Can. Journal of Mathematics 1956 pp.399-404&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goldberg85:_new_max_flow_algor&#34; name=&#34;goldberg85:_new_max_flow_algor&#34;&gt;37&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. V. Goldberg&lt;/li&gt;
&lt;li&gt;A New Max-Flow Algorithm.&lt;/li&gt;
&lt;li&gt;MIT Tehnical report MIT/LCS/TM-291, 1985.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#karzanov74:_deter&#34; name=&#34;karzanov74:_deter&#34;&gt;38&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. V. Karzanov&lt;/li&gt;
&lt;li&gt;Determining the maximal flow in a network by the method of preflows.&lt;/li&gt;
&lt;li&gt;Sov. Math. Dokl. 1974&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ahuja93:_network_flows&#34; name=&#34;ahuja93:_network_flows&#34;&gt;39&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ravindra K. Ahuja and Thomas L. Magnanti and James B. Orlin&lt;/li&gt;
&lt;li&gt;Network Flows: Theory, Algorithms, and Applications.&lt;/li&gt;
&lt;li&gt;Prentice Hall, 1993.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#edmonds72:_improvements_netflow&#34; name=&#34;edmonds72:_improvements_netflow&#34;&gt;40&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Jack Edmonds and Richard M. Karp&lt;/li&gt;
&lt;li&gt;Theoretical improvements in the algorithmic efficiency for network flow problems.&lt;/li&gt;
&lt;li&gt;Journal of the ACM, 1972 19:248-264&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#tarjan72:dfs_and_linear_algo&#34; name=&#34;tarjan72:dfs_and_linear_algo&#34;&gt;41&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Robert E. Tarjan&lt;/li&gt;
&lt;li&gt;Depth first search and linear graph algorithms.&lt;/li&gt;
&lt;li&gt;SIAM Journal on Computing, 1(2):146-160, 1972&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#eppstein97:dynamic_graph&#34; name=&#34;eppstein97:dynamic_graph&#34;&gt;42&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;David Eppstein, Zvi Galil, and Giuseppe F. Italiano&lt;/li&gt;
&lt;li&gt;Dynamic Graph Algorithms.&lt;/li&gt;
&lt;li&gt;Chapter 22, CRC Handbook of Algorithms and Theory of Computation, 1997.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#cuthill69:reducing_bandwith&#34; name=&#34;cuthill69:reducing_bandwith&#34;&gt;43&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. Cuthill and J. McKee&lt;/li&gt;
&lt;li&gt;Reducing the bandwidth of sparse symmetric matrices.&lt;/li&gt;
&lt;li&gt;Proceedings of the 24th National Conference of the ACM, 1969.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#liu75:anal_cm_rcm&#34; name=&#34;liu75:anal_cm_rcm&#34;&gt;44&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;J. Liu and A. Sherman&lt;/li&gt;
&lt;li&gt;Comparative analysis of the Cuthill-Mckee and the reverse Cuthill-Mckee ordering algorithms for sparse matrices.&lt;/li&gt;
&lt;li&gt;SIAM Journal of Numerical Analysis. 13 (1975), pp. 198-213.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george71:fem&#34; name=&#34;george71:fem&#34;&gt;45&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alan George&lt;/li&gt;
&lt;li&gt;Computer implementation of the finite element method&lt;/li&gt;
&lt;li&gt;Technical Report STAN-CS-208, Stanford University (1971).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#fortin96:_graph_iso_prob&#34; name=&#34;fortin96:_graph_iso_prob&#34;&gt;46&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scott Fortin&lt;/li&gt;
&lt;li&gt;The Graph Isomorphism Problem&lt;/li&gt;
&lt;li&gt;TR 96-20, Dept. of Computer Science, University of Alberta (1996)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#mckay81:_pract_graph_iso&#34; name=&#34;mckay81:_pract_graph_iso&#34;&gt;47&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Brendan D. McKay&lt;/li&gt;
&lt;li&gt;Practical Graph Isomorphism&lt;/li&gt;
&lt;li&gt;Congressus Numerantium (1981)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#reingold77:_combin_algo&#34; name=&#34;reingold77:_combin_algo&#34;&gt;48&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reingold, Nievergelt, and Deo&lt;/li&gt;
&lt;li&gt;Combinatorial Algorithms: Theory and Practice&lt;/li&gt;
&lt;li&gt;Prentice Hall (1977)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#moore59&#34; name=&#34;moore59&#34;&gt;49&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Edward Moore&lt;/li&gt;
&lt;li&gt;The shortest path through a maze&lt;/li&gt;
&lt;li&gt;International Symposium on the Theory of Switching (1959)&lt;/li&gt;
&lt;li&gt;Harvard University Press&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#nuutila95&#34; name=&#34;nuutila95&#34;&gt;50&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E. Nuutila&lt;/li&gt;
&lt;li&gt;Efficient transitive closure computation in large digraphs&lt;/li&gt;
&lt;li&gt;PhD Thesis, Helsinki University of Technology, 1995. &lt;/li&gt;
&lt;li&gt;Acta Polytechnica Scandinavica, Mathematics and Computing in Engineering Series, No. 74.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goral79&#34; name=&#34;goral79&#34;&gt;51&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. Goralcikova and V. Koubek&lt;/li&gt;
&lt;li&gt;A reduct and closure algorithm for graphs&lt;/li&gt;
&lt;li&gt;In Mathematical Foundations of Computer Science, &lt;/li&gt;
&lt;li&gt;volume 74 of Lecture Notes in Computer Science, pages 301-307. &lt;/li&gt;
&lt;li&gt;Springer-Verlag, 1979&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#simon86&#34; name=&#34;simon86&#34;&gt;52&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Klaus Simon&lt;/li&gt;
&lt;li&gt;An Improved Algorithm for Transitive Closure on Acyclic Digraphs&lt;/li&gt;
&lt;li&gt;Theoretical Computer Science 58&lt;/li&gt;
&lt;li&gt;Automata, Languages and Programming, 376-386, 1986&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#purdom70&#34; name=&#34;purdom70&#34;&gt;53&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P. Purdom&lt;/li&gt;
&lt;li&gt;A Transitive Closure Algorithm&lt;/li&gt;
&lt;li&gt;BIT, 10, 1970, pp. 76-94.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>breadth_first_search -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/breadth_first_search.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;breadth_first_search&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は有向グラフまたは無向グラフの幅優先巡回(breadth-first traversal) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#moore59&#34;&gt;[49]&lt;/a&gt; を行う。幅優先巡回は、始点から遠方に離れた頂点を訪れる前に近い頂点を訪れる。 この文脈中で「距離」とは始点からの最短経路中の辺の数として定義される。 &lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は始点から全ての到達可能な頂点への最短経路を計算するのに使用でき、結果として最短経路の距離が得られる。 BFS に関連した更なる定義は章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34;&gt;Breadth-First Search&lt;/a&gt; を見よ。&lt;/p&gt;
&lt;p&gt;BFS は巡回を実装するのに二つのデータ構造を使っている: 各頂点のカラー・マーカーとキューである。白色の頂点は未発見で、一方灰色の頂点は発見されたけれども未発見の隣接頂点を持つ。黒色の頂点は発見されており、他の黒色もしくは灰色の頂点にのみ隣接している。アルゴリズムは頂点 &lt;code&gt;u&lt;/code&gt; をキューから取り除き、 各出辺 &lt;code&gt;(u,v)&lt;/code&gt; を調べながら進められる。もし隣接頂点 &lt;code&gt;v&lt;/code&gt; がまだ 未発見ならば、灰色に色づけしてキューに置く。すべての出辺を調べた後、頂点 &lt;code&gt;u&lt;/code&gt; を黒色に色づけして手順を繰り返す。BFS アルゴリズムの疑似コードを下に示す。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;BFS(G, s)
  for each vertex u in V[G]      頂点uの初期化
    color[u] := WHITE 
    d[u] := infinity 
    p[u] := u 
  end for
  color[s] := GRAY 
  d[s] := 0 
  ENQUEUE(Q, s)                  頂点sの発見
  while (Q != Ø) 
    u := DEQUEUE(Q)              頂点uの調査
    for each vertex v in Adj[u]  辺(u,v)の調査
      if (color[v] = WHITE)      辺(u,v)は木の辺
        color[v] := GRAY 
        d[v] := d[u] + 1  
        p[v] := u  
        ENQUEUE(Q, v)            頂点vの発見
      else                       (u,v)は木でない辺
        if (color[v] = GRAY) 
          ...                    (u,v)は灰色の終点を持つ
        else
          ...                    (u,v)は黒色の終点を持つ
    end for
    color[u] := BLACK            頂点uの終了
  end while
  return (d, p)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt; 関数は一定のイベント・ポイントと呼ばれる、 ユーザ定義のアクションで拡張することができる。アクションはビジタ・オブジェクトの形で提供されなければならない。すなわち、型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; の要求を満たしているオブジェクトである。上の擬似コード内で、イベント・ポイントは右側のラベルである。さらに各イベント・ポイントの記述を以下に示した。デフォルトでは &lt;code&gt;breadth_first_search()&lt;/code&gt; 関数はどんなアクションも実行しない。距離や先行点の記録さえも。しかしながらこれらは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; のイベント・ビジタを用いて容易に追加できる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; コンセプトで指定されたイベント・ポイントで呼び出されるビジタ・オブジェクト。 ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 アルゴリズムは開始時に全ての頂点の色を白色に初期化するため、ユーザは &lt;code&gt;breadth_first_search()&lt;/code&gt; を呼ぶ前にカラー・マップを初期化する必要はない。もし複合的な幅優先探索をグラフ上で行う必要があるなら (例えばいくつかの切断された成分があるなら) &lt;code&gt;breadth_first_visit()&lt;/code&gt; 関数を使って独自の初期化を行うこと。
    &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならなく、そのキー型はグラフの頂点記述子型でなければならなく、カラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;code&gt;iterator_property_map&lt;/code&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。 このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。 &lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;buffer(Buffer&amp;amp; Q)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点が発見される順序を決定するために使用されるキュー。もしFIFOキューが使われると、 巡回は通常の BFS 順序付けに従う。他の型のキューも使用できるが、巡回順序は異なる。例えば Dijkstra のアルゴリズムは優先度付きキューを用いて実装することができる。&lt;code&gt;Buffer&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt; のモデルでなければならない。&lt;code&gt;buffer&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt; はグラフの &lt;code&gt;vertex_descriptor&lt;/code&gt; 型でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;boost::queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E + V) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(v, g)&lt;/code&gt; は、探索の開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、各頂点においてそれがキューから削除される時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、頂点が キューから削除された後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に加えて 辺が木の辺の場合に呼び出される。辺 &lt;code&gt;e&lt;/code&gt; の終点はこの時に発見される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、アルゴリズムが初めて頂点 &lt;code&gt;u&lt;/code&gt; を通った時に呼び出される。始点に近い全ての頂点が発見されており、始点から遠方に離れた頂点はまだ発見されていない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に加えて辺が tree edge でない場合に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が灰色に色づけされている場合に呼び出される。灰色は頂点が現在 キュー中にある印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が黒色に色づけされている場合に呼び出される。黒色は頂点がもはやキュー中にはない印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、 &lt;code&gt;u&lt;/code&gt; の全ての出辺が調べられ、全ての隣接頂点が発見された後で呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs-example.cpp.html&#34;&gt;examples/bfs-example.cpp&lt;/a&gt; 中にある例は、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34;&gt;Figure 6&lt;/a&gt; のグラフにおいて BGL 幅優先探索アルゴリズムを用いて実演している。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/bfs-example2.cpp.html&#34;&gt;examples/bfs-example2.cpp&lt;/a&gt; のファイルは同じ例を含むが、使われている &lt;code&gt;adacency_list&lt;/code&gt; クラスは &lt;code&gt;VertexList&lt;/code&gt; を持っており、&lt;code&gt;EdgeList&lt;/code&gt; が &lt;code&gt;listS&lt;/code&gt; に置かれている。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>breadth_first_visit -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/breadth_first_visit.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;breadth_first_visit&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_visit(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_visit
  (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFSVisitor&lt;/a&gt; vis, ColorMap color)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数はカラー・マーカーがアルゴリズム中で初期化されないことを除けば、基本的に &lt;code&gt;breadth_first_search()&lt;/code&gt; と同じである。 ユーザはアルゴリズムを呼ぶ前に全ての頂点の色が白色であることを確かめる責任がある。この違いでグラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; である代わりに &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; であることのみが要求される。 さらにこの違いはカラー・プロパティ・マップ中のより多くの柔軟性を考慮に入れている。例えば頂点上の部分的な関数を実装するだけのマップを使うことができる。そしてそれは探索がグラフのごく一部にしか及ばない場合、より良い空間効率であることができる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/breadth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(BFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/BFSVisitor.html&#34;&gt;BFS Visitor&lt;/a&gt; コンセプトで指定されたイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;bfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならなく、そのキー型はグラフの頂点記述子型でなければならなく、カラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_color, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;buffer(Buffer&amp;amp; Q)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点が発見される順序を決定するために使用されるキュー。 もしFIFO キューが使われると、巡回は通常の BFS 順序付けに従う。 他の型のキューも使用できるが、巡回順序は異なる。 例えば Dijkstra のアルゴリズムは優先度付きキューを用いて実装することができる。 &lt;code&gt;Buffer&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Buffer.html&#34;&gt;Buffer&lt;/a&gt; のモデルでなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;boost::queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(v, g)&lt;/code&gt; は、探索の開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、各頂点においてそれがキューから削除される時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、 頂点がキューから削除された後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt;に加えて辺が木の辺の場合に呼び出される。辺 &lt;code&gt;e&lt;/code&gt; の終点はこの時に発見される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、アルゴリズムが初めて頂点 &lt;code&gt;u&lt;/code&gt; に通った時に呼び出される。始点に近い全ての頂点が発見されており、始点から遠方に離れた頂点はまだ発見されていない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.non_tree_edge(e, g)&lt;/code&gt; は、 &lt;code&gt;examine_edge()&lt;/code&gt; に 加えて辺が木の辺でない場合に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.gray_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が灰色に色づけされている場合に呼び出される。 灰色は頂点が現在キュー中にある印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.black_target(e, g)&lt;/code&gt; は、 &lt;code&gt;non_tree_edge()&lt;/code&gt; に加えて調査時点で終点が黒色に色づけされている場合に呼び出される。 黒色は頂点がもはやキュー中にはない印である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、 &lt;code&gt;u&lt;/code&gt; の全ての出辺が調べられ、全ての隣接頂点が発見された後で呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_search.html&#34;&gt;&lt;code&gt;breadth_first_search()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html&#34;&gt;&lt;code&gt;depth_first_search()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/breadth_first_visit.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>connected_components -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/connected_components.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/connected_components.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;connected_components&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ComponentMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ComponentMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
connected_components(VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, ComponentMap comp,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この関数の名前なしパラメータバージョンは存在しない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;connected_components()&lt;/code&gt; 関数は、無向グラフの連結成分を DFS に基づく方法を用いて計算する。無向グラフの連結成分はすべての互いに到達可能な頂点の集合である。もしグラフが増大する間、連結成分を保持する必要があるなら、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.html&#34;&gt;&lt;code&gt;incremental_components()&lt;/code&gt;&lt;/a&gt; 関数の素集合に基づく方法の方が速い。「静的な」グラフには この DFS に基づく方法の方が速い &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;[8]&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;このアルゴリズムの出力は成分プロパティ・マップ &lt;code&gt;comp&lt;/code&gt; に記録され、そしてそれは各頂点に割り当てられた成分番号を与える数を含んでいる。 全成分数が関数の返却値である。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/connected_components.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const Graph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; かつ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;ComponentMap c&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;このアルゴリズムはグラフ中にある連結成分数を計算し、各成分に整数のラベルを割り当てる。このアルゴリズムはそれから成分プロパティ・マップ中の成分番号を記録することによってグラフ中の各頂点がどの成分に属しているかを登録する。&lt;code&gt;ComponentMap&lt;/code&gt; 型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/[WritablePropertyMap.html&#34;&gt;Writable Property Map&lt;/a&gt; のモデルでなければならない。値型は汎整数型であるべきで、できればグラフの &lt;code&gt;vertices_size_type&lt;/code&gt; に等しい方が望ましい。キー型はグラフの頂点記述子型でなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付き引数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフの進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; 型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。 このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。 &lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。 グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;連結成分のアルゴリズムの時間計算量もまた O(V + E) である。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/strong_components.html&#34;&gt;&lt;code&gt;strong_components()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.html&#34;&gt;&lt;code&gt;incremental_components()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;ファイル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/connected_components.cpp.html&#34;&gt;examples/connected_components.cpp&lt;/a&gt; は無向グラフの連結成分を計算する例を含む。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BGLでグラフアルゴリズムを構築する -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/constructing_algorithms.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/constructing_algorithms.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;BGLでグラフアルゴリズムを構築する&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;BGLの主な目標は、精密なグラフ・クラスを提供することにあるのではなく、また再利用可能なグラフ・アルゴリズムの広範囲にわたる集合を提供することにあるのでもない (それらは目標であるにもかかわらず)。BGLの主な目標は、他者に再利用可能なグラフのアルゴリズムを書くよう奨励することである。再利用可能とは最大限に再利用可能であることを意味する。ジェネリックプログラミングはアルゴリズムを最大限に再利用可能にする手法であり、この章でジェネリックプログラミングをいかにグラフ・アルゴリズムを構築するのに応用するかについて論ずるつもりである。&lt;/p&gt;
&lt;p&gt;ジェネリックプログラミングの過程を説明するために、グラフの着色アルゴリズムの構築を歩み抜けてみようと思う。グラフの着色問題 (またはもっと具体的に頂点着色問題) はグラフ &lt;code&gt;G&lt;/code&gt; 中の各頂点を、同じ色で彩られた隣接した二つの頂点がないように、そして最小の色数が使われるようにすることである。一般的に、グラフの着色問題はNP完全問題で、それゆえ適度な量の時間で最適解を見つけるのは不可能である。しかしながら、最小に近い着色を見つけるために発見的手法を使う多くのアルゴリズムが存在する。&lt;/p&gt;
&lt;p&gt;ここで示す今問題にするアルゴリズムは疎なヤコビ行列とヘッセン行列の消去法 [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#curtis74:_jacob&#34;&gt;9&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman84:_estim_jacob&#34;&gt;7&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#coleman85:_algor&#34;&gt;6&lt;/a&gt;] 中で用いられている 線形時間の SEQ サブルーチンに基づいている。このアルゴリズムはグラフ中の全ての頂点を入力された順序によって定義される順番に従って訪れる。各頂点において、アルゴリズムは隣接頂点の色を印付け、それから現時点の頂点の色のために最小のまだ印付けられていない色を選ぶ。もし全ての色がすでに印付けられていたら、新しい色が作成される。色の印番号が現在の頂点番号に等しいなら、色は印付けられているとみなされる。これは各頂点のために印を置き直さねばならない厄介ごとから守る。このアルゴリズムの有効性は入力された頂点の順番に大きく依存する。最大先頭 (largest-first) 順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#welsch67&#34;&gt;[31]&lt;/a&gt;、 最小後尾 (smallest-last) 順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#matula72:_graph_theory_computing&#34;&gt;[29]&lt;/a&gt;、そして接続次数 (incidence degree) による順序付け &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#brelaz79:_new&#34;&gt;[32]&lt;/a&gt; を含むいくつかの順序付けアルゴリズムが存在し、そしてそれらはこの着色アルゴリズムの有効性を改善する。&lt;/p&gt;
&lt;p&gt;汎用グラフ・アルゴリズムを構築する際にする最初の決定は、どのグラフ操作がアルゴリズムの実装のために必要か決定すること、そしてその操作にどのグラフ・コンセプトを結びつけるか決定することである。このアルゴリズム中で頂点の色を初期化するために全ての頂点を通して巡回する必要があるだろう。さらに隣接頂点もアクセスする必要がある。それゆえ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; コンセプトを選択するつもりである。というのは、これらの操作を含む最小の概念であるからである。グラフの型はこのアルゴリズムのためにテンプレート関数中で引数が決められるだろう。グラフの型を BGL &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt; のような特定のグラフ・クラスには限定しない。なぜかというとこれはアルゴリズムの再利用可能性を著しく制限するだろうからである (今まで書かれたほとんどのアルゴリズムはそうであるが)。グラフの型を &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; をモデルとする型にぜひ限定しよう。これはアルゴリズム中のそれらのグラフ操作の使用によって、その上 &lt;code&gt;function_requires()&lt;/code&gt; とともにコンセプト・チェックとして付け加えられた明示的な要求として強いられる (コンセプト・チェックについてのさらなる詳細のために章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;Concept Checking&lt;/a&gt; を見なさい)。&lt;/p&gt;
&lt;p&gt;次に、このプログラム中でどの頂点プロパティまたは辺プロパティが使われるであろうかについて考える必要がある。この場合、唯一のプロパティは頂点の色である。頂点の色へのアクセスを指定する最も融通のきく方法はプロパティ・マップのインターフェースを使うことである。これはアルゴリズムの使用者にどのようにプロパティを格納したいかを決定する能力を与える。色の読み書き両方が必要であろうから、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;ReadWritePropertyMap&lt;/a&gt; としての要求を指定する。カラー・マップの &lt;code&gt;key_type&lt;/code&gt; はグラフからの &lt;code&gt;vertex_descriptor&lt;/code&gt; でなければならず、&lt;code&gt;value_type&lt;/code&gt; は 整数の種類でなければならない。さらに &lt;code&gt;order&lt;/code&gt; 引数のためのインターフェースをプロパティ・マップとして指定する。この場合 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;ReadablePropertyMap&lt;/a&gt; である。順序付けのために、&lt;code&gt;key_type&lt;/code&gt; は整数のオフセットで、 &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;vertex_descriptor&lt;/code&gt; である。再びコンセプト・チェックとともにこれらの要求を適用する。このアルゴリズムの返却値はグラフを着色するのに必要な色の数で、従って関数の返却値型はグラフの &lt;code&gt;vertices_size_type&lt;/code&gt; である。次のコードはテンプレート関数としてのグラフのアルゴリズムのためのインターフェース、コンセプト・チェック、そしていくつかの &lt;code&gt;typedef&lt;/code&gt; を示す。実装は容易であり、上述で論ぜられていない唯一の段階は色の初期化段階で、そしてそこで全ての頂点の色を「着色されてない」状態にする。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Order&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Color&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertices_size_type
  sequential_vertex_color_ting(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, 
    Order order, Color color)
  {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; GraphTraits;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertex_descriptor vertex_descriptor;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertices_size_type size_type;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Color&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type ColorType;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Order&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type OrderType;

    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; VertexListGraphConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ReadWritePropertyMapConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Color, vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; IntegerConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ColorType&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; size_type, ReadablePropertyMapConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Order&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; same_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;OrderType, vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;type req_same;

    size_type max_color &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; size_type V &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; num_vertices(G);
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;size_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
      mark(V, numeric_limits_max(max_color));

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertex_iterator v, vend;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(v, vend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G); v &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;v)
      color[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;v] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; V &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// which means &#34;not colored&#34;&lt;/span&gt;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; V; i&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;) {
      vertex_descriptor current &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; order[i];

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 隣接頂点の全ての色を印付ける&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; GraphTraits&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;adjacency_iterator ai, aend;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (tie(ai, aend) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; adjacent_vertices(current, G); ai &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; aend; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ai)
        mark[color[&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ai]] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i; 

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 隣接頂点によって使われていない最小の色を見つける&lt;/span&gt;
      size_type smallest_color &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; (smallest_color &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; max_color &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mark[smallest_color] &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; i) 
        &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;smallest_color;

      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// もし全ての色を使い切ったら、色の数を増やす&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (smallest_color &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; max_color)
        &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;max_color;

      color[current] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; smallest_color;
    }
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; max_color;
  }
} &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// namespace boost&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>copy_graph -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/copy_graph.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/copy_graph.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;copy_graph&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt;&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; 
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; copy_graph(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;MutableGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G_copy,
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数はグラフ &lt;code&gt;G&lt;/code&gt; から &lt;code&gt;G_copy&lt;/code&gt; へとすべての頂点と辺をコピーする。また、頂点と辺のプロパティも、 &lt;code&gt;vertex_all&lt;/code&gt; と &lt;code&gt;edge_all&lt;/code&gt; プロパティマップを用いるか、あるいはユーザが与えたコピー関数を用いてコピーする。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/copy.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; G&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向または無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; モデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;MutableGraph&amp;amp; G_copy&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフのコピー結果。 グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/MutableGraph.html&#34;&gt;Mutable Graph&lt;/a&gt; モデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_copy(VertexCopier vc)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは オリジナルのグラフの頂点のプロパティをコピーの対応する頂点にコピーする &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;vertex_copier&amp;lt;VertexListGraph, MutableGraph&amp;gt;&lt;/code&gt; これはグラフからプロパティマップにアクセスするためにプロパティタグ &lt;code&gt;vertex_all&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;edge_copy(EdgeCopier ec)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは オリジナルのグラフの辺のプロパティをコピーの対応する辺にコピーする &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;edge_copier&amp;lt;VertexListGraph, MutableGraph&amp;gt;&lt;/code&gt; これはグラフからプロパティマップにアクセスするためにプロパティタグ &lt;code&gt;edge_all&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;頂点添え字マップの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; モデルでなければならず、また &lt;code&gt;G&lt;/code&gt; の頂点デスクリプタを &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;num_vertices(G)&lt;/code&gt; までの整数にマップしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, G)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;orig_to_copy(Orig2CopyMap c)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはオリジナルのグラフの頂点をコピーの頂点にマップする。&lt;/li&gt;
&lt;li&gt;デフォルト: 出力グラフの頂点デスクリプタ型のサイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から 作られる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、 添え字マップのために &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(V + E) 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:kn@mm.neweb.ne.jp&#34;&gt;Kent.N&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>cuthill_mckee_ordering -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/cuthill_mckee_ordering.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/cuthill_mckee_ordering.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;cuthill_mckee_ordering&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;構成要素&lt;/th&gt;
&lt;th&gt;値&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;グラフ&lt;/td&gt;
&lt;td&gt;無向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;プロパティ&lt;/td&gt;
&lt;td&gt;色、次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;計算量&lt;/td&gt;
&lt;td&gt;`time: O(log(m)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;IncidenceGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;OutputIterator&lt;/span&gt;,
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DegreeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; 
cuthill_mckee_ordering(IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
                       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
                       OutputIterator inverse_permutation, 
                       ColorMap color, DegreeMap degree)

(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;OutputIterator&lt;/span&gt;, 
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DegreeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; 
cuthill_mckee_ordering(VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G, OutputIterator inverse_permutation, 
                       ColorMap color, DegreeMap degree)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Cuthill-Mckee(と逆Cuthill-Mckee)順序アルゴリズム[&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george81:__sparse_pos_def&#34;&gt;14&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#cuthill69:reducing_bandwith&#34;&gt;43&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#liu75:anal_cm_rcm&#34;&gt;44&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#george71:fem&#34;&gt;45&lt;/a&gt;]の目的は、各頂点に割り当てられている添え字を再順序付けすることによって、グラフの&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;帯域幅&lt;/a&gt;を減らすことである。Cuthill-Mckee の順序付けアルゴリズムは、 i 番目の帯域幅の局所最小化によって動作する。頂点は基本的に幅優先探索順に割り当てられる。ただし各段階において、隣接頂点がキュー中に次数の昇順で並べられることを除く。&lt;/p&gt;
&lt;p&gt;このアルゴリズムのバージョン (1) がユーザに「始点」を選ばせるのに対し、 バージョン (2) は疑似周辺ペアの発見的手法を用いて良好な始点を見つける。「始点」の選択は順序付けの品質上、重要な影響を持つ傾向がある。&lt;/p&gt;
&lt;p&gt;このアルゴリズムの出力は、新しい順序付けになっている頂点である。使用した出力イテレータの種類に依存して、Cuthill-Mckee の順序付け、または逆 Cuthill-Mckee の順序付けのどちらか一方を得られる。例えば、出力を &lt;code&gt;vector&lt;/code&gt; のリバース・イテレータを用いて &lt;code&gt;vector&lt;/code&gt; に格納すれば、逆 Cuthill-Mckee 順序付けを得る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;vertex_descriptor&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; inv_perm(num_vertices(G));
cuthill_mckee_ordering(G, inv_perm.rbegin());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;どちらの方法でも、出力を &lt;code&gt;vector&lt;/code&gt; に格納することは、新しい順序付けから古い順序付けへの順列を与える。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;inv_perm[new_index[u]] &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; u
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;多くの場合、ほしい順列は逆の順列、つまり古い添え字から新しい添え字への順列である。これは次の方法で簡単に計算され得る。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (size_type i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; inv_perm.size(); &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
  perm[old_index[inv_perm[i]]] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; i;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;バージョン (1) 用:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vertex_descriptor s&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OutputIterator inverse_permutation&lt;/code&gt;  (OUT) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しい頂点の順序付け。頂点は新しい順序で &lt;a href=&#34;http://www.sgi.com/tech/stl/OutputIterator.html&#34; target=&#34;_blank&#34;&gt;output iterator&lt;/a&gt; に書かれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ColorMap color_map&lt;/code&gt;  (WORK) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部的にアルゴリズムの進行過程を保持するために使われる (同じ頂点を二回訪れるのを回避するために)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DegreeMap degree_map&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点を次数にマップしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バージョン (2) 用&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OutputIterator inverse_permutation&lt;/code&gt;  (OUT) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新しい頂点の順序付け。頂点は新しい順序で出力イテレータに書かれる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ColorMap color_map&lt;/code&gt;  (WORK) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部的にアルゴリズムの進行過程を保持するために使われる (同じ頂点を二回訪れるのを回避するために)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DegreeMap degree_map&lt;/code&gt;  (IN) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点を次数にマップしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/cuthill_mckee_ordering.cpp.html&#34;&gt;examples/cuthill_mckee_ordering.cpp&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bandwidth.html&#34;&gt;&lt;code&gt;bandwidth&lt;/code&gt;&lt;/a&gt;、それと boost/graph/properties.hpp 中の &lt;code&gt;degree_property_map&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dag_shortest_paths -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/dag_shortest_paths.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;dag_shortest_paths&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Param&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Tag&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Rest&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dag_shortest_paths(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Param,Tag,Rest&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;VertexListGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DijkstraVisitor&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistanceMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;WeightMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredecessorMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Compare&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Combine&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistInf&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;DistZero&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dag_shortest_paths(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;VertexListGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   DistanceMap distance, WeightMap weight, ColorMap color,
   PredecessorMap pred, DijkstraVisitor vis, 
   Compare compare, Combine combine, DistInf inf, DistZero zero)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズム &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;[8]&lt;/a&gt; は 重み付きの非循環有向グラフ (DAG) の単一始点の最短経路問題を解く。 このアルゴリズムは DAG にとって、Dijkstra や Bellman-Ford アルゴリズムより 一層効率的である。全ての辺の重みが 1 に等しい時はこのアルゴリズムの代わりに幅優先探索を使いなさい。最短経路問題の定義のために、最短経路問題のいくつかの背景についての章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-path-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dag_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。&lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・マップを提供するならばグラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう。さらに最短経路木を先行点マップ (predecessor map) に記録する事ができる。その場合 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点であるかまたは始点からは到達不能な頂点である場合を除く)。これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間アクションをとれる独自のビジタを提供することができる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dag_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムが適用されるグラフオブジェクト。&lt;code&gt;VertexListGraph&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。全ての距離はこの頂点から計算され、最短経路木はこの頂点を根とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重みまたは「長さ」。&lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。グラフの辺記述子型は重みマップのキー型として使用できる必要がある。マップの値型は距離マップの値型を伴った Addable でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。これは辺がリラックスされた (減らされた) 時、ヒープ・データ構造を効率よく更新するのに必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;distance_map(DistanceMap d_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点 &lt;code&gt;s&lt;/code&gt; から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。最短経路の重みは、最短経路に沿った辺の重みの和である。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。グラフの頂点記述子型は距離マップのキー型として使用できる必要がある。距離マップの値型は &lt;code&gt;combine&lt;/code&gt; 関数 オブジェクトと単位要素のための &lt;code&gt;zero&lt;/code&gt; オブジェクトから作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; の要素型である。さらに距離の値型は &lt;code&gt;compare&lt;/code&gt; 関数オブジェクトによって供給される &lt;a href=&#34;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&#34; target=&#34;_blank&#34;&gt;StrictWeakOrdering&lt;/a&gt; の順序付けを持っていなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;WeightMap&lt;/code&gt; の値型の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(CompareFunction cmp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数はどの頂点が始点により近いか決定するために距離を比較するのに使われる。 &lt;code&gt;CompareFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Predicate&lt;/a&gt; のモデルでなければならず、&lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致する引数型を持たなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(CombineFunction cmb)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数は道の距離を計算するために、距離を結合するのに使われる。 &lt;code&gt;CombineFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; のモデルでなければならない。二項関数の第一引数の型は &lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならず、第二引数の型は &lt;code&gt;WeightMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならない。結果型は距離の値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_inf(D inf)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inf&lt;/code&gt; オブジェクトは &lt;code&gt;D&lt;/code&gt; オブジェクトのどの値よりも最も大きくなければならない。すなわち、&lt;code&gt;d != inf&lt;/code&gt; の場合どれでも &lt;code&gt;compare(d, inf) == true&lt;/code&gt; でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::numeric_limits&amp;lt;D&amp;gt;::max()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_zero(D zero)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zero&lt;/code&gt; の値は距離の値と &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトによって作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; のための単一要素でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;D()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap c_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点に印をつけるためにアルゴリズムの実行の間使われる。頂点は白色から始めて、それがキュー中に挿入された時に灰色になる。それからそれがキューから取り除かれた時に黒色になる。アルゴリズムの終了時に、始点から到達可能な頂点は黒色に色づけされている。その他の全ての頂点は白色のままである。&lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。頂点記述子はマップのキー型として使用できる必要があり、マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; のモデルでなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;visitor(DijkstraVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズム内の一定のイベント・ポイントの間に起こしたいアクションを指定するのに使いなさい。&lt;code&gt;DijkstraVisitor&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt; コンセプトのモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dijkstra_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(V + E) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt; は、アルゴリズムの開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた時に呼び出される。この時点で &lt;code&gt;(p[u],u)&lt;/code&gt; は最短経路木の辺であることがわかるので、 &lt;code&gt;d[u] = delta(s,u) = d[p[u]] + w(p[u],u)&lt;/code&gt; である。さらに調査された頂点の距離は単調増加 &lt;code&gt;d[u1] &amp;lt;= d[u2] &amp;lt;= d[un]&lt;/code&gt; である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、頂点の各出辺において、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は、辺 &lt;code&gt;(u,v)&lt;/code&gt; において、 もし &lt;code&gt;d[u] + w(u,v) &amp;lt; d[v]&lt;/code&gt; であるなら呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(v, g)&lt;/code&gt; は、頂点 &lt;code&gt;v&lt;/code&gt; において、 &lt;code&gt;(u,v)&lt;/code&gt; が調査されて &lt;code&gt;v&lt;/code&gt; が白色である時に呼び出される。頂点が発見されていれば灰色に色づけされており、各到達可能な頂点はきっかり一度発見されるからである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし辺がリラックスされない (上を見よ) なら呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、頂点の出辺が全て調査された後に呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dag_shortest_paths.cpp.html&#34;&gt;examples/dag_shortest_paths.cpp&lt;/a&gt; を見よ。これはこのアルゴリズムの使用例である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dag_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われず ビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>depth_first_search -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/depth_first_search.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;depth_first_search&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;class&lt;/span&gt; P, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; G,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; vis, ColorMap color)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Graph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_search(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; vis, ColorMap color, 
                        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor start)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;depth_first_search()&lt;/code&gt; 関数は、有向グラフ中の頂点の深さ優先巡回(depth-first traversal)を行う。可能な時は、深さ優先巡回は次に訪れるために現在の頂点の隣接頂点を選ぶ。もし全ての隣接頂点がすでに発見されているならば、もしくは隣接頂点が存在しないならば、アルゴリズムは未発見の隣接を持つ前の頂点へとバックトラックする。一旦全ての到達可能な頂点が訪問されたら、アルゴリズムは残っている未発見の頂点のどれかを選び出し、巡回を続ける。このアルゴリズムは全ての頂点が訪問された時に終了する。深さ優先探索はグラフ中の辺を分類するのと、頂点を順序づけるのに役立つ。章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;Depth-First Search&lt;/a&gt; は DFS の様々な特性を記述し、適当に例をあげている。&lt;/p&gt;
&lt;p&gt;BFS に似て、頂点が発見された過程を保持するためにカラー・マーカーが使われる。白色はまだ発見されていない頂点を印づけ、灰色は発見されたけれどもまだ未発見の隣接している頂点を持つ頂点を印づける。黒い頂点はどの白い頂点にも隣接していない発見された頂点である。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;depth_first_search()&lt;/code&gt; 関数は、アルゴリズムの内部で一定のイベント・ポイントにおいて、ユーザ定義のアクションを呼び出す。これは一般的な DFS アルゴリズムが使用できる多くの状況に適用させるための機構を提供する。下の疑似コード中で、 DFS のためのイベント・ポイントは三角形と右側のラベルで示されている。ユーザ定義のアクションはビジタ・オブジェクトの形で提供されなければならない。すなわち、型が &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; の要求を満たしているオブジェクトである。擬似コード中では、先行点を計算するアルゴリズムを &lt;code&gt;p&lt;/code&gt;、発見時間を &lt;code&gt;d&lt;/code&gt;、そして終了時間を &lt;code&gt;t&lt;/code&gt; と表す。デフォルトでは、&lt;code&gt;depth_first_search()&lt;/code&gt; 関数はこれらのプロパティを計算しない。しかしながら、これを実行するのに使える &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; のような、あらかじめ定義されたビジタが存在する。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;DFS(G)
  for each vertex u in V 
    color[u] := WHITE              頂点 u の初期化
    p[u] = u 
  end for
  time := 0
  if there is a starting vertex s
    call DFS-VISIT(G, s)           頂点 s の開始
  for each vertex u in V 
    if color[u] = WHITE
      call DFS-VISIT(G, u)         頂点 u の開始
  end for
  return (p,d_time,f_time) 

DFS-VISIT(G, u) 
  color[u] := GRAY                 頂点 u の発見
  d_time[u] := time := time + 1 
  for each v in Adj[u]             辺 (u,v) の調査
    if (color[v] = WHITE)
      p[v] = u                     (u,v) は木の辺
      call DFS-VISIT(G, v)
    else if (color[v] = GRAY) 
      ...                          (u,v) は後退辺
    else if (color[v] = BLACK) 
      ...                          (u,v) は交差辺または前方辺
  end for
  color[u] := BLACK                頂点 u の終了
  f_time[u] := time := time + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IN: &lt;code&gt;Graph&amp;amp; g&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;有向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; と &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;visitor(DFSVisitor vis)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; コンセプトで指定されるイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dfs_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;root_vertex(typename graph_traits&amp;lt;VertexListGraph&amp;gt;::vertex_descriptor start)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは深さ優先探索が開始されるべき頂点を指定する。型は与えられたグラフの頂点記述子型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;*vertices(g).first&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。このパラメータはデフォルトのカラー・プロパティ・マップが使われた時にのみ必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E + V) である。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(s, g)&lt;/code&gt; は、グラフの探索の開始前にグラフの各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.start_vertex(s, g)&lt;/code&gt; は、探索の開始前に始点において一度呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(u, g)&lt;/code&gt; は、初めて頂点に通った時に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、各頂点のあらゆる出辺において、それが発見された後に呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.tree_edge(e, g)&lt;/code&gt; は、各辺において、それが探索木を構成する辺のメンバになった時に呼び出される。もし先行点の記録を望むなら、このイベント・ポイントで行いなさい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.back_edge(e, g)&lt;/code&gt; は、グラフ中の後退辺において呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.forward_or_cross_edge(e, g)&lt;/code&gt; は、グラフ中の前方辺または交差辺において呼び出される。無向グラフ中ではこのメソッドは決して呼ばれない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、出辺の全てが探索木に追加され、全ての隣接頂点が発見された (ただし、それらの出辺が調査される前に) 後の頂点において呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dfs-example.cpp.html&#34;&gt;examples/dfs-example.cpp&lt;/a&gt; 中の例は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34;&gt;Figure 1&lt;/a&gt; にあるグラフへ適用された DFS を示す。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html&#34;&gt;&lt;code&gt;depth_first_visit&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/undirected_dfs.html&#34;&gt;&lt;code&gt;undirected_dfs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_search.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>depth_first_visit -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/depth_first_visit.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;depth_first_visit&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; depth_first_visit(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;IncidenceGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; vis, ColorMap color)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この関数は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph/doc/graph_theory_review.html#dfs-algorithm&#34;&gt;depth-firstパターン&lt;/a&gt; を使って、始点 &lt;code&gt;s&lt;/code&gt; と同じ連結成分中にある全ての頂点を訪れる。時々単独で有用ではあるが、この関数の主な目的は &lt;code&gt;depth_first_search()&lt;/code&gt; の実装のためにある。&lt;/p&gt;
&lt;p&gt;ユーザによって提供される &lt;code&gt;DFSVisitor&lt;/code&gt; はアルゴリズムの内側の各イベント・ポイントで行われるアクションを決定する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ColorMap&lt;/code&gt; は訪れられた頂点の過程を保持するためにアルゴリズムによって使われる。&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN &lt;code&gt;IncidenceGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフまたは無向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/IncidenceGraph.html&#34;&gt;Incidence Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探索が開始される始点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;DFSVisitor visitor&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムの内側で &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFS Visitor&lt;/a&gt; コンセプトで指定されるイベント・ポイントで呼び出されるビジタ・オブジェクト。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html#note_1&#34;&gt;[1]&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;ColorMap color&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これはグラフを通る進行過程を保持するためにアルゴリズムによって使われる。 &lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならず、かつキー型はグラフの頂点記述子型でなければならず、またカラー・マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; をモデルとしなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O(E) である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/depth_first_visit.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたは リファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dfs_visitor&lt;EventVisitorList&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/dfs_visitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;dfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;例は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DFSVisitor.html&#34;&gt;DFSVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた EventVisitor のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/depth_first_search.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは DFSVisitor に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが &lt;code&gt;EventVisitorList&lt;/code&gt; の中の EventVisitor にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dfs_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_dfs_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを DFS ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dijkstra_shortest_paths -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/dijkstra_shortest_paths.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;dijkstra_shortest_paths&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; P, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;
dijkstra_shortest_paths(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s,
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前なしパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; PredecessorMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistanceMap,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; WeightMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; IndexMap, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Compare&lt;/a&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Combine&lt;/a&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistInf, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; DistZero&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; dijkstra_shortest_paths
  (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
   PredecessorMap predecessor, DistanceMap distance, WeightMap weight, 
   IndexMap index_map,
   &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Compare&lt;/a&gt; compare, &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Combine&lt;/a&gt; combine, DistInf inf, DistZero zero,
   &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; vis)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズム [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#dijkstra59&#34;&gt;10&lt;/a&gt;,&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#clr90&#34;&gt;8&lt;/a&gt;] は、全ての辺の重みが負でない場合の、重みづけされた有向グラフまたは無向グラフの単一始点の最短経路問題を解く。いくつかの辺の重みが負である場合は Bellman-Ford のアルゴリズムを使いなさい。全ての辺の重みが 1 に等しい時は Dijkstra のアルゴリズムの代わりに幅優先探索を使いなさい。最短経路問題の定義のために、最短経路問題のいくつかの背景 についての章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-path-algorithms&#34;&gt;Shortest-Paths Algorithms&lt;/a&gt; を見なさい。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dijkstra_shortest_paths()&lt;/code&gt; 関数から出力を得るための主な二つの選択が存在する。&lt;code&gt;distance_map()&lt;/code&gt; パラメータを通して距離プロパティ・ マップを提供するならば、グラフ中の始点から他の全ての頂点への最短距離は距離マップに記録されるだろう。さらに最短経路木を先行点マップ (predecessor map) に記録することができる。その場合 &lt;code&gt;V&lt;/code&gt; 中の各頂点 &lt;code&gt;u&lt;/code&gt; にとって、最短経路木中では &lt;code&gt;p[u]&lt;/code&gt; が &lt;code&gt;u&lt;/code&gt; の先行点になるだろう (ただし &lt;code&gt;p[u] = u&lt;/code&gt; でここに &lt;code&gt;u&lt;/code&gt; が始点であるかまたは始点からは到達不能な頂点である場合を除く)。 これらの二つの選択に加え、ユーザはアルゴリズムのイベント・ポイントのどれかの間アクションを取れる独自のビジタを提供することができる。&lt;/p&gt;
&lt;p&gt;Dijkstra のアルゴリズムは最短経路を知っている頂点集合 &lt;code&gt;S&lt;/code&gt; を反復的に「育てる」ことによって、始点から他の頂点への全ての最短経路を発見する。アルゴリズムの各段階で、&lt;code&gt;S&lt;/code&gt; に追加される次の頂点は優先度付きキューによって決定される。キューは、距離ラベルによって優先された &lt;code&gt;V - S&lt;/code&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_1&#34;&gt;[1]&lt;/a&gt; 中に頂点を含む。そして距離ラベルとはいまの所見られる各頂点への最短経路の長さである。それから優先度付きキューの先頭にある頂点 &lt;code&gt;u&lt;/code&gt; が &lt;code&gt;S&lt;/code&gt; に加えられ、その各先行辺はリラックス (距離が減らされる) される。つまり、もし &lt;code&gt;u&lt;/code&gt; への距離に出辺 &lt;code&gt;(u,v)&lt;/code&gt; の重みを加えた結果が &lt;code&gt;v&lt;/code&gt; の 距離ラベルより小さいなら、頂点 &lt;code&gt;v&lt;/code&gt; の評価された距離は減らされる。 それからアルゴリズムは元に戻り、優先度付きキューの先頭の次の頂点の処理をする。優先度付きキューが空になった時にアルゴリズムは終了する。&lt;/p&gt;
&lt;p&gt;アルゴリズムは各頂点がどの集合中にあるかの過程を保持するためにカラー・マーカー (白色、灰色、そして黒色) を使う。黒色に色づけされた頂点は &lt;code&gt;S&lt;/code&gt; 中にある。 白色または灰色に色づけされた頂点は &lt;code&gt;V-S&lt;/code&gt; 中にある。白色の頂点はまだ発見されていず、灰色の頂点は優先度付きキュー中にある。デフォルトでは、グラフ中の各頂点のためのカラー・マーカーを格納するための配列を割り当てる。&lt;code&gt;color_map()&lt;/code&gt; パラメータによって独自の記憶域と色へのアクセスを提供することができる。&lt;/p&gt;
&lt;p&gt;下記の擬似コードは Dijkstra の単一始点の最短経路アルゴリズムである。 &lt;code&gt;w&lt;/code&gt; は辺の重み、&lt;code&gt;d&lt;/code&gt; は距離ラベル、そして &lt;code&gt;p&lt;/code&gt; は最短経路木を符号化するのに使われる各頂点の先行点である。&lt;code&gt;Q&lt;/code&gt; は減少キー操作 (DECREASE-KEY operation) を備える優先度付きキューである。ビジタのイベント・ポイントは右側のラベルによって示されている。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;DIJKSTRA(G, s, w)
  for each vertex u in V           頂点 u の初期化
    d[u] := infinity 
    p[u] := u 
    color[u] := WHITE
  end for
  color[s] := GRAY 
  d[s] := 0 
  INSERT(Q, s)                     頂点 s の発見
  while (Q != Ø)
    u := EXTRACT-MIN(Q)            頂点 u の調査
    S := S U { u }
    for each vertex v in Adj[u]    辺 (u,v) の調査
      if (w(u,v) + d[u] &amp;lt; d[v])
        d[v] := w(u,v) + d[u]      辺 (u,v) はリラックスされた (減らされた)
        p[v] := u 
        if (color[v] = WHITE) 
          color[v] := GRAY
          INSERT(Q, v)             頂点 v の発見
        else if (color[v] = GRAY)
          DECREASE-KEY(Q, v)
      else
        ...                        辺 (u,v) はリラックスされない (減らされない)
    end for
    color[u] := BLACK              頂点 u の終了
  end while
  return (d, p)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dijkstra_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;const VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズムが適用されるグラフオブジェクト。&lt;code&gt;VertexListGraph&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;Vertex List Graph&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor s&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;始点。全ての距離はこの頂点から計算される。そして最短経路木はこの頂点を根とする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;weight_map(WeightMap w_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の各辺の重みまたは「長さ」。重みは全て非負でなければならず、辺の一つが負であればアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/exception.html#negative_edge&#34;&gt;&lt;code&gt;negative_edge&lt;/code&gt;&lt;/a&gt; 例外を投げる。&lt;code&gt;WeightMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。グラフの辺記述子型は重みマップのキー型として使用できる必要がある。このマップの値型は距離マップの値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_weight, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において整数にマップする。これは辺がリラックスされた (減らされた) 時、ヒープ・データ構造を効率よく更新するのに必要である。&lt;code&gt;VertexIndexMap&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップの値型は汎整数型でなければならない。グラフの頂点記述子型はマップのキー型として使用できる必要がある。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;predecessor_map(PredecessorMap p_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先行点マップ (predecessor map) は最小全域木中に辺を記録する。アルゴリズムの完了時に、&lt;code&gt;V&lt;/code&gt; 中の全ての &lt;code&gt;u&lt;/code&gt; のための辺 &lt;code&gt;(p[u],u)&lt;/code&gt; は最小全域木中にある。もし &lt;code&gt;p[u] = u&lt;/code&gt; なら &lt;code&gt;u&lt;/code&gt; は始点かまたは始点から到達不能な頂点である。 &lt;code&gt;PredecessorMap&lt;/code&gt; の型はキーと頂点の型がグラフの頂点記述子型と同じ &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dummy_property_map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;distance_map(DistanceMap d_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ &lt;code&gt;g&lt;/code&gt; 中の始点 &lt;code&gt;s&lt;/code&gt; から各頂点への最短経路の重みは、このプロパティ・マップ中に記録される。最短経路の重みは、最短経路に沿った辺の重みの和である。&lt;code&gt;DistanceMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。グラフの頂点記述子型は距離マップのキー型として使用できる必要がある。距離マップの値型は &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトと単位要素のための &lt;code&gt;zero&lt;/code&gt; オブジェクトから作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; の要素型である。さらに距離の値型は &lt;code&gt;compare&lt;/code&gt; 関数オブジェクトによって提供される &lt;a href=&#34;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&#34; target=&#34;_blank&#34;&gt;StrictWeakOrdering&lt;/a&gt; の順序付けを持っていなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;WeightMap&lt;/code&gt; の値型の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_compare(CompareFunction cmp)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数はどの頂点が始点により近いか決定するために距離を比較するのに使われる。&lt;code&gt;CompareFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryPredicate.html&#34; target=&#34;_blank&#34;&gt;Binary Predicate&lt;/a&gt; のモデルでなければならず、&lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・ マップの値型に一致する引数型を持たなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::less&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_combine(CombineFunction cmb)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この関数は道の距離を計算するために、距離を結合するのに使われる。 &lt;code&gt;CombineFunction&lt;/code&gt; の型は &lt;a href=&#34;http://www.sgi.com/tech/stl/BinaryFunction.html&#34; target=&#34;_blank&#34;&gt;Binary Function&lt;/a&gt; のモデルでなければならない。二項関数の第一引数の型は &lt;code&gt;DistanceMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならず、 第二引数の型は &lt;code&gt;WeightMap&lt;/code&gt; プロパティ・マップの値型に一致していなければならない。結果型は距離の値型と同じでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::plus&amp;lt;D&amp;gt;&lt;/code&gt; ここで &lt;code&gt;D=typename property_traits&amp;lt;DistanceMap&amp;gt;::value_type&lt;/code&gt; とする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_inf(D inf)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inf&lt;/code&gt; オブジェクトは &lt;code&gt;D&lt;/code&gt; オブジェクトのどの値よりも最も大きく なければならない。すなわち、&lt;code&gt;d != inf&lt;/code&gt; の場合どれでも &lt;code&gt;compare(d, inf) == true&lt;/code&gt; でなければならない。 &lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;std::numeric_limits&amp;lt;D&amp;gt;::max()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;distance_zero(D zero)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zero&lt;/code&gt; の値は距離の値と &lt;code&gt;combine&lt;/code&gt; 関数オブジェクトによって 作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/Monoid.html&#34;&gt;Monoid&lt;/a&gt; のための単一要素でなければならない。&lt;code&gt;D&lt;/code&gt; の型は &lt;code&gt;DistanceMap&lt;/code&gt; の値型である。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;D()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL/OUT: &lt;code&gt;color_map(ColorMap c_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは頂点に印をつけるためにアルゴリズムの実行の間使われる。頂点は白色から始めて、それがキュー中に挿入された時に灰色になる。それからそれがキューから取り除かれた時に黒色になる。アルゴリズムの終了時に、始点から到達可能な頂点は黒色に色づけされている。その他の全ての頂点は白色のままである。&lt;code&gt;ColorMap&lt;/code&gt; の型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.html&#34;&gt;Read/Write Property Map&lt;/a&gt; のモデルでなければならない。頂点記述子はマップのキー型として使用できる必要があり、マップの値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;Color Value&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt; で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;visitor(DijkstraVisitor v)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アルゴリズム内の一定のイベント・ポイントの間に起こしたいアクションを指定するのに使いなさい。&lt;code&gt;DijkstraVisitor&lt;/code&gt; は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt; コンセプトのモデルでなければならない。ビジタ・オブジェクトは値渡しされる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_2&#34;&gt;[2]&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;dijkstra_visitor&amp;lt;null_visitor&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は O((V + E) log V) か、もし全ての頂点が始点から到達可能ならちょうど O(E log V) になる。&lt;/p&gt;
&lt;h2&gt;ビジタ・イベント・ポイント&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vis.initialize_vertex(u, g)&lt;/code&gt; は、アルゴリズムの開始前に各頂点で呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_vertex(u, g)&lt;/code&gt; は、頂点が優先度付きキューから取り除かれ、集合 &lt;code&gt;S&lt;/code&gt; に加えられた時に呼び出される。この時点で &lt;code&gt;(p[u],u)&lt;/code&gt; は最短経路木の辺であることが分かるので &lt;code&gt;d[u] = delta(s,u) = d[p[u]] + w(p[u],u)&lt;/code&gt; である。さらに、調査された頂点の距離は単調増加 &lt;code&gt;d[u1] &amp;lt;= d[u2] &amp;lt;= d[un]&lt;/code&gt; である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.examine_edge(e, g)&lt;/code&gt; は、頂点の各出辺において、頂点が集合 &lt;code&gt;S&lt;/code&gt; に加えられた後で直ちに呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_relaxed(e, g)&lt;/code&gt; は、辺 &lt;code&gt;(u,v)&lt;/code&gt; において、もし &lt;code&gt;d[u] + w(u,v) &amp;lt; d[v]&lt;/code&gt; であるなら呼び出される。頂点 &lt;code&gt;v&lt;/code&gt; のための最近のリラックス (減少) にあずかった辺 &lt;code&gt;(u,v)&lt;/code&gt; は最短経路木の中にある辺である。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.discover_vertex(v, g)&lt;/code&gt; は、頂点 &lt;code&gt;v&lt;/code&gt; において、&lt;code&gt;(u,v)&lt;/code&gt; が調査されて &lt;code&gt;v&lt;/code&gt; が白色である時に呼び出される。頂点が発見されていれば灰色に色づけされており、各到達可能な頂点はきっかり一度発見されるからである。これは頂点が優先度付きキューに挿入される時にも言える。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.edge_not_relaxed(e, g)&lt;/code&gt; は、もし辺がリラックスされない (上を見よ) なら呼び出される。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis.finish_vertex(u, g)&lt;/code&gt; は、頂点の出辺が全て調査された後に呼び出される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dijkstra-example.cpp.html&#34;&gt;examples/dijkstra-example.cpp&lt;/a&gt; を見よ。これは Dijkstra のアルゴリズムの使用例である。&lt;/p&gt;
&lt;h2&gt;注釈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_1&#34; name=&#34;note_1&#34;&gt;[1]&lt;/a&gt; ここで使われているアルゴリズムは全ての &lt;code&gt;V - S&lt;/code&gt; 頂点を一度に優先度付きキュー中に置かないことによって、わずかなスペースを節約している。その代わり、発見された &lt;code&gt;V - S&lt;/code&gt; 中のこれらの頂点だけであり、それゆえ無限より少ない距離を持っている。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_shortest_paths.html#note_2&#34; name=&#34;note_2&#34;&gt;[2]&lt;/a&gt; ビジタのパラメータは値渡しされるので、もしビジタが状態を持っているなら、アルゴリズムの間のいかなる状態の変更も、送ったビジタ・オブジェクトには行われずビジタ・オブジェクトのコピーに対して行われる。それゆえポインタまたはリファレンスによってこの状態をビジタに保持させることを望むかもしれない。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>dijkstra_visitor&lt;EventVisitorList&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/dijkstra_visitor.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/dijkstra_visitor.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;dijkstra_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;このクラスは、(&lt;code&gt;std::pair&lt;/code&gt; を使って作られる) &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; のリストを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; に変換するアダプタである。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;以下は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/dave.cpp.html&#34;&gt;examples/dave.cpp&lt;/a&gt; からの抜粋である。ここでは Dijkstra のアルゴリズムで計算された最短経路木のコピーを作るために、 &lt;code&gt;copy_graph&lt;/code&gt; という単独イベントビジタを使っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;dijkstra_shortest_paths
  (G, vertex(a, G), 
   distance_map(make_iterator_property_map(distance.begin(), vertex_id, distance[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;])).
   predecessor_map(make_iterator_property_map(parent.begin(), vertex_id, parent[&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;])).
   visitor(make_dijkstra_visitor(copy_graph(G_copy, on_examine_edge()))));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;Dijkstra Visitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventVisitorList&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;std::pair&lt;/code&gt; で作られた EventVisitor のリスト。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null_visitor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/dijkstra_shortest_paths.hpp&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;このクラスは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/DijkstraVisitor.html&#34;&gt;DijkstraVisitor&lt;/a&gt; に要求される全てのメンバ関数を実装している。それぞれの関数で、適切なイベントが &lt;code&gt;EventVisitorList&lt;/code&gt; の中の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; にディスパッチされる。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;dijkstra_visitor&amp;lt;EventVisitorList&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;make_dijkstra_visitor(EventVisitorList ev_list);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;イベントビジタのリストを Dijkstra ビジタに適合させたものを返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html&#34;&gt;&lt;code&gt;distance_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。 &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>distance_recorder&lt;DistanceMap, EventTag&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/distance_recorder.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;distance_recorder&amp;lt;DistanceMap, EventTag&amp;gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;これは、グラフ探索中に、ある始点から各頂点までの距離を (&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map.html&#34;&gt;property map&lt;/a&gt; を使って) 記録する &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt; である。辺 &lt;code&gt;e = (u,v)&lt;/code&gt; に対して実行されると、 &lt;code&gt;v&lt;/code&gt; への距離は &lt;code&gt;u&lt;/code&gt; への距離より大きくなる。 &lt;code&gt;distance_recorder&lt;/code&gt; は &lt;code&gt;on_tree_edge&lt;/code&gt; や &lt;code&gt;on_relax_edge&lt;/code&gt; イベントでよく使われる。頂点イベントには使用できない。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; や &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/dfs_visitor.html&#34;&gt;&lt;code&gt;dfs_visitor&lt;/code&gt;&lt;/a&gt; などのアルゴリズム別のアダプタでラップすることで、 &lt;code&gt;distance_recorder&lt;/code&gt; を グラフアルゴリズムで使えるようになる。また、&lt;code&gt;std::pair&lt;/code&gt; を使って他のイベントビジタと結合して、 EventVisitorList を作れる。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;例は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bfs_visitor.html&#34;&gt;&lt;code&gt;bfs_visitor&lt;/code&gt;&lt;/a&gt; を参照。&lt;/p&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EventVisitor.html&#34;&gt;EventVisitor&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/visitors.hpp&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DistanceMap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;キーの型と値の型がグラフの頂点記述子型である &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/WritablePropertyMap.html&#34;&gt;WritablePropertyMap&lt;/a&gt; &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html#translate_note_1&#34;&gt;[訳注1]&lt;/a&gt;。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EventTag&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;グラフアルゴリズム中、いつ &lt;code&gt;distance_recorder&lt;/code&gt; が呼び出されるかを指定するタグ。 &lt;code&gt;EventTag&lt;/code&gt; は辺イベントでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;distance_recorder::event_filter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートパラメータ &lt;code&gt;EventTag&lt;/code&gt; と同じ型。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;distance_recorder(DistanceMap pa);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;距離プロパティマップ &lt;code&gt;pa&lt;/code&gt; を使って &lt;code&gt;distance_recorder&lt;/code&gt; オブジェクトを構築する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Edge, class Graph&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void operator()(Edge e, const Graph&amp;amp; g);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;辺 &lt;code&gt;e = (u,v)&lt;/code&gt; を渡されると、 &lt;code&gt;u&lt;/code&gt; への距離に 1 を足したものを &lt;code&gt;v&lt;/code&gt; への距離として記録する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class DistanceMap, class Tag&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;distance_recorder&amp;lt;DistanceMap, Tag&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;record_distances(DistanceMap pa, Tag);&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;distance_recorder&lt;/code&gt; を作る便利な方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;Visitorコンセプト&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;イベントビジタ: &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/predecessor_recorder.html&#34;&gt;&lt;code&gt;predecessor_recorder&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/time_stamper.html&#34;&gt;&lt;code&gt;time_stamper&lt;/code&gt;&lt;/a&gt; 、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/property_writer.html&#34;&gt;&lt;code&gt;property_writer&lt;/code&gt;&lt;/a&gt; 。&lt;/p&gt;
&lt;h2&gt;訳注&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/distance_recorder.html#translate_note_1&#34; name=&#34;translate_note_1&#34;&gt;[訳注1]&lt;/a&gt; 値の型は整数である。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:gimite@mx12.freecom.ne.jp&#34;&gt;Hiroshi Ichikawa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>edge_list&lt;EdgeIterator, ValueType, DiffType&gt; -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/edge_list.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;edge_list&amp;lt;EdgeIterator, ValueType, DiffType&amp;gt;&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; クラスは辺イテレータのペアを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph.html&#34;&gt;EdgeListGraph&lt;/a&gt; をモデルとするクラスに変えるアダプタである。辺イテレータの &lt;code&gt;value_type&lt;/code&gt; は &lt;code&gt;std::pair&lt;/code&gt; (もしくは少なくとも &lt;code&gt;first&lt;/code&gt; メンバと &lt;code&gt;second&lt;/code&gt; メンバを持っている) でなければならない。ペアの &lt;code&gt;first_type&lt;/code&gt; と &lt;code&gt;second_type&lt;/code&gt; は同じでなければならず、それらはグラフの &lt;code&gt;vertex_descriptor&lt;/code&gt; のために使われるだろう。 &lt;code&gt;ValueType&lt;/code&gt; と &lt;code&gt;DiffType&lt;/code&gt; のテンプレート・パラメータは、コンパイラが部分特殊化版をサポートしていない時にのみ必要である。そうでなければデフォルトは正しい型になる。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;Bellman-Ford の最短経路アルゴリズムを &lt;code&gt;edge_list&lt;/code&gt; に適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;enum&lt;/span&gt; { u, v, x, y, z, N };
&lt;span style=&#34;color: #B00040&#34;&gt;char&lt;/span&gt; name[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;u&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;v&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;y&#39;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#39;z&#39;&lt;/span&gt; };

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; E;
E edges[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { E(u,y), E(u,x), E(u,v),
              E(v,u),
              E(x,y), E(x,v),
              E(y,v), E(y,z),
              E(z,u), E(z,x) };

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; weight[] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;,
                 &lt;span style=&#34;color: #666666&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt; };

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; Graph;
Graph &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(edges, edges &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;sizeof&lt;/span&gt;(edges) &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;sizeof&lt;/span&gt;(E));

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; distance(N, std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;numeric_limits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;short&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;max());
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; parent(N,&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;);

distance[z] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
parent[z] &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; z;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; r &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bellman_ford_shortest_paths(g, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(N), weight,
                                            distance.begin(),
                                            parent.begin());
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (r)  
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; N; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i)
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name[i] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; distance[i]
              &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34; &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name[parent[i]] &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
  std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;negative cycle&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力は最短経路木中の根と各頂点の親からの距離になる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;u: 2 v
v: 4 x
x: 7 z
y: -2 u
z: 0 z
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/edge_list.hpp&lt;/p&gt;
&lt;h2&gt;テンプレートパラメータ&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;value_type&lt;/code&gt; が頂点記述子のペアである &lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;InputIterator&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ValueType&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt; の &lt;code&gt;value_type&lt;/code&gt;。&lt;br /&gt; デフォルト: &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::value_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DiffType&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;EdgeIterator&lt;/code&gt; の &lt;code&gt;difference_type&lt;/code&gt;。&lt;br /&gt; デフォルト: &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::difference_type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/EdgeListGraph&#34;&gt;EdgeListGraph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連型&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; に結びつけられた頂点記述子のための型。これは &lt;code&gt;std::iterator_traits&amp;lt;EdgeIterator&amp;gt;::value_type::first_type&lt;/code&gt; と同じ型であるだろう。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_descriptor
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edge_list&lt;/code&gt; に結びつけられた辺記述子のための型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;edge_iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edges()&lt;/code&gt; によって返されるイテレータのための型。&lt;code&gt;edge_iterator&lt;/code&gt; のイテレータの種類は &lt;code&gt;EdgeIterator&lt;/code&gt; のそれと同じであるだろう。&lt;/p&gt;
&lt;h2&gt;メンバ関数&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;edge_list(EdgeIterator first, EdgeIterator last) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;範囲 &lt;code&gt;[first,last)&lt;/code&gt; で与えられる辺リストで指定された &lt;code&gt;n&lt;/code&gt; 個の頂点と辺からなるグラフ・オブジェクトを作成する。&lt;/p&gt;
&lt;h2&gt;非メンバ関数&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;edge_iterator, edge_iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
edges(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;グラフ &lt;code&gt;g&lt;/code&gt; の辺集合へのアクセスを提供するイテレータ範囲を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
source(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の始点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;vertex_descriptor
target(edge_descriptor e, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; edge_list&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;辺 &lt;code&gt;e&lt;/code&gt; の終点を返す。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/liequan_lee.htm&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:llee@cs.indiana.edu&#34;&gt;llee@cs.indiana.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.osl.iu.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>edmunds_karp_max_flow -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/edmunds_karp_max_flow.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/edmunds_karp_max_flow.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;edmunds_karp_max_flow&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前付きパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;P&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; detail&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;edge_capacity_value&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;, P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
edmunds_karp_max_flow(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor src,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor sink,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; bgl_named_params&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;P, T, R&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; params &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; all defaults)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 名前無しパラメータバージョン&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;/span&gt;, 
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;CapacityEdgeMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ResidualCapacityEdgeMap&lt;/span&gt;,
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ReverseEdgeMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PredEdgeMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; property_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;CapacityEdgeMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type
edmunds_karp_max_flow(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor src,
   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Graph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor sink,
   CapacityEdgeMap cap, ResidualCapacityEdgeMap res, ReverseEdgeMap rev, 
   ColorMap color, PredEdgeMap pred)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edmunds_karp_max_flow()&lt;/code&gt; 関数はネットワークの最大流を計算する。最大流の記述のために章 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#network-flow-algorithms&#34;&gt;Network Flow Algorithms&lt;/a&gt; を見なさい。計算された最大流が関数の返却値になるだろう。関数はさらに &lt;code&gt;E&lt;/code&gt; 中の全ての &lt;code&gt;(u,v)&lt;/code&gt; のために流量 &lt;code&gt;f(u,v)&lt;/code&gt; を計算する。そしてそれは、残差容量 &lt;code&gt;r(u,v) = c(u,v) - f(u,v)&lt;/code&gt; の形で返される。&lt;/p&gt;
&lt;p&gt;このアルゴリズムのために、入力グラフとプロパティ・マップのパラメータにいくつかの特別な必要条件がある。最初に、ネットワークを表す有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; は、 &lt;code&gt;E&lt;/code&gt; 中の各辺のための逆辺 (reverse edge) を含むために増やされなければならない。換言すれば、入力グラフは &lt;code&gt;G&lt;sub&gt;in&lt;/sub&gt; = (V,{E U ET})&lt;/code&gt; であるべきである。&lt;code&gt;ReverseEdgeMap&lt;/code&gt; 引数 &lt;code&gt;rev&lt;/code&gt; は元のグラフ中の各辺をその逆辺にマップしなければならない。すなわち &lt;code&gt;E&lt;/code&gt; 中の全ての &lt;code&gt;(u,v)&lt;/code&gt; に対して &lt;code&gt;(u,v) -&amp;gt; (v,u)&lt;/code&gt; である。&lt;code&gt;CapacityEdgeMap&lt;/code&gt; 引数 &lt;code&gt;cap&lt;/code&gt; は &lt;code&gt;E&lt;/code&gt; 中の各辺を正の数にマップしなければならず、&lt;code&gt;E&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; 中の各辺は &lt;code&gt;0&lt;/code&gt; にされなければならない。&lt;/p&gt;
&lt;p&gt;このアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#edmonds72:_improvements_netflow&#34;&gt;Edmonds and Karp&lt;/a&gt; に負っている。もっとも &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ahuja93:_network_flows&#34;&gt;Network Flows&lt;/a&gt; に述べられている「ラベリング・アルゴリズム」と呼ばれる亜種を使っているが。&lt;/p&gt;
&lt;p&gt;このアルゴリズムは、最大流問題を実装するための大変単純で容易な解答である。しかしながら、このアルゴリズムが &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/push_relabel_max_flow.html&#34;&gt;&lt;code&gt;push_relabel_max_flow()&lt;/code&gt;&lt;/a&gt; アルゴリズムほどには良くないいくつかの理由がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非整数の容量の場合、時間計算量は最疎グラフを除く全てのグラフにとって push-relabel アルゴリズムの O(V&lt;sup&gt;2&lt;/sup&gt;E&lt;sup&gt;1/2&lt;/sup&gt;) より悪い O(V E&lt;sup&gt;2&lt;/sup&gt;) である。&lt;/li&gt;
&lt;li&gt;整数の容量の場合、もし容量の範囲 &lt;code&gt;U&lt;/code&gt; が大変大きいならば、アルゴリズムに長い時間がかかるだろう。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義場所&lt;/h2&gt;
&lt;p&gt;boost/graph/edmunds_karp_max_flow.hpp&lt;/p&gt;
&lt;h2&gt;パラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;VertexListGraph&amp;amp; g&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有向グラフ。グラフの型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/VertexListGraph.html&#34;&gt;VertexListGraph&lt;/a&gt; のモデルでなければならない。グラフ中の各辺 &lt;code&gt;(u,v)&lt;/code&gt; のために、逆辺 &lt;code&gt;(v,u)&lt;/code&gt; もまたグラフ中になければならない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor src&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流れのネットワーク・グラフのためのソース頂点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_descriptor sink&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流れのネットワーク・グラフのためのシンク頂点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;名前付きパラメータ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;capacity_map(CapacityEdgeMap cap)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;辺容量プロパティ・マップ。型は定数 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_capacity, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OUT: &lt;code&gt;residual_capacity_map(ResidualCapacityEdgeMap res)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;これは辺をその残差容量にマップする。型は変更可能の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。 &lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_residual_capacity, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;reverse_edge_map(ReverseEdgeMap rev)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフ中の全ての辺 &lt;code&gt;(u,v)&lt;/code&gt; を逆辺 &lt;code&gt;(v,u)&lt;/code&gt; にマップする辺プロパティ・ マップ。マップは定数 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(edge_reverse, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;color_map(ColorMap color)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;幅優先探索の段階の間、進行過程を保持するためにアルゴリズムによって使われる。アルゴリズムの終了時に、白色の頂点は最小カット集合を定義する。マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの頂点記述子型であるべきで、値型は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/ColorValue.html&#34;&gt;ColorValue&lt;/a&gt; のモデルでなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の &lt;code&gt;default_color_type&lt;/code&gt; の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UTIL: &lt;code&gt;predecessor_map(PredEdgeMap pred)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;増大した道を格納するためにアルゴリズムによって使われる。マップは変更可能の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/LvaluePropertyMap.html&#34;&gt;Lvalue Property Map&lt;/a&gt; でなければならない。キー型はグラフの頂点記述子型であるべきで、値型は グラフの辺記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: サイズ &lt;code&gt;num_vertices(g)&lt;/code&gt; の 辺記述子の &lt;code&gt;std::vector&lt;/code&gt; から作られた &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/iterator_property_map.html&#34;&gt;&lt;code&gt;iterator_property_map&lt;/code&gt;&lt;/a&gt;で、添え字マップには &lt;code&gt;i_map&lt;/code&gt; を用いる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IN: &lt;code&gt;vertex_index_map(VertexIndexMap i_map)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グラフの各頂点を &lt;code&gt;[0, num_vertices(g))&lt;/code&gt; の範囲において唯一の整数にマップしなさい。このプロパティ・マップはカラー・マップまたは先行点マップのためにデフォルトが使われた時にのみ必要である。頂点添え字マップは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.html&#34;&gt;Readable Property Map&lt;/a&gt; のモデルでなければならない。マップのキー型はグラフの頂点記述子型でなければならない。&lt;/li&gt;
&lt;li&gt;デフォルト: &lt;code&gt;get(vertex_index, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;計算量&lt;/h2&gt;
&lt;p&gt;時間計算量は、通常の場合には O(V E&lt;sup&gt;2&lt;/sup&gt;) で、もしくは容量値が 定数 &lt;code&gt;U&lt;/code&gt; で範囲づけられた整数であるならば O(V E U) である。&lt;/p&gt;
&lt;h2&gt;コード例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/examples/edmunds-karp-eg.cpp.html&#34;&gt;examples/edmunds-karp-eg.cpp&lt;/a&gt; 中のプログラムは最大流問題の例 (辺容量を伴うグラフ) を DIMACS 形式で書かれた ファイルから読み、最大流を計算する。&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/push_relabel_max_flow.html&#34;&gt;&lt;code&gt;push_relabel_max_flow()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 &lt;a href=&#34;mailto:takashi-it@po6.nsk.ne.jp&#34;&gt;Takashi Itou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>基本的なグラフ理論の復習 -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/graph/graph_theory_review.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;基本的なグラフ理論の復習&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;この章は、基本的なグラフ理論を思い出させることを意図している。読者があらかじめグラフアルゴリズムの知識があるのなら、始めるにあたりこの章は十分であろう。もし読者がグラフアルゴリズムの知識がないのならば、 Cormen, Leiserson, Rivestの&lt;a href=&#34;http://www.toc.lcs.mit.edu/~clr/&#34; target=&#34;_blank&#34;&gt;Introduction to Algorithms&lt;/a&gt; のようなもっと詳しいものを薦める。&lt;/p&gt;
&lt;h2&gt;グラフ抽象&lt;/h2&gt;
&lt;p&gt;グラフは、多くの種類の問題を解くのに有効な数学的抽象化である。基本的には、グラフは頂点と辺から構成され、辺は二つの頂点を結ぶ。もっと正確には、グラフ(graph)とは組&lt;code&gt;(V,E)&lt;/code&gt;で表され、&lt;code&gt;V&lt;/code&gt;は有限集合で、&lt;code&gt;E&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の２項関係である。&lt;code&gt;V&lt;/code&gt;は &lt;strong&gt;頂点集合(vertex set)&lt;/strong&gt; と呼ばれ、その要素を &lt;strong&gt;頂点(vertex)&lt;/strong&gt; と呼ぶ。&lt;code&gt;E&lt;/code&gt;は辺の集合で、 &lt;strong&gt;辺(edge)&lt;/strong&gt; とは&lt;code&gt;(u,v)&lt;/code&gt;の組で&lt;code&gt;u&lt;/code&gt;、&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;V&lt;/code&gt;の要素である。 &lt;strong&gt;有向グラフ(directed graph)&lt;/strong&gt; においては、辺は順序付けられた組で、 &lt;strong&gt;始点(source)&lt;/strong&gt; を &lt;strong&gt;終点(target)&lt;/strong&gt; へと接続する。無向グラフ(undirected graph)においては、辺は順序付けされていない組で、２つの頂点を両方向につなぐ。つまり、無向グラフでは &lt;code&gt;(u,v)&lt;/code&gt;と&lt;code&gt;(v,u)&lt;/code&gt;は同じ辺の２通りの書き方である。&lt;/p&gt;
&lt;p&gt;グラフのこの定義は、いくつかの点であいまいである。辺や頂点が何を表現するかが述べられていない。グラフの例としては、連絡道路やハイパーリンク付きのウェブページなどを挙げることができる。これらの詳細がグラフの定義からは除外されているのは、大きな理由がある。それらの詳細はグラフの &lt;strong&gt;抽象化&lt;/strong&gt; の中では必要な部分ではない。詳細を定義から除外することで再利用可能な理論を構築でき、そのことは多くの異なった種類の問題を解く際に役に立つのである。&lt;/p&gt;
&lt;p&gt;定義にもどろう。グラフは頂点と辺の集合である。実際の様子を見せるため、頂点に文字のラベルがついたグラフを考え、辺を単純に文字の組としよう。ここで、有向グラフの例を次のように書くことができる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y } 
E = { (b,y), (b,y), (y,v), (z,a), (x,x), (b,x), (x,v), (a,z) } 
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;このグラフを図示すると 図1 のようになる。辺 &lt;code&gt;(x,x)&lt;/code&gt; は &lt;strong&gt;輪(self-loop)&lt;/strong&gt; と呼ばれる。&lt;code&gt;(b,y)&lt;/code&gt;と &lt;code&gt;(b,y)&lt;/code&gt;は &lt;strong&gt;平行辺(parallel edges)&lt;/strong&gt; であり、これは &lt;strong&gt;マルチグラフ(multigraph)&lt;/strong&gt; でのみ許される(ただし、通常は有向グラフでも無向グラフでも許されない)。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/digraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図1: 有向グラフの例&lt;/p&gt;
&lt;p&gt;次に似たようなグラフを示すが、今度は無向グラフである。これは図2に図示する。無向グラフでは輪は許されない。上記のグラフ(から平行辺&lt;code&gt;(b,y)&lt;/code&gt;を除いたもの)の &lt;strong&gt;無向版(undirected version)&lt;/strong&gt; である。それはつまり、同じ頂点をもち、同じ辺から方向を除いたものを持つことを意味し、&lt;code&gt;(a,z)&lt;/code&gt;と&lt;code&gt;(z,a)&lt;/code&gt;という２つの辺は一つの辺に退化する。また、逆を考えることもできる。無向グラフの &lt;strong&gt;有向版(directed version)&lt;/strong&gt; は、すべての辺をそれぞれの方向を向く２つの辺で置き換えることで得られる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;V = {v, b, x, z, a, y }
E = { (b,y), (y,v), (z,a), (b,x), (x,v) }
G = (V, E)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/undigraph.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図2: 無向グラフの例&lt;/p&gt;
&lt;p&gt;ここでさらにグラフの用語を定義する。辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるとき、頂点&lt;code&gt;v&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;について &lt;strong&gt;隣接している(adjacent)&lt;/strong&gt; と言う。有向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は 頂点&lt;code&gt;u&lt;/code&gt;の &lt;strong&gt;出辺(out-edge)&lt;/strong&gt; であり、頂点&lt;code&gt;v&lt;/code&gt;の &lt;strong&gt;入辺(in-edge)&lt;/strong&gt; である。無向グラフでは、辺&lt;code&gt;(u,v)&lt;/code&gt;は頂点&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;v&lt;/code&gt;を &lt;strong&gt;接合している(incident on)&lt;/strong&gt; という。&lt;/p&gt;
&lt;p&gt;図1で、頂点&lt;code&gt;y&lt;/code&gt;は頂点&lt;code&gt;b&lt;/code&gt;に対して隣接している (ただし&lt;code&gt;b&lt;/code&gt;は&lt;code&gt;y&lt;/code&gt;に対して隣接していない)。辺&lt;code&gt;(b,y)&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;の出辺であり、&lt;code&gt;y&lt;/code&gt;の入辺である。図2で、&lt;code&gt;y&lt;/code&gt;は&lt;code&gt;b&lt;/code&gt;に隣接していて、また逆も同様である。辺&lt;code&gt;(y,b)&lt;/code&gt;は頂点&lt;code&gt;y&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;を接合している。&lt;/p&gt;
&lt;p&gt;有向グラフにおいて、ある頂点の出辺の数は &lt;strong&gt;出次数(out-degree)&lt;/strong&gt; と呼ばれ、入辺の数は &lt;strong&gt;入次数(in-degree)&lt;/strong&gt; と呼ばれる。無向グラフにおいて、ある頂点に対して接合している辺の数は &lt;strong&gt;次数(degree)&lt;/strong&gt; と呼ばれる。図1で、頂点&lt;code&gt;b&lt;/code&gt;の出次数は3であり、入次数は0である。図2では単純に頂点&lt;code&gt;b&lt;/code&gt;の次数は2である。&lt;/p&gt;
&lt;p&gt;グラフの &lt;strong&gt;路(path)&lt;/strong&gt; とは辺の列で、それぞれの辺の終点が次の辺の始点であるものである。頂点&lt;code&gt;u&lt;/code&gt;から始まり頂点&lt;code&gt;v&lt;/code&gt;で終わる路があれば、頂点&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;から &lt;strong&gt;到達可能(reachable)&lt;/strong&gt; であるという。路が &lt;strong&gt;単純(simple)&lt;/strong&gt; であるとは、辺の列の中でどの頂点も繰り返し現れないことである。路&lt;code&gt;&amp;lt;(b,x), (x,v)&amp;gt;&lt;/code&gt;は単純であるが、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は単純ではない。また、路&lt;code&gt;&amp;lt;(a,z), (z,a)&amp;gt;&lt;/code&gt;は最初の頂点と最後の頂点が一致するので、 &lt;strong&gt;サイクル(cycle)&lt;/strong&gt; と呼ばれる。サイクルのないグラフは &lt;strong&gt;アサイクリック(acyclic)&lt;/strong&gt; と呼ばれる。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平面的グラフ(planar graph)&lt;/strong&gt; とは、すべての辺が交差しないように平面上に描けるグラフのことである。そのように描かれたものは &lt;strong&gt;平面グラフ(plane graph)&lt;/strong&gt; と呼ばれる。平面グラフの &lt;strong&gt;面(face)&lt;/strong&gt; とは、辺に囲まれた連結成分のことである。平面的グラフの重要な特性は、面、辺、頂点の数がオイラーの定理：&lt;code&gt;|F| - |E| + |V| = 2&lt;/code&gt;によって関係付けられることである。このことは、平面的グラフは最大でもO(|V|)個の辺しか持たないことを意味する。&lt;/p&gt;
&lt;h2&gt;グラフデータ構造&lt;/h2&gt;
&lt;p&gt;データ構造を考えるときに最初に考えるべきグラフの属性は、&lt;strong&gt;まばらさ(sparsity)&lt;/strong&gt; である。まばらさとは、頂点に対する相対的な辺の数である。&lt;code&gt;E&lt;/code&gt;が&lt;code&gt;V²&lt;/code&gt;に近いグラフは &lt;strong&gt;密(dense)&lt;/strong&gt; であると呼ばれ、&lt;code&gt;E = alpha V&lt;/code&gt;で&lt;code&gt;alpha&lt;/code&gt;が&lt;code&gt;V&lt;/code&gt;より十分に小さい場合は、まばらな(sparse)グラフと呼ばれる。密なグラフについては、通常、 &lt;strong&gt;隣接行列表現(adjacency-matrix representation)&lt;/strong&gt; が最良の選択であり、一方まばらなグラフについては &lt;strong&gt;隣接リスト表現(adjacency-list representation)&lt;/strong&gt; が最良である。また、まばらなグラフについては &lt;strong&gt;辺リスト表現(edge-list representation)&lt;/strong&gt; も適切な状況下では記憶効率面でよい選択である。&lt;/p&gt;
&lt;h3&gt;隣接行列表現&lt;/h3&gt;
&lt;p&gt;グラフの隣接行列表現はV x Vの２次元配列である。 行列a&lt;sub&gt;uv&lt;/sub&gt;の要素は、辺&lt;code&gt;(u,v)&lt;/code&gt;がグラフに含まれるかどうかを示すブーリアン値である。図3に図1(から&lt;code&gt;(b,y)&lt;/code&gt;を引いたもの)の隣接行列表現を表す。保存に必要な領域はO(V²)である。任意の辺について、アクセス、追加、除去にかかる時間はO(1)である。 頂点の追加や除去は、再割り当てとすべてのグラフのコピーが必要になり、手順数はO(V²)になる。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_matrix.html&#34;&gt;&lt;code&gt;adjacency_matrix&lt;/code&gt;&lt;/a&gt;クラスは、隣接行列表現によってBGLグラフインターフェースを実装する。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_matrix.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図3: 隣接行列によるグラフの表現&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#adjacency-list-representation&#34; name=&#34;adjacency-list-representation&#34;&gt;隣接リスト表現&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;グラフの隣接リスト表現では、すべての頂点に対して出辺の列を保存する。まばらなグラフでは、こうすることでメモリ領域を節約でき、必要な領域はO(V + E)だけになる。さらに、すべての頂点の出辺にはより効果的にアクセスできる。辺の挿入のコストはO(1)で、任意の辺へのアクセスはO(alpha)である。ここで、alphaは行列のまばらさ(グラフ中のすべての頂点についての出辺の数の最大値)である。図4は図1のグラフの隣接リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/adjacency_list.html&#34;&gt;&lt;code&gt;adjacency_list&lt;/code&gt;&lt;/a&gt;は隣接リスト表現の実装である。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/adj_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図4: 隣接リストによるグラフ表現&lt;/p&gt;
&lt;h3&gt;辺リスト表現&lt;/h3&gt;
&lt;p&gt;グラフの辺リスト表現は、単純に辺の列であり、辺は頂点のIDの組で表される。必要なメモリはO(E)だけである。辺挿入のコストはO(1)であり、特定の辺のアクセスするのはO(E)(あまり効果的でない)である。図5は図1のグラフの辺リスト表現である。&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/edge_list.html&#34;&gt;&lt;code&gt;edge_list&lt;/code&gt;&lt;/a&gt;アダプタクラスは、辺リスト表現の実装を作るのに使うことができる。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/edge_list.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図5: 辺リストによるグラフの表現&lt;/p&gt;
&lt;h2&gt;グラフアルゴリズム&lt;/h2&gt;
&lt;h3&gt;グラフ探索アルゴリズム&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;木辺(tree edge)&lt;/strong&gt; とは、グラフ探索アルゴリズムをグラフに適用することによって作られた探索木(またはフォレスト)の辺ことである。辺&lt;code&gt;(u,v)&lt;/code&gt;は木辺であるのは、辺&lt;code&gt;(u,v)&lt;/code&gt;の探索(&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/visitor_concepts.html&#34;&gt;ビジタ&lt;/a&gt;の&lt;code&gt;explore()&lt;/code&gt;メソッドにあたる)をしているときに&lt;code&gt;v&lt;/code&gt;が最初に見つかるときである。&lt;strong&gt;後退辺(back edge)&lt;/strong&gt;とは、探索木上で頂点を先祖につなぐ辺である。したがって、辺&lt;code&gt;(u,v)&lt;/code&gt;では&lt;code&gt;v&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;の先祖である。輪は後退辺とみなされる。&lt;strong&gt;先行辺(forward edge)&lt;/strong&gt;は木辺ではない辺&lt;code&gt;(u,v)&lt;/code&gt;で、探索木上&lt;code&gt;u&lt;/code&gt;を子孫&lt;code&gt;v&lt;/code&gt;へとつなぐ。&lt;strong&gt;交差辺(cross edge)&lt;/strong&gt;とは、以上の３つのカテゴリに含まれない辺のことである。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#bfs-algorithm&#34; name=&#34;bfs-algorithm&#34;&gt;幅優先探索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;幅優先探索(Breadth-First Search, BFS)とは、グラフに対して横断的であり、特定の原点から到達可能な頂点をすべて探索する。また横断する順番については、頂点のすべての近傍を探索してから近傍の近傍の探索へと進む。幅優先探索について考えるには、例えば水溜りに石を落としたときに波が放射状に広がるように拡散すると思えばよい。同じ「波」の中の頂点は原点から同じ距離にある。頂点は最初にアルゴリズムによって遭遇するときに&lt;strong&gt;発見される(discovered)&lt;/strong&gt;と言う。頂点は、その近傍がすべて探索されたときに&lt;strong&gt;完了した(finished)&lt;/strong&gt;と言われる。これらをわかりやすくする例がある。グラフを図6に示し、そのBFSにおける発見と完了の順番をその下に示す。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/bfs_example.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図6: 広さ優先探索がグラフに広がる様子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順番: s r w v t x u y &lt;/li&gt;
&lt;li&gt;完了の順番: s r w v t x u y&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;s&lt;/code&gt;から開始して、最初は&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;(&lt;code&gt;s&lt;/code&gt;の近傍)にたどり着く。&lt;code&gt;s&lt;/code&gt;の両方の希望に到達してから、&lt;code&gt;r&lt;/code&gt;の近傍(頂点&lt;code&gt;v&lt;/code&gt;)に到達し、&lt;code&gt;w&lt;/code&gt;の近傍&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;に到達する (&lt;code&gt;r&lt;/code&gt;と&lt;code&gt;w&lt;/code&gt;の順序は意味を持たない)。最後に&lt;code&gt;t&lt;/code&gt;と&lt;code&gt;x&lt;/code&gt;の近傍、&lt;code&gt;u&lt;/code&gt;と&lt;code&gt;y&lt;/code&gt;に到達する。&lt;/p&gt;
&lt;p&gt;今グラフ上のどこにいるか、次にどこの頂点に行くかをアルゴリズムが把握するために、BFSは頂点に色を塗る。塗る色を置く場所は、グラフの中でもよいし、アルゴリズムに引数として渡すこともできる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#dfs-algorithm&#34; name=&#34;dfs-algorithm&#34;&gt;深さ優先探索&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;深さ優先探査(Depth-First Search, DFS) は、グラフ中の全頂点を探査する。このアルゴリズムでは、常にグラフ中の「深い」部分を、次に探査すべき辺として選択していく。これは、到達した頂点が未訪問の隣接頂点を持たなくなるまで次の未訪問な隣接頂点を選択していき、端に到達すれば前の頂点へと戻り、その頂点から任意の未探査な辺へと探査を継続していくことである。深さ優先探査は、出発する頂点から到達可能な全ての頂点を訪問した後に、残りの未訪問な頂点のうちから１頂点を選択して探査を継続していく。このプロセスは、深度優先の森からともに深度優先の木という集合を形成する。深さ優先探索は、グラフ中の辺を３つのカテゴリーに分類する：木辺、後退辺、先行辺か交差辺(どちらにも明確に分類しない)。与えられたグラフから多くの有効な深度優先の森が典型的に存在し、それゆえ辺を分類するには様々な(かつ等しく有効な)方法がある。&lt;/p&gt;
&lt;p&gt;深さ優先探査の興味深い特性は、各頂点の発見時と完了時の間において、括弧（入れ子）構造を形成するということである。頂点が発見される場合、私たちが開いた括弧を使用すれば、頂点が探査終了される場合には閉じた括弧が使用され、その結果、括弧により適切に入れ子にされた集合ができあがる。図7は、探査された順番にラベル付けされた辺による無向グラフに適応された DFS （深さ優先探査）である。図の下に、探査を開始した順序と探査を終了した順序を示し、それらから導かれる括弧構造を示す。DFS （深さ優先探査）は、２つが接続されたコンポーネント・アルゴリズム、トポロジカル・ソート、などを含む他のグラフ・アルゴリズムによって使用される核となるアルゴリズムである。これは循環を検知するために利用できる（ファイル依存関係の例における&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/file_dependency_example.html#cycles&#34;&gt;循環依存 （Cylic Dependencies）&lt;/a&gt; の節を見よ）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/dfs.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 7: 無向グラフにおける深度優先探査&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;発見の順序: a b e d c f g h i&lt;/li&gt;
&lt;li&gt;完了の順序: d f c e b a&lt;/li&gt;
&lt;li&gt;括弧構造: (a (b (e (d d) (c (f f) c) e) b) a) (g (h (i i) h) g)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#minimum-spanning-tree&#34; name=&#34;minimum-spanning-tree&#34;&gt;最小全域木問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最小全域木問題は、以下のように定義される：グラフ &lt;code&gt;E&lt;/code&gt; 中の全頂点を接続する循環のサブセット &lt;code&gt;T&lt;/code&gt; を接続の全コストが最小となるように選択することである。全コストは下記により与えられる。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(T) = T における辺 (u,v) におけるコスト w(u,v) の合計、 w(u,v) は辺 (u,v) のコスト
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T&lt;/code&gt; は&lt;strong&gt;全域木(spanning tree)&lt;/strong&gt;と呼ばれる.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#shortest-paths-algorithms&#34; name=&#34;shortest-paths-algorithms&#34;&gt;最短経路問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;グラフ理論における古典的問題のひとつは、グラフ中の２頂点間を結ぶ最短経路を見つけることである。形式的に経路はグラフ &lt;code&gt;G = (V, E)&lt;/code&gt; 中の頂点のシーケンス &lt;code&gt;&amp;lt;v0,v1,...,vk&amp;gt;&lt;/code&gt; で表される（辺 &lt;code&gt;(vi,vi+1) for i=0,1,...,k-1&lt;/code&gt; は 辺の集合 &lt;code&gt;E&lt;/code&gt; ）。シーケンスにおいて各頂点は次の頂点へ接続される。最短経路問題において、各辺は重みを数値として与えられている。それゆえ、&lt;strong&gt;経路の重み(weight of a path)&lt;/strong&gt;について記す&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;w(p) = i=1..k of w(vi-1,vi) の合計
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;頂点 &lt;code&gt;u&lt;/code&gt; から &lt;code&gt;v&lt;/code&gt; に至る&lt;strong&gt;最短経路の重み(shortest path weight)&lt;/strong&gt;は&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;delta (u,v) = min { w(p) : u --&amp;gt; v } もし 頂点 u から v に至る経路が存在すれば
delta (u,v) = 無限(infinity ) そうでなければ（ u から v に至る経路がなければ）
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;最短経路は、重みの合計が最小となる経路といえる。&lt;/p&gt;
&lt;p&gt;最短経路問題には、いくつかの変形された問題がある。ここでは単一ペアの問題を定義した、しかし、さらに単一出所問題(グラフ中の1つの頂点から各頂点ごとまでの最短のパス)があり、等価な単一目的地問題、全ペア問題、などである。単一出所の問題を解決するアルゴリズムより漸近的に速い、単一ペアの問題を解決するアルゴリズムは存在しない。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短経路木(shortest-paths tree)&lt;/strong&gt;は、グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; 中のある頂点を原点とした有向サブグラフである。&lt;code&gt;V&#39;&lt;/code&gt; を &lt;code&gt;V&lt;/code&gt; のサブセット、&lt;code&gt;E&#39;&lt;/code&gt; を &lt;code&gt;E&lt;/code&gt; のサブセットとし、 &lt;code&gt;V&#39;&lt;/code&gt; は&lt;code&gt;G&#39;&lt;/code&gt; から到達可能な頂点の集合、&lt;code&gt;G&#39;&lt;/code&gt; は原点から連なる経路木を成すものとすれば、&lt;code&gt;V&#39;&lt;/code&gt; 中の全ての頂点 &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;G&#39;&lt;/code&gt; 中の頂点 &lt;code&gt;v&lt;/code&gt; から唯一の経路を持つ。再帰的に、単一頂点アルゴリズムによる結果は最短経路木である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_theory_review.html#network-flow-algorithms&#34; name=&#34;network-flow-algorithms&#34;&gt;ネットワークフロー問題&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ネットワークの流れは&lt;strong&gt;送信(source)&lt;/strong&gt;頂点 &lt;code&gt;s&lt;/code&gt; から&lt;strong&gt;受信(sink)&lt;/strong&gt;頂点&lt;code&gt;t&lt;/code&gt;へと向かう有向グラフ &lt;code&gt;G=(V,E)&lt;/code&gt; である。各辺は数値による、&lt;strong&gt;容量(capacity)&lt;/strong&gt;関数 &lt;code&gt;c&lt;/code&gt; 、および、&lt;strong&gt;流れ(flow)&lt;/strong&gt;関数 &lt;code&gt;f&lt;/code&gt; を持つ。流れ関数は次の３条件を満たしていなければならない：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;f(u,v) &amp;lt;= c(u,v) for all (u,v) in V x V (容量制限) 
f(u,v) = - f(v,u) for all (u,v) in V x V (流れ対称性)
sumv in V f(u,v) = 0 for all u in V - {s,t} (流れ保存則)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;ネットワークにおける&lt;strong&gt;流れ(flow)&lt;/strong&gt;は、受信頂点 &lt;code&gt;t&lt;/code&gt; に流れ込む集合の流れである（それは、送信頂点 &lt;code&gt;s&lt;/code&gt; から流れ出るネットの流れに等価である）。&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;|f| = sumu in V f(u,t) = sumv in V f(s,v)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;辺における&lt;strong&gt;余剰容量(residual capacity)&lt;/strong&gt;を &lt;code&gt;r(u,v) = c(u,v) – f(u,v)&lt;/code&gt; とする。 &lt;code&gt;r(u,v) &amp;gt; 0&lt;/code&gt; を満たす辺は余剰辺 &lt;code&gt;E&lt;sub&gt;f&lt;/sub&gt;&lt;/code&gt; であり、それは余剰グラフ &lt;code&gt;G&lt;sub&gt;f&lt;/sub&gt; = (V, E&lt;sub&gt;f&lt;/sub&gt;)&lt;/code&gt; を成す。 &lt;code&gt;r(u,v) = 0&lt;/code&gt; を満たす辺は&lt;strong&gt;飽和(saturated)&lt;/strong&gt;している。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大流問題(maximum flow problem)&lt;/strong&gt;は、最大に可能な流量値 &lt;code&gt;|f|&lt;/code&gt; を決定することであり、そのときのグラフ中における各辺に対する流量値を決定することである。&lt;/p&gt;
&lt;p&gt;ネットワークの流れを 図 8 に示す。 &lt;code&gt;A&lt;/code&gt; は送信頂点で、&lt;code&gt;H&lt;/code&gt; は受信頂点。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.boost.org/doc/libs/1_31_0/libs/graph/doc/figs/max-flow.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;図 8: 最大流ネットワーク。各辺は（流れ/容量）のラベルで示している。&lt;/p&gt;
&lt;p&gt;最大流ネットワーク問題を解決するには長い歴史があり、最初のアルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#ford56:_maxim&#34;&gt;Ford と Fulkerson&lt;/a&gt;による。現在に至る最良のアルゴリズムである push-relabel アルゴリズムは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#goldberg85:_new_max_flow_algor&#34;&gt;Goldberg&lt;/a&gt; によるもので、これは &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/bibliography.html#karzanov74:_deter&#34;&gt;Karzanov&lt;/a&gt; による &lt;strong&gt;preflow&lt;/strong&gt; introduced という概念を元に成り立っている。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000-2001 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Indiana University (&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 KATO Kimikazu, &lt;a href=&#34;mailto:oki_miyuki@cppll.jp&#34;&gt;OKI Miyuki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mem_fn.hpp -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/mem_fn.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;mem_fn.hpp&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34;&gt;FAQ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34;&gt;インタフェース&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34;&gt;実装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34;&gt;ファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34; name=&#34;purpose&#34;&gt;目的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::mem_fn&lt;/code&gt; は、標準関数である&lt;code&gt;std::mem_fun&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt;の一般化である。&lt;code&gt;mem_fn&lt;/code&gt;は、2つ以上の引数をとる メンバ関数へのポインタをサポートし、また&lt;code&gt;mem_fn&lt;/code&gt;の戻す関数オブジェクトは第一引数に、 (訳注: そのメンバ関数の属するクラスのインスタンスを指すような) ポインタ、参照、スマートポインタをとることができる。 &lt;code&gt;mem_fn&lt;/code&gt;は、メンバ変数へのポインタも、引数をとらず自身への定数参照を 戻す関数とみなすことによってサポートする。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;の目的は2つある。一つ目は、コンテナにスマートポインタが格納されている場合であっても、 次のような&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;見慣れた文法によって、メンバ関数の呼び出しを可能にすることである。&lt;/p&gt;
&lt;p&gt;二つ目は、メンバ関数へのポインタを関数オブジェクトのように取り扱いたいライブラリ開発者に、 実装の道具として使用して貰うことである。例えば、あるライブラリは次のようにしてより便利な &lt;code&gt;for_each&lt;/code&gt;アルゴリズムを提供することができ、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;It&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; for_each(It first, It last, R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(first, last, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(pmf));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムは次のようにして手軽に利用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;for_each(v.begin(), v.end(), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムの機能を文書化する際には、単に次のように書けば良い：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;template&amp;lt;class It, class R, class T&amp;gt;&lt;/code&gt;
&lt;code&gt;void for_each(It first, It last, R (T::*pmf) ());&lt;/code&gt;
&lt;strong&gt;結果:&lt;/strong&gt; &lt;code&gt;std::for_each(first, last, boost::mem_fn(pmf));&lt;/code&gt; と同等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ここで、 &lt;code&gt;boost::mem_fn&lt;/code&gt; の部分はこのページへのリンクとするとよいだろう。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bindのドキュメント&lt;/a&gt; にそのような例があるので参照のこと。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; は1つの引数(メンバ関数へのポインタ)をとり、標準あるいは独自の アルゴリズムに渡すのに適した関数オブジェクトを戻す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X
{
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f();
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;h&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X &lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;k&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;戻される関数オブジェクトは、引数のメンバ関数ポインタと同じ引数をとることに加え、 インスタンスを表すための「柔軟な」第一引数をとる。&lt;/p&gt;
&lt;p&gt;関数オブジェクトが、適切なクラス(上の例では &lt;code&gt;X&lt;/code&gt;)を指すポインタでも参照でも ない第一引数&lt;code&gt;x&lt;/code&gt;をもって呼ばれた場合、関数オブジェクトは&lt;code&gt;get_pointer(x)&lt;/code&gt; を用いて&lt;code&gt;x&lt;/code&gt;からポインタを得ようとする。 スマートポインタの作者は、自分たちのスマートポインタ向けの適切な&lt;code&gt;get_pointer&lt;/code&gt;関数 を定義(overload)しておくことで、それを&lt;code&gt;mem_fn&lt;/code&gt;対応とすることができる。&lt;/p&gt;
&lt;p&gt;[注意: &lt;code&gt;get_pointer&lt;/code&gt; の戻り値はポインタでなくともよい。 &lt;code&gt;(x-&amp;gt;*pmf)(...)&lt;/code&gt;という形式でメンバ関数が呼び出せるなら、どんなオブジェクトでも問題ない。]&lt;/p&gt;
&lt;p&gt;[注意: ライブラリは、&lt;code&gt;get_pointer&lt;/code&gt; の非限定的 (訳注:名前空間を明示しない) 呼び出しを行なう。 そのため、引数依存検索の過程では、オーバーロードされた&lt;code&gt;boost::get_pointer&lt;/code&gt;関数群に加えて、 そのスマートポインタが定義された名前空間内の&lt;code&gt;get_pointer&lt;/code&gt;関数群も検索対象になる。]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;が戻す全ての関数オブジェクトは、&lt;code&gt;result_type&lt;/code&gt;なる&lt;code&gt;typedef&lt;/code&gt;を開示する。 この&lt;code&gt;typedef&lt;/code&gt;は、メンバ関数の戻り型を表す。メンバ変数を渡した場合には、&lt;code&gt;result_type&lt;/code&gt; はそのメンバ変数の型の定数参照として定義される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34; name=&#34;faq&#34;&gt;FAQ&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34; name=&#34;Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。単純な使い方では、&lt;code&gt;mem_fn&lt;/code&gt; は標準のアダプタが提供しないいくつかの機能を提供する。 &lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;Boost.Compose&lt;/a&gt; と標準のアダプタを組み合わせるような複雑な使い方をしている場合は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;&lt;code&gt;boost::bind&lt;/code&gt;&lt;/a&gt; を使用するように書き換えることで、&lt;code&gt;mem_fn&lt;/code&gt;の恩恵を自動的に受けることができる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34; name=&#34;Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いいえ。そうする強い理由がないならすべきではない。&lt;code&gt;mem_fn&lt;/code&gt; は、標準のアダプタに 非常に良く似ているが、100%の互換性があるわけではない。特に、&lt;code&gt;mem_fn&lt;/code&gt;は、標準の アダプタとは違って &lt;code&gt;std::[const_]mem_fun[1][_ref]_t&lt;/code&gt; 型のオブジェクトを戻さないので、 標準の &lt;code&gt;argument_type&lt;/code&gt; 及び &lt;code&gt;first_argument_type&lt;/code&gt; という (nested) &lt;code&gt;typedef&lt;/code&gt; を 用いて第一引数の型を記述することが (完全には) できない。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。&lt;code&gt;#define BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; とすれば可能である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;特定のベンダへの依存を避けるため、可搬性のない拡張は、一般にデフォルトでオフにされるべきである。 もし &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; がデフォルトで有効であったなら、あなたはそうとは気づかずに その拡張を使ってしまい、結果としてあなたのコードの可搬性が損なわれるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34; name=&#34;interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34; name=&#34;synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost
{

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ());

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt;&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-5&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-6&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 実際には、より多くの引数をとるような関数が、更にいくつかオーバーロードされている&lt;/span&gt;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34; name=&#34;requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Synopsis で述べられた全ての &lt;em&gt;unspecified-N&lt;/em&gt; 型は &lt;code&gt;CopyConstructible&lt;/code&gt; (コピーコンストラクト可能) かつ &lt;code&gt;Assignable&lt;/code&gt; (代入可能) であること。そのためのコピーコンストラクタ及び代入演算子 は例外を送出しないこと。 &lt;em&gt;unspecified-N&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;mem_fn&lt;/code&gt; に渡されたメンバ関数ポインタの戻り型、と定義されること (Synopsis での &lt;code&gt;R&lt;/code&gt;)。 &lt;em&gt;unspecified-2-1&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;R const &amp;amp;&lt;/code&gt; 、と定義されること。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34; name=&#34;get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34; name=&#34;mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt;あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2-1&lt;/span&gt;&lt;/i&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;t.*pm&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;get_pointer(t)-&amp;gt;*pm&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-5&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-6&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34; name=&#34;implementation&#34;&gt;実装&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34; name=&#34;files&#34;&gt;ファイル&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;boost/mem_fn.hpp (メインヘッダ)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_cc.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_vw.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_template.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_test.cpp (テスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_derived_test.cpp (派生オブジェクトでのテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_fastcall_test.cpp (&lt;code&gt;__fastcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_stdcall_test.cpp (&lt;code&gt;__stdcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_void_test.cpp (戻りが&lt;code&gt;void&lt;/code&gt;であるケースのテスト)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34; name=&#34;dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Config&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34; name=&#34;number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;この実装では、8つまでの引数をとるメンバ関数がサポートされている。これは、設計に固有の 制限という訳ではなく、実装の詳細である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34; name=&#34;stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いくつかのプラットフォームでは、 &lt;strong&gt;呼び出し規則&lt;/strong&gt; (どのように関数が起動されるかの規則: 引数はどのように渡されるのか、戻り値はどのように扱われるのか、もしスタックを使用したなら、 誰がそれを奇麗にするのか) の異なるような何種類かのメンバ関数を作成できる。&lt;/p&gt;
&lt;p&gt;例えば、Windows API の関数と、COMインタフェースのメンバ関数は、 &lt;code&gt;__stdcall&lt;/code&gt; という呼び出し規則を用いるし、 Borland の VCL コンポーネントは &lt;code&gt;__fastcall&lt;/code&gt; を用いる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__stdcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__fastcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_FASTCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;[注意: これは可搬性のない拡張であり、インタフェースの一部ではない。]&lt;/p&gt;
&lt;p&gt;[注意: いくつかのコンパイラは、 &lt;code&gt;__stdcall&lt;/code&gt; キーワードに対して最小限のサポートしか提供していない。]&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get_pointer&lt;/code&gt;ベースの設計は、Rene Jageによる、特性クラスを用いて &lt;code&gt;mem_fn&lt;/code&gt;を ユーザ定義のスマートポインタに適合させるという提案に影響されたものである。&lt;/p&gt;
&lt;p&gt;フォーマルレビューの期間に、Richard Crossley、 Jens Maurer、 Ed Brey、その他の方々の示唆によって、たくさんの 改良があった。レビューマネージャは Darin Adler であった。&lt;/p&gt;
&lt;p&gt;Steve Anichini は、COMインタフェースが &lt;code&gt;__stdcall&lt;/code&gt; を使用していることを指摘した。&lt;/p&gt;
&lt;p&gt;Dave Abrahams は、不完全なコンパイラにおいても &#34;戻り値なし&#34; をサポートすべく、&lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;mem_fn&lt;/code&gt; を改良した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2001, 2002 by Peter Dimov and Multi Media Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 SATO Yusuke &lt;a href=&#34;mailto:y-sato@y-sa.to&#34;&gt;y-sato@y-sa.to&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Assignable -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/utility/Assignable.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Assignable&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;説明&lt;/h2&gt;
&lt;p&gt;その型のオブジェクトから、その型の他のオブジェクトに代入が可能である場合、その型はAssignableである。&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;はAssignableモデルの型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト、もしくは可能であれば&lt;code&gt;const T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義&lt;/h2&gt;
&lt;h2&gt;妥当な式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値の型&lt;/th&gt;
&lt;th&gt;意味論&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;代入&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t = u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;u&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html&#34;&gt;CopyConstructible&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.lsc.nd.edu/~jsiek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Copy Constructible -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/CopyConstructible.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/utility/CopyConstructible.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Copy Constructible&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/utility/CopyConstructible.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;説明&lt;/h2&gt;
&lt;p&gt;オブジェクトのコピーが可能である場合、その型はCopy Constructibleである。&lt;/p&gt;
&lt;h2&gt;表記&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;はCopy Constructibleモデルの型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;const T&lt;/code&gt;型のオブジェクト&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定義&lt;/h2&gt;
&lt;h2&gt;妥当な式&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名前&lt;/th&gt;
&lt;th&gt;式&lt;/th&gt;
&lt;th&gt;戻り値の型&lt;/th&gt;
&lt;th&gt;意味論&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T(t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;は&lt;code&gt;T(t)&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;コピーコンストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T(u)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;は&lt;code&gt;T(u)&lt;/code&gt;と同等である&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;デストラクタ&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t.~T()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;アドレス演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;のアドレスを意味する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;アドレス演算子&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;のアドレスを意味する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;モデル&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;コンセプトチェックするクラス&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; CopyConstructibleConcept
{
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; constraints() {
    T a(b);            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require copy constructor&lt;/span&gt;
    T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ptr &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;a;       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require address of operator&lt;/span&gt;
    const_constraints(a);
    ignore_unused_variable_warning(ptr);
  }
  &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; const_constraints(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; a) {
    T c(a);            &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require const copy constructor&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ptr &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;a; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// require const address of operator&lt;/span&gt;
    ignore_unused_variable_warning(c);
    ignore_unused_variable_warning(ptr);
  }
  T b;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;関連項目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/DefaultConstructible.html&#34; target=&#34;_blank&#34;&gt;Default Constructible&lt;/a&gt; and &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/utility/Assignable.html&#34;&gt;Assignable&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.lsc.nd.edu/~jsiek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>MultiPassInputIterator -- &lt;hoge@piyo&gt;記法で書かれたメールアドレスに、mailto:を追加</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/utility/MultiPassInputIterator.html"/>
      <id>fa32124a0cd97456980f9864012fb7e3d06f03b8:archive/boost_docs/libs/utility/MultiPassInputIterator.md</id>
      <updated>2015-01-19 20:14:42 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;MultiPassInputIterator&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント : &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/utility/MultiPassInputIterator.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/utility/MultiPassInputIterator.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このコンセプトは&lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;Input Iterator&lt;/a&gt;を精製し、範囲を複数のパスで通るようイテレータを使用してもよいという要件を追加しており、&lt;code&gt;it1 == it2&lt;/code&gt;かつ&lt;code&gt;++it1 == ++it2&lt;/code&gt;のとき、&lt;code&gt;it1&lt;/code&gt;は間接参照可能である。このMulti-Pass Input Iteratorは、&lt;a href=&#34;http://www.sgi.com/tech/stl/ForwardIterator.hmtl&#34; target=&#34;_blank&#34;&gt;Forward Iterator&lt;/a&gt;によく似ている。唯一の違いは、&lt;a href=&#34;http://www.sgi.com/tech/stl/ForwardIterator.hmtl&#34; target=&#34;_blank&#34;&gt;Forward Iterator&lt;/a&gt;の&lt;code&gt;reference&lt;/code&gt;型が&lt;code&gt;value_type&amp;amp;&lt;/code&gt;であることを要求するのに対し、MultiPassInputIteratorは&lt;a href=&#34;http://www.sgi.com/tech/stl/InputIterator.html&#34; target=&#34;_blank&#34;&gt;Input Iterator&lt;/a&gt;のように&lt;code&gt;reference&lt;/code&gt;が&lt;code&gt;value_type&lt;/code&gt;に変換できるということである。&lt;/p&gt;
&lt;h2&gt;設計ノート&lt;/h2&gt;
&lt;p&gt;Valentin Bonnardからのコメント：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;私は、Multi-Pass Input Iteratorの導入は、正しい解決ではないと考える。これと同様に、Multi-Pass Bidirectional IteratorやMulti-Pass Random Access Iteratorを定義したいと思うだろうか？私は思わない、確実に。これは問題を混乱させるだけだ。この問題は、既存のイテレータ階層に含まれている移動性(movavility)と変更性(modifiability)と左辺値らしさを混ぜ合わせたものであり、これらは明確に独立している。

Forward、Bidirectional、Random Accessは移動性に関しての用語であり、それ以外の意味に使用すべきではない。イテレータが不変(immutable)か変更可能(mutable)かは、完全に直交する。左辺値のイテレータもまた、不変性(immutability)は直交する。これらのクリーンなコンセプトでは、Multi-Pass Input Iteratorは素直にForward Iteratorと呼べる。

他の変換は以下のようになる：

std::Forward Iterator -&amp;gt; ForwardIterator &amp;amp; Lvalue Iterator

std::Bidirectionnal Iterator -&amp;gt; Bidirectionnal Iterator &amp;amp; Lvalue Iterator

std::Random Access Iterator -&amp;gt; Random Access Iterator &amp;amp; Lvalue Iterator

私のForward Iteratorで許可しておらず、std::Forward Iteratorでは許可されている唯一の操作は「&amp;amp;*it」である。私は、「&amp;amp;*」はジェネリックコードではほとんど必要ないと考える。
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Jeremy Siekからの返信：&lt;/p&gt;
&lt;p&gt;Valentinの分析は正しい。もちろん、ここには後方互換性の問題がある。現在のSTLの実装は、古いForward Iteratorの定義に基いている。これに対するアクションの正しい道筋は、標準C++のForward Iteratorやその他の定義を変更することである。そうすれば、我々はMulti-Pass Input Iteratorをなくすことができる。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Japanese Translation Copyright © 2014 &lt;a href=&#34;mailto:faithandbrave@gmail.com&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>