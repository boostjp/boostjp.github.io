<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-01-18T23:01:32.383170</updated>
  <id>0417a2ef-a79f-4d52-9fe0-d43e553f6c23</id>

  
    <entry>
      <title>Other Classses -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/document/boostserialization/other-classses.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:document/boostserialization/other-classses.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Other Classses&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/boostserialization/other-classses/extended_type_info.html&#34;&gt;&lt;code&gt;extended_type_info&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/boostserialization/other-classses/void_cast.html&#34;&gt;&lt;code&gt;void_cast&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utf8_codecvt_facet&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_STRONG_TYPEDEF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state_saver&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dataflow Iterators&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smart_cast&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_STATIC_WARNING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/boostserialization/other-classses/singleton.html&#34;&gt;&lt;code&gt;singleton&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Export Key -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/document/boostserialization/reference/serializableconcept/class-serialization-traits/export-key.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:document/boostserialization/reference/serializableconcept/class-serialization-traits/export-key.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Export Key&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;仮想基底クラスのポインタを経由して派生クラスをシリアライズするとき、問題が2つ発生します。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;派生クラスのコードは、明示的に参照されないかもしれません。そのようなコードは、インスタンス化できません。この問題には、クラスTを定義(実装)するファイルで、&lt;code&gt;BOOST_CLASS_EXPORT_IMPLEMENT(T)&lt;/code&gt;を実行することで対処します。これにより、派生クラス&lt;code&gt;T&lt;/code&gt;のためのコードが明示的にインスタンス化されることが確実になります。&lt;/li&gt;
&lt;li&gt;オブジェクトがロードされるとき実行されるコードを選択するのに用いることができるある種の識別子である必要が あります。標準C++は、クラスのためのユニークな文字列を返す&lt;code&gt;typeid()&lt;/code&gt;を実装します。これは、以下の理由により、目的を完全に満たすとはいえません。    - 文字列がプラットフォームをまたいで同じであるという保証がありません。これでは、ポータブルなアーカイブをサポートできません。&lt;ul&gt;
&lt;li&gt;いろんなソースコードから、(当該クラスの定義された)コードモジュールを利用する際に、クラスはそれぞれ異なる名前空間で包まないといけないかもしれません。&lt;/li&gt;
&lt;li&gt;同じ名前を持っているが内容は異なるクラスが、利用する側のコードでローカルに定義されているかもしれません。&lt;/li&gt;
&lt;li&gt;シリアライズのためにライブラリが同じと考えるべき、異なる名前があるかもしれません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;よってserializationライブラリでは、そのクラスが宣言されるヘッダファイルで&lt;code&gt;BOOST_CLASS_EXPORT_KEY2(my_class, &#34;my_class_external_identifier&#34;)&lt;/code&gt;を記述することで対処します。多くのアプリケーションで、&lt;code&gt;BOOST_CLASS_EXPORT_KEY(my_class)&lt;/code&gt;として定義されるショートカットが利用できます。これは、クラス名を外部識別し文字列として使うのに最適です。
1つだけのモジュールからなるプログラム、すなわちDLLを利用しないプログラムは、&lt;code&gt;BOOST_CLASS_EXPORT(my_class)&lt;/code&gt;または、&lt;code&gt;BOOST_CLASS_EXPORT_GUID(my_class, &#34;my_class_external_identifier&#34;)&lt;/code&gt;を宣言ヘッダまたは定義で指定できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記2つのマクロは、実装に展開されます。(GUIDはグローバルユニーク識別子のことを示します）&lt;/p&gt;
&lt;p&gt;(このマニュアルの別の場所(&lt;a href=&#34;http://boostjp.github.io/document/boostserialization/reference/special-considerations/exporting-class-serialization.html&#34;&gt;ExportingClassSerialization&lt;/a&gt;)で、派生クラスのシリアライズについて詳細に説明します。)&lt;/p&gt;
&lt;p&gt;ライブラリは以下の場合に例外を投げます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exportされていない明示的に参照されないタイプの場合&lt;/li&gt;
&lt;li&gt;複数のモジュールまたはDLLでシリアライズのための同じタイプがインスタンス化された場合&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.46.0 リリースノート -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/document/version/1_46_0.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:document/version/1_46_0.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost 1.46.0 リリースノート&lt;/h1&gt;
&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/news/version_1_46_0&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/news/version_1_46_0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interval Container Library。interval setとmap、および interval に関連づけられた値の集約。作者：Joachim Faulhaber。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#array&#34;&gt;Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#asio&#34;&gt;Asio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#bind&#34;&gt;Bind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#concept-check&#34;&gt;Concept Check&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#filesystem&#34;&gt;Filesystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#fusion&#34;&gt;Fusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#hash&#34;&gt;Hash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#iterator&#34;&gt;Iterator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#math&#34;&gt;Math&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#optional&#34;&gt;Optional&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#pool&#34;&gt;Pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#program-options&#34;&gt;Program Options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#proto&#34;&gt;Proto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#signals&#34;&gt;Signals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#spirit&#34;&gt;Spirit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#tokenizer&#34;&gt;Tokenizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#unordered&#34;&gt;Unordered&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#wave&#34;&gt;Wave&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ツール&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#boostbook&#34;&gt;Boostbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#inspect&#34;&gt;Inspect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#array&#34; name=&#34;array&#34;&gt;Array&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cbegin&lt;/code&gt;/&lt;code&gt;cend&lt;/code&gt;のサポートを追加(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4761&#34; target=&#34;_blank&#34;&gt;#4761&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Sunコンパイラでの問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4757&#34; target=&#34;_blank&#34;&gt;#4757&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#asio&#34; name=&#34;asio&#34;&gt;Asio&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ip::address_v4::broadcast()&lt;/code&gt; を64ビット環境で使用する場合に生じる整数オーバーフローの問題を修正。&lt;/li&gt;
&lt;li&gt;プログラムがしばらく動作したあとに、 &lt;code&gt;deadline_timer&lt;/code&gt; ハンドラーの期限内の呼び出しを阻む、古い Linux カーネル上の問題を修正( &lt;code&gt;timerfd&lt;/code&gt; サポートなしで &lt;code&gt;epoll&lt;/code&gt; が使われるところ) (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5045&#34; target=&#34;_blank&#34;&gt;#5045&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#bind&#34; name=&#34;bind&#34;&gt;Bind&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make_adaptable&lt;/code&gt;のドキュメントを記載(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4532&#34; target=&#34;_blank&#34;&gt;#4532&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#concept-check&#34; name=&#34;concept-check&#34;&gt;Concept Check&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自己代入による警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4918&#34; target=&#34;_blank&#34;&gt;#4918&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#filesystem&#34; name=&#34;filesystem&#34;&gt;Filesystem&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;デフォルトのライブラリバージョンをv3にした。&lt;/li&gt;
&lt;li&gt;IBM vacpp: コンパイラのバグによる&lt;code&gt;iterator_facade&lt;/code&gt;のworkaroundに対応(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4912&#34; target=&#34;_blank&#34;&gt;#4912&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;検証し、ドキュメント化された &lt;code&gt;&amp;lt;boost/config/user.hpp&amp;gt;&lt;/code&gt; は、&lt;code&gt;BOOST_FILESYSTEM_VERSION&lt;/code&gt; の規定のために使用される(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4891&#34; target=&#34;_blank&#34;&gt;#4891&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Cスタイルの &lt;code&gt;assert&lt;/code&gt; を &lt;code&gt;BOOST_ASSERT&lt;/code&gt; で置き換えた。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_path()&lt;/code&gt; の非推奨を取りやめた。代わりに、スレッド安全性と cwd のための代替手段を注記するようにした。 &lt;code&gt;unique_path()&lt;/code&gt; は非推奨にするにはあまりに便利すぎる！&lt;/li&gt;
&lt;li&gt;GCC のいくつかの警告を解消。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_THROW_EXCEPTION&lt;/code&gt; を使用するよう、 v2 コードを修正。&lt;/li&gt;
&lt;li&gt;Windows: 非symlink reparseポイントを正確に報告するよう &lt;code&gt;status()&lt;/code&gt; を修正。&lt;/li&gt;
&lt;li&gt;directory symlink に再帰の制御を許可するために、 &lt;code&gt;recursive_directory_iterator&lt;/code&gt; に &lt;code&gt;symlink_option&lt;/code&gt; を追加。&lt;ul&gt;
&lt;li&gt;※注： directory symlink はデフォルトでは再帰できない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;リファレンスドキュメントをクリーンナップした：リンク切れ、インクルード漏れ、記載されていない関数の追加。&lt;/li&gt;
&lt;li&gt;雑なコードをクリーンナップ。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#fusion&#34; name=&#34;fusion&#34;&gt;Fusion&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt; のコピーコンストラクタを、異なる環境でも同じ順序でシーケンスメンバをコピーするよう修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2823&#34; target=&#34;_blank&#34;&gt;#2823&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#graph&#34; name=&#34;graph&#34;&gt;Graph&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++ 7.1 で Graphviz 出力が動作するよう修正。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assert&lt;/code&gt; を &lt;code&gt;BOOST_ASSERT&lt;/code&gt; に置き換え。&lt;/li&gt;
&lt;li&gt;使用する Boost.Filesystem のバージョンを v3 に変更。&lt;/li&gt;
&lt;li&gt;(&lt;code&gt;graph_traits&lt;/code&gt; 等を用いて) アダプトされたユーザー定義グラフを、&lt;code&gt;reverse_graph&lt;/code&gt; アダプタとともに使用する際の問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1021&#34; target=&#34;_blank&#34;&gt;#1021&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GraphML を使用する場合はビルドが必要であることをドキュメントに記載(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4556&#34; target=&#34;_blank&#34;&gt;#4556&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r_c_shortest_path&lt;/code&gt; のオーバーロードのうち一本の経路を要求するバージョンについて経路が見つからなかった場合にクラッシュする問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4631&#34; target=&#34;_blank&#34;&gt;#4631&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;BGL ヘッダファイルと &lt;code&gt;boost/range/irange.hpp&lt;/code&gt; で名前衝突が発生する問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4642&#34; target=&#34;_blank&#34;&gt;#4642&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;カスタム &lt;code&gt;property_map&lt;/code&gt; が &lt;code&gt;astar_search&lt;/code&gt; で動作しない問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4715&#34; target=&#34;_blank&#34;&gt;#4715&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dijkstra_shortest_path&lt;/code&gt; （ダイクストラ法）のドキュメント中で、最小スパニングツリーでないものを最小スパニングツリーとして記述していた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4731&#34; target=&#34;_blank&#34;&gt;#4731&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prim_minimum_spanning_tree&lt;/code&gt; （プリムの最小全域木）のドキュメント中で &lt;code&gt;distance_map&lt;/code&gt; に関する記述が間違っていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4737&#34; target=&#34;_blank&#34;&gt;#4737&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subgraph.hpp&lt;/code&gt; の &lt;code&gt;remove_edge_if&lt;/code&gt; と &lt;code&gt;clear_vertex&lt;/code&gt; が(遅いが正しいコードなのに) &#34;wrong&#34; とコメントで記述されていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4753&#34; target=&#34;_blank&#34;&gt;#4753&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;generate_random_graph&lt;/code&gt; の結果が指定通りの辺数にならない場合がある問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4758&#34; target=&#34;_blank&#34;&gt;#4758&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy_component&lt;/code&gt; が正しく動作しない場合がある問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4793&#34; target=&#34;_blank&#34;&gt;#4793&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GraphML の parser が &lt;code&gt;edge&lt;/code&gt; の省略可能なプロパティ &lt;code&gt;id&lt;/code&gt; を必須としていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4843&#34; target=&#34;_blank&#34;&gt;#4843&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;ドキュメントのスペルミスを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4851&#34; target=&#34;_blank&#34;&gt;#4851&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Dijkstra アルゴリズムの計算量の記述が誤っていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4852&#34; target=&#34;_blank&#34;&gt;#4852&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clustering_coefficient&lt;/code&gt; が &lt;code&gt;graph_traits&lt;/code&gt; を使っていなかった問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4887&#34; target=&#34;_blank&#34;&gt;#4887&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filtered_graph&lt;/code&gt; でグラフに対するプロパティの扱いが抜けていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4914&#34; target=&#34;_blank&#34;&gt;#4914&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;部分グラフに対してループ辺を追加した場合に二重に追加される問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4966&#34; target=&#34;_blank&#34;&gt;#4966&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Trac 上に無い種々の問題の修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#hash&#34; name=&#34;hash&#34;&gt;Hash&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::type_index&lt;/code&gt;をサポート&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wconversion&lt;/code&gt;警告を回避&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#iterator&#34; name=&#34;iterator&#34;&gt;Iterator&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;implicit_cast&lt;/code&gt; での問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3645&#34; target=&#34;_blank&#34;&gt;#3645&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function_input_iterator&lt;/code&gt; を追加(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2893&#34; target=&#34;_blank&#34;&gt;#2893&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transform_iterator&lt;/code&gt; は &lt;code&gt;function_object_result&lt;/code&gt; という独自の result type を使うのではなくて &lt;code&gt;boost::result_of&lt;/code&gt; を使うように修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1427&#34; target=&#34;_blank&#34;&gt;#1427&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#math&#34; name=&#34;math&#34;&gt;Math&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Wald分布(Wald distribution)、 逆ガウス分布(Inverse Gaussian distribution)、幾何分布(geometric distributions)を追加。&lt;/li&gt;
&lt;li&gt;configurationマクロの情報を追加。&lt;/li&gt;
&lt;li&gt;real-numered 型のために &lt;code&gt;mpreal&lt;/code&gt; のサポートを追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#msm&#34; name=&#34;msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Back-end チュートリアルに、&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/msm/doc/HTML/ch03s05.html#backend-compile-time-analysis&#34; target=&#34;_blank&#34;&gt;コンパイル時状態マシン解析(Compile-time state machine analysis)&lt;/a&gt;の節を追加。&lt;/li&gt;
&lt;li&gt;Back-end チュートリアルに、 &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/msm/doc/HTML/ch03s05.html#backend-boost-parameter&#34; target=&#34;_blank&#34;&gt;Boost.Parameter によるポリシー定義(Policy definition with Boost.Parameter)&lt;/a&gt;の節を追加。&lt;/li&gt;
&lt;li&gt;Back-end チュートリアルに、&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/msm/doc/HTML/ch03s05.html#backend-queues&#34; target=&#34;_blank&#34;&gt;メッセージキューのカスタマイズ(Customizing the message queues)&lt;/a&gt;の節を追加。
イベント、もしくは遅延されたイベントのキューのコンテナを提供することが可能になった。 Boost.CircularBuffer による効率的な実装。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;msm::back::state_machine&amp;lt;&amp;gt;::is_flag_active&lt;/code&gt; メソッドの &lt;code&gt;const&lt;/code&gt; 版を用意した。&lt;/li&gt;
&lt;li&gt;Back-end チュートリアルに、&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/msm/doc/HTML/ch03s05.html#backend-enqueueing&#34; target=&#34;_blank&#34;&gt;遅延処理のためのイベントキューイング(Enqueueing events for later processing)&lt;/a&gt;の節を追加。&lt;/li&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;deferred eventsがVC++8.0で動かなかった問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4926&#34; target=&#34;_blank&#34;&gt;#4926&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Defer functorでスタックオーバーフローしていた問題を修正。&lt;/li&gt;
&lt;li&gt;initial stateで、匿名サブマシンの遷移が動作していなかった問題を修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#optional&#34; name=&#34;optional&#34;&gt;Optional&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;コンパイラのバグでテストが失敗する可能性があるということをテスト結果に記述(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2294&#34; target=&#34;_blank&#34;&gt;#2294&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#pool&#34; name=&#34;pool&#34;&gt;Pool&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;poolに&lt;code&gt;max_size&lt;/code&gt;をセット可能になった(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2696&#34; target=&#34;_blank&#34;&gt;#2696&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/pool/pool.hpp&lt;/code&gt; &lt;code&gt;static_cast&lt;/code&gt;のかわりに&lt;code&gt;reinterpret_cast&lt;/code&gt;が使われている問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2941&#34; target=&#34;_blank&#34;&gt;#2941&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::pool_allocator&lt;/code&gt; &lt;code&gt;vector&lt;/code&gt;の&lt;code&gt;vector&lt;/code&gt;でも動作するように修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/386&#34; target=&#34;_blank&#34;&gt;#386&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Microsoftのメモリリーク検出機能との互換性を確立した(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4346&#34; target=&#34;_blank&#34;&gt;#4346&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#program-options&#34; name=&#34;program-options&#34;&gt;Program Options&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ドキュメントのサンプルのエラーを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3992&#34; target=&#34;_blank&#34;&gt;#3992&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4858&#34; target=&#34;_blank&#34;&gt;#4858&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argv&lt;/code&gt; に &lt;code&gt;const&lt;/code&gt; を付けるように修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3909&#34; target=&#34;_blank&#34;&gt;#3909&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#proto&#34; name=&#34;proto&#34;&gt;Proto&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;※破壊的変更： &lt;code&gt;&amp;lt;boost/proto/core.hpp&amp;gt;&lt;/code&gt; で定義されていた &lt;code&gt;functional::pop_front&lt;/code&gt; と &lt;code&gt;functional::reverse&lt;/code&gt; を &lt;code&gt;&amp;lt;boost/proto/functional&amp;gt;&lt;/code&gt; に移動。&lt;/li&gt;
&lt;li&gt;多くのFusionアルゴリズムのラッパー(&lt;code&gt;fusion::at&lt;/code&gt;等)と、標準ユーティリティライクな &lt;code&gt;make_pair&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt; を 新たな `&amp;lt;boost/proto/functional&amp;gt;&amp;gt; ディレクトリに追加。&lt;/li&gt;
&lt;li&gt;文法から個別に変換を指定するのを許可。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proto::matches&lt;/code&gt; は、ドメイン固有式(domain-specific expression)を保存するラッパー。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proto::and_&lt;/code&gt; 内での &lt;code&gt;operator,&lt;/code&gt; の ADL 問題を修正。&lt;/li&gt;
&lt;li&gt;複数ドメインの式における文法チェックのハンドリングを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4675&#34; target=&#34;_blank&#34;&gt;#4675&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proto::display_expr&lt;/code&gt; で &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; が曖昧になっていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4910&#34; target=&#34;_blank&#34;&gt;#4910&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Proto expression で &lt;code&gt;fusion::is_sequence&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返すよう修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5006&#34; target=&#34;_blank&#34;&gt;#5006&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GCC で &lt;code&gt;-Wundef&lt;/code&gt; オプションを使用したときに &lt;code&gt;&amp;lt;boost/proto/fusion.hpp&amp;gt;&lt;/code&gt; で警告が出ていたのを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5075&#34; target=&#34;_blank&#34;&gt;#5075&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#signals&#34; name=&#34;signals&#34;&gt;Signals&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;gcc で警告が出ないようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4365&#34; target=&#34;_blank&#34;&gt;#4365&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#spirit&#34; name=&#34;spirit&#34;&gt;Spirit&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Spirit V2.4.2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spirit.Qi および Spirit.Karma のドキュメントに、キーワードインデックスを追加。&lt;/li&gt;
&lt;li&gt;コンテナに対して属性値を追加する場合に呼ばれる新たなカスタマイゼーションポイントとして &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/advanced/customize/assign_to/assign_to_container_from_value.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;traits::assign_to_container_from_value&lt;/code&gt;&lt;/a&gt; を追加。&lt;/li&gt;
&lt;li&gt;「&lt;code&gt;lit(foo)&lt;/code&gt;」か「&lt;code&gt;foo&lt;/code&gt;」かを区別することを可能にするために、 &lt;code&gt;sprit::lit&lt;/code&gt; を実装するために使われていた &lt;code&gt;proto::lit&lt;/code&gt; を独立したバージョンに置き換えた。この変更によってセマンティクスは全く変更されないはずであり、既存コードも破壊されないはずである。&lt;/li&gt;
&lt;li&gt;コンテナ属性型として代入可能にするために、 Spirit.Qi に &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/qi/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as&amp;lt;T&amp;gt;[]&lt;/code&gt;&lt;/a&gt; ディレクティブを追加(また、 &lt;code&gt;string&lt;/code&gt; の特殊化バージョンである &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/qi/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as_string&lt;/code&gt;&lt;/a&gt; および &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/qi/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as_wstring&lt;/code&gt;&lt;/a&gt; を追加)。&lt;/li&gt;
&lt;li&gt;出力生成中にコンテナ属性型として処理可能にするために、 Spirit.Karma に &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as&amp;lt;T&amp;gt;[]&lt;/code&gt;&lt;/a&gt; ディレクティブを追加(また、 &lt;code&gt;string&lt;/code&gt; の特殊化バージョンである &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as_string&lt;/code&gt;&lt;/a&gt; および &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/directive/as.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;as_wstring&lt;/code&gt;&lt;/a&gt; を追加)。&lt;/li&gt;
&lt;li&gt;Spirit.Qi において、 &lt;code&gt;lit()&lt;/code&gt; を数値に対しても使用できるようにした。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/qi/reference/string/symbols.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;symbols&amp;lt;Ch, T&amp;gt;&lt;/code&gt;&lt;/a&gt; パーサーで、明示的な名前をエラーハンドリングとデバッギングに使用できるようにした。これは新メンバ関数 &lt;code&gt;sym.name(...)&lt;/code&gt; を使用することで設定できる。パッチを送ってくれた teajay に感謝する。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/string/symbols.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;symbols&amp;lt;Attrib, T&amp;gt;&lt;/code&gt;&lt;/a&gt; ジェネレータで、明示的な名前をエラーハンドリングとデバッギングに使用できるようにした。これは新メンバ関数 &lt;code&gt;sym.name(...)&lt;/code&gt; を使用することで設定できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Qi もしくは Karma のバグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spirit.Qi シーケンスでコンテナ属性を扱う際の問題を解決した。先頭要素に対して適切に解析された属性がシーケンスの後ろの方の値によって上書きされてしまっていた。&lt;/li&gt;
&lt;li&gt;Spirit.Karma の &lt;a href=&#34;http://www.boost.org/doc/libs/1_46_0/libs/spirit/doc/html/spirit/karma/reference/string.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;string(s)&lt;/code&gt;&lt;/a&gt; ジェネレータを修正。 &lt;code&gt;s&lt;/code&gt; が属性のプレフィックスだけとマッチした場合でも成功していた。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Spirit.Lex の変更内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;qi::tokenid()&lt;/code&gt; プリミティブパーサーで、与えられた token id に基づいた任意の lexer token とマッチすることを可能にした。&lt;/li&gt;
&lt;li&gt;デフォルト &lt;code&gt;lexertl::token&amp;lt;&amp;gt;&lt;/code&gt; 定義のためのテンプレートパラメータを追加： token id の型。この型はデフォルトで &lt;code&gt;std::size_t&lt;/code&gt; となる。 id 型として使用されるあらゆる型は、(明示的に) &lt;code&gt;std::size_t&lt;/code&gt; に変換可能でなければならない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lex::char_()&lt;/code&gt; および &lt;code&gt;lex::string()&lt;/code&gt; に基づいたトークン定義に、 &lt;code&gt;lexer&lt;/code&gt; のセマンティックアクションを付加できるようにした。&lt;/li&gt;
&lt;li&gt;あるトークンとマッチした後、 &lt;code&gt;lexer&lt;/code&gt; が自動的に切り替わるように &lt;code&gt;lexer&lt;/code&gt; 状態を指定することを可能にした。この理由のために、トークン定義構文を拡張した：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; lexer &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; lex&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
{
    lexer()
    {
        int_ &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;[1-9][0-9]*&#34;&lt;/span&gt;;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt;self(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;INITIAL&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;TARGETSTATE&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; int_;
     }
     lex&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;token_def&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; int_;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;この例の &lt;code&gt;lexer&lt;/code&gt; は &lt;code&gt;int_&lt;/code&gt; にマッチし、 &#34;TARGETSTATE&#34; 状態に切り替わる。第2引数が指定されない場合は、(これまで通り)前の状態のままである。&lt;/li&gt;
&lt;li&gt;パーサープリミティブ &lt;code&gt;qi::tokens&lt;/code&gt; および &lt;code&gt;qi::tokenid&lt;/code&gt; を引数なしで使用できるようにした。その場合、あらゆるトークンにマッチする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lex::lit()&lt;/code&gt; を削除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Spirit.Lexのバグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;すべての &lt;code&gt;lexer&lt;/code&gt; 状態にただちにトークンを割り当てるために、 &lt;code&gt;Lexer&lt;/code&gt; を与える問題を解決した。これは現在、状態の名前として &lt;code&gt;&#34;*&#34;&lt;/code&gt; を使用することで可能となる。たとえば、以下は全ての &lt;code&gt;lexer&lt;/code&gt; 状態にトークン &lt;code&gt;int_&lt;/code&gt; を加えるだろう：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; lexer &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; lex&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Lexer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
{
      lexer()
      {
          int_ &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;[1-9][0-9]*&#34;&lt;/span&gt;;
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt;self(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;*&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; int_;
      }
      lex&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;token_def&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; int_;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;注：すべての &lt;code&gt;lexer&lt;/code&gt; 状態が &lt;code&gt;lexer&lt;/code&gt; オブジェクトに導入されたあと、 &lt;code&gt;self(&#34;*&#34;) = ...&lt;/code&gt; が実行されなければならない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lexer&lt;/code&gt; 先読みを修正。先読み操作は現在、その引数として使用される &lt;code&gt;token_def&lt;/code&gt; インスタンスが使用した &lt;code&gt;lexer&lt;/code&gt; 状態を使用して評価される。&lt;/li&gt;
&lt;li&gt;multi_pass iterator の中で間違ったトークンがユーザーに返される問題を解決した。これは &lt;code&gt;lexer&lt;/code&gt; 状態変更を実行し、トークンマッチを失敗させるためにセマンティックアクションの中で &lt;code&gt;pass_fail&lt;/code&gt; を使用していた &lt;code&gt;lexer&lt;/code&gt; とともの起こるかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;既知の問題&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数リテラル(&lt;code&gt;int_(10)&lt;/code&gt;のような)は、失敗に関して入力を消費する。これは代替演算子に関する問題に結びつくかもしれない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#tokenizer&#34; name=&#34;tokenizer&#34;&gt;Tokenizer&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isspace&lt;/code&gt;/&lt;code&gt;ispunct&lt;/code&gt; が間違ったキャラクタ型で呼ばれていたのを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4791&#34; target=&#34;_blank&#34;&gt;#4791&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#unordered&#34; name=&#34;unordered&#34;&gt;Unordered&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;value type での &lt;code&gt;operator&amp;amp;&lt;/code&gt; の使用を回避。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wconversion&lt;/code&gt; での警告を回避。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#wave&#34; name=&#34;wave&#34;&gt;Wave&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;V2.2.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++0xでキーワードとされる語をRe2C lexerに追加。&lt;/li&gt;
&lt;li&gt;コマンドラインオプション &lt;code&gt;--c++0x&lt;/code&gt; を追加。このオプションを付けると、C++0xでキーワードされる語と、それらのC++0xトークンへの変換が有効になる。&lt;/li&gt;
&lt;li&gt;全ライブラリをBoost.Filesystem V3と協調動作するように適合 (デフォルトで有効)。&lt;/li&gt;
&lt;li&gt;拡張文字・文字列リテラルのサポートと、それに関するテストケースを追加 (テストアプリケーションへのC++0xサポートの追加が要求される)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--c++0x&lt;/code&gt; modeに仕様に沿った定義済みマクロの追加。現在&lt;code&gt;__cplusplus&lt;/code&gt;は&lt;code&gt;201101L&lt;/code&gt;と定義されているが、言語仕様が決定する際に変更されるかもしれない。&lt;/li&gt;
&lt;li&gt;オブジェクト形式マクロがカッコと隣接していて、&lt;code&gt;expanding_object_like_macro()&lt;/code&gt;フック関数によってマクロ展開が抑制されるとき、カッコが消えてしまう問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pragma option(preserve)&lt;/code&gt;のバグを修正 (以前の値が&lt;code&gt;preserve=2&lt;/code&gt;だった場合、&lt;code&gt;perserve=1&lt;/code&gt;がセットされないバグ)。&lt;/li&gt;
&lt;li&gt;waveコマンドの&lt;code&gt;--preserve&lt;/code&gt;オプションのinteger argumentの解釈を少し変更:&lt;ul&gt;
&lt;li&gt;0: 空白文字は全て処理する&lt;/li&gt;
&lt;li&gt;1: 行頭の空白文字だけそのままにする&lt;/li&gt;
&lt;li&gt;2: 行頭とコメントの空白文字だけそのままにする&lt;/li&gt;
&lt;li&gt;3: 全ての行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#pragma wave option(preserve)&lt;/code&gt; は次の引数をサポートする: [0|1|2|3|push|pop]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#boostbook&#34; name=&#34;boostbook&#34;&gt;Boostbook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ルート要素に対する属性のより良いサポート(&lt;code&gt;lang&lt;/code&gt;を含む)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#inspect&#34; name=&#34;inspect&#34;&gt;Inspect&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boostのヘッダで、Cの&lt;code&gt;assert&lt;/code&gt;マクロが使われていないかをチェック&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_46_0.html#quickbook&#34; name=&#34;quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ドキュメント情報中での &lt;code&gt;lang&lt;/code&gt; 属性のサポートを追加&lt;/li&gt;
&lt;li&gt;アンカーを改善&lt;/li&gt;
&lt;li&gt;条件節での &lt;code&gt;import&lt;/code&gt;、&lt;code&gt;include&lt;/code&gt; 、 &lt;code&gt;xinclude&lt;/code&gt; のサポート&lt;/li&gt;
&lt;li&gt;Filesystem v3を使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主要テストコンパイラ：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: 3.4.6, 4.2.4, 4.3.4, 4.4.3, 4.4.5, 4.5.2,&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.3.4, 4.4.3, 4.5.0, 4.5.2&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1&lt;/li&gt;
&lt;li&gt;Clang: 2.8&lt;/li&gt;
&lt;li&gt;Pathscale: 3.2.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: 4.0.1, 4.2.1, 4.4&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.4.&lt;/li&gt;
&lt;li&gt;Intel: 11.1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++: 7.1, 8.0, 9.0 and 10.0.&lt;/li&gt;
&lt;li&gt;GCC, mingw: 4.4.0.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FreeBSD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: 4.2.1, 64 bit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加のテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC: 3.4.6, 4.2.4, 4.3.4, 4.3.5, 4.4.3, 4.4.5, 4.5.0, 4.5.2&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.3.4, 4.4.3, 4.5.0, 4.5.2&lt;/li&gt;
&lt;li&gt;pgCC [/ 10.1,] 11.1&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1&lt;/li&gt;
&lt;li&gt;PathScale: 3.2, 4.0&lt;/li&gt;
&lt;li&gt;Visual Age C++ 10.1&lt;/li&gt;
&lt;li&gt;Clang from subversion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Intel C++ Compiler: 10.1, 11.0, 11.1&lt;/li&gt;
&lt;li&gt;GCC: 4.0.1, 4.2.1, 4.4.4&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.4.4&lt;/li&gt;
&lt;li&gt;Clang from subversion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++: 7.1, 8.0, 9.0, 10.0&lt;/li&gt;
&lt;li&gt;Visual C++ with STLport: 9.0&lt;/li&gt;
&lt;li&gt;Visual C++, Windows Mobile 5, with STLport: 9.0&lt;/li&gt;
&lt;li&gt;GCC, mingw: 4.4.0, 4.5.1, 4.6.0&lt;/li&gt;
&lt;li&gt;GCC, mingw, C++0x mode: 4.5.1&lt;/li&gt;
&lt;li&gt;Borland: 6.1.3 (2009), 6.2.1 (2010)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AIX:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FreeBSD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 4.2.1, 64 bit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solaris:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sun C++: 5.10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, melpon, zakkas783, yak_ex&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.47.0 リリースノート -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/document/version/1_47_0.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:document/version/1_47_0.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost 1.47.0 リリースノート&lt;/h1&gt;
&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_47_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_47_0.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Chrono&lt;ul&gt;
&lt;li&gt;有用な時間ユーティリティ。&lt;/li&gt;
&lt;li&gt;作者：Vicente J. Botet Escribá&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Geometry&lt;ul&gt;
&lt;li&gt;幾何学ライブラリ。&lt;/li&gt;
&lt;li&gt;作者：Barend Gehrels, Bruno Lalande and Mateusz Loskot&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phoenix&lt;ul&gt;
&lt;li&gt;呼び出し側での小さな無名関数の定義と、より多くのもの。&lt;/li&gt;
&lt;li&gt;作者：Joel de Guzman, Dan Marsden and Thomas Heller&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ratio&lt;ul&gt;
&lt;li&gt;コンパイル時有理数ライブラリ。&lt;/li&gt;
&lt;li&gt;作者：Vicente J. Botet Escribá&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#accumulators&#34;&gt;Accumulators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#asio&#34;&gt;Asio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#config&#34;&gt;Config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#datetime&#34;&gt;DateTime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#dynamic-bitset&#34;&gt;Dynamic Bitset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#function&#34;&gt;Function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#foreach&#34;&gt;Foreach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#function-types&#34;&gt;Function Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#iostreams&#34;&gt;Iostreams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#iterator&#34;&gt;Iterator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#lexical-cast&#34;&gt;Lexical Cast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#logic&#34;&gt;Logic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#math&#34;&gt;Math&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#multi-index&#34;&gt;MultiIndex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#random&#34;&gt;Random&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#proto&#34;&gt;Proto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#range&#34;&gt;Range&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#spirit&#34;&gt;Spirit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#tokenizer&#34;&gt;Tokenizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#utility&#34;&gt;Utility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#uuid&#34;&gt;Uuid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#wave&#34;&gt;Wave&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ツール&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#boostbook&#34;&gt;BoostBook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#accumulators&#34; name=&#34;accumulators&#34;&gt;Accumulators&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新たな統計アキュムレータを追加 : &lt;code&gt;sum_kahan&lt;/code&gt;, &lt;code&gt;sum_of_weights_kahan&lt;/code&gt;, &lt;code&gt;sum_of_variates_kahan&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#asio&#34; name=&#34;asio&#34;&gt;Asio&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;シグナルハンドリング。&lt;code&gt;signal_set&lt;/code&gt;クラスを追加。&lt;/li&gt;
&lt;li&gt;非同期プログラムのデバッグ支援。&lt;code&gt;BOOST_ASIO_ENABLE_HANDLER_TRACKING&lt;/code&gt;をdefineすることで利用可能。&lt;/li&gt;
&lt;li&gt;ソケット&lt;code&gt;iostream&lt;/code&gt;に対するタイムアウト。&lt;code&gt;ip::tcp::iostream&lt;/code&gt;で&lt;code&gt;expires_at()&lt;/code&gt;もしくは&lt;code&gt;expires_from_now()&lt;/code&gt;を使用する。&lt;/li&gt;
&lt;li&gt;ソケット&lt;code&gt;iostream&lt;/code&gt;に&lt;code&gt;error()&lt;/code&gt;メンバ関数を追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;basic_deadline_timer::cancel_one()&lt;/code&gt;を追加。この関数は、タイマーに対する待機ハンドラを解除するのに使用できる。ハンドラはFIFO順に解除される。&lt;/li&gt;
&lt;li&gt;完了条件の&lt;code&gt;transfer_exactly()&lt;/code&gt;関数を追加。これは、バッファの合計サイズ(またはバッファのシーケンス)が大きい場合でも、指定されたバイト数を送受信するのに使用することができる。&lt;/li&gt;
&lt;li&gt;接続操作の合成。&lt;code&gt;connect()&lt;/code&gt;, &lt;code&gt;async_connect()&lt;/code&gt;フリー関数の追加。これらの操作は、ソケットが正常に接続されるまで、リスト内の各エンドポイントを試みる。IPv4とIPv6の両方で動作するTCPクライアントを作成するために便利。&lt;/li&gt;
&lt;li&gt;個々のバッファに加え、バッファシーケンスを動作するように&lt;code&gt;buffer_size()&lt;/code&gt;関数を拡張。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buffer_copy()&lt;/code&gt;関数を追加。個々のバッファと、バッファシーケンスの間で生のバイトデータをコピーするのに使用できる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read_at()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;write_at()&lt;/code&gt;のno throw版オーバーロードを追加。&lt;/li&gt;
&lt;li&gt;終了ハンドラが必要な型要件を満たさない場合のよりフレンドリーなコンパイルエラーを追加。C++0xの&lt;code&gt;static_assert&lt;/code&gt;が利用可能な環境で自動的にONになる(g++やVC10以降など)。&lt;code&gt;BOOST_ASIO_DISABLE_HANDLER_TYPE_REQUIREMENTS&lt;/code&gt;をdefineすることでこのモードを無効にできる。&lt;/li&gt;
&lt;li&gt;SSL実装の書き直し。新たな実装は、高速コンパイル、パフォーマンスの大幅向上、カスタムメモリアロケートとハンドラの呼び出しをサポートする。証明書検証コールバックなどの新たなAPI関数が含まれていて、エラー報告機能の強化がある。新たな実装は、ほとんどの場合に古いソースに互換性がある。ただし、必要に応じて&lt;code&gt;BOOST_ASIO_ENABLE_OLD_SSL&lt;/code&gt;を定義することで以前の実装を使用する可能性がある(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3702&#34; target=&#34;_blank&#34;&gt;#3702&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3958&#34; target=&#34;_blank&#34;&gt;#3958&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;AsioのSSL機能を使うために、あなたのプログラムにひとつのソースファイル&lt;code&gt;boost/asio/ssl/impl/src.hpp&lt;/code&gt;を含める、というように、分割コンパイルサポートを変更した。&lt;/li&gt;
&lt;li&gt;SSL v2を明示的に無効化できるようにSSL実装を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5453&#34; target=&#34;_blank&#34;&gt;#5453&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_loopback()&lt;/code&gt;, &lt;code&gt;is_unspecified()&lt;/code&gt;, &lt;code&gt;is_multicast()&lt;/code&gt;関数を、&lt;code&gt;ip::address&lt;/code&gt;, &lt;code&gt;ip::address_v4&lt;/code&gt;, &lt;code&gt;ip::address_v6&lt;/code&gt;の全てで使用できるよう修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3939&#34; target=&#34;_blank&#34;&gt;#3939&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;ソケットやdescriptorでノンブロッキングの振る舞いを管理するための&lt;code&gt;non_blocking()&lt;/code&gt;関数を追加。&lt;code&gt;non_blocking_io&lt;/code&gt;という名前の&lt;code&gt;io_control&lt;/code&gt;コマンドは、この新たな関数によって非推奨(deprecated)となる。&lt;/li&gt;
&lt;li&gt;ソケットやdescriptorでノンブロッキングモードの基礎的なものをを管理するための、&lt;code&gt;native_non_blocking()&lt;/code&gt;関数を追加。この関数は、ソケットオブジェクトのユーザーに透過的な方法での非同期操作として、任意のノンブロッキングシステムコールのカプセル化を許可するものである。この関数は、ソケットやdescriptorの同期操作の挙動に影響を及ぼす。&lt;/li&gt;
&lt;li&gt;socket acceptorのための&lt;code&gt;io_control()&lt;/code&gt;メンバ関数を追加(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3297&#34; target=&#34;_blank&#34;&gt;#3297&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;posix descriptorに&lt;code&gt;release()&lt;/code&gt;メンバ関数を追加。この関数は、ネイティブなdescriptorの所有権を解放する(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3900&#34; target=&#34;_blank&#34;&gt;#3900&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;sequenced packet sockets(&lt;code&gt;SOCK_SEQPACKET&lt;/code&gt;)のサポートを追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;io_service&lt;/code&gt;が停止しているかどうかを判定するための&lt;code&gt;io_service::stopped()&lt;/code&gt;関数を追加(&lt;code&gt;reset()&lt;/code&gt;呼び出しは、&lt;code&gt;run()&lt;/code&gt;, &lt;code&gt;run_one()&lt;/code&gt;, &lt;code&gt;poll()&lt;/code&gt;, &lt;code&gt;poll_one()&lt;/code&gt;呼び出しの前に必要になる)。&lt;/li&gt;
&lt;li&gt;C++0x標準ライブラリとの整合性のために、&lt;code&gt;native_type&lt;/code&gt; typedefを非推奨とし、&lt;code&gt;native_handle_type&lt;/code&gt;を推奨とした。また、&lt;code&gt;native()&lt;/code&gt;メンバ関数を非推奨とし、&lt;code&gt;native_handle()&lt;/code&gt;メンバ関数を推奨とした。&lt;/li&gt;
&lt;li&gt;C++0xのmoveに対応。ソケット、シリアルポート、posix descriptor、Windowsハンドルのムーブコンストラクト、ムーブ代入に対応。&lt;/li&gt;
&lt;li&gt;(C++0xのmoveなどにより)ハンドラ関数オブジェクトのコピーを減らした。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt;システムコールのサポートを追加。&lt;code&gt;fork()&lt;/code&gt;を使用するプログラムは、&lt;code&gt;io_service.notify_fork()&lt;/code&gt;を適切なタイミングで呼び出す必要がある。この機能の2つのサンプルを追加した(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3238&#34; target=&#34;_blank&#34;&gt;#3238&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4162&#34; target=&#34;_blank&#34;&gt;#4162&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close()&lt;/code&gt;システムコールによって報告されたエラーのクリーンアップ。ほとんどのオペレーティングシステムは、&lt;code&gt;EWOULDBLOCK&lt;/code&gt;によって&lt;code&gt;close()&lt;/code&gt;が失敗するが、それはブロッキングモードを設定して呼び出しを再起動していない場合に起こる。その他のエラーの場合には、descriptorは閉じられると想定する(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3307&#34; target=&#34;_blank&#34;&gt;#3307&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;asio::buffer()&lt;/code&gt;関数に、&lt;code&gt;std::array&lt;/code&gt;のオーバーロードを追加。&lt;/li&gt;
&lt;li&gt;その実装がBoostと同等以上である場合に、C++0x標準ライブラリの&lt;code&gt;array&lt;/code&gt;, &lt;code&gt;shared_ptr&lt;/code&gt;, &lt;code&gt;weak_ptr&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;を使用するよう内部実装を修正。&lt;/li&gt;
&lt;li&gt;C++0x可変引数テンプレートが利用可能である場合に、Boost.Preprocessorによるオーバーロードの代わりにそちらの実装を使用するようにした。&lt;/li&gt;
&lt;li&gt;例外の&lt;code&gt;what()&lt;/code&gt;メンバ関数で返されるメッセージに、関数名を含めるようにした。&lt;/li&gt;
&lt;li&gt;MinGWでの未初期化変数警告を修正。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutdown_service()&lt;/code&gt;メンバ関数を&lt;code&gt;private&lt;/code&gt;にした。&lt;/li&gt;
&lt;li&gt;ソケットオプション関数のテストを追加。&lt;/li&gt;
&lt;li&gt;Boost.Asioの例でBoost.Threadを使用しないようにした。&lt;/li&gt;
&lt;li&gt;IPv4とIPv6のための、OSが提供するマクロへの依存をやめた(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3741&#34; target=&#34;_blank&#34;&gt;#3741&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip::basic_endpoint&amp;lt;&amp;gt;&lt;/code&gt;(と同じく&lt;code&gt;ip::tcp::endpointとip::udp::endpoint&lt;/code&gt;も)のサイズを小さくした。&lt;/li&gt;
&lt;li&gt;任意のソケットやdescriptorが、&lt;code&gt;dup()&lt;/code&gt;を持っている場合に&lt;code&gt;assign()&lt;/code&gt;を使用するようリアクターのバックエンドを変更し、リアクターの明示的な要件から削除(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4971&#34; target=&#34;_blank&#34;&gt;#4971&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;非推奨だったメンバ関数&lt;code&gt;io_service()&lt;/code&gt;を削除した。&lt;code&gt;get_io_service()&lt;/code&gt;を使用するべきである。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip::tcp&lt;/code&gt;, &lt;code&gt;ip::udp&lt;/code&gt;, &lt;code&gt;ip::icmp&lt;/code&gt;クラスから、非推奨だったtypedefである&lt;code&gt;resolver_query&lt;/code&gt;, &lt;code&gt;resolver_iterator&lt;/code&gt;を削除した。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buffers_iterator&amp;lt;&amp;gt;&lt;/code&gt;と&lt;code&gt;ip::basic_resolver_iterator&lt;/code&gt;の&lt;code&gt;value_type&lt;/code&gt;を非&lt;code&gt;const&lt;/code&gt; &lt;code&gt;byte&lt;/code&gt;型に修正。&lt;/li&gt;
&lt;li&gt;g++の-Wshadowコンパイルオプションによる警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3905&#34; target=&#34;_blank&#34;&gt;#3905&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;一部の環境でのコンパイラ警告を抑制するために、&lt;code&gt;FIONBIO&lt;/code&gt;定数を&lt;code&gt;int&lt;/code&gt;に明示的にキャストするようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5128&#34; target=&#34;_blank&#34;&gt;#5128&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;acceptorの例で、エラーを許容するように修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5124&#34; target=&#34;_blank&#34;&gt;#5124&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tick_count_timer&lt;/code&gt;の例での間違いを修正。&lt;code&gt;signed&lt;/code&gt;な&lt;code&gt;duration&lt;/code&gt;を作るようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5418&#34; target=&#34;_blank&#34;&gt;#5418&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#config&#34; name=&#34;config&#34;&gt;Config&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;マクロの名称変更(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1988&#34; target=&#34;_blank&#34;&gt;#1988&lt;/a&gt;)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BOOST_NO_THREADEX&lt;/code&gt; -&amp;gt; &lt;code&gt;BOOST_HAS_THREADEX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_NO_GETSYSTEMTIMEASFILETIME&lt;/code&gt; -&amp;gt; &lt;code&gt;BOOST_HAS_GETSYSTEMTIMEASFILETIME&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#datetime&#34; name=&#34;datetime&#34;&gt;DateTime&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;サンプルの間違いを修正。typoなど(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4920&#34; target=&#34;_blank&#34;&gt;#4920&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;ドキュメントにあるサンプルの変数名、関数名などの間違いを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3651&#34; target=&#34;_blank&#34;&gt;#3651&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;サンプルの間違いを修正。&lt;code&gt;end_of_month_day()&lt;/code&gt; -&amp;gt; &lt;code&gt;end_of_month()&lt;/code&gt;(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4845&#34; target=&#34;_blank&#34;&gt;#4845&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;OpenVMSの64ビットプラットフォームサポートを追加(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4475&#34; target=&#34;_blank&#34;&gt;#4475&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GCC 4.3での&lt;code&gt;time_facet&lt;/code&gt;の警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4952&#34; target=&#34;_blank&#34;&gt;#4952&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time_serialize&lt;/code&gt;で、依存名に対して&lt;code&gt;typename&lt;/code&gt;が付いていなかったのを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5345&#34; target=&#34;_blank&#34;&gt;#5345&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;clangでの、二重カッコによる警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5250&#34; target=&#34;_blank&#34;&gt;#5250&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;valgrindプラットフォームでの警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4798&#34; target=&#34;_blank&#34;&gt;#4798&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;オーストラリアでの、夏時間の開始と終了が間違っていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4754&#34; target=&#34;_blank&#34;&gt;#4754&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Australia/Euclaのタイムゾーンデータベースが間違っていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4411&#34; target=&#34;_blank&#34;&gt;#4411&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;SCCキーワードのエスケープに関するバグ修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5126&#34; target=&#34;_blank&#34;&gt;#5126&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;タイムゾーンデータベースの、ファイルからの読み込みをサポート(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2475&#34; target=&#34;_blank&#34;&gt;#2475&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;グローバルロケールを使用した場合に、&lt;code&gt;ymd_formatter&lt;/code&gt;で年が&lt;code&gt;2,008&lt;/code&gt;のようにフォーマットされる問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1674&#34; target=&#34;_blank&#34;&gt;#1674&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#dynamic-bitset&#34; name=&#34;dynamic-bitset&#34;&gt;Dynamic Bitset&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GCCで&lt;code&gt;-Wshadow&lt;/code&gt;コンパイラオプションを付けた際に出る警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5439&#34; target=&#34;_blank&#34;&gt;#5439&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#function&#34; name=&#34;function&#34;&gt;Function&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GCCで&lt;code&gt;-Wold-style-cast&lt;/code&gt;コンパイラオプションを付けた際に出る警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3410&#34; target=&#34;_blank&#34;&gt;#3410&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;MSVCでの未使用変数警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3618&#34; target=&#34;_blank&#34;&gt;#3618&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Visual Age C++の古いバージョンのためのworkaroundに、新しいバージョン(&lt;code&gt;__IBMCPP__ &amp;gt;= 800&lt;/code&gt;)が適用されないよう修正。新しいバージョンでは、&lt;code&gt;boost::function&lt;/code&gt;の引数が11個以上使用できる(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3912&#34; target=&#34;_blank&#34;&gt;#3912&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;VC10で、&lt;code&gt;function&lt;/code&gt;内部で&lt;code&gt;boost::mem_fn&lt;/code&gt;が呼ばれるべきところを、ADLによって&lt;code&gt;std::mem_fn&lt;/code&gt;が探索されコンパイルエラーになっていた問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4073&#34; target=&#34;_blank&#34;&gt;#4073&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::function&lt;/code&gt;に、関数の参照を持たせるために&lt;code&gt;boost::ref&lt;/code&gt;でラップして渡すとコンパイルエラーになる問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4325&#34; target=&#34;_blank&#34;&gt;#4325&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::function&lt;/code&gt;内部の&lt;code&gt;stored_vtable&lt;/code&gt;が非&lt;code&gt;const&lt;/code&gt;のために書き込み可能メモリに配置されてしまう問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4717&#34; target=&#34;_blank&#34;&gt;#4717&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;関数呼び出し演算子で、&lt;code&gt;inline&lt;/code&gt;キーワードの書く場所を間違えていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4765&#34; target=&#34;_blank&#34;&gt;#4765&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#foreach&#34; name=&#34;foreach&#34;&gt;Foreach&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++0xムーブセマンティクスに対応。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#function-types&#34; name=&#34;function-types&#34;&gt;Function Types&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;デフォルトビルドにおいてプリプロセス済みの &lt;code&gt;function_types&lt;/code&gt; ヘッダを作成しようとし、waveの実行ファイルが要求される問題をデフォルトビルド対象外とすることで修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1653&#34; target=&#34;_blank&#34;&gt;#1653&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function_types&lt;/code&gt;/&lt;code&gt;components&lt;/code&gt; のtypoを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3162&#34; target=&#34;_blank&#34;&gt;#3162&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#graph&#34; name=&#34;graph&#34;&gt;Graph&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;非推奨な関数であった&lt;code&gt;kolmogorov_max_flow&lt;/code&gt;を削除した。以降は&lt;code&gt;boykov_kolmogorov_max_flow&lt;/code&gt;を使う。&lt;/li&gt;
&lt;li&gt;Boost.Type_Traitsに同等の機能があるため&lt;code&gt;&amp;lt;boost/graph/detail/is_same.hpp&amp;gt;&lt;/code&gt;ヘッダを削除した&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#iostreams&#34; name=&#34;iostreams&#34;&gt;Iostreams&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Filesystem V3の&lt;code&gt;path&lt;/code&gt;をサポート(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4485&#34; target=&#34;_blank&#34;&gt;#4485&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chain&lt;/code&gt;でのメモリリークを修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4922&#34; target=&#34;_blank&#34;&gt;#4492&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#iterator&#34; name=&#34;iterator&#34;&gt;Iterator&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function_input_iterator&lt;/code&gt;追加 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/2893&#34; target=&#34;_blank&#34;&gt;#2893&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;&lt;code&gt;transform_iterator&lt;/code&gt;の戻り型の推論に&lt;code&gt;boost::result_of&lt;/code&gt;を使うよう修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1427&#34; target=&#34;_blank&#34;&gt;#1427&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zip_iterator&lt;/code&gt;が&lt;code&gt;BidirectionalInputIterator&lt;/code&gt;を&lt;code&gt;zip&lt;/code&gt;できない問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/1517&#34; target=&#34;_blank&#34;&gt;#1517&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/iterator.hpp&lt;/code&gt;のコメントのtypoを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3434&#34; target=&#34;_blank&#34;&gt;#3434&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Lexical Cast&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Source&lt;/code&gt;と&lt;code&gt;Target&lt;/code&gt;型の特殊化を追加し、パフォーマンスとメモリ効率を改善した&lt;ul&gt;
&lt;li&gt;&lt;code&gt;signed char&lt;/code&gt;と&lt;code&gt;unsigned char&lt;/code&gt;の特殊化 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5564&#34; target=&#34;_blank&#34;&gt;#5564&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;整数型 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5417&#34; target=&#34;_blank&#34;&gt;#5417&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Source&lt;/code&gt;と&lt;code&gt;Target&lt;/code&gt;が同じ型の場合 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4397&#34; target=&#34;_blank&#34;&gt;#4397&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Source&lt;/code&gt;から&lt;code&gt;Target&lt;/code&gt;を直接コンストラクト可能な場合 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5350&#34; target=&#34;_blank&#34;&gt;#5350&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;整数型のグルーピングが0の場合 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5576&#34; target=&#34;_blank&#34;&gt;#5576&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ドキュメント更新&lt;ul&gt;
&lt;li&gt;パフォーマンスセクションの追加 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5576&#34; target=&#34;_blank&#34;&gt;#5576&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;FAQに&lt;code&gt;lexical_cast&amp;lt;unsigned int&amp;gt;(&#34;-1&#34;)&lt;/code&gt;が例外を送出する件について追加 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5494&#34; target=&#34;_blank&#34;&gt;#5494&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#logic&#34; name=&#34;logic&#34;&gt;Logic&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logic/tribool&lt;/code&gt;のGCC Shadow errorを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3093&#34; target=&#34;_blank&#34;&gt;#3093&lt;/a&gt;)   &lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_TRIBOOL_THIRD_STATE&lt;/code&gt;の未使用変数警告を抑制 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/3600&#34; target=&#34;_blank&#34;&gt;#3600&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#math&#34; name=&#34;math&#34;&gt;Math&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;nonfinite facetを容易に追加するために、&lt;code&gt;changesign&lt;/code&gt;関数を&lt;code&gt;sign.hpp&lt;/code&gt;に追加した&lt;/li&gt;
&lt;li&gt;Johan Rade氏によるnonfinite facetと、そのテスト、C99形式の無限大と&lt;code&gt;NaN&lt;/code&gt;での利用例、およびドキュメントの追加&lt;/li&gt;
&lt;li&gt;Johan Rade氏による&lt;code&gt;changesign&lt;/code&gt;のテストとドキュメントの追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#msm&#34; name=&#34;msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バックエンドに&lt;code&gt;stop()&lt;/code&gt;メソッドを追加&lt;/li&gt;
&lt;li&gt;Boost.Phoenix ファンクタのeUML表現を部分的にサポートした&lt;/li&gt;
&lt;li&gt;ステートスイッチングが発生した際に選択する可能性を考慮&lt;/li&gt;
&lt;li&gt;バグ修正&lt;ul&gt;
&lt;li&gt;Trac &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5117&#34; target=&#34;_blank&#34;&gt;#5117&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5253&#34; target=&#34;_blank&#34;&gt;#5253&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5533&#34; target=&#34;_blank&#34;&gt;#5533&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5573&#34; target=&#34;_blank&#34;&gt;#5573&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;gccで未使用変数の警告がでる問題を修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;favor_compile_time&lt;/code&gt; バックエンドポリシーをさらに統合した&lt;/li&gt;
&lt;li&gt;ステート構築とeUMLのバグを修正&lt;/li&gt;
&lt;li&gt;eUML イヴェントとステートマクロの誤りを修正&lt;/li&gt;
&lt;li&gt;直接入力のステートの&lt;code&gt;on_entry&lt;/code&gt;アクションに間違ったイヴェントタイプが渡される問題を修正&lt;/li&gt;
&lt;li&gt;コードサンプルを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#multi-index&#34; name=&#34;multi-index&#34;&gt;MultiIndex&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Refに関連する&lt;code&gt;composite_key_compare&lt;/code&gt;のADL問題を修正した&lt;/li&gt;
&lt;li&gt;メンテナンス上の修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#random&#34; name=&#34;random&#34;&gt;Random&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;新たな標準(C++0x)に同期&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多くの分布を追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chi_squared_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;negative_binomial_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fisher_f_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;student_t_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weibull_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extreme_value_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discrete_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;piecewise_constant_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;piecewise_liear_distribution&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;名称変更：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;uniform_int&lt;/code&gt; → &lt;code&gt;uniform_int_distribution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform_real&lt;/code&gt; → &lt;code&gt;uniform_real_distribution&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全ての分布クラスに以下のメンバを追加：&lt;code&gt;param_type&lt;/code&gt;, &lt;code&gt;param&lt;/code&gt;, ストリーム演算子, 比較演算子, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分布クラスを、&lt;code&gt;variate_generator&lt;/code&gt;を通さずに直接ジェネレータを使用できるようにした。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geometric_distribution&lt;/code&gt;と&lt;code&gt;lognormal_distribution&lt;/code&gt;のパラメータの意味を変えた。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gamma_distribution&lt;/code&gt;に第2パラメータを追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;seed_seq&lt;/code&gt;を追加し、対応するコンストラクタと&lt;code&gt;seed&lt;/code&gt;オーバーロードジェネレータを追加。- &lt;code&gt;generate_canonical&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;エンジンテンプレートの名称変更。たとえば、&lt;code&gt;mersenne_twister&lt;/code&gt;は&lt;code&gt;mersenne_twister_engine&lt;/code&gt;となる。&lt;/li&gt;
&lt;li&gt;新たなエンジンアダプタ&lt;code&gt;independent_bits_engine&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;新たな事前定義&lt;code&gt;typedef&lt;/code&gt;を追加：&lt;code&gt;mt19937_64&lt;/code&gt;, &lt;code&gt;ranlux[24|48][_base]&lt;/code&gt;, &lt;code&gt;knuth_b&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;シードアルゴリズムを更新。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discard&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;全ての定義済みエンジンで、符合あり型の代わりに符号なし型を使用するようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全てのケースで剰余演算が実装されていなかったので、&lt;code&gt;linear_congruential_engine&lt;/code&gt;が&lt;code&gt;assert&lt;/code&gt;する可能性があった。&lt;code&gt;shuffle_output&lt;/code&gt;は整数オーバーフローを起こす可能性があったため、今は&lt;code&gt;shuffle_order_engine&lt;/code&gt;を呼ぶようにした。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniform_small_int&lt;/code&gt;は現在、ドキュメント通りに動作する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;その他変更&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binomial_distribution&lt;/code&gt;と&lt;code&gt;poisson_distribution&lt;/code&gt;のための新たな効率的なアルゴリズム。&lt;/li&gt;
&lt;li&gt;全ての機能を&lt;code&gt;boost::random&lt;/code&gt;名前空間に移動。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;下位互換性の問題&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;シードアルゴリズムが変更した。これは標準との互換性のために避けられなかった。既存のいくつかのアルゴリズムに矛盾があったことは言うまでもない。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;によるシード：&lt;code&gt;lagged_fibonacci&lt;/code&gt;と&lt;code&gt;subtract_with_carry&lt;/code&gt;(つまり&lt;code&gt;ranlux&lt;/code&gt;)を除くほとんどのジェネレータを変更する必要がある。&lt;/li&gt;
&lt;li&gt;別のジェネレータとジェネレータのシード：これは全てのジェネレータモデル&lt;code&gt;SeedSeq&lt;/code&gt;を作ることで有効になっている。したがって、非Boost.RandomジェネレータでBoost.Randomジェネレータのシードを使用した場合、それはコンパイルに成功しない。アルゴリズムが変更されたため、このシード処理のメソッドを使用したコードが異なる値を生成する。&lt;/li&gt;
&lt;li&gt;イテレータの組からシードを生成する：全てではないがいくつかの場所で、暗黙的に要素が32ビット整数であることを仮定する。この要件を追加し、それに応じてアルゴリズムを更新した。ジェネレータの&lt;code&gt;value_type&lt;/code&gt;が32ビット以上の場合には、動作を変更する必要がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;名称変更&lt;ul&gt;
&lt;li&gt;クラス名が変更されたものには、古い名前によるラッパーを用意した。また、名前空間が移動された全てのもののために、&lt;code&gt;boost&lt;/code&gt;名前空間での&lt;code&gt;using&lt;/code&gt;宣言を行うようにした。&lt;/li&gt;
&lt;li&gt;分布クラスのいくつかのアクセッサ名が変更された。古いものと新しいもの両方を使用できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geometric_distribution&lt;/code&gt;と&lt;code&gt;lognormal_distribution&lt;/code&gt;：実行時に異なる動作をするようになった。これまでの動作をする&lt;code&gt;boost::geometric_distribution&lt;/code&gt;と&lt;code&gt;boost::lognormal_distribution&lt;/code&gt;、新たな動作をする&lt;code&gt;boost::random::geometric_distribution&lt;/code&gt;と&lt;code&gt;boost::random::lognormal_distribution&lt;/code&gt;を提供する。&lt;/li&gt;
&lt;li&gt;ストリーミング：&lt;code&gt;gamma_distribution&lt;/code&gt;は新たなパラメータを持っているため、古いバージョンでストリーム演算子を使用して出力されたテキストを新しいバージョンで読み込むことはできない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;variate_generator&lt;/code&gt;は現在、単なるラッパーである。ジェネレータの結果が分布の結果型と一致することを期待しているコードは動作しなくなる。これはBoost.Randomが提供する分布の問題ではない。&lt;/li&gt;
&lt;li&gt;戻り値の型：いくつかのジェネレータの&lt;code&gt;result_type&lt;/code&gt;を変更した。標準に合わせて、いくつかの符号あり型は符号なし型に変更された。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;has_fixed_range&lt;/code&gt;：これは常に&lt;code&gt;false&lt;/code&gt;を返し、非常に有用ではあるが過度に複雑だった。最初に&lt;code&gt;has_fixed_range&lt;/code&gt;をチェックせずに&lt;code&gt;const_min&lt;/code&gt;, &lt;code&gt;const_max&lt;/code&gt;を使用していたのがはじめから間違いだった。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#proto&#34; name=&#34;proto&#34;&gt;Proto&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;コンパイルタイム改善のためにプリプロセス済みのマクロ(Pre-preprocessed)を用意した&lt;/li&gt;
&lt;li&gt;デフォルトのプリプロセッサ制限を引き上げた&lt;ul&gt;
&lt;li&gt;式の引数の数(&lt;code&gt;BOOST_PROTO_MAX_ARITY&lt;/code&gt;)を5から10に増やした&lt;/li&gt;
&lt;li&gt;関数呼び出しの引数の数(&lt;code&gt;BOOST_PROTO_MAX_FUNCTION_CALL_ARITY&lt;/code&gt;)を5から10に増やした&lt;/li&gt;
&lt;li&gt;論理演算子の引数の数(&lt;code&gt;BOOST_PROTO_MAX_LOGICAL_ARITY&lt;/code&gt;)を8から10に増やした&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不要な&lt;code&gt;proto::expr&lt;/code&gt;のインスタンス化を避けるために&lt;code&gt;proto::basic_expr&lt;/code&gt;をさらに統合した&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#range&#34; name=&#34;range&#34;&gt;Range&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;破壊的変更&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;irange&lt;/code&gt;で、&lt;code&gt;step&lt;/code&gt;が2以上のときの終端の計算が間違っていたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5544&#34; target=&#34;_blank&#34;&gt;#5544&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#spirit&#34; name=&#34;spirit&#34;&gt;Spirit&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Spirit V2.5&lt;/p&gt;
&lt;p&gt;Boost 1.47.0でリリースされるBoost.Phoenix V3に対応した。&lt;/p&gt;
&lt;p&gt;これによってユーザーコードに影響を与えることはない。&lt;/p&gt;
&lt;p&gt;Boost.Phoenix V3を有効にするには、Spiritのヘッダをインクルードする前に以下のプリプロセッサ定数を定義する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#define BOOST_SPIRIT_USE_PHOENIX_V3 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Qi or Karmaの新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ジェネリックで、階層的で、抽象構文木を表すことができる動的なデータ構造であるutreeを追加。これはSpirit.QiとSpirit.Karmaに統合される。これはほぼすべての構文を解析の属性として渡すことができる。同時に、その属性を使用して出力を生成できる。&lt;/li&gt;
&lt;li&gt;新たなマクロ&lt;code&gt;BOOST_SPIRIT_TERMINAL_NAME&lt;/code&gt;は、2つのパラメータをとる(ターミナルの名前と型)。ターミナルの名前のみを引数にとる&lt;code&gt;BOOST_SPIRIT_TERMINAL&lt;/code&gt;マクロもあり、これは「ターミナル名 + &lt;code&gt;_type&lt;/code&gt;」という型名を生成する。&lt;code&gt;int_&lt;/code&gt;のような名前の場合には&lt;code&gt;int__type&lt;/code&gt;のような、C++言語でシステムに予約されているダブルアンダーバーを含む型が生成されるので注意。&lt;/li&gt;
&lt;li&gt;数値パーサーで2..10と16の基数を許可。&lt;/li&gt;
&lt;li&gt;プレースホルダー &lt;code&gt;_val&lt;/code&gt; が、トップレベルセマンティックルールの右辺で使用できるようになった。以下がその例である：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
BOOST_TEST(test_attr(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;456&#34;&lt;/span&gt;, int_[_val &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; _1], i) &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;456&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この場合、&lt;code&gt;parse()&lt;/code&gt; または &lt;code&gt;phrase_parse()&lt;/code&gt; 関数に渡された属性の値 &lt;code&gt;_val&lt;/code&gt; を指す。これはSpirit.Karmaでも同様に可能となる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;123&lt;/span&gt;;
BOOST_TEST(test(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123&#34;&lt;/span&gt;, int_[_1 &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; _val], i));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この変更により&lt;code&gt;_val&lt;/code&gt;プレースホルダーがどこでも使えるようになり、セマンティックアクションのルールが統一される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spirit.Karmaに、2..36基数のunsigned numericジェネレータのサポートを追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Qi or Karmaのバグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int_(10)&lt;/code&gt;のような整数リテラルのパース失敗時に入力を消費してしまう問題を修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mmap_file_iterator&lt;/code&gt;の初期化に失敗する問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5246&#34; target=&#34;_blank&#34;&gt;#5246&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;karma::real_policies&lt;/code&gt;で&lt;code&gt;const&lt;/code&gt;浮動小数点数を使用する際の&lt;code&gt;const&lt;/code&gt; correctness問題を修正。パッチとテストを送付してくれたJeroen Habraken(a.k.a VeXocide)に感謝する。&lt;/li&gt;
&lt;li&gt;Spirit.Qi &lt;code&gt;attr(attrib)&lt;/code&gt;パーサー, Spirit.Qi &lt;code&gt;symbols&amp;lt;&amp;gt;&lt;/code&gt;パーサー, Spirit.Karma &lt;code&gt;symbols&amp;lt;&amp;gt;&lt;/code&gt;ジェネレータでのコンテナ属性のプロパティハンドルを修正。これはBoost V1.46.1で壊れていた(この問題を報告してくれたAaron Graham, Joerg Beckerに感謝する)。&lt;/li&gt;
&lt;li&gt;streamパーサーコンポーネントが成功したときに、もとになる入力ストリームのイテレータを正しく調整するようstream パーサーを修正。Stackoverflowで問題を報告してくれたBrian O’Kennedyに感謝する。&lt;/li&gt;
&lt;li&gt;アダプトされたADTを使用するときにKarma数値ジェネレータが失敗する問題を修正(問題を報告してくれたColin Rundelに感謝する)。
破壊的変更&lt;/li&gt;
&lt;li&gt;Spirit.Qi &lt;code&gt;repeat&lt;/code&gt;ディレクティブが失敗した場合に値を残し、その属性のコミット／ロールバックのセマンティクスを実装した。同様のコンポーネントが矛盾している動作を削除した。この機能に依存する既存のコードは破壊される。コードを修正する方法は、Spirit.Qi &lt;code&gt;hold&lt;/code&gt; ディレクティブを参照。&lt;/li&gt;
&lt;li&gt;コンパイル時間を大きく低下させていた定義済みターミナルのインスタンス化を防ぐために、&lt;code&gt;BOOST_SPIRIT_NO_PREDEFINED_TERMINALS&lt;/code&gt;プリプロセッサマクロを追加した。&lt;code&gt;BOOST_SPIRIT_NO_PREDEFINED_TERMINALS&lt;/code&gt; が定義されている場合は、ユーザーは必要なターミナルをインスタンス化する。したがって、&lt;code&gt;using qi::uint_&lt;/code&gt;の代わりに&lt;code&gt;qi::uint_type uint_&lt;/code&gt;のように書く。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Lexの新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lex::char_&lt;/code&gt;と&lt;code&gt;lex::string&lt;/code&gt;を使用して、トークンの定義を作成中にトークンの&lt;code&gt;id&lt;/code&gt;を指定することを可能にした。両方のプリミティブはこの定義から生成されたトークンの要求されたトークンIDとして解釈され、2番目のパラメータを受け付けるようになった。&lt;/li&gt;
&lt;li&gt;新たなトークン型&lt;code&gt;lex::lexertl::position_token&amp;lt;&amp;gt;&lt;/code&gt;を追加。これは本質的には、既存の&lt;code&gt;lex::lexertl::token&amp;lt;&amp;gt;&lt;/code&gt;によるプラグイン互換である。基になる入力シーケンスとして、&lt;code&gt;iterator_range&lt;/code&gt;を指すイテレータのペアを格納する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Lexのバグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アクションに添付されたトークン定義のすべての状態(状態名 &lt;code&gt;&#34;*&#34;&lt;/code&gt; を使用する)を関連付けて問題を修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Making Stuff Work&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性がコンテナの場合(&lt;code&gt;traits::is_container&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;を返す属性)に、古いカスタマイズポイント&lt;code&gt;traits::extract_from&lt;/code&gt;の代わりに呼び出される、Spirit.Karmaカスタマイズポイント&lt;code&gt;traits::extract_from_container&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hold_any&lt;/code&gt;型がテンプレート引数をとるようにした：&lt;code&gt;basic_hold_any&amp;lt;Char&amp;gt;&lt;/code&gt;。&lt;code&gt;Char&lt;/code&gt;は、ストリーム演算子(&lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;と&lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;)で使用される。&lt;code&gt;hold_any&lt;/code&gt;は、&lt;code&gt;typedef basic_hold_any&amp;lt;char&amp;gt; hold_any&lt;/code&gt;と定義される。&lt;/li&gt;
&lt;li&gt;セマンティックアクションで属性の互換性がサポートされた。これは破壊的な変更だが、&lt;code&gt;#define BOOST_SPIRIT_ACTIONS_ALLOW_ATTR_COMPAT&lt;/code&gt;で新しい動作を定義する必要がある。規定ではこれまでの動作である。&lt;/li&gt;
&lt;li&gt;属性互換性の選択肢をサポート。&lt;/li&gt;
&lt;li&gt;シーケンス&amp;amp;コンテナコンポーネント(list, Kleene, Plus, repeat)のコンテナ属性のための属性ハンドリングが書き直された。これによって多くの場合に予測可能な動作をするようになった。Thomas Taylor, Richard Crossley, Semen, Adalberto Casteloそして問題を報告し、支援してくれた方々に感謝する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#tokenizer&#34; name=&#34;tokenizer&#34;&gt;Tokenizer&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio で&lt;code&gt;/W4&lt;/code&gt;にてビルドすると、warning C4127(条件文が定数)がでる問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4649&#34; target=&#34;_blank&#34;&gt;#4699&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#utility&#34; name=&#34;utility&#34;&gt;Utility&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio 2010でwarning number 4284がなくなったことによるwarningの抑制(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4432&#34; target=&#34;_blank&#34;&gt;#4432&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#uuid&#34; name=&#34;uuid&#34;&gt;Uuid&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;例外を無効にした場合に&lt;code&gt;string_generator.hpp&lt;/code&gt;がコンパイルエラーになる問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5570&#34; target=&#34;_blank&#34;&gt;#5570&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;VC8での暗黙の型変換警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4601&#34; target=&#34;_blank&#34;&gt;#4601&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GHSコンパイラ(Green Hills Compiler)でこのライブラリが動作するようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/4991&#34; target=&#34;_blank&#34;&gt;#4991&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;論理演算子周りの警告を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5145&#34; target=&#34;_blank&#34;&gt;#5145&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;uuidのテストに、まだリリースされていない&lt;code&gt;lightweight_test_ex.hpp&lt;/code&gt;を使用していたので修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5235&#34; target=&#34;_blank&#34;&gt;#5235&lt;/a&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#wave&#34; name=&#34;wave&#34;&gt;Wave&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;V2.3.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma wave option()&lt;/code&gt; のプリプロセス後、連続した文字列リテラルを一つにまとめるようにした。&lt;/li&gt;
&lt;li&gt;空白文字のハンドリングを修正し、そのテストを追加 (&lt;code&gt;t_9_020.cpp&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;新しいプリプロセスフック &lt;code&gt;locate_include_file&lt;/code&gt; を追加。インクルードするファイルの決定方法をカスタマイズできる。&lt;/li&gt;
&lt;li&gt;Wave コマンドに新しいオプション &lt;code&gt;--noexpand&lt;/code&gt;/&lt;code&gt;-N&lt;/code&gt; を追加。指定した名前のマクロ（オブジェクト形式でも関数形式でもOK）の展開を抑制できる。このオプションは、出力結果中のマクロ全部が実行されないだけでなく、Wave自身からもその存在が消されるので、よく考えて使うべきである。もし展開を抑制されたマクロがあとでどこかの &lt;code&gt;#ifdef&lt;/code&gt; に影響がある場合、予期しない結果を引き起こす可能性がある。&lt;/li&gt;
&lt;li&gt;Wave コマンドの対話モードで、定義された全マクロをコマンドラインに出すのを修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5554&#34; target=&#34;_blank&#34;&gt;#5554&lt;/a&gt; の修正 (wave slex parser が &lt;code&gt;eol&lt;/code&gt; の前に &lt;code&gt;eof&lt;/code&gt; を見つけると最終行を処理しない問題)。&lt;/li&gt;
&lt;li&gt;コンパイル時のオプション設定に、&lt;code&gt;BOOST_WAVE_WCHAR_T_SIGNEDNESS&lt;/code&gt; を追加。これには &lt;code&gt;BOOST_WAVE_WCHAR_T_AUTOSELECT&lt;/code&gt;, &lt;code&gt;BOOST_WAVE_WCHAR_T_FORCE_SIGNED&lt;/code&gt;, または &lt;code&gt;BOOST_WAVE_WCHAR_T_FORCE_UNSIGNED&lt;/code&gt; を指定できる。デフォルトは auto select.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#pragma&lt;/code&gt; のオプション (output) を付けて実行した Wave コマンドがすぐに終了した場合、上書きせずに追記してしまう問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5569&#34; target=&#34;_blank&#34;&gt;#5569&lt;/a&gt; を修正 (slex の CONTLINE が LF で改行するファイルでしか動かない)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#boostbook&#34; name=&#34;boostbook&#34;&gt;BoostBook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;doxygenタグをハンドル : &lt;code&gt;\see&lt;/code&gt;, &lt;code&gt;tparam&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; (クラスのみ)&lt;/li&gt;
&lt;li&gt;クラスと関数のメモをサポート&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_47_0.html#quickbook&#34; name=&#34;quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;見出しの一貫性あるID生成&lt;/li&gt;
&lt;li&gt;WindowsでのUnicodeサポートを改善&lt;/li&gt;
&lt;li&gt;移植性のないWindowsのパスで警告を出力するようにした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[br]&lt;/code&gt;の非推奨を取りやめ&lt;/li&gt;
&lt;li&gt;copyright属性で、日付の範囲と、カンマ区切りされた節をサポート&lt;/li&gt;
&lt;li&gt;簡単なマークアップ(例えば&lt;strong&gt;bold&lt;/strong&gt;)のために、区切り文字のチェック機能を改善&lt;/li&gt;
&lt;li&gt;コードスニペット内でのコメントをそのまま使用するようにした&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__FILENAME__&lt;/code&gt;マクロが相対パスを生成するようにした&lt;/li&gt;
&lt;li&gt;コード内でエスケープによる強調表示を許可&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要テストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LLVM Clang 2.8&lt;/li&gt;
&lt;li&gt;GCC: 3.4.6, 4.2.4, 4.3.4, 4.3.5, 4.4.1, 4.4.3, 4.4.5, 4.5.1, 4.5.2, 4.6.0, 4.6.1&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.3.4, 4.4.3, 4.5.2&lt;/li&gt;
&lt;li&gt;Intel 12.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apple Clang 2.1&lt;/li&gt;
&lt;li&gt;Intel 11.1&lt;/li&gt;
&lt;li&gt;GCC: 4.2.1, 4.4.4&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.4.4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++ 7.1, 9.0, 10.0&lt;/li&gt;
&lt;li&gt;GCC, mingw: 4.4.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FreeBSD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GCC 4.2.1, 64 bit&lt;/li&gt;
&lt;li&gt;QNX:- QCC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加のテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clang from subversion, with GNU libstdc++.&lt;/li&gt;
&lt;li&gt;LLVM Clang 2.8&lt;/li&gt;
&lt;li&gt;GCC: 3.4.6, 4.2.4, 4.3.4, 4.3.5, 4.4.3, 4.4.5, 4.5.1, 4.5.2, 4.6.0, 4.6.1&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.3.4, 4.4.3, 4.5.2&lt;/li&gt;
&lt;li&gt;pgCC: 11.2&lt;/li&gt;
&lt;li&gt;Intel: 10.1, 11.0, 11.1, 12.0&lt;/li&gt;
&lt;li&gt;PathScale: 3.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS X:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clang from subversion, with GNU libstdc++.&lt;/li&gt;
&lt;li&gt;Intel 11.1&lt;/li&gt;
&lt;li&gt;GCC: 4.4.4&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode: 4.4.4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual C++ 7.1, 9.0, 10.0&lt;/li&gt;
&lt;li&gt;Visual C++ with STLport: 9.0&lt;/li&gt;
&lt;li&gt;Visual C++, Windows Mobile 5, with STLport: 9.0&lt;/li&gt;
&lt;li&gt;GCC, mingw: 4.5.2&lt;/li&gt;
&lt;li&gt;GCC, C++0x mode, mingw: 4.5.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AIX:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBM XL C/C++ Enterprise Edition, V11.1.0.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, zakkas783, digitalghost, yak_ex&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.勉強会 #13 仙台 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/study_meeting/study13.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:study_meeting/study13.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;Boost.勉強会 #13 仙台&lt;/h1&gt;
&lt;h2&gt;開催日時&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2013/10/19(土) 10:30～&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;開催場所&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;宮城県仙台市内 戦災復興記念館 第2会議室&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;募集ページ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://partake.in/events/6d6339e0-95df-4275-ba00-5e5344cb84f3#&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 @仙台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://partake.in/events/e16749f6-bb06-45bf-8f15-09a0b2b82506#&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 @仙台 懇親会&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;主催&amp;amp;スタッフ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;主催者： 橋本達明(&lt;a href=&#34;https://twitter.com/chichimotsu&#34; target=&#34;_blank&#34;&gt;@chichimotsu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;タイムテーブル&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;時間&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;th&gt;担当者&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10:00&lt;/td&gt;
&lt;td&gt;勉強会スタート&lt;/td&gt;
&lt;td&gt;@chichimotsu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10:00-10:15&lt;/td&gt;
&lt;td&gt;趣旨説明・タイムテーブル確認&lt;/td&gt;
&lt;td&gt;@chichimotsu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10:20-11:05&lt;/td&gt;
&lt;td&gt;Boost.Asioを使おう&lt;/td&gt;
&lt;td&gt;@chichimotsu&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11:10-11:55&lt;/td&gt;
&lt;td&gt;Boost.Randomで乱数を学ぼう&lt;/td&gt;
&lt;td&gt;@cpp_akira&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12:00-13:00&lt;/td&gt;
&lt;td&gt;昼休憩&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13:00-13:45&lt;/td&gt;
&lt;td&gt;boost::multiprecisionに勝負を挑んだのち，オリジナル三角形分割手法の実装&lt;/td&gt;
&lt;td&gt;@oniprog&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13:50-14:35&lt;/td&gt;
&lt;td&gt;boost::signals2とboost::anyで作ったiPhoneアプリ『ういろう』&lt;/td&gt;
&lt;td&gt;@5mingame2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14:35-14:50&lt;/td&gt;
&lt;td&gt;休憩&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14:50-15:35&lt;/td&gt;
&lt;td&gt;並列アルゴリズムライブラリThrustについて&lt;/td&gt;
&lt;td&gt;@krustf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15:40-16:35&lt;/td&gt;
&lt;td&gt;Wandbox を支える技術&lt;/td&gt;
&lt;td&gt;@melponn&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16:40-16:55&lt;/td&gt;
&lt;td&gt;アプリ紹介&lt;/td&gt;
&lt;td&gt;@about_hiroppy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17:00-17:15&lt;/td&gt;
&lt;td&gt;鳥小屋を支える技術＆問題点&lt;/td&gt;
&lt;td&gt;@yutopp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16:30&lt;/td&gt;
&lt;td&gt;閉会&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;ライブ配信&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ustream.tv/channel/boost-%E5%8B%89%E5%BC%B7%E4%BC%9A-13-%E4%BB%99%E5%8F%B0&#34; target=&#34;_blank&#34;&gt;http://www.ustream.tv/channel/boost-勉強会-13-仙台&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Twitterハッシュタグ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://twitter.com/search?q=%23boostjp&#34; target=&#34;_blank&#34;&gt;#boostjp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;発表内容&lt;/h2&gt;
&lt;h3&gt;Boost.Asioを使おう&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：橋本達明&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter： &lt;a href=&#34;https://twitter.com/chichimotsu&#34; target=&#34;_blank&#34;&gt;https://twitter.com/chichimotsu&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://www.slideshare.net/chichimotsu/asio&#34; target=&#34;_blank&#34;&gt;http://www.slideshare.net/chichimotsu/asio&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ:  &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIWlEtclpncjVSSFU/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 637MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Boost.Randomで乱数を学ぼう&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：高橋晶&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;サイト： &lt;a href=&#34;https://sites.google.com/site/faithandbrave/about&#34; target=&#34;_blank&#34;&gt;https://sites.google.com/site/faithandbrave/about&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：[&lt;a href=&#34;http://www.slideshare.net/faithandbrave/leanning-random-using-boost-random&#34; target=&#34;_blank&#34;&gt;slideshare&lt;/a&gt;][&lt;a href=&#34;https://dl.dropboxusercontent.com/u/1682460/presentation/boost_random/boost_random.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt;][&lt;a href=&#34;https://dl.dropboxusercontent.com/u/1682460/presentation/boost_random/boost_random.key&#34; target=&#34;_blank&#34;&gt;key&lt;/a&gt;]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ: &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIdmhSVEJHMkJHUlU/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4 動画 607MB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;アフターケア：&lt;a href=&#34;http://d.hatena.ne.jp/faith_and_brave/20131021/1382340838&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 仙台 - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;boost::multiprecisionに勝負を挑んだのち，オリジナル三角形分割手法の実装&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：oniprog&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twiter: &lt;a href=&#34;https://twitter.com/oniprog&#34; target=&#34;_blank&#34;&gt;https://twitter.com/oniprog&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://ohkuma.mydns.jp/homepage/tech/boost/boost_presen/Ohkuma_boost2.pdf&#34; target=&#34;_blank&#34;&gt;http://ohkuma.mydns.jp/homepage/tech/boost/boost_presen/Ohkuma_boost2.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ: &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKISlNhdElDX3NhaU0/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 393MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;boost::signals2とboost::anyで作ったiPhoneアプリ『ういろう』&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：西山信行&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/5mingame2&#34; target=&#34;_blank&#34;&gt;https://twitter.com/5mingame2&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：[&lt;a href=&#34;http://www.slideshare.net/5mingame2/iphoneboost&#34; target=&#34;_blank&#34;&gt;slideshare&lt;/a&gt;][&lt;a href=&#34;https://www.dropbox.com/s/96g3h8pvqjsmlji/iPhone%E3%82%A2%E3%83%97%E3%83%AA%E3%80%8E%E3%81%86%E3%81%84%E3%82%8D%E3%81%86%E3%80%8F%E3%81%A8boost.pptx&#34; target=&#34;_blank&#34;&gt;pptx&lt;/a&gt;]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ:&lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKId0Q3d3d2aWFmQ0U/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 478MB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;アフターケア：&lt;a href=&#34;http://blog.livedoor.jp/tek_nishi/archives/8109245.html&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 仙台 で発表してきた - でらうま倶楽部&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;並列アルゴリズムライブラリThrustについて&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者： krustf&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/krustf&#34; target=&#34;_blank&#34;&gt;https://twitter.com/krustf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://www.slideshare.net/krustf/thrust-27354206&#34; target=&#34;_blank&#34;&gt;http://www.slideshare.net/krustf/thrust-27354206&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ: &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIQ2pnR0w3TDZEcTQ/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 364MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Wandbox を支える技術&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：melpon&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/melponn&#34; target=&#34;_blank&#34;&gt;https://twitter.com/melponn&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://melpon.org/pub/wandbox&#34; target=&#34;_blank&#34;&gt;http://melpon.org/pub/wandbox&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ: &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIUjE3aWpIRGhTRjQ/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 784MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;アプリ紹介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：about_hiroppy&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/about_hiroppy&#34; target=&#34;_blank&#34;&gt;https://twitter.com/about_hiroppy&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;メモアプリLabelial&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://about-hiroppy.com/Labelial/index.html&#34; target=&#34;_blank&#34;&gt;http://about-hiroppy.com/Labelial/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ:  &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKIbVMxNnE2TkEyMVE/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 156MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;鳥小屋を支える技術＆問題点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;発表者：yutopp&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Twitter : &lt;a href=&#34;https://twitter.com/yutopp&#34; target=&#34;_blank&#34;&gt;https://twitter.com/yutopp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料：&lt;a href=&#34;http://www.slideshare.net/yutopp/boost-13&#34; target=&#34;_blank&#34;&gt;http://www.slideshare.net/yutopp/boost-13&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ビデオ:  &lt;a href=&#34;https://docs.google.com/file/d/0B9BH0LS6wCKISkxQZW8xWC1TVnM/edit?usp=sharing&#34; target=&#34;_blank&#34;&gt;MP4動画 210MB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;関連リンク&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/faith_and_brave/20131021/1382340838&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 仙台 - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.livedoor.jp/tek_nishi/archives/8109245.html&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 仙台 で発表してきた - でらうま倶楽部&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://togetter.com/li/579014&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #13 ＠仙台 - togetter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンパイラ間の差を吸収する -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/tips/config.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:tips/config.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンパイラ間の差を吸収する&lt;/h1&gt;
&lt;p&gt;ここでは、コンパイラ間の差を吸収するための方法を挙げる。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#support-cpp11&#34;&gt;コンパイラが、あるC++11の機能をサポートしているかどうかでコードを変更する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#deduced-typename&#34;&gt;コンパイラによって、テンプレート中の &lt;code&gt;hoge&amp;lt;T&amp;gt;::type x;&lt;/code&gt; や &lt;code&gt;fuga.f();&lt;/code&gt; がコンパイルエラーになったりならなかったりする問題を回避する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#nested-template&#34;&gt;メンバ関数テンプレートの呼び出しでコンパイルエラーになる問題を回避する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#support-cpp11&#34; name=&#34;support-cpp11&#34;&gt;コンパイラが、あるC++11の機能をサポートしているかどうかでコードを変更する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下は可変長テンプレート引数をサポートしているコンパイラならそれを使い、そうでなければ Boost.Preprocessor などでエミュレートする例&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/config.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#if defined BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/repetition/enum_params.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/repetition/enum_binary_params.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  include &amp;lt;boost/preprocessor/facilities/intercept.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 他色々&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  if !defined MAX_PARAM_LIMIT&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#    define MAX_PARAM_LIMIT 10&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#  endif&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#endif&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#if !defined BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; ...T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T ...x) {
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// fの定義&lt;/span&gt;
}

&lt;span style=&#34;color: #BC7A00&#34;&gt;#else&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// fの定義（長くなるので省略）&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boost/config.hpp&lt;/code&gt; をインクルードすると、コンパイラやバージョンに応じて &lt;code&gt;BOOST_NO_&lt;/code&gt;&lt;em&gt;FEATURE_NAME&lt;/em&gt; が定義される。定義されているマクロ名に対応した機能は、そのコンパイラでは使えない。&lt;/p&gt;
&lt;p&gt;以下はそのマクロ一覧である。C++11の新機能については各々で調べたし。&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;マクロ名&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ALIGNAS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の&lt;code&gt;alignas&lt;/code&gt;キーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ALLOCATOR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11バージョンの&lt;code&gt;std::allocator&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_ATOMIC_SP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11のスマートポインタがアトミック操作をサポートしているか&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_ARRAY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/array.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CHRONO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/chrono.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CODECVT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/codecvt.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_CONDITION_VARIABLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/condition_variable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;condition_variable&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FORWARD_LIST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/forward_list.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FUNCTIONAL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11バージョンと互換のある&lt;a href=&#34;http://cpprefjp.github.io/reference/functional.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_FUTURE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/future.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;future&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_INITIALIZER_LIST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/initializer_list.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;initializer_list&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ。 変数の初期化を &lt;code&gt;{1, 2, 3}&lt;/code&gt; のような記述で行う&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_MUTEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/mutex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;mutex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_RANDOM&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/random.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_RATIO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/ratio.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_REGEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/regex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_SYSTEM_ERROR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/system_error.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_THREAD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/thread.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;thread&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TUPLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/tuple.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;tuple&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TYPEINDEX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/typeindex.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;typeindex&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_TYPE_TRAITS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/type_traits.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_UNORDERED_MAP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/unordered_map.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_HDR_UNORDERED_SET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11の標準ライブラリ&lt;a href=&#34;http://cpprefjp.github.io/reference/unordered_set.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_INLINE_NAMESPACES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;inline namespace&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_SMART_PTR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;C++11のスマートポインタ、&lt;code&gt;shared_ptr&lt;/code&gt;と&lt;code&gt;unique_ptr&lt;/code&gt;を提供しているか&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_AUTO_DECLARATIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto&lt;/code&gt; による変数の型の自動決定&lt;br /&gt; &lt;code&gt;// x の型は初期化式 expr から自動的に決定する&lt;/code&gt;&lt;br /&gt; &lt;code&gt;auto x = expr;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;auto&lt;/code&gt; での宣言で、一度に複数の変数を宣言する&lt;br /&gt; &lt;code&gt;auto x = expr1, y = expr2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CHAR16_T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;組み込み型 &lt;code&gt;char16_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CHAR32_T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;組み込み型 &lt;code&gt;char32_t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_TEMPLATE_ALIASES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;template&lt;/code&gt; による別名宣言。&lt;br /&gt; &lt;code&gt;template&amp;lt;typename T&amp;gt; using my_vector = std::vector&amp;lt;T, my_allocator&amp;lt;T&amp;gt; &amp;gt;;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;my_vector&amp;lt;T&amp;gt; v;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_CONSTEXPR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンパイル時に計算して定数に畳み込むことが可能なことを示す修飾子&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DECLTYPE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boost.Typeof のように式から型を取得する&lt;br /&gt; &lt;code&gt;// x は expr1 の型として宣言され、&lt;/code&gt;&lt;br /&gt; &lt;code&gt;// expr2 で初期化される&lt;/code&gt;&lt;br /&gt;&lt;code&gt;decltype(expr1) x = expr2;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DECLTYPE_N3276&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;N3276仕様の&lt;code&gt;decltype&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DEFAULTED_FUNCTIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ、コピー代入演算子、デストラクタをデフォルト実装で宣言する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_DELETED_FUNCTIONS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の &lt;code&gt;delete&lt;/code&gt; 宣言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;型変換演算子に対する &lt;code&gt;explicit&lt;/code&gt; 宣言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_EXTERN_TEMPLATE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;テンプレートのインスタンス化をその翻訳単位では行わないようにする&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数テンプレートのテンプレートパラメータにデフォルト引数を指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_LAMBDAS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ラムダ式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ローカルクラスをテンプレートパラメータに指定する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_LONG_LONG&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(unsigned) long long&lt;/code&gt; 型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_NOEXCEPT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;noexcept&lt;/code&gt;キーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_NULLPTR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ヌルポインタを示すキーワード&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_RANGE_BASED_FOR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;範囲&lt;code&gt;for&lt;/code&gt;文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;`BOOST_NO_CXX11_RAW_LITERALS&lt;/td&gt;
&lt;td&gt;文字列リテラルの新しい表記法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_RVALUE_REFERENCES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右辺値参照型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_SCOPED_ENUMS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;スコープ付きの列挙型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_STATIC_ASSERT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条件式によってコンパイルエラーにするための &lt;code&gt;static_assert&lt;/code&gt; 文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_STD_UNORDERD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unordered_set&lt;/code&gt;, &lt;code&gt;unordered_multiset&lt;/code&gt;, &lt;code&gt;unordered_map&lt;/code&gt;, &lt;code&gt;unordered_multimap&lt;/code&gt; の4つのコンテナクラステンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_TRAILING_RESULT_TYPES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;関数の戻り値型を後置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_UNICODE_LITERALS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unicode 文字・文字列リテラル(&lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタの呼び出しを初期化子リストと同じ構文で記述する&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_USER_DEFINED_LITERALS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ユーザー定義リテラル&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_VARIADIC_TEMPLATES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変引数テンプレート&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BOOST_NO_CXX11_VARIADIC_MACROS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可変引数マクロ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#deduced-typename&#34; name=&#34;deduced-typename&#34;&gt;コンパイラによって、テンプレート中の &lt;code&gt;hoge&amp;lt;T&amp;gt;::type x;&lt;/code&gt; や &lt;code&gt;fuga.f();&lt;/code&gt; がコンパイルエラーになったりならなかったりする問題を回避する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; hoge {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; type;
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f(T x) {
    T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;type x; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a)&lt;/span&gt;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g() {
    hoge x;
    f(x); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この部分をコンパイルしようとすると (a) でコンパイルエラーが起きる&lt;/span&gt;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;関数テンプレートもしくはクラステンプレート内で、上の &lt;code&gt;f&lt;/code&gt; のように内部でテンプレートパラメータの内部で宣言された型名を利用する場合、(a) の箇所では、&lt;code&gt;T::type&lt;/code&gt; が型名であることを示す必要がある。具体的には &lt;code&gt;typename&lt;/code&gt; キーワードを使って、 &lt;code&gt;typename T::type x;&lt;/code&gt; のように記述する。しかし古いコンパイラなどでは、&lt;code&gt;typename&lt;/code&gt; を付けずとも空気を読んで &lt;code&gt;T::type&lt;/code&gt; が型であると判断することで、&lt;code&gt;typename&lt;/code&gt; キーワードそのものをサポートしていない場合がある。次のように記述することで、この問題は回避可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f() {
    BOOST_DEDUCED_TYPENAME T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;type x;
    &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BOOST_DEDUCED_TYPENAME&lt;/code&gt; マクロは、普通 &lt;code&gt;typename&lt;/code&gt; になるが、かかる位置での &lt;code&gt;typename&lt;/code&gt; をサポートしていないコンパイラでは空に展開される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/config.html#nested-template&#34; name=&#34;nested-template&#34;&gt;メンバ関数テンプレートの呼び出しでコンパイルエラーになる問題を回避する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上記の &lt;code&gt;typename&lt;/code&gt; と似たような問題で、次のようなコードがコンパイラによって通ったり通らなかったりする：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; hoge {
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f() {}
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; fuga {};
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a)&lt;/span&gt;
    T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b)&lt;/span&gt;
}

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; h() {
    hoge x;
    g(x); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// この関数呼び出しをコンパイルしようとすると (a) や (b) の箇所でコンパイルエラーが起きる&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;(a) は &lt;code&gt;int&lt;/code&gt; で実体化したメンバ関数テンプレートの呼び出しとは認識されず、(b) もメンバクラステンプレートを &lt;code&gt;int&lt;/code&gt; で実体化した型の変数の宣言とは見なされない。次のように記述する必要がある。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a’)&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b’)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;(a’) では &lt;code&gt;f&lt;/code&gt; の前に &lt;code&gt;template&lt;/code&gt; キーワードを付けて、&lt;code&gt;f&lt;/code&gt; がテンプレートであることを明記している。(b’) も同様に &lt;code&gt;fuga&lt;/code&gt; がテンプレートであると示しているが、同時に &lt;code&gt;T::template fuga&amp;lt;int&amp;gt;&lt;/code&gt; が型であることも示すために &lt;code&gt;typename&lt;/code&gt; も付けている。しかし上の &lt;code&gt;typename&lt;/code&gt; の問題と同様に、この &lt;code&gt;template&lt;/code&gt; キーワードの使い方をサポートしないコンパイラが存在する。これについては &lt;code&gt;BOOST_NESTED_TEMPLATE&lt;/code&gt; マクロを使うことで解決する。次のように使う：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; g(T &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; x) {
    x.BOOST_NESTED_TEMPLATE f&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (a&#39;)&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;BOOST_NESTED_TEMPLATE fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; y; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// (b&#39;)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;この &lt;code&gt;template&lt;/code&gt; キーワードの使い方をサポートするコンパイラでは &lt;code&gt;template&lt;/code&gt; と展開され、そうでないコンパイラでは空に展開される。&lt;/p&gt;
&lt;p&gt;documented boost version is 1.51.0&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>構文解析 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/tips/parser.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:tips/parser.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;構文解析&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;本稿は記述途中です。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/index.html&#34; target=&#34;_blank&#34;&gt;Boost Spirit&lt;/a&gt; ライブラリ、特にその中の &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi.html&#34; target=&#34;_blank&#34;&gt;Qi&lt;/a&gt; を用いることにより構文解析器を作成することが可能である。&lt;/p&gt;
&lt;p&gt;文法、アクションを記述したファイルを元に C/C++ ソースを生成する yacc や bison といった伝統的なパーサジェネレータとは異なり、Spirit Qi では C++ 内で文法、アクションの記述を完結させることができる。また、対象とする文法も文脈自由文法のような伝統的なクラスではなく解析表現文法(PEG: Parsing Expression Grammar)である(一般に解析表現文法は自然言語の解析には適しておらずコンピュータ言語の解析に適している)。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#api&#34;&gt;1 API&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#check-all-consume&#34;&gt;1.1 入力を全て消費したかを確認する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#skip&#34;&gt;1.2 空白等を読み飛ばす&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#get-parsed-result&#34;&gt;1.3 解析された値を受け取る&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2 ルール&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#primitive&#34;&gt;2.1 プリミティブ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#directive&#34;&gt;2.2 ディレクティブ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#operator&#34;&gt;2.3 演算子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#semantic-action&#34;&gt;2.4 セマンティックアクション&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#nonterminal&#34;&gt;2.5 非終端記号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-reference&#34;&gt;3 逆引き&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-skip&#34;&gt;3.1 空白等を読み飛ばしたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-find&#34;&gt;3.2 特定の文字列で終了する部分まで読み出したい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-default-value&#34;&gt;3.3 デフォルト値を与えたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-check-condition&#34;&gt;3.4 条件によって構文解析を途中で失敗させたい&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-as-string&#34;&gt;3.5 ある範囲全体の結果を文字列として得たい&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#api&#34; name=&#34;api&#34;&gt;API&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;構文解析の実施は &lt;code&gt;parse()&lt;/code&gt; 関数、あるいは &lt;code&gt;phrase_parse()&lt;/code&gt; 関数を呼び出すことによって行う。&lt;code&gt;parse()&lt;/code&gt; 関数と &lt;code&gt;phrase_parse()&lt;/code&gt; 関数の違いは、&lt;code&gt;phrase_parse()&lt;/code&gt; が空白等の読み飛ばし(後述する&lt;code&gt;Skipper&lt;/code&gt;)を行う一方、&lt;code&gt;parse()&lt;/code&gt; 関数は読み飛ばしを行わない点である。&lt;code&gt;phrase_parse()&lt;/code&gt; については&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#skip&#34;&gt;空白等を読み飛ばす&lt;/a&gt;を参照。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; spirit { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi {
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Expr&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; parse(
        Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; first
      , Iterator last
      , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Expr&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; expr);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Expr
      , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Attr1, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Attr2, ..., &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; AttrN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; parse(
        Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; first
      , Iterator last
      , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Expr&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; expr
      , Attr1&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attr1, Attr2&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attr2, ..., AttrN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attrN);
}}}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parse()&lt;/code&gt;関数の引数・戻り値は、以下を意味する：&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;引数・戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;td&gt;解析が成功したかどうか。&lt;br /&gt;入力が余っている場合でも解析が完了した場合は &lt;code&gt;true&lt;/code&gt; を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;first&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非 &lt;code&gt;const&lt;/code&gt; 参照で受け、かつ、値が変更されるため &lt;code&gt;s.begin()&lt;/code&gt; 等は直接渡せない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;last&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;終端のイテレータ。参照ではなく値であるため、&lt;code&gt;s.end()&lt;/code&gt;の戻り値を直接渡せる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ルール(文法部分) 後述　この場合は1つの整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;attrN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取った値の格納先&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123 456&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(
    first,
    last,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK が出力される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#check-all-consume&#34; name=&#34;check-all-consume&#34;&gt;1.1 入力を全て消費したかを確認する&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parse()&lt;/code&gt; 関数、&lt;code&gt;phrase_parse()&lt;/code&gt; 関数の第1引数であるイテレータへの参照は、解析中に更新されていく。そのため構文解析中に入力が全て消費されたか確認したい場合は、第2引数に渡した値と比較すれば良い。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123 456&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(
    first,
    last,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; first &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; last) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK は出力されない&lt;/span&gt;

s &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123&#34;&lt;/span&gt;; first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(); last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(first, last, qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; first &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; last) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK が出力される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#skip&#34; name=&#34;skip&#34;&gt;1.2 空白等を読み飛ばす&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前述の通り &lt;code&gt;phrase_parse()&lt;/code&gt; 関数を用いる。関数呼び出しの際にどのような内容を読み飛ばすかを第4引数にルールの形で指定する(&lt;code&gt;Skipper&lt;/code&gt; と呼ばれる)。非終端記号（後述）を使用している場合は、その非終端記号の型に &lt;code&gt;Skipper&lt;/code&gt; の型を指定してやる必要があることに注意（FAQ）。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; spirit { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi {

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Expr, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Skipper&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; phrase_parse(
        Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; first
      , Iterator last
      , Expr &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; expr
      , Skipper &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; skipper
      , BOOST_SCOPED_ENUM(skip_flag) post_skip &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; skip_flag&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;postskip);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Expr, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Skipper
      , &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Attr1, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Attr2, ..., &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; AttrN&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; phrase_parse(
        Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; first
      , Iterator last
      , Expr &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; expr
      , Skipper &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; skipper
      , Attr1&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attr1, Attr2&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attr2, ..., AttrN&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; attrN);

}}}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;引数・戻り値&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;戻り値&lt;/td&gt;
&lt;td&gt;解析が成功したかどうか。&lt;br /&gt;入力が余っている場合でも解析が完了した場合は &lt;code&gt;true&lt;/code&gt; を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;first&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非 &lt;code&gt;const&lt;/code&gt; 参照で受け、かつ、値が変更されるため &lt;code&gt;s.begin()&lt;/code&gt; 等は直接渡せない&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;last&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;終端のイテレータ。参照ではなく値であるため、&lt;code&gt;s.end()&lt;/code&gt;の戻り値を直接渡せる&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ルール(文法部分) 後述　この場合は1つの整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;skipper&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み飛ばす条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;attrN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;読み取った値の格納先&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;   123&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phrase_parse(
    first,
    last,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Skipper この場合は任意の空白&lt;/span&gt;
              &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 勝手に繰り返し呼び出されるので繰り返し分を明示的に指定する必要はない&lt;/span&gt;
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK が出力される&lt;/span&gt;

first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin();
success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(first, last, qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 最初の空白で失敗するため OK は出力されない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#get-parsed-result&#34; name=&#34;get-parsed-result&#34;&gt;1.3 解析された値を受け取る&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parse()&lt;/code&gt; 関数、&lt;code&gt;phrase_parse()&lt;/code&gt; 関数のいずれも追加で読み取った値を受け取る変数を渡すことができる。複数の値を読み取る場合は複数の変数を渡すことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;123 456&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n1, n2;
&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phrase_parse(
    first,
    last,
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_ &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 2つの整数&lt;/span&gt;
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space,
    n1, n2                &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 読み取った値の格納先&lt;/span&gt;
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK: 123, 456 が出力される&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK: &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; n1 &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;, &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; n2 &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#rule&#34; name=&#34;rule&#34;&gt;2 ルール&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ルールはプリミティブ、ディレクティブ、演算子を組み合わせることによって表現される。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#primitive&#34; name=&#34;primitive&#34;&gt;2.1 プリミティブ&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字を読むプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/char.html&#34; target=&#34;_blank&#34;&gt;Character Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;数値を読むプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/numeric.html&#34; target=&#34;_blank&#34;&gt;Numeric Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;文字列を読むプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/string.html&#34; target=&#34;_blank&#34;&gt;String Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;バイナリ値を読むプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/binary.html&#34; target=&#34;_blank&#34;&gt;Binary Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;補助的なプリミティブのリストについては &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/auxiliary.html&#34; target=&#34;_blank&#34;&gt;Auxiliary Parsers&lt;/a&gt; を参照。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;※後で適当に丸めて翻訳して入れる&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#directive&#34; name=&#34;directive&#34;&gt;2.2 ディレクティブ&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ディレクティブのリストは &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/directive.html&#34; target=&#34;_blank&#34;&gt;Parser Directives&lt;/a&gt; を参照。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;※後で翻訳して入れる&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#operator&#34; name=&#34;operator&#34;&gt;2.3 演算子&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;演算子のリストは &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/qi_parsers/operator.html&#34; target=&#34;_blank&#34;&gt;Parser Operators&lt;/a&gt; を参照。&lt;/li&gt;
&lt;li&gt;属性（読み取る値）の型については &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/quick_reference/compound_attribute_rules.html&#34; target=&#34;_blank&#34;&gt;Compound Attribute Rules&lt;/a&gt; を参照。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;※後で翻訳して入れる&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#semantic-action&#34; name=&#34;semantic-action&#34;&gt;セマンティックアクション&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#nonterminal&#34; name=&#34;nonterminal&#34;&gt;非終端記号&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;rule&lt;/code&gt;型を用いることで、ルールに名前をつけることができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Iterator の型以外は省略可能で、順序も自由&lt;/span&gt;
qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator, &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 解析対象の Iterator の型 ※しばしば template 引数&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;),             &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 属性の型 ※関数型として指定し戻り値の型が読み取る値 ※省略可能&lt;/span&gt;
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;locals&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;,       &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ローカル変数の型 ※省略可能&lt;/span&gt;
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space_type         &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Skipper の型 ※省略可能　Skipper を使いたい時には忘れず指定すること&lt;/span&gt;
                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ※指定しなくともコンパイルできてしまうが望み通りの挙動とならない&lt;/span&gt;
&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; int_pair;
int_pair &lt;span style=&#34;color: #666666&#34;&gt;%=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_[qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_a &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_1] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_(qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_a); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 同じ数字の2回の繰り返し&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// int_pair の任意の回数の繰り返し&lt;/span&gt;
qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;), qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; int_pairs &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;int_pair;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;また複数の &lt;code&gt;rule&lt;/code&gt; の固まりを &lt;code&gt;grammar&lt;/code&gt; としてまとめることもできる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; Iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; mygrammar &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;grammar&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iterator, A1, A2, A3&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// start_rule の template 引数と一致すること&lt;/span&gt;
{
    mygrammar() &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; mygrammar&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;base_type(start_rule, name)
    {
        start_rule &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;/* */&lt;/span&gt;;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;/* 他の rule の定義 */&lt;/span&gt;
    }
    qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Iterator, A1, A2, A3&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; start_rule;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;/* 他の rule の宣言 */&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-reference&#34; name=&#34;reverse-reference&#34;&gt;3 逆引き&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-skip&#34; name=&#34;reverse-skip&#34;&gt;3.1 空白等を読み飛ばしたい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;phrase_parse()&lt;/code&gt; と &lt;code&gt;Skipper&lt;/code&gt; を使う。&lt;code&gt;rule&lt;/code&gt;型 や &lt;code&gt;grammar&lt;/code&gt;型 を使う場合は &lt;code&gt;Skipper&lt;/code&gt; の型を指定する必要があることに注意すること。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;   123&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();

qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(), &lt;span style=&#34;color:#ff0000&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space_type&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; rule &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Skipper の型指定&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff0000&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phrase_parse&lt;/span&gt;( &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// phrase_parse() を使用&lt;/span&gt;
    first,
    last,
    rule,
    &lt;span style=&#34;color:#ff0000&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;space&lt;/span&gt; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// Skipper この場合は任意の空白&lt;/span&gt;
              &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 勝手に繰り返し呼び出されるので繰り返し分を明示的に指定する必要はない&lt;/span&gt;
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;OK&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// OK が出力される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-find&#34; name=&#34;reverse-find&#34;&gt;3.2 特定の文字列で終了する部分まで読み出したい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;文字列 &lt;code&gt;&#34;end&#34;&lt;/code&gt; までの任意の文字列(&lt;code&gt;&#34;end&#34;&lt;/code&gt; を含まない)を読み出したい場合は以下のようなルールを用いれば良い。読み飛ばしたい場合は &lt;code&gt;qi::omit&lt;/code&gt; ディレクティブを使えばよい。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;char_ &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;end&#34;&lt;/span&gt;)) &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;end&#34;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-default-value&#34; name=&#34;reverse-default-value&#34;&gt;3.3 デフォルト値を与えたい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;例えば文字列 &lt;code&gt;&#34;value:&#34;&lt;/code&gt; に続いて数値がある場合はその数値を、ない場合はデフォルト値 &lt;code&gt;42&lt;/code&gt; を返したい場合は以下のように &lt;code&gt;qi::attr&lt;/code&gt; を使用すればよい。省略された場合にさらに数値が続く場合は省略されているか否かが判別できずにうまくいかない（場合が多い）ので注意。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;value:&#34;&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; (qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_ &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;attr&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;42&lt;/span&gt;) )
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-check-condition&#34; name=&#34;reverse-check-condition&#34;&gt;3.4 条件によって構文解析を途中で失敗させたい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通常は何もせず常に成功するプリミティブ &lt;code&gt;qi::eps&lt;/code&gt; （※特定のタイミングでセマンティックアクションを実行させたい場合等に使う）に遅延評価される引数を与えることで実現できる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; phx &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phoenix;
&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 読み出した整数が 42 以外の時だけ成功する&lt;/span&gt;
qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;rule&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; rule &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;int_[phx&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ref(n) &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_1] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;eps&lt;/span&gt;(phx&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ref(n) &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;42&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/tips/parser.html#reverse-as-string&#34; name=&#34;reverse-as-string&#34;&gt;3.5 ある範囲全体の結果を文字列として得たい&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;例えば改行で終端される空白区切りの文字列を得たい場合、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;char_(&lt;span style=&#34;color: #BA2121&#34;&gt;&#39; &#39;&lt;/span&gt;)) &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit_(&lt;span style=&#34;color: #BA2121&#34;&gt;&#39;\n&#39;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;をルールとすると空白を除いた文字列が得られることになるが場合によっては空白を含む文字列全体を得たい場合があるかもしれない。あるいは、単純に構成すると文字列のリスト(&lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt;)が属性の型となってしまうが欲しいのはリストではなく文字列である場合もあるだろう。こうした場合、&lt;code&gt;qi::raw&lt;/code&gt; ディレクティブを使うのが簡単である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/spirit/include/qi.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; qi &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;spirit&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;qi;

std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;a b c&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;);
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator first &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.begin(), last &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; s.end();
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string value;

&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; success &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;parse(
    first,
    last,
    &lt;span style=&#34;color:#ff0000&#34;&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;raw&lt;/span&gt;[(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;graph &lt;span style=&#34;color: #666666&#34;&gt;%&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#39; &#39;&lt;/span&gt;))] &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; qi&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lit(&lt;span style=&#34;color: #BA2121&#34;&gt;&#39;\n&#39;&lt;/span&gt;),
    value
);
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (success) { std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; value &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl; } &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// a b c が出力される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>優先順位を付けて並べ替える -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/tips/priority_sort.html"/>
      <id>35b61155dc805e43c659694e1ce1711d792dda4a:tips/priority_sort.md</id>
      <updated>2015-01-17 00:39:06 +0900</updated>
      
        <content type="html">&lt;h1&gt;優先順位を付けて並べ替える&lt;/h1&gt;
&lt;p&gt;ここでは、優先順位を付きのオブジェクト比較と、それによる並べ替えの方法を示す。優先順位付きの比較とは、Windowsのエクスプローラで言うところの「ファイル種別順に並べて、同じファイル種別のものはファイル名順に並べる」というようなものである。
このような比較方法は、一覧画面のようなものを作る場合に必要となる。&lt;/p&gt;
&lt;p&gt;優先順位付きの比較には、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/&#34; target=&#34;_blank&#34;&gt;Boost Fusion Library&lt;/a&gt;が提供するタプル型を使用する。タプルとは、異なる複数の型からなるシーケンスである。&lt;a href=&#34;http://cpprefjp.github.io/reference/utility/pair.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/a&gt;が2つの異なる型のオブジェクトを格納するのに対して、タプルは任意個のオブジェクトを格納できる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/&#34; target=&#34;_blank&#34;&gt;Boost.Fusion&lt;/a&gt;が提供するタプルは比較演算子を持っており、それがちょうど前述した「ファイル種別順に並べて、同じファイル種別のものはファイル名順に並べる」という意味論での比較を行う。&lt;/p&gt;
&lt;p&gt;クラスのメンバ変数をタプルに変換することにより、優先順位付きの比較が可能となる。&lt;/p&gt;
&lt;p&gt;以下がその例である：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;algorithm&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/fusion/include/comparison.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/fusion/include/&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; File {
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string type;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string name;

    File(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; type, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; name)
        &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; type(type), name(name) {}
};

&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; a, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; b)
{
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ファイル種別、ファイル名の順番で優先順位を付けて比較&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; fusion &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;fusion;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; fusion&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;(a.type, a.name) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; fusion&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#ff0000&#34;&gt;vector_tie&lt;/span&gt;(b.type, b.name);
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; main()
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;File&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; files &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; {
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;text&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;b.txt&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;application&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;b.exe&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;application&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;a.exe&#34;&lt;/span&gt;},
        {&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;text&#34;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;a.txt&#34;&lt;/span&gt;}
    };

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 並べ替え&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;sort(files.begin(), files.end());

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; File&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; file &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; files) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; file.type &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;, &#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; file.name &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;出力：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;application, a.exe
application, b.exe
text, a.txt
text, b.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;ファイルが、ファイル種別順に並んだ上で、種別が同じファイルは名前で並べ替えられていることがわかるだろう。&lt;/p&gt;
&lt;p&gt;このプログラムでは、&lt;code&gt;File&lt;/code&gt;クラスの&lt;code&gt;operator&amp;lt;()&lt;/code&gt;演算子において「ファイル種別でどちらが小さいかを比較し、同じであればファイル名がどちらが小さいかを比較する」という優先順位付き比較を行なっている。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/container/generation/functions/vector_tie.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::fusion::vector_tie()&lt;/code&gt;&lt;/a&gt;関数は、引数として受け取った変数への参照から、参照のタプル型を構築する。ここでは、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/container/vector.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;boost::fusion::vector&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;const std::string&amp;amp;, const std::string&amp;amp;&amp;gt;&lt;/code&gt;という型のタプルオブジェクトを構築する。&lt;/p&gt;
&lt;p&gt;Boost.Fusionが提供するタプル型に対する比較演算子は、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/fusion/doc/html/fusion/sequence/operator/comparison.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;&amp;lt;boost/fusion/include/comparison.hpp&amp;gt;&lt;/code&gt;&lt;/a&gt;ヘッダで定義されている。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参照：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cpprefjp.github.io/reference/algorithm/lexicographical_compare.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::lexicographical_compare()&lt;/code&gt; - cpprefjp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>第3回 C++Now! 読書会 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/cpp_online_reading/archive_003.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:archive/cpp_online_reading/archive_003.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;第3回 C++Now! 読書会&lt;/h1&gt;
&lt;h2&gt;日時&lt;/h2&gt;
&lt;p&gt;2012/09/23 13:00-&lt;/p&gt;
&lt;h2&gt;資料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#haskell-pseudo-cpp&#34;&gt;Haskell - C++テンプレートメタプログラミングのための擬似言語&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;参加者リスト&lt;/h2&gt;
&lt;p&gt;2名。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LNSEAB&lt;/li&gt;
&lt;li&gt;manga_osyo&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;ログ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://lingr.com/room/reading_cpp_now_2012_doc/archives/2012/09/23#message-12089750&#34; target=&#34;_blank&#34;&gt;http://lingr.com/room/reading_cpp_now_2012_doc/archives/2012/09/23#message-12089750&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/osyo-manga/20120923/1348379488&#34; target=&#34;_blank&#34;&gt;http://d.hatena.ne.jp/osyo-manga/20120923/1348379488&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>第4回 C++Now! 読書会 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/cpp_online_reading/archive_004.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:archive/cpp_online_reading/archive_004.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;第4回 C++Now! 読書会&lt;/h1&gt;
&lt;h2&gt;日時&lt;/h2&gt;
&lt;p&gt;2012/10/07 13:00-&lt;/p&gt;
&lt;h2&gt;資料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#haskell-pseudo-cpp&#34;&gt;Haskell - C++テンプレートメタプログラミングのための擬似言語&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;参加者リスト&lt;/h2&gt;
&lt;p&gt;4名。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lindan&lt;/li&gt;
&lt;li&gt;manga_osyo&lt;/li&gt;
&lt;li&gt;saki7&lt;/li&gt;
&lt;li&gt;yutopp&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;ログ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://lingr.com/room/reading_cpp_now_2012_doc/archives/2012/10/07#message-12332231&#34; target=&#34;_blank&#34;&gt;http://lingr.com/room/reading_cpp_now_2012_doc/archives/2012/10/07#message-12332231&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;関連&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/osyo-manga/20120923/1348379488&#34; target=&#34;_blank&#34;&gt;http://d.hatena.ne.jp/osyo-manga/20120923/1348379488&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BoostCon 2010 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/boostcon/2010.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:boostcon/2010.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;BoostCon 2010&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/&#34; target=&#34;_blank&#34;&gt;2010 Program - boostcon&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/2010_presentations&#34; target=&#34;_blank&#34;&gt;BoostCon 2010 Presentations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#clang-lib&#34;&gt;Clang: オープンソースのC++コンパイラライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#generic-programming-graph-lib&#34;&gt;ジェネリックプログラミングとBoost Graph Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#geometry&#34;&gt;幾何学のためのジェネリックプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#instantiations-must-go&#34;&gt;Instantiations Must Go!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-update&#34;&gt;C++0x update&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#exception-safety&#34;&gt;C++での例外使用に関するガイドラインの再考 - 例外安全なコードを効果的に設計するための10の助言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-rad-framework&#34;&gt;RAD Spiritのためのフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#is-boost-broken&#34;&gt;Is Boost Broken?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#data-structure-visualizers&#34;&gt;Data Structure Visualizers in Visual Studio 2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#alabaster&#34;&gt;Boost.Alabaster: A Law Based Tester&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tool-builder&#34;&gt;C++ Tool-Builders Workshop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-concurrency&#34;&gt;C++0x Concurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#basic-lock-free&#34;&gt;Lock-freeプログラミングの基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tboost-stm&#34;&gt;TBoost.STMエンジン: コミット時無効化を使用したSoftware Transactional Memoryの効率化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-v2&#34;&gt;Using Spirit V2: Qi and Karma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#boost-test&#34;&gt;Production use of Boost.Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#asio-based-flash-xml-server&#34;&gt;An Asio Based Flash XML Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#msm-v2&#34;&gt;The Meta State Machine Library V2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#overview-of-transactional-memory&#34;&gt;Transactional Memoryの概観&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#ame-pattern-library&#34;&gt;AME Patterns Library: モデリング、認識、シーケンシャルパターンの統合のためのジェネリックライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#type-erasure&#34;&gt;Type Erasure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#dsel-design&#34;&gt;Protoによる実用的なDSELの設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#network-library-implementation&#34;&gt;柔軟なヘッダオンリーC++ネットワークライブラリ実装の手法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#mime&#34;&gt;A MIME library for Boost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#nt2&#34;&gt;The Numerical Template Toolbox : 高性能コンピューティングのための加速(Boost)されたGeneric配列ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#functional-programming&#34;&gt;C++による関数型プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#logic&#34;&gt;C++による論理型パラダイム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#qt&#34;&gt;QtとBoostによるクロスプラットフォーム開発&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-history-and-evolution&#34;&gt;Spiritの歴史と進化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#future-of-boost&#34;&gt;Future of Boost Panel ’10&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#clang-lib&#34; name=&#34;clang-lib&#34;&gt;Clang: オープンソースのC++コンパイラライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Clang: An Open-Source C++ Compiler Library&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Clangは、C言語ファミリー(C, C++, Objective-C)のための新たなオープンソースコンパイラフロントエンドである。&lt;br /&gt;
C++コンパイラとして、Clangは速く提供できる生産品質なコンパイラであり、省メモリ使用、表現力豊かな診断、標準一致に関する強い関心で、低レベル仮想マシン(Low Level Virtual Machine ： LLVM)を通じて、様々な構造のためにコード生成を最適化した。&lt;/p&gt;
&lt;p&gt;しかし、Clangはコンパイラを超えるものである。&lt;br /&gt;
再使用可能なC++コンパイラライブラリとして設計され、Clangは大きなC++開発ツールを作るためのプラットフォームである。&lt;br /&gt;
Clang内部のデータ構造は、プログラムソースコードに関する完全な構文情報(マクロを含む、正確な位置情報)とセマンティクス(解決されたオーバーロード関数呼び出し、暗黙の変換)、両方を提供する。&lt;br /&gt;
その、Boost互換で、BSDライクなオープンソースライセンスは、新たなC++言語機能とアイデアのための潜在的な実験場としてや、C++コードを完全に、正しく構文解析することに依存するあらゆるツールのための理想的なベースにもなる。&lt;/p&gt;
&lt;p&gt;このトークでは、Clangコンパイラを導入し、その豊かな内部のデータ構造がどれほど大きなユーザーエクスペリアンスを提供するか、次に、Clangに基づく開発ツールを作るためのアーキテクチャ、主要なデータ構造と、ライブラリのチュートリアルに焦点をあてる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#generic-programming-graph-lib&#34; name=&#34;generic-programming-graph-lib&#34;&gt;ジェネリックプログラミングとBoost Graph Library&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming And the Boost Graph Library&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jeremy-siek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;グラフのアルゴリズムとデータ構造は、インターネットパケットルーティング、分子生物学、科学的なコンピューティング、電話ネットワーク設計などの多様な領域の問題を解決するが伝統的なグラフライブラリ設計は、十分な柔軟性を提供することに失敗していた。&lt;br /&gt;
Boost Graph Library(BGL)はSTLをグラフドメインに適用し、グラフ問題を解決するための非常に柔軟で効率的なライブラリとなった。&lt;br /&gt;
しかし、BGLは使うのが難しいため、このチュートリアルではプログラミングの基本原則を学び、それらがBGLでどう適用されるのかを学んでいく。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#href&#34; name=&#34;geometry&#34;&gt;計算幾何のためのジェネリックプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming for Geometry&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#barend-gehrels&#34; target=&#34;_blank&#34;&gt;Barend Gehrels&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#bruno-lalande&#34; target=&#34;_blank&#34;&gt;Bruno Lalande&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#mateusz-loskot&#34; target=&#34;_blank&#34;&gt;Mateusz Loskot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Geometryは、現代のC++ジェネリックプログラミング手法を使用して設計された。&lt;br /&gt;
タグディスパッチはいたるところで使用され、メタ関数、テンプレートメタプログラミング、Traitsおよびコンセプトチェックを組み合わせた。&lt;br /&gt;
この講義では、タグディスパッチによって通常ではとれない値をとるなどの、手法を一歩一歩説明し、どのようにそれを使用することができるか、他の技術を組み合わせることができるかを解説する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#instantiations-must-go&#34; name=&#34;instantiations-must-go&#34;&gt;Instantiations Must Go!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#matt-calabrese&#34; target=&#34;_blank&#34;&gt;Matt Calabrese&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#zachary-laine&#34; target=&#34;_blank&#34;&gt;Zachary Laine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon 2009では、メタ関数を簡単に書くための取り組みで変なことをしていたが、あとで多くの専門家と話してそれが不可能であることがわかった。一方、彼らは時々ゾッとするようなTMPのコードをより通常の関数プログラミングのようなコードで書き、大部分のメタ関数のテンプレート定義(宣言ではない)をインスタンス化する必要性を取り除くおもしろい手法を発見した。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-update&#34; name=&#34;cpp0x-update&#34;&gt;C++0x update&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-wong&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;
形式 ： 講義
トラック ： Track II 2010&lt;/p&gt;
&lt;p&gt;BoostCon 2009から継続して、最新コンパイラの実装状況に関するレポートと、C++0x機能に関する最新ニュースについての詳細を伝える。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#exception-safety&#34; name=&#34;exception-safety&#34;&gt;C++での例外使用に関するガイドラインの再考 - 例外安全なコードを設計するための10の助言&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Demystifying C++ Exceptions – 10 Tips to Effectively Design Exception-Safe Code&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#ken-joyner&#34; target=&#34;_blank&#34;&gt;Ken Joyner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例外安全なコードを書くことが挑戦的であることは有名である。これは、多くの開発者に、例外の使用が避けられるべきであると結論させる。しかし、この結論に関する問題は、開発者が例外を使わずにエラー安全なコードを書くことがより簡単であると仮定しているということである。私は、この仮定が間違っていると考える。その代わりに、私は実際には、多くの開発者がエラー安全なコードを書くというわけではないと考えている。そして、例外は発生するエラーを無視することは、より挑戦的になる。(あなたのプログラムが未処理例外で終わるので処理しなければならない)&lt;/p&gt;
&lt;p&gt;エラー安全なコードを書くのは例外の使用のあるなしにかかわらず、やりがいがある。そして、エラー安全なコードを書かないのは予測できない、不安定なコードをもたらす。&lt;/p&gt;
&lt;p&gt;この論文は、(いくつかの修正をした)例外安全性のレベルを再文書化した例外安全推奨を提供する。これは、会社や開発者が必要とする、安全性のレベルを達成するために従うべき実質的なガイドラインの包括的なマニュアルとなる。特定の推奨とともに例外を使用することで、エラー安全なコードを書くことを、例外を使用することへの付加的な利益を加えるとともに、挑戦的なことをしないで済むアシスタントライブラリを提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-rad-framework&#34; name=&#34;spirit-rad-framework&#34;&gt;RAD Spiritのためのフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Framework for RAD Spirit&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-de-guzman&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#hartmut-kaiser&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;従来のパーサージェネレータと比較したBoost Spiritパーサーの魅力は、それがC++に埋め込まれることである。ライブラリのユーザーは、C++コードにおいてExpression Templateを使ってパーサー文法を直接指定する。このアプローチには利点もあるが、同時に問題もある。&lt;/p&gt;
&lt;p&gt;最も目に付く問題点は、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コンパイル時間が長い&lt;/li&gt;
&lt;li&gt;エラーメッセージを理解するのが難しい&lt;/li&gt;
&lt;li&gt;パーサーのデバッグとテストが難しい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という点である。&lt;/p&gt;
&lt;p&gt;小さな構文解析については、これらは許容できる。しかし、アクティブな開発の8年後、より複雑な構文解析の中で使用されるポイントに来た。2と3はどうにか、Protoを使用することで軽減できる。しかしそれは、ライブラリがもはや役に立たない点にコンパイル時間を増大させる。&lt;/p&gt;
&lt;p&gt;EBNF/PEG式を受け入れて、すぐに実行可能であるパーサーかC++ Boost Spiritコードを出力するツールを持つことはおもしろい。RADツールは、パーサーを記述することをできるだけ容易にする。&lt;/p&gt;
&lt;p&gt;私たちは、そのようなツールの設計と開発を示したい。明らかに、この「動的なSpirit」ツールは「静止なSpirit」を使用して書かれるだろう。これはSpiritを使用した、本当に実用的な例になるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#is-boost-broken&#34; name=&#34;is-boost-broken&#34;&gt;Is Boost Broken?&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#robert-ramey&#34; target=&#34;_blank&#34;&gt;Robert Ramey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostのいいところ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;形式的なレビュープロセスによるライブラリ品質と完全性の「証明」&lt;/li&gt;
&lt;li&gt;形式的なテスト、リリースプロセスの実施による信頼できる実装の「証明」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostは拡張性が高くない&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テスト時間が長く、より長くなる・・・&lt;/li&gt;
&lt;li&gt;有名でないコンパイラをテストすることは難しい&lt;/li&gt;
&lt;li&gt;現在のテストはコンパイラ設定(RTTIのON/OFF、デバッグ/リリース、STLライブラリなど)のすべての可能な組み合わせを扱うことができるというわけではない&lt;/li&gt;
&lt;li&gt;より多くのライブラリが追加されるとき、インストールが面倒で、壊れやすくなる&lt;/li&gt;
&lt;li&gt;したがって、新規ユーザーがひとつのライブラリだけを使い始める場合でも、　Boostを使うための「コスト」と「オーバーヘッド」は時間とともに増加する。しかし、ひとつのライブラリをテスト／使用するための方法がない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostのアイデンティティの危機&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コアユーティリティの唯一のライブラリ？&lt;ul&gt;
&lt;li&gt;i) ツールがテスト、リリース、配置を行う&lt;/li&gt;
&lt;li&gt;ii) ライブラリのサブセットのテスト、リリース、配置が必要であると考えられる&lt;/li&gt;
&lt;li&gt;iii) 全てのライブラリのためのひとつのバージョンを振る&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;あるいは、独立、分離されたライブラリのグループ(現在大きい)？&lt;ul&gt;
&lt;li&gt;i) 多く、あるいはほとんどのライブラリが他のBoostライブラリのサブセットにだけ依存する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私の議論は、Boostが前者として始まり、後者へ向かって進化していきそうだということである。&lt;br /&gt;
Boostにとってすばらしい10年だったが、成功し続けるためには進化しなければならないだろう。&lt;br /&gt;
この発表では、私が、Boostがどのように変わらなければならないと思うかを説明する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#data-structure-visualizers&#34; name=&#34;data-structure-visualizers&#34;&gt;Data Structure Visualizers in Visual Studio 2010&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#stephan-t-lavavej&#34; target=&#34;_blank&#34;&gt;Stephan T. Lavavej&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多くのSTLクラスが説明を複雑にした。デバッグをより簡単にするために、Visual Studio 2005と2008は、人間が読めるようにSTLオブジェクトを表示する「Visualizer」を持っていた。誰でも、Boostクラスのような他の型のためのVisualizerを書くことができる。これはアンドキュメントで、サポートもされないが、非常に有用になりえる。&lt;/p&gt;
&lt;p&gt;この発表は、&lt;code&gt;shared_ptr&lt;/code&gt;、&lt;code&gt;function&lt;/code&gt;および&lt;code&gt;map&lt;/code&gt;の表示を改善するためにVisualizerを書く方法について説明し、Visual Studio 2010の新しい特徴を利用する方法を紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#alabaster&#34; name=&#34;alabaster&#34;&gt;Boost.Alabaster: A Law Based Tester&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joachim-faulhaber&#34; target=&#34;_blank&#34;&gt;Joachim Faulhaber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これは、形式的に規定された法則あるいは公理に基づいて自動テストを提供する、Boostライブラリのための提案である。&lt;br /&gt;
テストシステムは3部から成る。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;法則のインスタンス化変数を表わす型の並び上のクラステンプレートとして公理または法則を表現することを可能にする法則概念。&lt;/li&gt;
&lt;li&gt;与えられた法則と与えられた型の並び用の法則インスタンス化を任意に生成する、法則インスタンス用のジェネレーター。&lt;/li&gt;
&lt;li&gt;法則違反を選択し、単純性順序によってそれらを格納するフィルタ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost Interval Containerライブラリの開発のために、Boost.Alabasterのプロトタイプは法則に基づいた開発(law based development)に使用された。手法とツールとしての法則に基づいたテスト(law based testing)は、多くの面で有益であることが判明した:&lt;/p&gt;
&lt;p&gt;形式仕様の探究はより深く根付いた設計決定を生じさせ、より耐久性のある設計に結びつく。進化のプロセスでは、一般的なソフトウェアに関してあなたが即座に作った公理で開発を始められなかったとしても、ソフトウェア開発(法則のテスト)では前部(仕様)が抽象化と抽象推論を引っ張り出す。法則に基づいた開発プロセスは、ソフトウェアだけでなくそのソフトウェアに関して保証することができる形式上のプロパティももたらす。それらのプロパティの検証はいつでも繰り返す(replicate)ことができる。テストは、退屈で愛されなかった義務から抽象と設計の品質を促進する非常にクリエイティブなプロセスへと変形される。法則に基づいたテストは、従来の単体テストが提示することができる利点をすべて持ち、それを超える方法である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tool-builder&#34; name=&#34;tool-builder&#34;&gt;C++ Tool-Builders Workshop&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： ワークショップ&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多くの専門家のように、プログラマは、生産性を改善する様々なツールを使用し、プロジェクト特有のニーズに焦点を当てた自分のツールを作るだろう。不運にも、C++プログラマのために、よいC++ツールの構築は、C++コードを解析する固有の複雑さによって非常に複雑になる。C++の全てを解析することができるオープンソースライブラリの不足と結び付けられたこの複雑さは、C++ツールを他の言語でそれらに相当するものより劣らせていた。Clang( &lt;a href=&#34;http://clang.llvm.org&#34; target=&#34;_blank&#34;&gt;http://clang.llvm.org&lt;/a&gt; )は、大きなC++開発ツールを構築することをより簡単にすることによりこの不均衡に焦点を当てたサポートを意図した新たなオープンソースC++コンパイラライブラリである。&lt;/p&gt;
&lt;p&gt;このハンズオンワークショップでは、出席者は、新たなC++ツールを構築するためにClangライブラリを使用する方法を学習する。私たちはまず、C++プログラムを解析および識別する面白いプログラム構築から始める。そこから私たちは、その抽象構文ツリーによって語彙の構造(トークン、マクロのインスタンス化など)から意味的な構造(クラス、関数、式、テンプレートなど)までClangがどのようにプログラムを表わすかを知るだろう。最後に、私たちは手を汚して、Clangを使用して、あるC++ツールを構築する。私たちが構築する実際のツールは出席者によって決定されるだろう。しかし、可能性は以下のものを含んでいる:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;プロジェクト絶対コーディング標準、&lt;/li&gt;
&lt;li&gt;特定のオーバーロードが選ばれた理由の説明、&lt;/li&gt;
&lt;li&gt;クラスを自動的に生成するシリアライズコード、&lt;/li&gt;
&lt;li&gt;Boostライブラリから抽出するドキュメンテーション、&lt;/li&gt;
&lt;li&gt;あるいは、対話的にテンプレートやプリプロセッサのメタプログラムをデバッグする&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といったものを強化する。&lt;/p&gt;
&lt;p&gt;プログラム委員会は以下のことに注意する:&lt;/p&gt;
&lt;p&gt;私は、Clangに基づいた2つの異なるセッションを提案している。&lt;br /&gt;
90分の発表(「Clang: An Open-Source C++ Compiler Library」)は、Clangをコンパイラ、ライブラリおよびオープンソースプロジェクトと評するだろう:&lt;br /&gt;
これはあまり深く話せないため、実際には概要である。&lt;/p&gt;
&lt;p&gt;ワークショップは、去年のDaveによるハンズオンBoost++0xワークショップに沿った単なる実験ではない:&lt;br /&gt;
今年、私たちは、出席者にBoosterが使用するべきクールなツールを構築させることができるかどうか確かめたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-concurrency&#34; name=&#34;cpp0x-concurrency&#34;&gt;C++0x Concurrency&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-wong&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この話では、私はBoostCon 09でのC++0x並列性の議論に引き続いて話していくつもりである。&lt;br /&gt;
とくに、C++のメモリモデル、新たなC++0xライブラリを通じて並列性がどのように扱われるか、スレッド管理、スレッド間のデータ共有、同期並列操作に関して話す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#basic-lock-free&#34; name=&#34;basic-lock-free&#34;&gt;Lock-freeプログラミングの基礎&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Basics of Lock-free Programming&lt;/li&gt;
&lt;li&gt;スピーカー ： Tony Van Eerd&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基礎から始め、共有データにアクセスするという問題を示し、ゆっくり問題を露出させていき、問題へのLock-freeによる解決策を示す。この話は以下を含む：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始性についての説明&lt;/li&gt;
&lt;li&gt;CAS命令とCASループについての説明&lt;/li&gt;
&lt;li&gt;Double-Checked-Locking Pattern(DCLP)の危険性とそれを避ける方法(メモリバリア)の説明&lt;/li&gt;
&lt;li&gt;read-request queueとwrite-request queueのアイデアに基づき、どのように複数のCPUが働くか理解できるモデルを提示しメモリバリアを説明する&lt;/li&gt;
&lt;li&gt;Lock free stackを提示する&lt;/li&gt;
&lt;li&gt;ABAと、それを回避する方法についての説明&lt;/li&gt;
&lt;li&gt;Lock-freeプログラミング(楽観的なrelaxed memory operation)におけるいくつかの最前線開発に触れる&lt;/li&gt;
&lt;li&gt;BoostとC++0xがどのようにLock-freeプログラミングに影響するかについて触れる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tboost-stm&#34; name=&#34;tboost-stm&#34;&gt;TBoost.STMエンジン:コミット時無効化を使用したSoftware Transactional Memoryの効率化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Reducing the Integration Complexity of Software Transactional Memory with TBoost.STM&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#vicente-j-botet-escriba&#34; target=&#34;_blank&#34;&gt;Vicente J. Botet Escriba&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#justin-gottschlich&#34; target=&#34;_blank&#34;&gt;Justin Gottschlich&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dwight-y-winkler&#34; target=&#34;_blank&#34;&gt;Dwight Y. Winkler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここでは、具体的なTBoost.STMの内部エンジンの現状、トランザクションコンフリクトの検出、トランザクションがコミットできるかどうかを決定するプロセスを調査する。多くのtransactional memory(TM)は矛盾検知の最適化に専念するが、ほぼ全てのTMがトランザクションのコミット段階で同じ矛盾検知戦略を行う。つまり、彼らはコミット時に検証を行うのである。そこでは、トランザクションが、以前にコミットされたトランザクションによってコンフリクトチェックされる。コミット時検証(commit-time validation)が限られた競合を示す作業量に対して効率的な間、それは競合した作業量のために並列性をきびしく制限できる。&lt;/p&gt;
&lt;p&gt;ここでは、TBoost.STMがこのモデルからどう逸れるかを説明し、コミット時無効化(commit-time invalidation)を使用することでコミットする前に飛行中(コミットされていない)トランザクションがそれらのコンフリクトを全て解決する戦略について話す。コミット時無効化は競合マネージャ(CM:contention manager)にコミット時検証を通じて利用不可能なデータを供給し、CMが決定にBoost Concurrencyを作ることを可能にする。コミット時無効化はまた、メモリ集約的なトランザクションのためにコミット時検証より著しく少ない操作を必要とし、動的に検出されたread-onlyトランザクションのための操作と保証、どんなトランザクションでもO(N)時間で完全な不透明性を保証する(インクリメンタルな検証のO(N^2)より速い)。作業量競合の実験結果は、私たちの効率的なコミット時無効化されたSTMは、TL2(最高水準のSTM)より3倍速かった。&lt;/p&gt;
&lt;p&gt;しかし、コミット時無効化だけでは不十分である。プログラマはそれらがこの競合検出戦略の利点を完全に利用するために実行している作業量のための効率的な競合マネージャに書く方法を知らなければならない。私たちは、プログラマがどのように自身の競合マネージャに書くか、そして正しい競合マネージャが実行される作業量に基づくTBoost.STMの性能を根本的にどうしたら向上させることができるかを調査する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-v2&#34; name=&#34;spirit-v2&#34;&gt;Using Spirit V2: Qi and Karma&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-caisse&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;機械、センサー、機材、クライアント/サーバーコミュニケーション、ファイル形式でさえ...コミュニケーションストリームの解析と生成はどこでも見るだろう。多くの場合、これらのタスクはその場限りの解決策を勧めるのに十分に単純であるか、あるいは小さい。Spirit 2.1ライブラリは、それらの「quick hacks」に取り組むのに十分に単純で、AST生成のために容易に拡張できる十分な機能のモデルを提供する。&lt;/p&gt;
&lt;p&gt;このセッションは、Spiritライブラリのパーサーとジェネレーター(Qi/Karma)による現実の経験を調査する。様々な製品の中で使用された、様々な小型/中型のパーサー/ジェネレーターを見るとともに、私たちは「rules-of-thumb」、およびQi/Karmaを持ったパーサー/ジェネレータードメインに取り組むためのガイドラインを確立するだろう。このセッションは、使用可能なXMLパーサーと、単純化されたXPathのようなノード抽出器の実装で終える。&lt;/p&gt;
&lt;p&gt;このセッションは、いくつかのレクチャーと、多くのチュートリアルを含む。&lt;br /&gt;
出席者は、知識と、Spirit Qi/Karmaで解析し生成することを始めるツールを持ち帰るだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#boost-test&#34; name=&#34;boost-test&#34;&gt;Production use of Boost.Test&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#gennadiy-rozental&#34; target=&#34;_blank&#34;&gt;Gennadiy Rozental&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションでは、プロダクションコンポーネントにおいてのBoost.Testの様々な使用法のシナリオをカバーする。&lt;br /&gt;
とくに、以下の主題をカバーする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数実行を保護する&lt;code&gt;execution_monitor&lt;/code&gt;の使用法。&lt;/li&gt;
&lt;li&gt;高水準なプログラム実行保護のための&lt;code&gt;program_execution_monitor&lt;/code&gt;の使用法。様々な配置オプション。&lt;ul&gt;
&lt;li&gt;(New) 浮動小数点例外の取り扱い。&lt;/li&gt;
&lt;li&gt;(New) コールバックでの罠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(New) 生産コンポーネントにおけるBoostテストツールの使用法。&lt;/li&gt;
&lt;li&gt;単体テストにおいて：実装自体の内部を構築コンポーネントユニットテストする2つのアプローチ：&lt;ul&gt;
&lt;li&gt;a) コンパイル時のスイッチを使用する&lt;/li&gt;
&lt;li&gt;b) コンソールテスト実行と、共有ライブラリとして組み込まれた実装を使用する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#asio-based-flash-xml-server&#34; name=&#34;asio-based-flash-xml-server&#34;&gt;An Asio Based Flash XML Server&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-caisse&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reactiveシステムはいたるところで見つけられる。多くの待ちスレッドでそれらを実装する誘惑は強くなりえる。しかし、結果はほとんどいつも期待はずれである。&lt;/p&gt;
&lt;p&gt;Boost.Asioライブラリは、特定のクラスがネットワーク、シリアルポートI/O、タイマー、およびその他に向けられている状態で非同期なリソースを扱うためのフレームワークを提供する。このセッションでは、様々なシリアル入出力ハードウェアコンポーネントから接続されたFlashディスプレイへのデータストリームを送るサーバーを構築するつもりである。以前のセッションのときに開発したQiパーサーとKarmaジェネレータは、それらの適切な目的地へとシャッフルされるASTを作成するのに使われるだろう。&lt;/p&gt;
&lt;p&gt;この講演/チュートリアルは、Flash XML Socketからサーバーを組み合わせてデータストリーミングし、要求を受け取ることができるようにAsio、Spirit、Fusion、Phoenix、Smart_ptr、Thread、FunctionとBindを含むライブラリを使用するだろう。&lt;br /&gt;
出席者は、彼ら自身のAsioベースサーバーを作成するために、Asioモデルと様々な実装パターンを理解することになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#msm-v2&#34; name=&#34;msm-v2&#34;&gt;The Meta State Machine Library V2&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#christophe-henry&#34; target=&#34;_blank&#34;&gt;Christophe Henry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon09でのMSM v1に関する私のアーティクルは、MDD(モデル駆動開発)アプローチと呼ばれるMDA(モデル駆動アーキテクチャ)を促進するというゴールをもつライブラリの主な特徴を示した。具体的に、その話はMSMの記述的に表現する性質を主張した。この論文は初めに、メインサポートされたUML機能を要約し、MSM v2によって提供される新たなフロントエンドでのそれらの使用法を示すだろう。第2部では、MDDコンテキストにおいて使用可能なより多くの能力の提供により、いまMSMがどのようにMDD法をより先に進めさせたかを知ることになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#overview-of-transactional-memory&#34; name=&#34;overview-of-transactional-memory&#34;&gt;Transactional Memoryの概観&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Overview of Transactional Memory Day&lt;/li&gt;
&lt;li&gt;スピーカー ： Tatiana Shpeisman&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Transactional Memory(TM)は並列プログラミングを単純化し、制限のない実行モデルをサポートする現代の並列制御パラダイムである。この終日セッションは、それらの最近のTM研究開発について議論するために業界と学会のエキスパートを集める。Boost、IBM、Intel、Microsoft、およびSun Microsystemsから招待された講演者は、最新作の概要を提供してくれるだろう。セッションは彼らがTMの短期的、あるいは長期的な挑戦についての考えを示すところでパネルディスカッションを締めくくる。最後に、聴衆からの質問に答える。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#ame-pattern-library&#34; name=&#34;ame-pattern-library&#34;&gt;AME Patterns Library: モデリング、認識、シーケンシャルパターンの統合のためのジェネリックライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AME Patterns Library: a generic library for modeling, recognition, and synthesis of sequential patterns&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#stjepan-rajko&#34; target=&#34;_blank&#34;&gt;Stjepan Rajko&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルは、モデリング、認識、シーケンシャルパターンの統合のためのオープンソースのジェネリックC++ライブラリであるAMEパターンライブラリについて発表する。&lt;/p&gt;
&lt;p&gt;このライブラリは、ジェスチャーや音声認識などのアプリケーション、およびそのようなパターンの統合に役立つ。また、隠れマルコフモデル(Hidden Markov Model)などのモデルのための汎用ライブラリとして使用することができる。コンセプトベースのジェネリックプログラミングの使用は、ライブラリに大きな柔軟性を与える。パターン解析が多くのドメインにまたがるので、それは役立つだろう。&lt;/p&gt;
&lt;p&gt;また、このライブラリはさらに、プログラミングの計算量、柔軟性、汎用性、およびコンパイルタイムの異なるトレードオフを提供する、いくつかのAPIレベルを提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#type-erasure&#34; name=&#34;type-erasure&#34;&gt;Type Erasure&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#nevin-liber&#34; target=&#34;_blank&#34;&gt;Nevin Liber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ Template Metaprogrammingで見つかった定義から始め、Type Erasureとは何かと、それがどのような利点とコストがあるかについて話す。継承ベースのインタフェースから、それをType Erasureで変換する例から始める。Boost.AnyとBoost.Functionの簡易実装をカバーする予定だ。&lt;/p&gt;
&lt;p&gt;regular型とクラスの概念について触れる。( &lt;a href=&#34;http://stlab.adobe.com/wiki/index.php/Image:2008_06_26_classes_that_work.pdf&#34; target=&#34;_blank&#34;&gt;http://stlab.adobe.com/wiki/index.php/Image:2008_06_26_classes_that_work.pdf&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;それと共に、Copyable/Assignable型のコンテナを使用することでBoost.shared_ptrとBoost.Pointer Containerを比較する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#dsel-design&#34; name=&#34;dsel-design&#34;&gt;Protoによる実用的なDSELの設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Practical DSEL Design with Proto&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#eric-niebler&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この発表は、Boost.Protoで有用なDSELを急速に構築する方法に注目する。&lt;/p&gt;
&lt;p&gt;このセッションは、数個の現実世界のDSELの設計と実装に踏み出すだろう。簡単な例(例えば、Boost.Assignのmake_list_of())から始めて、中級(例えば、Howard Hinnantのfutureグループ)、最後に、単純化されたPhoenixライブラリの設計について解説する。現実世界のライブラリ設計問題への解決策に重点を置く。特定の現実世界の問題を通じて、ProtoによってC++でそれを実装する価値があるように、一般的なDSELの価値が明白になるだろう。また、コンパイル時間とテンプレートのエラーメッセージについて議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#network-library-implementation&#34; name=&#34;network-library-implementation&#34;&gt;柔軟なヘッダオンリーC++ネットワークライブラリ実装の手法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Techniques in Flexible Header-Only C++ Network Library Implementations&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dean-michael-berris&#34; target=&#34;_blank&#34;&gt;Dean Michael Berris&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この論文は、Boost.Asio上に単純ではあるが強力なヘッダオンリーC++ネットワークライブラリを提供するcpp-netlibプロジェクトによって使用された様々な手法に重点を置く。&lt;/p&gt;
&lt;p&gt;一般的なプログラミング法則に従うベストプラクティスから発生している一方、使用される手法のうちのいくつかは他の既存のライブラリから借りられる。この論文は、共通メッセージ型、型安全なURIパーサーおよびオブジェクト表現の非常にモジュラーで柔軟な実装を達成するために使用されるイディオムと同様にライブラリの異なる部品の構成およびセマンティクス的に一貫したHTTPクライアントを強調することを目標とする。&lt;/p&gt;
&lt;p&gt;この論文は、ライブラリの様々なモジュールの実装の全体にわたって使用される現代C++の手法に関する調査と、同様にcpp-netlibプロジェクトへの入門として役立つ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#mime&#34; name=&#34;mime&#34;&gt;A MIME library for Boost&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#marshall-clow&#34; target=&#34;_blank&#34;&gt;Marshall Clow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： lecture&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;インターネットプロトコル中のデータをカプセル化する最も一般的な方法はMIME(Multipurpose Internet Mail Extensions:多目的インターネットメール拡張)を使用することである。このフォーマットはHTTP、emailおよび他の多くのプロトコルの中で使用される。&lt;/p&gt;
&lt;p&gt;私は、作成、解析、およびMIME構造の操作のために、Boostを包含するという視点から開始し、このライブラリを作る際の設計選択について話そう。(提案された)Boost.MIMEライブラリはDean Michael Berrisのネットワークライブラリによって使用される(だろう)。&lt;/p&gt;
&lt;p&gt;MIME処理ライブラリは、(スレッド、ネットワークI/Oおよび状態マシンを合わせた)ネットワークプロトコルを実装するために必要とされる基本ビルディングブロックのうちの1つである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#nt2&#34; name=&#34;nt2&#34;&gt;The Numerical Template Toolbox:高性能コンピューティングのための加速(Boost)されたGeneric配列ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Numerical Template Toolbox:BOOST’ed Generic Array Library for High Performance Computing&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-falcou&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jean-thierry-lapreste&#34; target=&#34;_blank&#34;&gt;Jean-Thierry Lapreste&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配列のようなデータ構造上での集中的、あるいは非自明なコンピューティングを行うことは、科学的なコンピューティング、ビデオゲーム開発、および他のフィールドで最も一般的なタスクのうちのひとつである。この事実は、そのようなタスクを行うために、ツール、言語、そしてライブラリといったかなりの数のものによってバックアップされる。私たちが自身をC++に基づいた解決策に制限する場合、1ダース以上のライブラリはテンプレートメタプログラミングに基づいたBlitz++やEigen2といったBLAS/LAPACKのC++バインディングが存在している。これらのライブラリの全てが良いパフォーマンス、または良い抽象化を提供する場合、そられのどれも非常に多くのユーザー型に適合するようには思えない。&lt;/p&gt;
&lt;p&gt;ここで私たちは、Numeric Template Toolbox(NT2)を提供する。これはテンプレートメタプログラミングで、配列に基づいた演算ライブラリで、直感的であるが拡張可能なユーザーAPIと開発者SDKを提供している間に、メモリハンドリングと自動的な並行処理のようなアーキテクチャの懸念に関して良い性能を出すためにrock-solid実装を目指す。また、全体のライブラリ設計とパフォーマンスのためにBoost.Components(MPI, Proto, Fusion, PP, Serialization, etc...)を使用しているという付加価値を強調する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#functional-programming&#34; name=&#34;functional-programming&#34;&gt;C++による関数型プログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Functional Programming in C++&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#david-sankel&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;関数型プログラミング(FP)手法は、一般的で、簡潔で、合成可能で、正確なコードを生成する。最近まで、これらの手法の多くは学究的な世界と難解プログラミング言語(esoteric programming language)の領域に制限されていた。新たなC++とboostでの開発は最終的にこれらの高度な技術にアクセス可能にする。&lt;/p&gt;
&lt;p&gt;このセッションの最初では、いま可能なFP手法のHowとWhyを調査する。私たちは代数のデータ型、ポイントフリー高階関数、純粋、ジェネリックプログラミング、型族(Type Families)、圏論および実用的な関数記号をカバーする。&lt;/p&gt;
&lt;p&gt;セッションの第2部では、FPの事例研究について話す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1に、運動コントローラーに基づいた組み込みドメイン特化言語(EDSL)。&lt;/li&gt;
&lt;li&gt;第2に、他に類を見ないジェネリックなXMLシリアライズフレームワーク。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#logic&#34; name=&#34;logic&#34;&gt;C++による論理型パラダイム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Logic Paradigm for C++&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#roshan-naik&#34; target=&#34;_blank&#34;&gt;Roshan Naik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;論理型パラダイム(LP)は、オブジェクト指向、命令型、関数型のパラダイムと比較して、主流言語では表現をほとんど見ない、強力でチューリング完全なプログラミングパラダイムである。&lt;br /&gt;
LPは時々、プログラミングの聖杯と呼ばれるものへのコンピュータ科学の重要なアプローチである。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「ユーザーが問題を延べ、コンピュータがそれを解決する」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理論の起源は、アリストテレスが論理的な推論に厳格さをもたらすために形式論理を構築した約紀元前300年までさかのぼる。ラッセルとホワイトヘッドが数学をすべて実行することができるかもしれないことを示した時、理論は、現代の論理へ最近(1900年の初め)成熟した。&lt;/p&gt;
&lt;p&gt;この話は、Boostへ提案することを目的とする新たなオープンソースライブラリであるCastorを中心に展開する。LPをサポートするBoostの能力の拡張に加えて、これはBoostプログラマがLPと関数型のパラダイムからの機能を組み合わせて、イテレータや範囲の必要なしでストリーム、アルゴリズムおよびコンテナの統合を可能にするだろう。&lt;/p&gt;
&lt;p&gt;この話は、C++でLPの基本的な入門を提供する。そして、あなたをこのパラダイムについて考えるようにするための多くの例が続く。私たちは、既存のBoostとC++の概念で、それがどのように自然に混じるか話す。最後に、プログラマが自由にパラダイムを混合しマッチすることができる場合に強力なマルチパラダイム解決がどのように出現するか確かめるために範囲を広げる。LPのきれいで深い統合が、C++を源泉とする多くのデザインパターンがいまだ発見されていないことがこの話で明確になるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#qt&#34; name=&#34;qt&#34;&gt;QtとBoostによるクロスプラットフォーム開発&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cross-platform development with Qt and Boost&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joao-p-r-abecasis&#34; target=&#34;_blank&#34;&gt;Joao P. R. Abecasis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このワークショップの意図は、Qtライブラリの簡潔な概要と、QtとBoostを混合するための現在の現実的解決策を提供することである。&lt;/p&gt;
&lt;p&gt;とくに私は、MOCモデルとQObjectモデル(BoostとQtを混合したプロジェクトのための構造システムインテグレーション)を調べ、Boostベースのコンポーネントを小さなサンプルアプリケーションに基づくQObjectシグナル/スロット実装に融合させる様相を調査するつもりである。&lt;/p&gt;
&lt;p&gt;私は、相互運用問題と、それがどのように改善することができるかについてBoostコミュニティからフィードバックを集めたいと考えている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-history-and-evolution&#34; name=&#34;spirit-history-and-evolution&#34;&gt;Spiritの歴史と進化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Spirit: History and Evolution&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-de-guzman&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#hartmut-kaiser&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今年、私たちは、90年代初期に非常に大きいGUIライブラリから枝分かれし、2001年にBoostデビューしたSpiritの10周年を祝福する。Spiritは、控えめな7ヘッダファイルのライブラリから成長して最も洗練されたBoostライブラリのうちの一つとなり、途中からBoost.Fusion, Boost.Phoenix, Boost.Wave, Boost.Protoライブラリの培養器となった。&lt;/p&gt;
&lt;p&gt;私たちは、歴史的観点からSpirit(そして、それに刺激されたライブラリ)を紹介したい。この発表は、およそ10年間で少なくても4つのライブラリへと発展させ、演算子を虐待し、クレイジーなテンプレートメタプログラムを好む、正真正銘のマッドサイエンティストであるBoost作者の経験と観点から、起爆剤を提供することを目標とする。もちろん、あちこちでC++トリックを誇示するのであれば、私たちはそれを助けることはできないが、私たちがそれを行うのと同じくらい、できるだけ簡単にすることができる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Future of Boost Panel ’10&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dave-abrahams&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#beman-dawes&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jeff-garland&#34; target=&#34;_blank&#34;&gt;Jeff Garland&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： パネル&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostには、メーリングリストの話題上で、丁寧で、役立つポストを適度に走らせる少数のモデレーターグループがある。さらに、彼らはウェブサイト、ソースリポジトリ、および他の行政機構の内部を管理する。また、大事なことを一つ言い残していましたが、モデレータは、Boostを促進するための委員会を監督する非公式の幹部の役割を務める。&lt;/p&gt;
&lt;p&gt;このセッションでは、モデレータにそれぞれBoostの将来のビジョンに関して5分ずつ話してもらう。しかし、セッションの大部分は聴衆からの質問と提案に専念するだろう。これは、Boostコミュニティの方向性に関して何でも聞けて、提案できる絶好のチャンスである。例えば、特別な政策、ツール、あるいはあなたの考えを採用する。&lt;/p&gt;
&lt;h2&gt;翻訳者&lt;/h2&gt;
&lt;p&gt;Akira Takahashi&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2012 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/cppnow/2012.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:cppnow/2012.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;C++Now! 2012&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://cppnow.org/2012/&#34; target=&#34;_blank&#34;&gt;C++Now! 2012&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2012&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://boostjp.github.io/archive/cpp_online_reading.html&#34;&gt;C++オンライン読書会&lt;/a&gt; にて有志が一部の資料を読んでいるので、そちらも資料を読むお供にどうぞ。&lt;/p&gt;
&lt;h2&gt;ビデオ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.youtube.com/user/BoostCon&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/user/BoostCon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参加レポート&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/redboltz/20120519/1337385881&#34; target=&#34;_blank&#34;&gt;C++Now2012体験記 - redboltzの日記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/faith_and_brave/20120522/1337650107&#34; target=&#34;_blank&#34;&gt;C++Now! 2012に参加してきました - Faith and Brave - C++で遊ぼう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zakkas783.tumblr.com/post/25007975614/c-now-boostcon-c-now-boost-konferenz-im&#34; target=&#34;_blank&#34;&gt;C++Now! - BoostCon新装開店 (C++Now! – Boost-Konferenz im neuen Gewand) - 雑貨’s tumblr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#50-boost-libs&#34;&gt;180分でめぐるBoost Library 50個の旅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#more-useful-computations&#34;&gt;おなじ環境でより効果的な計算を： C++で組み込みリアルタイムコード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#whirlwind-overview-cpp11&#34;&gt;駆け足でC++11の概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#odeint&#34;&gt;odeint - C++で常微分方程式を解く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#fresh-paint&#34;&gt;新仕様できたてほやほや!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#openmp-for-better-high&#34;&gt;ハイパフォーマンスを求めるためだけではなく、高次の並列化のためのOpenMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#hpx&#34;&gt;HPX: C++11並列実行システム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#lambda-functions&#34;&gt;ラムダ関数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#future-cpp1x-proposals&#34;&gt;来るC++1xへの提案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#variadic-tmp&#34;&gt;モナドを使って可変長テンプレートメタプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#ustring&#34;&gt;Ustring - 現代的な&lt;code&gt;std::string&lt;/code&gt;の代替&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#high-level-threading&#34;&gt;C++11: 高次のスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#grill-the-committee&#34;&gt;標準委員を質問攻めにしよう!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#moving-forward&#34;&gt;キーノート：C++11で前進せよ!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#metaparse&#34;&gt;Metaparse – テンプレートメタプログラミングによるコンパイル時構文解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#ladon&#34;&gt;Ladon - 分散状態マシンフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#low-level-threading&#34;&gt;黒魔術につき取扱注意 - C++11で低レヴェルスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#exception-safety&#34;&gt;C++で例外安全なコーディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#moving-boost-to-git&#34;&gt;BoostをGitに移行しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#learned-developing-std-lib&#34;&gt;C++11標準ライブラリの策定を通じて学んだこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#utilizing-modern-programming&#34;&gt;科学的ソフトウェア開発における今日的プログラミングテクニックとBoostライブラリの適用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#vs-ide&#34;&gt;C++開発者むけVisual Studio IDEの最新情報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#modules&#34;&gt;キーノート： C++におけるモジュール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#generic-programming-real-world&#34;&gt;C++でのジェネリックプログラミング： 実例を交えて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#lowest-variational-methods&#34;&gt;Boost.Protoを用いた最低次変分法のドメイン特化固有言語の実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-containers&#34;&gt;C++11コンテナの最新情報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#concept-clang&#34;&gt;ConceptClang： C++ Conceptの実装モデル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#modern-cpp-techniques&#34;&gt;現代的C++テクニック入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#smart-pointers-algorithm&#34;&gt;C++11のスマートポインタとアルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#voronoi&#34;&gt;Boost.Polygon.Voronoiライブラリを例に、堅牢かつ効率的多倍精度アルゴリズムの設計について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#tool-for-class-and-library-authors&#34;&gt;C++11: クラスやライブラリ実装者のための新しいツール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cmake-modularization&#34;&gt;CMake、モジュール化と Ryppl 開発者向けプレヴュー&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#now-what&#34;&gt;キーノート： さて、これからどうしよう？ 3つの視点から&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#compile-time-reparsing&#34;&gt;コンパイル時 再パース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#type-string-conversions&#34;&gt;型から文字列への変換と、その逆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34;&gt;C++11にある珠玉の品々&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#linear-programming-proto&#34;&gt;Boost Protoで線型計画法を簡単に&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#solidfire&#34;&gt;SolidFireではC++11への移行をいかにして成しとげたか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#refactoring-clang&#34;&gt;ClangでC++のリファクタリング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#state-machine-coroutine&#34;&gt;Boost.Coroutineを用いてステートマシンを解決する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#metaprogramming-cpp11&#34;&gt;C++11でのメタプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#numerical-problems-metaprogramming&#34;&gt;メタプログラミングの数学的問題への適用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#tr2-boost&#34;&gt;TR2に向けたBoostライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#how-i-code-and-why&#34;&gt;どうしてそう書くの？なんで？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#preparation-cppnow-2013&#34;&gt;C++Now! 2013に向けた準備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#winrt&#34;&gt;WinRTにむけたC++コンポーネント拡張&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#value-semantics&#34;&gt;値のセマンティクスとConceptベースの多態&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#future-of-boost&#34;&gt;Boostの将来&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#50-boost-libs&#34; name=&#34;50-boost-libs&#34;&gt;180分でめぐるBoost Library 50個の旅&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;50 Boost Libraries in 180 minutes&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/boris-schaeling/&#34; target=&#34;_blank&#34;&gt;Boris Schäling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/50_boost_libraries.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/50_boost_libraries.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションでは、50個のBoost Libraryを180分かけて紹介する。多くのBoost Libraryについて、幅広く俯瞰する。あまりboostに詳しくない方、または、いくつかのライブラリしか知らない方は、今後、boostが提供すべきすぐれたアイデアを得ることができるだろう。このセッションは、後程どのライブラリについて学びたいか、いまのプロジェクトで使えるか、さらには貢献できそうか判断する指針となるだろう。 このセッションは、プレゼンターの著書である「The Boost C++ Libraries」(英語版 2011/6刊行)と「Die Boost C++ Bibliotheken」(ドイツ語版 2012/1刊行)に基づいている。これらの書籍ではすぐに習得できる一般的なライブラリを紹介している。このセッションでは、これらの本から例を引用するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#more-useful-computations&#34; name=&#34;more-useful-computations&#34;&gt;おなじ時間でより効果的な計算を： C++で組み込みリアルタイムコード&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;More Useful Computations in the Same Duration: Optimizing Embedded Hard Real-Time Code in C++
スピーカー：&lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/schurr_more_useful_computations.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/schurr_more_useful_computations.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=mJjYgpeo5ws&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=mJjYgpeo5ws&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は非常に広い問題領域に適用可能なマルチパラダイム言語である。このセッションでは限られたメモリリソース、かつ、200KHz(5マイクロ秒)サーボインタラプト割合のリアルタイム組み込みシステムにC++を利用した際の最適化と拡張について紹介する。二年以上かけて、このシステムのデータ処理帯域幅は、ハードウェアの強化をすることなく大きく改善した。この改善を達成するために、様々なアプローチとテクニックについて議論した。その結果、ほとんどのよく知られているC++イディオムは組み込みのリアルタイムシステム環境にはよく合わないことが分かった。しかし、C++はCよりもメンテナンスの面でもコード実行速度の面でも優位な性能を見せた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、組み込み向け、汎用機向けという区分なく、特定のC++コードの実行速度の高速化に興味がある方には有意だろう。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションで、特定の組み込み環境について、何が正しく動き、何が正しく動かないのか、そしてその理由はなにかについて説明する。主なテーマはパフォーマンスモニタリング、特定領域のコードデザイン、コンパイラに高速なコードを生成させる方法、スレッドセーフオプションである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#whirlwind-overview-cpp11&#34; name=&#34;whirlwind-overview-cpp11&#34;&gt;駆け足でC++11の概要&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Whirlwind Overview of C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/leor-zolman/&#34; target=&#34;_blank&#34;&gt;Leor Zolman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/cpp_overview_handout.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/cpp_overview_handout.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=jrCrWdrH17g&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=jrCrWdrH17g&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このC++11の簡潔なイントロダクションでは、プレゼンターであるLeor Zolmanが言語への主要な機能追加について調査する。また以下の項目についても述べる：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コード可読性の向上について(ラムダ, 統一初期化, &lt;code&gt;auto&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;パフォーマンスの向上について(右辺値参照とムーブコンストラクタ)&lt;/li&gt;
&lt;li&gt;マルチスレッドについて(並行性とアトミック型)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、他の多岐に渡る便利な機能や、標準ライブラリのコンポーネント(スマートポインタと新しいSTLコンテナ)についても触れる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションはC++11の簡潔な概要を知りたい方向けである。そのため、詳細をカヴァーしきれない言語機能、ライブラリが多々あることをご了承いただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#odeint&#34; name=&#34;odeint&#34;&gt;odeint - C++で常微分方程式を解く&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;odeint – Solving ordinary differential equations in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/karsten-ahnert/&#34; target=&#34;_blank&#34;&gt;Karsten Ahnert&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mario-mulansky/&#34; target=&#34;_blank&#34;&gt;Mario Mulansky&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/odeint.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/odeint.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=jv2oDfT-jds&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=jv2oDfT-jds&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常微分方程式(ODE: Ordinary differential equation)は自然科学、応用分野の諸領域で重要な役割を果たしている。&lt;br /&gt;
例示すると、古典的ニュートン物理学、化学反応式、量子系から神経系にわたる、個体群動態における反応速度式などである。&lt;br /&gt;
さらに、常微分方程式は偏微分方程式(PDE: partial differential equation)の離散化をする際頻出する。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、odeint(&lt;a href=&#34;http://odeint.com&#34; target=&#34;_blank&#34;&gt;odeint.com&lt;/a&gt;) -常微分方程式の数値解法を探索するためだけのC++ライブラリ- を紹介する。このライブラリはBoost入りを目指している。&lt;/p&gt;
&lt;p&gt;odeintは非常にジェネリックに実装されており、高速に相互運用することができる。&lt;/p&gt;
&lt;p&gt;odeintはODEソルバのためのC++コンセプトを導入しており、標準的なメソッドを数多く実装している。例えば、古典的Runge-Kuttaスキーム、ステップサイズコントロールと稠密出力のメソッド、非明示なメソッドとシンプレティック解法などである。； odeintはコンテナ非依存であることを強調しておきたい。つまり、使用者はstd::vectorのような特定の型を使うことを強いられない。 それゆえ、ネットワーク、ラティス上のODEを解くこともできる。 さらに、多倍精度か区間演算を利用できる。 ジェネリックな設計を取っているので、odeintは容易に並列化してCUDA GPUで実行できる。 それにもかかわず、odeintはわかりやすいインターフェースを備えているので、簡単に、容易に使うことができる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではodeintの主要な機能ならびにそのソフトウェアデザインについて述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#fresh-paint&#34; name=&#34;fresh-paint&#34;&gt;新仕様できたてほやほや!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Fresh Paint&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/fresh_paint.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/fresh_paint.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=ourmFvidEpk&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=ourmFvidEpk&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11では様々な方法で言語を拡張する興味深い新機能が導入された。&lt;/p&gt;
&lt;p&gt;このセッションではそれらを完全に無視して、別のテーマに焦点を当てる。すなわち、C++11でよりシンプルに、クリーンに、エレガントに記述する方法について述べる。このセッションはソフトウェアデザインの最先端についてあまりよく知らないけれど、クリーンかつシンプルかつ効率的なコードを書くことに関心がある方に最適である。話のなかでデザインについて知見が得られれば幸いである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#openmp-for-better-high&#34; name=&#34;openmp-for-better-high&#34;&gt;ハイパフォーマンスを求めるためだけではなく、高次の並列化のためのOpenMP&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OpenMP for better high-level parallelism, not just for High Performance Computing&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/47981ddb3630f7fc1651ae0ecb608b0344d19b5f/mon/cppnow_openmp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/47981ddb3630f7fc1651ae0ecb608b0344d19b5f/mon/cppnow_openmp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=iGrk2mbKTS0&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=iGrk2mbKTS0&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OpenMPは高次の言語を用いたインクリメンタル並列化をサポートする、C,C++,FORTRAN向けの分散メモリ並列化の仕様である。&lt;/p&gt;
&lt;p&gt;OpenMPはハイパフォーマンスコンピューティング、スーパーコンピューティングのためのもの、と思っている方がいるかもしれないが、実際は他にほぼ類をみない分散メモリ並列化 - これは3つの汎用言語で実装されている - に適しており、それ自体高次言語である。OpenMPはグラフィクスや可視化の分野や、組み込みやリアルタイムアプリケーション分野、コミュニケーションとネットワーク分野、自動化とロボディクス分野、財務や通商分野、医療と生命工学分野、石油・ガス業界、シミュレーション、データベースとミドルウェア、音声・オーディオ処理、汎用データ解析などの分野でも有効であることが知られている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#hpx&#34; name=&#34;hpx&#34;&gt;HPX: C++11並列実行システム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HPX: A C++11 parallel runtime system&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/bryce-adelstein-lelbach/&#34; target=&#34;_blank&#34;&gt;Bryce Adelstein-Lelbach&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/hartmut-kaiser/&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/matthew-anderson/&#34; target=&#34;_blank&#34;&gt;Matthew Anderson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/thu/hpx_a_cxx11_parallel_distributed_system.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/thu/hpx_a_cxx11_parallel_distributed_system.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;計算科学のアプリケーションは、しばしば基になる実行モデルから受けついだ選択の影響を受ける。並列計算アプリケーションにおいては、MPIが注目をあつめている。しかし、電源や、プロセッサコアの複雑性、マルチコアソケット、GPUの異種混在という問題が深刻になってきたため、並列アプリケーションはスケーリング不全の危機に陥っている。&lt;/p&gt;
&lt;p&gt;HPX実行時システムはモジュラーであり、完全実装であり、SMPノードとコモディティ・クラスターのような従来型の並列計算アーキテクチャを対象としたParalleX実行モデルのパフォーマンス指向の表現である。MPIの代替として、HPXは軽量ユーザースレッドを管理するためのルーチンに加えて、アクティヴグローバルアドレス空間(AGAS: Active Global Address Space)を提供している。HPXはC++11で実装され、20のBoostライブラリ/Boostライブラリ候補を利用している。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、実行時システムアーキテクチャに焦点を当てるとともに、HPXでどのようにBoost C++ライブラリやC++11機能を利用しているかについて議論する。HPXの概要についてプレゼンテーションし、さらに、競合するランタイムシステムおよび科学計算コミュニティ向けアプリケーションとの比較とベンチマークを紹介する。HPXに興味、関心をもたれて、実際に試用していただければ幸いである。ダウンロードはこちらから： &lt;a href=&#34;http://stellar.cct.lsu.edu/&#34; target=&#34;_blank&#34;&gt;http://stellar.cct.lsu.edu/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#lambda-functions&#34; name=&#34;lambda-functions&#34;&gt;ラムダ関数&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lambda Functions&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/lambda.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/lambda.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=tLp6ZBHwvj4&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=tLp6ZBHwvj4&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;無名関数は多くの言語で有用なツールとして成功を収めている。その局所性と明瞭な構文により、高い表現力と、バグの少ないコードを記述できる。Boost.LambdaやBoost.Phoenix、そしてFC++といったライブラリによって、C++にラムダ式がもたらされたが、今日、C++11には言語機能としてラムダ関数がある。ラムダ関数は無名関数オブジェクトとよく似ている。というのは、ラムダのスコープ外でキャプチャ/識別子の状態の変更が可能だからだ。&lt;/p&gt;
&lt;p&gt;この90分のチュートリアルセッションで、この新しい言語機能の構文と利用方法を概観する。上達を図るために練習問題や例を多数用意している。ラムダが利用可能なコンパイラを持参し、ぜひラムダ関数を使うとコードがどれほどよくなるか体験していただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#future-cpp1x-proposals&#34; name=&#34;future-cpp1x-proposals&#34;&gt;来るC++1xへの提案&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Future C++1x proposals&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/cppnow_future.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/cppnow_future.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=NdWHVyZBazo&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=NdWHVyZBazo&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11が公開された今、C++1xに搭載される次の機能は何だろうか？ このプレゼンテーションでは2月のコナ会議で提案されたものを紹介していく。Evolution Working Groupでレヴュー済みのペーパーと、ConcurrencyおよびLibrary Working Groupの活動についても焦点を当てる。 おまけ： 主要なコンパイラについて、最新のC++11実装状態についてもお伝えしたい。&lt;/p&gt;
&lt;p&gt;2012年2月のコナ会議を経て、標準委員会は次のC++標準を暫定的に2017年に、その次を2022年に、おおよそ五年毎に公開するように決定した。また、いくつか主要なものを例にあげると、モジュールや高度な並列抽象化、リフレクションといった次の標準にむけての提案についても精査した。このプレゼンテーションではこれらの機能について焦点をあて、C++11にどのような影響を与えるかについて議論する。&lt;/p&gt;
&lt;p&gt;カナダ、IBMのC++標準委員会代表や、BoostConでトランザクショナル・メモリからC++11の並行について多様なトピックを長きにわたってプレゼンターを務めた者として、標準委員会でC++の将来搭載されるべき機能についての議論にはできるだけ参加するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#variadic-tmp&#34; name=&#34;variadic-tmp&#34;&gt;モナドを使って可変長テンプレートメタプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Variadic Template Metaprogramming using Monads&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bartosz-milewski/&#34; target=&#34;_blank&#34;&gt;Bartosz Milewski&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/eric-niebler/&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/compile_time_runtime_cpp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/compile_time_runtime_cpp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11 の新機能である可変引数テンプレートは，パワフルだが気の触れた制限がついている．なんと template parameter pack が一級市民ではないので，一部のよくある(メタ)プログラミングの定石で使いにくいのだ．うれしいことに偶然，関数型プログラミング，正確に言うと Haskell では，おもしろい方法でこの問題を解決している．というわけで我々は，可変個継続，継続モナド，カリー化，その他C++メタプログラミングで使うためのエキゾチックな構成を使った方法について話す．&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#ustring&#34; name=&#34;ustring&#34;&gt;Ustring - 現代的なstd::stringの代替&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ustring – A Modern Alternative to &lt;code&gt;std::string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alan-talbot/&#34; target=&#34;_blank&#34;&gt;Alan Talbot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/ustring.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/raw/master/mon/ustring.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=nAm1Tbk068U&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=nAm1Tbk068U&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++プログラミングで推奨される文字列表現はstd::stringである。しかし、実際には、あるプログラムには三つ以上の文字列型(例えば、&lt;code&gt;std::string&lt;/code&gt;、MFCの&lt;code&gt;CString&lt;/code&gt;、&lt;code&gt;char*&lt;/code&gt;)が混在していることがほとんどである。われらが&lt;code&gt;std::&lt;/code&gt;stringは長年よくやってくれているが、いろいろな制限やときどき見せる奇行に悩まされることもままある。そして、他の文字列クラスが備えている便利な機能、特に言うならUnicodeサポートが欠けている。C++11が公開されたことと、&lt;code&gt;std::string&lt;/code&gt;が実装されてから数十年来の知見を集めて、よりよいツールを創ってみた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションの前半は、将来、強力かつ競争力のあるツールとなるよう、&lt;code&gt;std::string&lt;/code&gt;の制限や問題を解決することをめざした新しいクラスの設計について述べる。多くの知見を集積して、C++11にふさわしい、簡便で、表現力豊かで、強力な文字列処理を創りだすことが目標である。そのために、後半は理論や秘話、懸案事項やアイデアなどをいただきたく、聴講されている皆様とブレインストーミングするセッションにするつもりである。このライブラリは開発の初期段階にあるので、変更の余地はあるし、どんなアイデアでも歓迎する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#high-level-threading&#34; name=&#34;high-level-threading&#34;&gt;C++11: 高次のスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11: High-Level Threading&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/concurrency.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/mon/concurrency.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=9GILH2U94Ls&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=9GILH2U94Ls&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11は並行処理の新しい機構を備えている。慎重に設計されたシステムのプログラミング言語であるならば当然のことだが、言語機能は厳格な理論的基礎(メモリモデル)に基いて構築され、低レヴェルプリミティヴ(atomic)へのアクセスを提供している。幸運にも、C++11ではスレッドを効果的に使う際に、こうした難解な詳細について理解する必要はない。(もし低レヴェルの事柄について詳細を知りたければ、Tony Van Eerdのプレゼンテーションを見るべし)&lt;/p&gt;
&lt;p&gt;その基礎の上に、プログラマが日々のコンカレントなコードを記述する際、実際に使うべきAPIが用意されている。すなわち、大量のロックやミューテクスや条件変数、そして、より高いレヴェルの&lt;code&gt;future&lt;/code&gt;, &lt;code&gt;promise&lt;/code&gt;, &lt;code&gt;packaged_task&lt;/code&gt;などだ。また、スレッドセーフなプログラミングの中核的問題についても述べ、これら問題を解決するためのコンポーネントの使いかたについても述べる。&lt;/p&gt;
&lt;p&gt;メモ： このプレゼンテーションに興味を持たれたかたは、&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34;&gt;&#34;Other C++11 Gems&#34;&lt;/a&gt;のプレゼンテーションにも食指が動くかもしれない。そちらのプレゼンテーションでは、時刻や時間、タイムアウトでのロック、スリープといった優れたデザインの新機能について取りあげるそうだ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#grill-the-committee&#34; name=&#34;grill-the-committee&#34;&gt;標準委員を質問攻めにしよう!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Grill the Committee&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準のなれそめについて知りたくないか？ このパネルディスカッションではC++標準委員会のメンバーに登壇いただき、聴衆の皆様に気になっていることを質問していただく趣旨である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#moving-forward&#34; name=&#34;moving-forward&#34;&gt;キーノート： C++11で前進せよ!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Moving Forward with C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料&lt;ul&gt;
&lt;li&gt;前編：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part1.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part1.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;後編：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part2.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward_part2.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;前編・後編一括：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_moving_forward.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;右辺値参照はC++に二つの新しい相乗的に機能するプログラミングイディオムをもたらす。すなわちムーブセマンティクスと完全転送である。このプレゼンテーションでは右辺値参照とは何か、ムーブセマンティクスとは何か、完全転送とは何か、といった基礎からはいる。また、このプレゼンテーションではこれらが導入された動機や利用法、コンパイラがこれらを自動生成する条件についても述べる。さらに、クラスを設計した後でも、条件に合致すれば自動的に、ムーブセマンティクスが最適化の役目を果たすことができるけれども、ムーブセマンティクスの知識は直接的にクラス設計に影響を与えることを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#metaparse&#34; name=&#34;metaparse&#34;&gt;Metaparse – テンプレートメタプログラミングによるコンパイル時構文解析&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaparse – Complie-time parsing with template metaprogramming&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/abel-sinkovics/&#34; target=&#34;_blank&#34;&gt;Ábel Sinkovics&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/zoltan-porkolab/&#34; target=&#34;_blank&#34;&gt;Zoltan Porkolab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/2b6b26f9fcc28fa7b2c777819111012217116ff5/tue/metaparse.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/tue/metaparse.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=v3XoWi0XbZk&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=v3XoWi0XbZk&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Metaparseは、C++のコンパイル時文字列を解析する、パーサー生成のためのC++テンプレートメタプログラミングライブラリである。Boostはすでに2つのパーサージェネレータライブラリを持っている：Boost.SpiritとBoost.Proto。MetaparseとBoost.Spiritの主な違いは、Metaparseによって生成されたパーサーはコンパイル時に実行され、Boost.Spiritによって生成されたパーサーは実行時に実行されるということである。Boost.ProtoパーサーはC++の有効な式をコンパイル時に処理し、Metaparseは自由形式の文字列を入力としてパーサーを構築する。&lt;/p&gt;
&lt;p&gt;コンパイル時の任意なテキストを解析することは、多くの状況で有用である。我々はより複雑なユースケースを比較的に簡単にする方法を提供する。一般的な構文は、以下の正規表現のコンパイル時検証を有効にすることでBoost.Xpressiveのラッパーを作成できる。より複雑な例として、printfの書式指定文字列を解析し、コンパイル時に引数の型を検査する。コンパイル時パーサーの別な手段は、組み込みDSLスクリプトをC++のネイティブな関数への変換をコンパイル時に行い、実行時にそれを実行することである。最も複雑な例では、テンプレートメタ関数を定義するために、組み込みDSLをどのようにして実装するかを示す。Metaparseはパーサー生成のDSLをメタ関数に変換する能力を持つ。&lt;/p&gt;
&lt;p&gt;Metaparseの内部構造と、それをどのようにして拡張するかを説明する。ライブラリの正確なエラー報告の機能を紹介する。モナドの概念の入門と、それを使用することでパーサーの構築を容易にすることを示す。新たなC++標準の&lt;code&gt;constexpr&lt;/code&gt;は、コンパイル時にアルゴリズムを実行するための構造を提供する。メタプログラミングと&lt;code&gt;constexpr&lt;/code&gt;の間を繋ぎ、パーサーによって処理される入力の構文的なオーバーヘッドを最小限にしてそれを利用する方法を提供する。&lt;/p&gt;
&lt;p&gt;Metaparseと、その元となるライブラリは、以下から利用可能である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://abel.web.elte.hu/mpllibs&#34; target=&#34;_blank&#34;&gt;http://abel.web.elte.hu/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sabel83/mpllibs&#34; target=&#34;_blank&#34;&gt;https://github.com/sabel83/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これはユーザーと開発者にとって高度な話である。Boost.MPLに精通していることを前提とする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#ladon&#34; name=&#34;ladon&#34;&gt;Ladon - 分散状態マシンフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ladon - A Distributed State-Machine Framework&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/ladon.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/ladon.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=KExYq1bepT0&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=KExYq1bepT0&amp;amp;feature=plcp&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;階層的な状態マシンは、多くのドメインにエレガントな解決策を提供する。それらの厳格な要件は、高い信頼性のシステムのための規律を一段階強化する。状態マシンはシステムの反応的な振る舞い(reactive behavior)について記述するのに役立つ。ポート束縛、メッセージ配信、およびプロトコル変換を提供する一方で、コミュニケーションポートや包含コンセプト(containment concepts)のようないくつかの(ROOMのような)構造的コンポーネントを加える。そうすれば、分散状態マシンフレームワークが生まれる。よく定義されたインタフェースを持ったより小さな分散マシンに分割することは、大きな反応的システムのための強力なツールである。&lt;/p&gt;
&lt;p&gt;このセッションでは、Ladon分散状態マシンフレームワーク(C++Now 2012でデビューするciere consultingのオープンソースプロジェクト)を導入する。Ladonは、反応的なシステムのためのリッチな分散ソリューションを作成するために、Boost.MSM、Boost.AsioおよびBoost.Spiritを融合させる。フレームワークの設計と基本的な使用法についての議論に加え、我々はあなたのシステムで使用できるおもしろいパターンと解決策のいくつかを紹介する。我々が言及するライブラリは、以下のものを含む：MSM、Spirit、Asio、Fusion、Signals2、そしてPhoenix。&lt;/p&gt;
&lt;p&gt;この90分間のセッションは、初心者と中級レベルの出席者に、いくつかのBoostライブラリと現代的なC++手法の概観を提供する。&lt;/p&gt;
&lt;p&gt;語源 - Ladon(Λάδων)は、ヘスペリデスの庭のトマトを守護する、ギリシャの100の頭を持つヘビのようなドラゴンである。頭がそれぞれ異なる言語を話したという噂がある。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#low-level-threading&#34; name=&#34;low-level-threading&#34;&gt;黒魔術につき取扱注意 - C++11で低レヴェルスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Don’t Try This at Work – Low Level Threading with C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/low_level_threading_with_cpp11.pps?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/low_level_threading_with_cpp11.pps?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のC++は&#34;メモリモデル&#34;がある。しかしこれはどんな意味で、どうして導入されたのか、また、以前のC++に必要なかったのは何故か？ これを使って何ができるか？ そしてこれらの新しい原子操作にはなにやら相関があるようだ… むむむ…&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#exception-safety&#34; name=&#34;exception-safety&#34;&gt;C++で例外安全なコーディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Exception-Safe Coding in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/exception_safe_coding.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/exception_safe_coding.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;皆様のコードは100%例外安全を達成していると言えるだろうか？&lt;/p&gt;
&lt;p&gt;例外を安全に利用するのはなまはんかな問題ではない。この業界では20年来この問題に奮闘してきた。もし皆様が恐怖や不透明感、例外安全に疑いをもっていたり、純粋にC++で例外のベストプラクティスを知りたいと思っているならば、ぜひこのプレゼンテーションを聞いていただきたい。まず始めに、&#34;何を解決しようとしているか&#34;から入り、代案について議論し、例外の利用に関する問題を確認し、例外安全について曲解されやすい試みについて述べる。また、安全な例外の利用法についての基本的なガイドラインと過去の例外安全ではないコードベースから移行するための鉄板の実装テクについても述べる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションの目的は、皆様に、簡単に記述できて、理解しやすく、高速に動作し、例外が発生しても100%の堅牢性を誇るコードをどうやったら書けるようになるかお伝えすることである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#moving-boost-to-git&#34; name=&#34;moving-boost-to-git&#34;&gt;BoostをGitに移行しよう&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Moving Boost to Git&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/moving_to_git.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/moving_to_git.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=rqKGX2LJOmU&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=rqKGX2LJOmU&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gitヴァージョン管理システムはSubversionに比べてBoostの開発者、利用者双方に利益がある。このセッションではBoostからみたGitについて紹介し、徐々に高度な議題について述べていく：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;なぜGitなのか？ - 成層圏から俯瞰してみよう&lt;/li&gt;
&lt;li&gt;皆様にGitの基礎を知っていただくために、駆け足のGitのチュートリアル&lt;/li&gt;
&lt;li&gt;Subversionに対するGitの優位性 - Boost開発者の視点から&lt;/li&gt;
&lt;li&gt;Subversionに対するGitの優位性 - Boost利用者の視点から&lt;/li&gt;
&lt;li&gt;Boostのモジュール化への試み - 課題、アプローチ、トレードオフについて&lt;/li&gt;
&lt;li&gt;Boost開発者にあわせたワークフロー構築の試み&lt;/li&gt;
&lt;li&gt;BoostをGitに移行してみるワークショップ - 実行計画の開発&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この&#34;BoostをGitに移行しよう の前準備&#34;と題したドキュメントとファイルをC++Now!の二週間前くらいまでに用意するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#learned-developing-std-lib&#34; name=&#34;learned-developing-std-lib&#34;&gt;C++11標準ライブラリの策定を通じて学んだこと&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lessons Learned Developing the C++11 Standard Library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/lessons_from_the_library.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/lessons_from_the_library.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11の標準化作業はおおよそ8年かかり、標準ライブラリのサイズは少なくともページ数上では倍増した。標準化作業は標準ライブラリの設計を再確認し、おおよそ十年間で蓄積したBoostライブラリで得られた知見や開発技術をもって仕様をクリーンアップし、右辺値参照やコンセプト、並行処理のサポートといった、言語に導入が考えられた新しいアイデアについて学び、最後に新しい機能でライブラリを拡張した。この経験は有意だったか、それとも無意だったか？ 次の機会によりうまくやるために、いったい何を学んだのか？ 次のライブラリ TR を策定するにあたり、このレッスンをどう生かせばいいのか？&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#utilizing-modern-programming&#34; name=&#34;utilizing-modern-programming&#34;&gt;科学的ソフトウェア開発における現代的プログラミングテクニックとBoostライブラリの適用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Utilizing Modern Programming Techniques and the Boost Libraries for Scientific Software Development&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/josef-weinbub/&#34; target=&#34;_blank&#34;&gt;Josef Weinbub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_weinbub.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/cppnow_weinbub.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現代的プログラミングテクニックとライブラリを利用することで、ソフトウェア開発者は膨大な機能と柔軟性を手にいれることができる。しかし、ジェネリックプログラミング、関数型プログラミング、メタプログラミングのような関連技術を利用するには、高度なプログラミングスキルが要求されるので、マニアかコンピュータサイエンティストでなければ使い熟し得ない。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、Boostライブラリのような現代的プログラミング技術を利用する科学的コンピューティングの範疇に含まれる3つの仕事について報告する。まず、主にBoost GraphライブラリとBoost Phoenixライブラリを利用した順次および並列タスクグラフ実行のための拡張可能なプラグインスケジューラを紹介する。次に、Boost MetaprogrammingライブラリとBoost Fusionライブラリを利用した、コンパイルタイムに任意のプロパティに基づいてコンポーネントのサブセットを選択するというメタプロパティの選択方法について紹介する。最後に、ジェネリックパラダイムのもと幾何学的アルゴリズムを一般化するためのアプローチについて示す。&lt;/p&gt;
&lt;p&gt;これらアプローチの紹介を通じて、現代的プログラミングテクニックとBoostライブラリの適用により、非常に汎用的で、維持可能で、コンパクトで、拡張可能なコードを生み出せることを示す。以上から、長期的には高度なC++スキルを習得するために費した時間はペイすると結論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#vs-ide&#34; name=&#34;vs-ide&#34;&gt;C++開発者むけVisual Studio IDEの最新情報&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What’s new in Visual Studio IDE for C++ Developers&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sumit-kumar/&#34; target=&#34;_blank&#34;&gt;Sumit Kumar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/visual_studio_ide_for_cpp%20_developers.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/tue/visual_studio_ide_for_cpp%20_developers.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=XLrR3cJCjlI&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=XLrR3cJCjlI&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;きたるVisual Studio 11のリリースには、IDEとのやりとりやチーム内の他のC++開発者と共同作業するといった、日々のコーディング作業でC++開発をより効率的にするような新しい機能や革新が数多く詰まっている。&lt;/p&gt;
&lt;p&gt;本プレゼンテーションではデモをごらんいただきながら、構文の色分け、参照のハイライト、進化したインテリセンス、コード解析、プロファイリングといった機能に焦点を当てて紹介する。また、ドキュメントとの連携、検索やナビゲーションといった普段の作業を非常に簡易化するIDEの改善点についてもひととおりごらんいただく。このプレゼンテーションではコードレヴューやテスト、コードカヴァレッジといった統合機能についても概説する。Visual Studio 11はC++開発者チーム全体に有益である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#modules&#34; name=&#34;modules&#34;&gt;キーノート： C++におけるモジュール&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Modules in C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/david-vandevoorde/&#34; target=&#34;_blank&#34;&gt;David Vandevoorde&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modules_aspen2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modules_aspen2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=8SOCYQ033K8&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=8SOCYQ033K8&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の幕開け以来、プリプロセッサはC++ライブラリインターフェースとやりとりするための手段としての役割を果たしてきた。しかし、長年にわたり、プリプロセッサであるがゆえに生じる制約によって、不愉快なビルド時間は増加の一途をたどっている。今日、プリプロセッサはよりよいC++開発ツールをつくるにあたり唯一最大の阻害要因になっている。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、C++に&#34;モジュール&#34;の概念を導入するための選択肢を紹介し、それらがもたらす課題と恩恵について議論する。次のC++標準仕様に向けて、C++標準委員会はこれらの選択肢について活発に検討している段階である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#generic-programming-real-world&#34; name=&#34;generic-programming-real-world&#34;&gt;C++でのジェネリックプログラミング： 実例を交えて&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming in C++: A Real-World Example&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/marshall-clow/&#34; target=&#34;_blank&#34;&gt;Marshall Clow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/marshall_generic_programming.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/marshall_generic_programming.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=SWGMq0_X32Q&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=SWGMq0_X32Q&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この90分のセッションでは、Boost MLでいただいたリクエストに答えようと思う。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;なぜBoostには&lt;code&gt;hex&lt;/code&gt;／&lt;code&gt;unhex&lt;/code&gt;関数がないのか？ とても有用だと思うけど。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;また、Boost.Algorithmライブラリにマッチしたこれらのアルゴリズムのデザインと実装についても概説する。&lt;/p&gt;
&lt;p&gt;この関数は単純であるけれども、非常に多くの興味深い設計決定が実装中になされている。これについてもこのプレゼンテーションで述べるつもりだ。&lt;/p&gt;
&lt;p&gt;カヴァーする議題は以下の通り：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ジェネリックプログラミングデザイン&lt;/li&gt;
&lt;li&gt;イテレータの取り扱い(出力イテレータの問題についても述べる)&lt;/li&gt;
&lt;li&gt;テンプレートメタプログラミング(&lt;code&gt;enable_if&lt;/code&gt;の用法についても述べる)&lt;/li&gt;
&lt;li&gt;Boost.Exception&lt;/li&gt;
&lt;li&gt;コードの最適化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#lowest-variational-methods&#34; name=&#34;lowest-variational-methods&#34;&gt;Boost.Protoを用いた最低次変分法のドメイン特化固有言語の実装&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Implementing a Domain Specific Embedded Language for lowest-order variational methods with Boost Proto&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jean-marc-gratien/&#34; target=&#34;_blank&#34;&gt;Jean-Marc Gratien&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/jmg_cppnow_2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/jmg_cppnow_2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このペーパーでは、FreeFEM様のドメイン特化言語を用いて線型離散と双線型離散の定義を対象とする拡散問題を解くための最低次変分法族の原実装を示す。Boost Protoフレームワークの利用によって、この言語のバックエンドとフロントエンドをどう実装したかについて議論する。種々の学術的問題の実装を行なうことで、このDSEL設計を検証する。この言語のオーヴァーヘッドは従来の実装と比較することで評価する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-containers&#34; name=&#34;cpp11-containers&#34;&gt;C++11コンテナの最新情報&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What’s new with C++11 containers?&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/cppnow_containers.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/cppnow_containers.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11でピカピカのコンテナがいくつか導入された。すなわち、単方向リスト、ハッシュコンテナ、固定長同型コンテナ、そして異形コンテナである。しかしこれだけではない。前仕様C++98/03のコンテナも新しいメンバ関数の追加、ムーブのサポート、&#34;移動のみ&#34;のコンテナをつくれるように、&lt;code&gt;value_type&lt;/code&gt;に課されていた制限の緩和といった手直しがなされている。さあC++11のコンテナを有効利用する方法についてみていこう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#concept-clang&#34; name=&#34;concept-clang&#34;&gt;ConceptClang： C++ Conceptの実装モデル&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ConceptClang: An Implementation Model for C++ Concepts&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/andrew-lumsdaine/&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;,&lt;a href=&#34;http://cppnow.org/participant/larisse-voufo/&#34; target=&#34;_blank&#34;&gt;Larisse Voufo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/concept_clang.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/concept_clang.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Conceptはテンプレートに安全性を付与することを意図として、制約ベースのポリモルフィズムを行うために提案されたC++の拡張である。本プレゼンテーションではConceptClangを紹介する。これは、C族言語のLLVMフロントエンドであるClangをベースとする、Conceptデザインの検証を行うための基盤の実装例である。このプレゼンテーションでは、Conceptの提案された主要な機能(コンセプトに基づく探索、テンプレートのオーヴァーロード、テンプレートの拘束など)をどう実装したかについて述べるとともに、種々のConcept設計を深めていくために、ConceptClang基盤をいかに利用すればいいかについても示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#modern-cpp-techniques&#34; name=&#34;modern-cpp-techniques&#34;&gt;現代的C++テクニック入門&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Introduction to Modern C++ Techniques&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modern_cpp.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/modern_cpp.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ポリシー、SFINAE、タグディスパッチ… ktkr! 現代的C++にノって弾みをつける準備はOK? Ciere C++ ニンジャシリーズから、このセッションでは基本的なことから、ジェネリックプログラミングで使われているテクニックやストラテジーを紹介する。このセッションで話すトピックは以下のとおり：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Concept&lt;/li&gt;
&lt;li&gt;Trait&lt;/li&gt;
&lt;li&gt;ポリシークラス&lt;/li&gt;
&lt;li&gt;CRTP (Curiously Recurring Template Pattern)&lt;/li&gt;
&lt;li&gt;SFINAE (Substitution Failure is not an Error)&lt;/li&gt;
&lt;li&gt;タグディスパッチ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この3時間のハンズオンチュートリアルは例がびっしりの参加型セッションである。ノートPCを持参されたし! 日々のコーディングで現代的C++の技法を使いたい開発者には、きっと得るものがあるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#smart-pointers-algorithm&#34; name=&#34;smart-pointers-algorithm&#34;&gt;C++11のスマートポインタとアルゴリズム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11 Smart Pointers and Algorithms&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/smart_pointers_algorithms.key?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/smart_pointers_algorithms.key?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++03で言うところのスマートポインタとは&lt;code&gt;auto_ptr&lt;/code&gt;だった。&lt;code&gt;auto_ptr&lt;/code&gt;は最良の型であり最悪の型である。このプレゼンテーションでは&lt;code&gt;auto_ptr&lt;/code&gt;がどのように&lt;code&gt;unique_ptr&lt;/code&gt;を触発したか、その違いはなにかについて説明する。&lt;code&gt;unique_ptr&lt;/code&gt;を比較対象として、&lt;code&gt;shared_ptr&lt;/code&gt;についても概説する。これらを使うべきときはいつか？ どちらのスマートポインタを使うべきか？&lt;/p&gt;
&lt;p&gt;加えて、このプレゼンテーションではC++11に新しく追加されたアルリズムについて、また、&lt;code&gt;unique_ptr&lt;/code&gt;のようなムーブのみ可能な型で動作するよう修正された多数の新旧アルゴリズムについても述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#voronoi&#34; name=&#34;voronoi&#34;&gt;Boost.Polygon.Voronoiライブラリを例に、堅牢かつ効率的多倍精度アルゴリズムの設計について&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Robust and efficient multi precision algorithms design based on Boost.Polygon.Voronoi library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/andrii-sydorchuk/&#34; target=&#34;_blank&#34;&gt;Andrii Sydorchuk&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/lucanus-simonson/&#34; target=&#34;_blank&#34;&gt;Lucanus Simonson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/voronoi_presentation_andrii_sydorchuk.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/voronoi_presentation_andrii_sydorchuk.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;複雑な数値計算アルゴリズムの設計と実装はユーザビリティ、拡張性、効率性、堅牢性という4つの要素を満たさねばならない。&lt;/p&gt;
&lt;p&gt;ユーザビリティとは、その分野に精通していないユーザーにとっての、公開されているアルゴリズムインターフェースのわかりやすさである。同時に、精通しているユーザーにとっての、アルゴリズムを構成できる幅のことでもある。&lt;/p&gt;
&lt;p&gt;拡張性とは、アルゴリズムそれ自身、依存するデータ構造、計算カーネル、数値型といった部分を再構成または置換する際、アルゴリズムに汎用性と柔軟性を持たせることである。&lt;/p&gt;
&lt;p&gt;効率性はまずアルゴリズムの複雑度とデータ構造の分析に始まり、メモリやパフォーマンスプロファイルを行い、システム/コンパイラ特異的な最適化に終わる。これには、数値型の操作および現実装と他のよく知られたアプローチとの比較も含まれる。&lt;/p&gt;
&lt;p&gt;堅牢性は数値アルゴリズムの最も重要な研究分野であろう。もし内部データ構造が実行時に破壊されたらどうなるか、という問いに対する答を用意しておくことである。アルゴリズムの出力と、出力がどの範囲で正常かつ信頼できるかを定義することでもある。言い変えれば、受けとった出力とランダムデータとの違いは何か、ということである。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、アルゴリズムの動機となった実世界の問題を見ていきながらアルゴリズムを紹介する。Boost.Polygon.Voronoiライブラリで用いているアルゴリズム設計テクニックと実装をもとに、上記で言及した要素全てについて示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#tool-for-class-and-library-authors&#34; name=&#34;tool-for-class-and-library-authors&#34;&gt;C++11: クラスやライブラリ実装者のための新しいツール&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11: New Tools for Class and Library Authors&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/schurr_cpp11_tools_for_class_authors.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/wed/schurr_cpp11_tools_for_class_authors.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この新しい標準はクラスやライブラリ実装者のために、可変引数テンプレートや&lt;code&gt;static_assert&lt;/code&gt;、&lt;code&gt;constexpr&lt;/code&gt;、明示的な変換関数、および&lt;code&gt;decltype&lt;/code&gt;といった多数のツールが用意されている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cmake-modularization&#34; name=&#34;cmake-modularization&#34;&gt;CMake、モジュール化と Ryppl 開発者向けプレヴュー&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CMake, Modularization and Ryppl Developer Preview&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rypplは、C++の開発や、構築、テストならびにBoostとそのユーザーの要求、すなわちC++コミュニティに合わせて設計された配信のための基盤フレームワークである。巨大化、複雑化、また潜在的にモジュール化がすすむBoostは、Rypplの完全なテストケースになりえる。このため我々は一年間、このコンセプトを証明するために必要なシステムと変更に取りくんできた。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、CMakeを使ってビルドおよびテストできるように、なにもインストールせずに配置できるように、またBuildBotを用いてリモートでビルド、テストできるようにするための、Boostのモジュール化にむけた作業の進捗について示す。BoostCon(訳註：C++Now2012のことか)が始まった時点で、Boost開発者に利用いただける、コミュニティ全体で予備的なレヴュー可能なシステムの機能を完全に揃えている予定である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#now-what&#34; name=&#34;now-what&#34;&gt;キーノート： さて、これからどうしよう？ 3つの視点から&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Now What? A vignette in 3 parts&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sean-parent/&#34; target=&#34;_blank&#34;&gt;Sean Parent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/now_what.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/now_what.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=iGenpw2NeKQ&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=iGenpw2NeKQ&amp;amp;feature=plcp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;パート1： 美しさ&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は効率性が要求されるところでは復権を果たした。しかし、C++へ移行してきた者に対して、いまだ多くの者が歓迎していない。これはJavaやJavaScript、Pythonからきたプログラマにとって移行の脅威になりえる。C++コミュニティとして、美しく、効率的なコードを書くための、C++11で提供されるツールを梃入れする必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;パート2： 真実&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のハードウェア上では、単一スレッドで実行されるC++コードではマシン性能のたった0.25%ほどしか引き出せない。C++11ではほんのちょっとだけスレッドサポートが解禁された。未来を見据える言語、ライブラリに課せられた最大の試練は、いかにマシン性能の残り99.75%を引き出すか、ということに尽きるだろう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;パート3： 美点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;過剰なネットワークディヴァイスはソフトウェアの展望を変えつつある。インターネットの基盤は次第に裏方にまわり、増えつづける顧客はディヴァイス上にある情報を簡便に取得できるよう要求している。そのようなシステムが我々のソフトウェア設計と記述にどんな影響を与えるだろうか？この新しい世界におけるC++の果たす役割とは何だろうか。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#compile-time-reparsing&#34; name=&#34;compile-time-reparsing&#34;&gt;コンパイル時 &#39;再パース&#39;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Compile-time ‘reparsing’&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/gordon-woodhull/&#34; target=&#34;_blank&#34;&gt;Gordon Woodhull&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/gordon_woodhull_reparsing_2012.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/gordon_woodhull_reparsing_2012.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++コンパイラは今コードをパースしているとする。さて、その一部を再度パースしたいとしたらどうだろう？&lt;/p&gt;
&lt;p&gt;数年前から、ドメイン固有特化言語のためのメタプログラミングライブラリ群が提案され、ユーザーや特殊なライブラリアンはC++内に独自の言語を構築できるようになった。このようなユーザーやライブラリアンは皆、実行時表現のEric Niebler氏によるBoost.Protoに精通する必要がある。しかし、Ábel Sinkovic氏による、コンパイル時文字列パースのためのMetaparseや、&amp;lt;&amp;gt;表記をパースするための、プレゼンターが作成した&#34;とんがった(原：Angly)&#34;パーサもある。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではこれら三つのライブラリを研究し、計算的に等価であることを(一方で、ドメインや表現力の違いについても)示す。コンピュータサイエンスの視点からは、これらライブラリは全てプッシュダウン・オートマトンである。ではなぜインターフェースがこうも違っているのだろう？対象ドメインの違いから生れるものなのか？それともライブラリ著者のバックグラウンドによるものなのか？&lt;/p&gt;
&lt;p&gt;また、コードをごらんいただきながら、これらのライブラリが実際にどのように動作するかごらんいただきたいと思う。このプレゼンテーションの大きな目的は、これらライブラリでどんなテクニックが一般的になっているか見ていくことと、共通のパターンがあるかどうか見ること、そして聴衆の皆様にメタプログラミングテクニックについて習熟していただくことである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#type-string-conversions&#34; name=&#34;type-string-conversions&#34;&gt;型から文字列への変換と、その逆&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Type to string conversions, and vice-versa&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/jeroen-habraken/&#34; target=&#34;_blank&#34;&gt;Jeroen Habraken&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/convert_types_to_strings.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/convert_types_to_strings.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=WLYcyu6mlgg&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=WLYcyu6mlgg&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、型から文字列への変換、またその逆に変換する際の、さまざまな選択肢について研究していく。古くは&lt;code&gt;atoi&lt;/code&gt;や&lt;code&gt;strtol&lt;/code&gt;から、真新しくは&lt;code&gt;std::stoi&lt;/code&gt;や、&lt;code&gt;boost::lexical_cast&lt;/code&gt;のようなBoostで提供されているものまで見る。これら選択肢のエラーハンドリングやフォールバック機構、localeサポートといった観点からみた利点と欠点についても研究する。&lt;/p&gt;
&lt;p&gt;利点と欠点を見ていただいた後は、それら利点と欠点をもとにGoogle Summer of Codeで作成したboost::coerceについて、現在の選択肢をどう補間するか紹介したい。このライブラリは速度や拡張性の面で優れている。このプレゼンテーションでは設計について概説し、またどう達成したかについて、使用法の豊富な例とともに紹介する。&lt;/p&gt;
&lt;p&gt;時間が許すなら、カスタマイズポイントやSpiritとの関連を見ていきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#cpp11-gems&#34; name=&#34;cpp11-gems&#34;&gt;C++11にある珠玉の品々&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Other C++11 Gems&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/alisdair-meredith/&#34; target=&#34;_blank&#34;&gt;Alisdair Meredith&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/howard-hinnant/&#34; target=&#34;_blank&#34;&gt;Howard Hinnant&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jeff-garland/&#34; target=&#34;_blank&#34;&gt;Jeff Garland&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp11_allocators.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp11_allocators.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp_gems_garland_chrono_ratio.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cpp_gems_garland_chrono_ratio.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非常に重要だが、それ単品では1セッションに満たないようなトピックについてとりあげる。GarlandとHinnantは&lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;から。またstateful allocatorとregexへのサポートについてもとりあげる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#linear-programming-proto&#34; name=&#34;linear-programming-proto&#34;&gt;Boost Protoで線型計画法を簡単に&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linear programming made easy with Boost Proto&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/patrick-mihelich/&#34; target=&#34;_blank&#34;&gt;Patrick Mihelich&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/linear_programming_proto.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/linear_programming_proto.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;オペレーションリサーチや金融、チップデザインに渡る分野の問題は、線型計画にモデル化できる。決定問題のための高度に汎用的で効率的なアルゴリズムがあるメソッドとして、線型計画法は有効なツールである。&lt;/p&gt;
&lt;p&gt;GLPKのような、線型計画を解くための強力なソフトウェアライブラリが存在するが、低レヴェルAPIが非常に使いにくいので、問題を一旦人が読みづらい形式に変換する必要がある。AMPLのようなモデリング言語を使えば、問題を容易に叙述的に表現できるが、汎用プログラミング言語としての力量と親和性が足りない。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは線型計画法を表現し解くための、Boost.Protoを用いたDSELであるCVX++を紹介する。Protoはどちらの世界、すなわちC++に組み込まれた叙述的プログラミングスタイルとして最高の役割を果たしてくれる。CVX++はGLPKをバックエンドソルバとして備え、Protoを用いて目的関数と制約をより機械が読みとりやすい表現に変換する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#solidfire&#34; name=&#34;solidfire&#34;&gt;SolidFireではC++11への移行をいかにして成しとげたか&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How we switched to C++11 at SolidFire and how it worked out&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/travis-gockel/&#34; target=&#34;_blank&#34;&gt;Travis Gockel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=43ej-H8yHWE&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=43ej-H8yHWE&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、SolidFireのコードベースをC++03からC++11に移行する過程について、まず作業チームがワクワクするところから順に見ていく。正確性の検証やパフォーマンステストをどう行なったか、またそれとともに、C++03とC++11のどちらでも動作するコードをどう書いたらいいか紹介していくつもりだ(また、どうやって障害を迅速に乗り越えたかについても)。&lt;/p&gt;
&lt;p&gt;C++03/C++11開発で最初の月を越したころ、我々はよりよいコードを書くためにC++03コードベースのサポートを放棄した。このプレゼンテーションの第二部は、新しい標準によってもたらされる新しいコーディングスタイルについて述べる。また、それなしでは実装できなかったとんでもなくトリッキーなクラスや、可読性を上げるためにややトリッキーなことをしているクラスについても紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#refactoring-clang&#34; name=&#34;refactoring-clang&#34;&gt;ClangでC++のリファクタリング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Refactoring C++ with Clang&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/chandler-carruth/&#34; target=&#34;_blank&#34;&gt;Chandler Carruth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cxxnow2012_refactoring.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/cxxnow2012_refactoring.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ：&lt;a href=&#34;http://www.youtube.com/watch?v=yuIOGfcOH0k&amp;amp;feature=plcp&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=yuIOGfcOH0k&amp;amp;feature=plcp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;十年来、C++開発者はJavaなどの言語が持っているツールをうらやましく思っていた。Clangでとうとう、我々は安全な自動変換を構築することができるほど簡便にC++コードの推論ができるようになる。このプレゼンテーションでは特殊なC++パターンの自動認識と変換をサポートする、Clang上に組まれた基盤について紹介する。また、古いAPIから新しい別のAPIへ更新するための、実際のソースコード変換ツールを実装するために必要な知識・技術についても示す。&lt;/p&gt;
&lt;p&gt;ライブラリの利用者が自身のコードを新しいAPIに置換するためのユーザー向けのスタンドアロンツールを組みあげることは、Boostのような広く利用されているライブラリでは非常に重要だが、C++11においては、新しい言語機能の利益を教授するために大量のインターフェースが更新されることになる。これらのインターフェースの採用を自動化することは、広く利用されているライブラリでは、長期にわたってサポートしなければならない非推奨APIの増加を抑える意味でも、急速な進歩をする上でも極めて重大なことである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#state-machine-coroutine&#34; name=&#34;state-machine-coroutine&#34;&gt;Boost.Coroutineを用いてステートマシンを解決する&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using Boost.Coroutine to untangle a state machine&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/nat-goodspeed/&#34; target=&#34;_blank&#34;&gt;Nat Goodspeed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/coroutine.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/coroutine.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションはイヴェント駆動型プログラムにおけるスタートアップのケーススタディである。このプログラムは外部サーバーへの一連のリクエストを生成し、それぞれ結果が返ってくるまで次のリクエストの生成を待機している。&lt;/p&gt;
&lt;p&gt;もともと、これはグローバルな&lt;code&gt;int&lt;/code&gt;状態変数を使って、巨大な&lt;code&gt;switch&lt;/code&gt;文として実装されていた。内在する関数はすべてのフレームで呼び出され、現在のステートロジックにジャンプし、結果を受けて状態を更新する。&lt;/p&gt;
&lt;p&gt;共同研究者がこれをBoost.Statechartを使って、ロジックをクラスのコレクションとして表現することで再実装した。&lt;/p&gt;
&lt;p&gt;どちらのケースでもロジックの構造は明確だった。実際の制御フローを解明するために、全てのコンポーネントの念入りな研究が必要だった。&lt;/p&gt;
&lt;p&gt;我々は同じロジックを、外部サーバーへのリクエストを結果が返ってくるまで待機する関数呼び出しとして表現するコルーチンとして再実装した。このような関数呼び出しはコルーチンだけを阻害する。すなわち、メインスタックの通常のフレーム毎の処理が継続する。実際のスタートアップ制御フローは、C++に精通していれば誰でも読める三重ループとして表現できる。さらに、メンテナンス(例えば、新しいリクエストを挿入するとか)は非常に容易である - これは前の実装ではとても言えなかったことであるが。&lt;/p&gt;
&lt;p&gt;このようなユースケースにおけるスレッドとコルーチンの対比を行う。&lt;/p&gt;
&lt;p&gt;coroutine オブジェクトの操作法について示す。&lt;/p&gt;
&lt;p&gt;Boost.Coroutineライブラリの微調整についても触れる。&lt;/p&gt;
&lt;p&gt;Boost.Contextがマージされたら、CoroutineをContextで再実装するつもりである。これこそまさにContextがサポートしようとしている種類のライブラリである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#metaprogramming-cpp11&#34; name=&#34;metaprogramming-cpp11&#34;&gt;C++11でのメタプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaprogramming in C++11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11で導入された新機能で、メタプログラマの世界は変化した。このプレゼンテーションでは、C++11メタプログラムをどう記述するかについての研究結果と、特にこの新しい言語にあわせたBoost.MPLの設計について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#numerical-problems-metaprogramming&#34; name=&#34;numerical-problems-metaprogramming&#34;&gt;メタプログラミングの数学的問題への適用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Metaprogramming Applied to Numerical Problems&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/karsten-ahnert/&#34; target=&#34;_blank&#34;&gt;Karsten Ahnert&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mario-mulansky/&#34; target=&#34;_blank&#34;&gt;Mario Mulansky&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/generic_stepper.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/generic_stepper.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ルンゲ=クッタ法と呼ばれるメソッドの高速かつ汎用的な実装をつくるために、現代的テンプレートメタプログラミングの手法をつかう。ルンゲ=クッタ法は常微分方程式(ODE: Ordinary Differential Equation)の初期値問題の近似解を探索する数値アルゴリズムである。常微分方程式を解くのは化学者、物理学者、生物学者にとっては日常のことである…&lt;/p&gt;
&lt;p&gt;今日、異なる一連のパラメータ値をとり、近似解の精度が違う、様々なルンゲ=クッタ法が存在する。そこで、これらのルンゲ=クッタ法を汎用的に実装し、テンプレートメタプログラミングを利用することで、非常に汎用的な実装であるにもかかわらず、非常に高いパフォーマンスを達成した。これは数値計算アルゴリズムの領域においてもテンプレートメタプログラミングの力を印象づける事例である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#tr2-boost&#34; name=&#34;tr2-boost&#34;&gt;TR2に向けたBoostライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boosting Libraries for TR2&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/boosting_libraries_for_standardization.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/boosting_libraries_for_standardization.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準委員会のLibrary Working Group(LWG)は新しいライブラリの技術報告、TR2に向けたライブラリ提案を待っている。開発者以外の方でも、BoostライブラリをTR2に提案できる。&lt;/p&gt;
&lt;p&gt;このセッションはまず、TR2にBoost ライブラリをうまく提案し、委員会を通して提案を導いていく方法についてのチュートリアルから入る。話す予定のトピックは以下の通り：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;どうしてわざわざこんなことを - 経験から得られるもの&lt;/li&gt;
&lt;li&gt;標準化プロセスの概略&lt;/li&gt;
&lt;li&gt;提案募集&lt;/li&gt;
&lt;li&gt;委員会ウェブサイトの案内&lt;/li&gt;
&lt;li&gt;システム - 提案はどのようなものか、 いつどこで提出するのか&lt;/li&gt;
&lt;li&gt;初期の提案 - 何を詳細に見て、何を詳細に見るべきではないかについて - 演習つき&lt;/li&gt;
&lt;li&gt;提案の用語と標準の記述&lt;/li&gt;
&lt;li&gt;ドラフトとレヴューを手伝ってもらう&lt;/li&gt;
&lt;li&gt;提案提出 - のるかそるか&lt;/li&gt;
&lt;li&gt;委員会からのフィードバックへの対応&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;セッションの後ろ半分はTR2にむけて実際にBoostライブラリの提案を一緒にやるワークショップを開く。まず提案のテンプレートの空欄を埋めていくところから始める。このワークショップにはLWGメンバが何人かいらっしゃるので、彼らに助言をもらったり、意見を聞いたりするといいだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#how-i-code-and-why&#34; name=&#34;how-i-code-and-why&#34;&gt;どうしてそう書くの？なんで？&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How I Code and Why&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/how_i_code_and_why.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/thu/how_i_code_and_why.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost委員会の方々(まだ未定。だが以前のBoostConで参加していただける旨をうかがった方の暫定リストはある)に、日々のコーディングで従っている原則について、なぜこの原則を適用していうのか、どのあたりに価値があると思っているかについて説明していただこうと思う。&lt;/p&gt;
&lt;p&gt;(例えば、私は、なぜ自分の好きなコミットワードが&#39;otherwise&#39;なのか、以前聞いたり読んだりされているかもしれないが、これに関連するどのようなアドヴァイスがあるか、この天啓に至った事件は何かを説明するつもりだ)
このプレゼンテーションの目的は、現実世界の話を時として書籍や講義で語られる高尚な理念に引き上げることである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#preparation-cppnow-2013&#34; name=&#34;preparation-cppnow-2013&#34;&gt;C++Now! 2013に向けた準備&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preparation of C++ Now! 2013&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来年の会合の準備委員会は早期に動きだす。提案があったり、支援していただける方はぜひご参加いただきたい。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;winrt&#34;&gt;WinRTにむけたC++コンポーネント拡張&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Component Extensions for WinRT&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/ale-contenti/&#34; target=&#34;_blank&#34;&gt;Ale Contenti&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/cpp_component_extensions_for_winrt_upload_version.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/cpp_component_extensions_for_winrt_upload_version.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は他のプログラミング言語やテクノロジー(例えば、 iOSのObjective-C、AndroidのJava、Windowsの.NETなど)を適用するプラットフォームにおいても活用されている。異種プログラミングプロジェクトがもたらす課題の一つに、C++の外部オブジェクトモデルとの結合という要求がある。CORBAやCOMといった既存の方法は一定の成功を収めているが、開発者は複雑性の増大というツケを払う羽目になる。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、この問題に対処するために、Microsoftが取った二つのアプローチの詳細について述べる。最初のアプローチは、同じアプリケーションの中に、C++と非C++コンポーネント(外部オブジェクトモデル)が 混在するという複雑性に対処するためにC++抽象化レイヤを採用するというものである。この抽象化レイヤ(例えば Boostユーザーや開発者の方々にはおなじみの今日的C++テクニックをがっつり使ったWRLライブラリとか)はCOMコンポーネントの実装を単純化したが、このソリューションにある一般概念は他のいかなる異種混在環境においても拡張可能である。二つ目のアプローチは、異種言語で記述されたピア(訳註： 同格のコンポーネント)とやりとりするコンポーネントの宣言と定義ができるように、その構文にいくつかの拡張を追加して、C++自身の境界を押し上げることである。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではこれら二つのアプローチについて、長所と短所、利点と注意事項についてそれぞれ説明していく。最後に、これらの設計が、C++の進化にとって潜在的にどのような影響を与えるかについてお話しする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#value-semantics&#34; name=&#34;value-semantics&#34;&gt;値のセマンティクスとConceptベースの多態&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Value Semantics and Concepts-based Polymorphism&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/sean-parent/&#34; target=&#34;_blank&#34;&gt;Sean Parent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表資料：&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/fri/value_semantics/value_semantics.pdf?raw=true&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/cppnow_presentations_2012/blob/355ac05d2937eea9b577b5a737b705b021b80045/fri/value_semantics/value_semantics.pdf?raw=true&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プレゼンターであるSeanは先のキーノートの &lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#now-what&#34;&gt;&#34;Now What? A vignette in 3 parts.&#34;&lt;/a&gt; で話した値のセマンティクスとConceptベースの多態コンセプトについて、更に深めていくつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Boostの将来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Future of Boost&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://cppnow.org/participant/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostとC++Now!の発起人であるお三方が将来について語り、どう考えているのかお答えする。&lt;/p&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi、zak、DigitalGhost&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2013 -- リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/cppnow/2013.html"/>
      <id>1d69ff3f3215dfb334de145741be086f700c6f89:cppnow/2013.md</id>
      <updated>2015-01-17 00:32:07 +0900</updated>
      
        <content type="html">&lt;h1&gt;C++Now! 2013&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://cppnow.org/schedule-table/&#34; target=&#34;_blank&#34;&gt;http://cppnow.org/schedule-t&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2013&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2013&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#doe&#34;&gt;キーノート： DOEによるC++の高性能コンピューティング - 過去と未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#survey-of-mt&#34;&gt;C++11とBoostにおけるマルチスレッドプログラミングサポートの概説&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#qt-eventloop&#34;&gt;Qtのイベントループ、ネットワーク、入出力API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#container-boost&#34;&gt;Boostのコンテナ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#low-level-threading&#34;&gt;C++11での低レベルスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#zephyr-cpp11&#34;&gt;&#39;優しきそよ風&#39;の見たC++11&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#proto-0x&#34;&gt;Proto-0x初お披露目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#nonalloc-future&#34;&gt;アロケートしない&lt;code&gt;std::future&lt;/code&gt;／&lt;code&gt;promise&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#debug-tmp&#34;&gt;C++テンプレートメタプログラムのデバッグとプロファイリング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#optimize-structure&#34;&gt;キーノート： C++の創発的構造を最適化する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#small-stuff&#34;&gt;おいしい小さな機能たち： 波カッコ初期化、共用体、列挙型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#agda&#34;&gt;Agdaへの知識向上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#hpx&#34;&gt;HPX: 非同期並列と分散コンピューティングのためのC++標準準拠ランタイムシステム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#scaling-cpp11&#34;&gt;C++11でスケールさせる！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#charm&#34;&gt;Charm++を使った並列プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#easy-binary-compatible&#34;&gt;C++の複数コンパイラ間バイナリ互換インタフェースを簡単に作る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#transactional-memory&#34;&gt;C++でのトランザクショナルメモリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#libcppa&#34;&gt;libcppa - C++11でのアクターセマンティックな設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#binary-compatibility&#34;&gt;ライブラリ開発者が知るべきバイナリ互換性について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#yet-another-paradigm-shift&#34;&gt;さらなるパラダイムシフト? (並行のMeta4モデル)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#spirit-x3&#34;&gt;Inside Spirit X3: C++11で再設計されたBoost.Spirit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#weak-hiding&#34;&gt;C++コンセプトのための弱い隠蔽: プログラミング言語の名前バインディングについて推論するフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cpp11-qt5&#34;&gt;Qt5でC++11を使う： 課題と解法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#thread-safe-bag&#34;&gt;スレッドセーフでスレッド中立なbag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#practical-cpp11-odb&#34;&gt;実践C++11：ODBへのC++11サポート追加で学んだこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#bloomberg&#34;&gt;応用階層的再利用: Bloomberg基盤ライブラリの利用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#boost-dispatch&#34;&gt;Boost.Dispatch - 汎用タグディスパッチ基盤ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#vienna&#34;&gt;計算科学向けViennaライブラリについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#alignment&#34;&gt;C++のアラインメント: 利用法、制限、および拡張法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#community-dev&#34;&gt;C++ コミュニティの発展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#dynamic&#34;&gt;動的なC++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#debruijn&#34;&gt;DeBruijn Bind: シンプルさを維持するより強力なbind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#multi-threading&#34;&gt;C++11とBoostを利用したマルチスレッディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#concept-lite&#34;&gt;軽量コンセプト: 述語による制約テンプレート&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#html5&#34;&gt;ママ見て “C++を使ってデータベース更新からHTML5が生成されたよ”, 自動化して!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#odb&#34;&gt;C++(11)のためのORマッパー：ODB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#fusion&#34;&gt;Fusionで世界の謎を解く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#dds&#34;&gt;モダンなC++向けのデータ分散サーヴィス(DDS: Data Distribution Service)の標準化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#member-access-operator&#34;&gt;メンバーアクセス演算子のオーヴァーロード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cern&#34;&gt;CERNでの対話的で内省的なC++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#haskell&#34;&gt;Haskellの力でMPLを強化しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#object-transmission&#34;&gt;Boost.AsioとBoost.Serialization: オブジェクト受け渡しのデザインパターン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cppnow-2014&#34;&gt;C++Now 2014の準備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#hetero&#34;&gt;静的型付け言語における、動的で再帰的なヘテロ型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#projucer&#34;&gt;Projucer: C++とLLVM JIT エンジンを利用したライブコーディング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#matrix&#34;&gt;EigenとBoost Protoライブラリを用いた有限要素マトリックス式の組み立て&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#deadlock-prevention&#34;&gt;侵入的動的解析を使用したリソースデッドロック防止システム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#future-of-boost&#34;&gt;Boostの未来&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#doe&#34; name=&#34;doe&#34;&gt;キーノート： DOEによるC++の高性能コンピューティング - 過去と未来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: C++ Use in High Performance Computing Within DOE: Past and Future&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/daniel-quinlan/&#34; target=&#34;_blank&#34;&gt;Daniel Quinlan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=zZGYfM1iM7c&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=zZGYfM1iM7c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#survey-of-mt&#34; name=&#34;survey-of-mt&#34;&gt;C++11とBoostにおけるマルチスレッドプログラミングサポートの概説&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Survey of Multi-Threaded Programming Support in C++11 and Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/rob-stewart/&#34; target=&#34;_blank&#34;&gt;Rob Stewart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルではBoostとC++11によるマルチスレッドプログラミング向けのツールについて概説します。&lt;/p&gt;
&lt;p&gt;このセッションの内容に取り入れる事が明らかな項目としては、例えば &lt;code&gt;std::thread&lt;/code&gt; や &lt;code&gt;boost::thread&lt;/code&gt; 、またより先進的な機能、 例えば &lt;code&gt;std::async&lt;/code&gt; 、それに、これらを実現する為のより基本的な部品として、例えばミューテックス(&lt;code&gt;std::mutex&lt;/code&gt;)、条件変数(&lt;code&gt;std::condition_variable&lt;/code&gt;)、アトミック(&lt;code&gt;std::atomic&lt;/code&gt;) などが挙げられる。&lt;/p&gt;
&lt;p&gt;つまるところこのセッションでは全体として、BoostやC++11が如何に皆さんのマルチスレッドプログラムのコーディングを助けてくれるのかについて概説します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#qt-eventloop&#34; name=&#34;qt-eventloop&#34;&gt;Qtのイベントループ、ネットワーク、入出力 API&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Qt event loop, networking and I/O API&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Qtフレームワークが誕生したのは1990年台始めの頃の事、その時Qtはまだ、単純な目的の為だけに開発されたんだ。そう、グラフィカルプリケーションを作る為のクロスプラットフォームなAPI（それもその当時はせいぜいデスクトップとワークステーション程度を対象にね）としてね。それからQtはその目標を遥かに超えてよく成長してくれました。今日ではGUIツールキットの枠を超えて他の多くのサブシステム群、データベース接続、WEB技術との統合、そしてパワフルな非同期I/Oとネットワーク周りの機能等々を提供するに至っている。このセッションではそれらの中から、QtのI/Oとネットワーク周りについてチュートリアル形式で紹介します。&lt;/p&gt;
&lt;p&gt;Qtの全ての非同期的なメカニズム群はイベントループないしメインループによるセントラルイベントハンドリングのループから呼び出されています。そうしてQtが提供する非同期I/Oによる子プロセスの動作や、TCP接続群のアクセプト、TCP接続群の発信の生成、TCPとUDPのI/Oハンドリング、その他のタスク群が構築されています。もちろんそれはHTTPとFTPのダウンロードとアップロードと言った高レベルなイベントにも至ります。このセッションではそれら全てのサブシステム群についてを取り上げ、どうやってアプリケーションにそれらを組み込んで使うのかについて、例示をしたり、それに一緒に議論をしたいと考えています。このセッションを通じてライブラリー開発者とアプリケーション開発者、双方の理解をQtを通して深める機会として頂ければ幸いです。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#container-boost&#34; name=&#34;container-boost&#34;&gt;Boostのコンテナ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Containers in Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-schaeling/&#34; target=&#34;_blank&#34;&gt;Boris Schäling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostライブラリは、多くの便利なコンテナと、標準コンテナの素敵な拡張を提供している。このセッションでは、Boostにある以下のコンテナ群を見ていく： Boost.Multiindex、Boost.Bimap、Boost.CircularBuffer、Boost.PropertyTree、Boost.DynamicBitset、Boost.PointerContainer、Boost.Intrusive。開発者は、自分のプロジェクトに恩恵をもたらすコンテナを選択できるようになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#low-level-threading&#34; name=&#34;low-level-threading&#34;&gt;C++11での低レベルスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Low Level Threading with C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は現在、「メモリモデル」を持っている。それは何を意味するのか、それはなぜあるのか、それが必要ならなぜこれまでなかったのか？これがあると我々は何ができるのか？これは新しく入ったアトミック操作と多少関連があるようだ。うーん・・・。&lt;/p&gt;
&lt;p&gt;(これは昨年やったチュートリアル「C++11の新たなメモリモデルとアトミック」のアップデートである。)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#zephyr-cpp11&#34; name=&#34;zephyr-cpp11&#34;&gt;&#39;優しきそよ風&#39;の見たC++11&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Zephyr Overview of C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/leor-zolman/&#34; target=&#34;_blank&#34;&gt;Leor Zolman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;去年の事、私はC++11の殆どの機能について、たった90分だけの&#34;嵐の様な&#34;セッションで質問に答える間も無く、その可能性について示すに留まった。&lt;/p&gt;
&lt;p&gt;そして今年、私は1本90分のセッション枠を拡大して、2本分のセッションを使える事になった。参加してくれるみんな（それに私自身も含めて）、今回はきちんと息をする余裕もあるよ。だから今回は質問に答えたり、それにひょっとしたらライブコーディングをできるチャンスもあるかもしれないね。&lt;/p&gt;
&lt;p&gt;内容については凡そ去年のそれと同じにするつもりだけど、去年は時間が無くて扱えなかった言語とライブラリーの機能、それと実装例なんかも用意したいね。&lt;/p&gt;
&lt;p&gt;(訳者註: Zephyr(ゼファー)はギリシア神話の風の神様の中で最も温和で春の訪れを告げる豊穣の優しいそよ風の神様のこと。)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#proto-0x&#34; name=&#34;proto-0x&#34;&gt;Proto-0x初お披露目&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A First Look at Proto-0x&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/eric-niebler/&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Protoは、C++に組み込みドメイン特化言語(EDSL)を構築するためのライブラリである。Boostでは、Spirit、Phoenix、Xpressive、MSM、それと提案中ではあるがBoost.SIMDのようなライブラリが、Protoによる式テンプレートベースで構築されている。Protoで定義されたEDSLは、手間のかかるテンプレートメタプログラミングの雑用からライブラリ作者を解放し、構文やセマンティックアクションといった面で、高レベルに表現できる。&lt;/p&gt;
&lt;p&gt;Boost.Protoの現在利用可能なバージョンは、C++03言語の限界を押し上げてはいるが、言語によって課せられる制約で苦しんでいる。このトークでは、C++11で再設計されたProtoの新バージョンについて話す。これは、EDSLの設計を、これまで以上に簡単かつ安全にできる。&lt;/p&gt;
&lt;p&gt;このトークでは、Proto-0xによる小さなEDSL定義の基本をカバーする。新しいProtoは、古いProtoと異なるポイントはあるが、その事前知識は必要ない。C++11の新機能がProtoの設計にどのような影響をもたらしたか、また、それらの機能が一般的なライブラリ設計を、根本的なところでより良くすることを紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#nonalloc-future&#34; name=&#34;nonalloc-future&#34;&gt;アロケートしないstd::future／promise&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Non-Allocating &lt;code&gt;std::future&lt;/code&gt;/&lt;code&gt;promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/tony-van-eerd/&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共有状態 - mutex/convarが待ち合わせるように別スレッドの処理の結果を置く場所 - は、&lt;code&gt;future&lt;/code&gt;と&lt;code&gt;promise&lt;/code&gt;はいつでもムーヴ、破棄され得るので、&lt;code&gt;future&lt;/code&gt;と&lt;code&gt;promise&lt;/code&gt;で別々にアロケートされる必要があると予想される。故に共有状態には別個のメモリ配置が必要である。&lt;/p&gt;
&lt;p&gt;本当にそうだろうか？&lt;/p&gt;
&lt;p&gt;このセッションでは、等式の右辺、左辺ともにムーヴ中もしくは破棄されようとしていても、アロケートなしで状態を共有するために細心の注意を払ってロックフリーの技術を用いる&lt;code&gt;std::future&lt;/code&gt;／&lt;code&gt;promise&lt;/code&gt;の草案について説明する。&lt;/p&gt;
&lt;p&gt;このセッションは非常にインタラクティヴなものになるだろう。聴者諸氏は実装に漏れがなくなるまで、実装のどのステップについても問題点を指摘していただきたい。このセッションでは、ロックフリーテクニックを現実のコードにどう適用したらいいか、感覚がつかめるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#debug-tmp&#34; name=&#34;debug-tmp&#34;&gt;C++テンプレートメタプログラムのデバッグとプロファイリング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Debugging and Profiling C++ Template Metaprograms&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/zoltan-porkolab/&#34; target=&#34;_blank&#34;&gt;Zoltan Porkolab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++テンプレートメタプログラミングは、テンプレートの巧妙な定義によって、C++コンパイラにコンパイル時にアルゴリズムを実行させる、よく知られた手法である。アプリケーションにおけるテンプレートメタプログラムには、式テンプレート、静的なインタフェースチェック、アダプトによるコード最適化、組み込みドメイン特化言語とアクティブライブラリなどがある。C++11の新機能は、テンプレートメタプログラミングをさらに魅力的にする。&lt;/p&gt;
&lt;p&gt;その重要性にもかかわらず、C++テンプレートメタプログラミングの設計、保守、分析を支援するためのツールは、驚くほど少ない。テンプレートの重いコードを使用することでプログラムに増加されるコンパイル時間は、その分野への挑戦が少なくなっている理由のひとつである。利用できるデバッガ、プロファイラといったツールの欠如は、テンプレートメタプログラミングの広い使用を妨げている。&lt;/p&gt;
&lt;p&gt;我々は、これまでの経験に基づいて、テンプレートメタプログラムのデバッガとプロファイラのプロトタイプツールセットを開発している。このツールセットの目的は、C++テンプレートの使用率が高い、大きなコードベースで作業している、開発者やメンテナのためのサポートを提供することだ。このツールセットは、C++テンプレートメタプログラムのバグやコンパイルボトルネックを調査するという、おもしろいことができる。&lt;/p&gt;
&lt;p&gt;このツールセットは、LLVM/ClangオープンソースC++コンパイラインフラストラクチャ上に構築されている。テンプレートに関連するコンパイラアクションの最も重要なキャプチャは、プログラムの「インスタンス化スタック」を記録し、XML形式のトレースファイルを出力する。このファイル内の全てのエントリは、テンプレートインスタンス化の最初か最後を表す。エントリには、Clang仕様のイベントの型が含まれる。さらにくわしい情報は、テンプレートの名前へのインスタンス化、およびインスタンス化によるコードの位置(通常は、呼び出し元)である。プロファイルに関連する情報は、インスタンス化の時間(これは実行時間:wall time)と実際のメモリ使用量が含まれるタイムスタンプである。時間とリソース消費のメモリプロファイリングは、オフにすることができる。プロファイリングの歪み(distortion)を最小限に抑えるには、XMLトレースファイルの内部バッファと生成の遅延を行う。我々の計測では、時間の歪みは3%未満だった。&lt;/p&gt;
&lt;p&gt;また、我々はトレースファイルに格納されている結果を資格する、Qtベースのフロントエンドも開発した。このフロントエンドは、実行時デバッガと同様、ユーザーがブレークポイントを設定でき、ステップバイステップでインスタンス化を再生できる、ソースコードビューを持っている。興味のないインスタンス化は、正規表現を使用して可視化から除外できる。他のビューとしては、インスタンス化にかかる時間と、オプショナルなメモリ使用量のプロファイル情報がある。最後に、インスタンス化の依存関係を表現し、インスタンス化手順のアニメーション化とグラフ化を行う。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#optimize-structure&#34; name=&#34;optimize-structure&#34;&gt;キーノート： C++の創発的構造を最適化する&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: Optimizing the Emergent Structures of C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/chandler-carruth/&#34; target=&#34;_blank&#34;&gt;Chandler Carruth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=eR34r7HOU14&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=eR34r7HOU14&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日、C++ソフトウェアの複雑さはいや増している。この複雑さを管理し、大規模アプリケーションやシステムを構築するべく、C++は、シンプルなパターンを組み合わせて非常に複雑かつ強力なシステムをつくりだす創発的構造(自然界ではよく見られる、雪の結晶のような対象構造)をつくりだすべく努力している。このような構造により、各コンポーネントの複雑性を制限し、ソフトウェア開発する上で信頼できるスケーラビリティが得られる。&lt;/p&gt;
&lt;p&gt;手持ちのディヴァイスからウェアハウス級データセンターまで、よりディヴァイスを小さくしようとしたりと電力消費を抑えようとして、C++を利用すると、効率と複雑さが相応しないシステムになってしまうことは疑いない。今日も最適化がすすむC++コンパイラはかつてないほどその重要性が高まっているが、現役プログラマにはほとんどそれが伝わっていない。これらのことを鑑みると、高度創発的構造はC++システムを拡大し、しばしば最適化に関する独創的で未解決の問題を提起することがある。&lt;/p&gt;
&lt;p&gt;このセッションでは、今日の最適化されたコンパイラがC++コードをいかに高度にコンパイルするか、という概観から始める。次に、C++コードの創発的構造を単純かつエレガントに形成する鍵となる特殊な構造とパターンについて概説する。さらに、このような相互作用をいかに効率的にモデル化し解析できるかについて、効率的な完成プログラムを作るためのコンパイラを使って検証する。実際のケーススタディを例としてとりあげ、最新のC++コードベースで表現され、広く適用可能であることを示す。これらのパターンによる意味に気付いていただくために、最適化されたコンパイラとC++コード双方の相互作用を理解するためのフレームワークを示すことが目的である。最後に、特にそれぞれのコンポーネントが単純さを保持し、組み合わせによって力を発揮する、今日の最適化向けの方法を示すため、C++プログラムやライブラリの設計上、実装上の技術および原理について示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#small-stuff&#34; name=&#34;small-stuff&#34;&gt;おいしい小さな機能たち： 波カッコ初期化、共用体、列挙型&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sweating the Small Stuff: Brace Initialization, Unions and Enums&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/scott-schurr/&#34; target=&#34;_blank&#34;&gt;Scott Schurr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11は多くの派手な新機能がある： ラムダ式、ムーブコンストラクタみたいな。このようなカッコイイ機能に比べてセクシーさでは劣るが、便利な変更がいくつか入った。このトークでは、初心者から中級レベルの専門家に向けて、C++11の波カッコ初期化(一様初期化とも呼ばれる)、共用体、列挙型について話す。&lt;/p&gt;
&lt;h2&gt;&lt;a name=&#34;agda&#34;&gt;Agdaへの知識向上&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Intellectual Ascent to Agda&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/david-sankel/&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数学とコンピュータサイエンスについて考えていると、漸近解析と物理シミュレーションのビックリするようなアルゴリズムが思いつくことがある。これらはいつも見過ごされがちな表示的意味論であり、構文と意味論の数学である。&lt;/p&gt;
&lt;p&gt;表示的設計(denotative design)、表示的意味論の実践は、シンプルで、合成可能で、信じられないほどパワフルなライブラリを作るトップダウン設計の方法論である。これは全く異なる文化のものだが、一般的に使用できる。そのパワフルなテンプレートエンジンは、C++に特に適している。&lt;/p&gt;
&lt;p&gt;このセッションでは、純粋関数型で依存型言語であるAgdaの構文を使用して、ドメイン固有の数学的エンティティからC++プログラムに派生させる表示的設計を、以下にして適用するかを学ぶ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#hpx&#34; name=&#34;hpx&#34;&gt;HPX: 非同期並列と分散コンピューティングのためのC++標準準拠ランタイムシステム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HPX: A C++ Standards Compliant Runtime System For Asynchronous Parallel And Distributed Computing&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/hartmut-kaiser/&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/vinay-amatya/&#34; target=&#34;_blank&#34;&gt;Vinay Amatya&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マルチコアとマルチスレッディングは、新しい計算手法であり、科学分野か非科学分野かに関わらず、システムの継続的なスケーラビリティを得るためには、ノード内だけでなくノード間もスケールさせる必要がある。新しいアーキテクチャにおける計算量やサイズ増加といったものは、スタベーション、レイテンシー、オーバーヘッド、競合解決待ちと呼ばれ、これらはシングルコアマシンでも存在はしていたが、表面化しにくかった。Exaflopレベルにシステムを拡張すると、この大幅に少ないリソース使用率の面でコストが増加する。その間、スケーリングシステムであっても、特定クラスのアプリケーションは従来の計算モデルを使用してスケールすることはできない。&lt;/p&gt;
&lt;p&gt;HPXは、新たな計算モデルに対する新たなランタイムシステムである(ParalleXは、上述した問題への挑戦である)。HPXはC++で実装され、最新のC++標準とBoostに準拠している。HPXは、新たな計算モデルに対する新たなランタイムシステムである(ParalleXは、上述した問題への挑戦である)。HPXは、様々な実績あるソフトウェア技術とアルゴリズムを、理解しやすくすることができます。HPX APIは、マルチコア・マルチスレッド化された混在アークテキチャとユーザーレベルソフトウェアアプリケーションのシームレスな統合のためのインタフェースを提供し、学ぶのを容易にする。&lt;/p&gt;
&lt;p&gt;非同期と計算、通信、それらを組み合わせることは、新たなマルチコア混在アーキテクチャをサポートする、新たな計算モデル要件のひとつとして重要である。非同期タスク(アクションという形式でのローカル関数やリモート関数)は、HPXの主要設計機能のひとつである。HPXは最新のC++標準がサポートしているローカル非同期関数だけでなく、リモート非同期関数も実装している：Actionという。これに加えて、非同期をサポートするのに本質的な、タスク実行中にFutureやDataFlowとしてデータを構築することができる。&lt;/p&gt;
&lt;p&gt;マルチコアドメインはシステムアーキテクチャ分野での巨大な飛躍にも関わらず、数十コアを超えたスケーラビリティ制限の課題がある。したがって、高パフォーマンスシステムでは、我々は複数ノードのBeowulfタイプのクラスターに依存している。通信の待ち時間が大幅に増加するようなシステムでは、非同期が大きな役割を果たしている。これに加えて、コアを数万を超えて拡張すると、新たなアドレッシングシステムが必要となり、アクティブアプリケーションのリモートスレッドオブジェクトを一時的に停止するのを許可するだけでなく、リソースの必要性(システム的な失敗やビジー状態)に従ってタスクを移動する必要がある。このアクティブなアドレッシングスキームは、HPXではActive Global Address Space(AGAS)として実装されている。このアドレッシングスキームは、HPXを、アプリケーションの必要性に応じた正しいリソース配置のためのリソースマネージャーをサポートすることを可能にする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#scaling-cpp11&#34; name=&#34;scaling-cpp11&#34;&gt;C++11でスケールさせる！&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scaling with C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/edouard-alligand/&#34; target=&#34;_blank&#34;&gt;Edouard Alligand&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;プロセッサのコア数が増加するにつれて、ソフトウェアはムーアの法則からの恩恵を受けるために、複数のタスクを実行できるようにする必要がでてきます。これは並列アルゴリズムを書くという問題だけではなく、スレッド間の依存関係を正しく減らす、アプリケーション設計の問題でもあります。これらの依存関係を見つけることは、シリアルプログラミングの数十年の結果から見ても、非常に難しいことです。したがって、真にスケーラブルなソフトウェアを書くことは、精神状態を適切に適応させることよりも小さな、技術的な専門知識の問題です。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、超スケーラブルなデータベースである「quasardb」を書いたチームによって使用されている、設計、手法、ツールについて話します。具体的なスケーラビリティの課題として、典型的なマルチスレッドプログラミングのアンチパターンと、それを避ける方法を紹介します。説明するトピックは、以下のものをカバーします：アトミック、マイクロロック、Lock-freeとwait-freeなコンテナ、メモリ管理戦略(copy on write、スマートポインタ、完全転送)、スレッドローカル記憶域、非同期I/I、その他いろいろ！&lt;/p&gt;
&lt;p&gt;このプレゼンテーションは、システムプログラミングとC++11(ラムダと右辺値参照)の十分な知識を想定しています。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#charm&#34; name=&#34;charm&#34;&gt;Charm++を使った並列プログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Parallel Programming using Charm++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/phil-miller/&#34; target=&#34;_blank&#34;&gt;Phil Miller&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/axmikant-kale/&#34; target=&#34;_blank&#34;&gt;Laxmikant Kale&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/ramprasad-venkataraman/&#34; target=&#34;_blank&#34;&gt;Ramprasad Venkataraman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Charm++は、20年の実績があり、シングルワークステーションから世界最大のスーパーコンピュータまでカヴァーするハイパフォーマンスなC++ベースの並列プログラミングフレームワークである。このフレームワークは共有メモリシステムと分散メモリシステムを、双方のシステムで共通な技術で横断できる並列実行機能を備える。&lt;/p&gt;
&lt;p&gt;並列の単位としてオブジェクトを利用することで、Charm++は、関連するオブジェクトのコレクションによる並列アプリケーションロジックが表現できる。これにより、現存するハードウェアを十分効率的に利用する、結合可能な並列ソフトウェアが作成できる。実行中、Charm++のランタイムシステムはアプリケーションの挙動とシステムの状態を観測し、その結果に応じて、オブジェクトとプロセッサのマッピングを行なう。そうすることで、ランタイムシステムは効率よくロードバランスやエネルギー管理といったドメインに依存しない要求を自動化できる。それゆえ、アプリケーション開発者は、アプリケーションやユーザーからのそういった要求に取り組むことから解放される。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションではCharm++での並列アプリケーション開発の原理について示す。このパラダイムを使った並列アルゴリズムを記述する利点についても述べる。高速でスケーラブルなソフトウェアを作成するためにCharm++をどのように使うかという例もいくつか紹介する。Charm++を使って、自身の並列プログラムを構築するための並列ロジックをどう組みあげるかについて学習する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#easy-binary-compatible&#34; name=&#34;easy-binary-compatible&#34;&gt;C++の複数コンパイラ間バイナリ互換インタフェースを簡単に作る&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Easy Binary Compatible C++ Interfaces Across Compilers&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/johnbandela/&#34; target=&#34;_blank&#34;&gt;John Bandela&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++は他の生産性が高い言語から、使うのが難しいと認識されています。その理由のひとつに、バイナリコンポーネントの互換運用性の欠如があります。ライブラリを使用するとそのうち、ソースから構築したり、複数のバイナリを配布したりする必要が出てきます。たとえばWindowsでは、GCC Mingw、Visual C++ 2010(のリリース、デバッグ、静的と動的のCRT)、Visual C++ 2012などのバイナリを配布する必要があります。この問題を回避するための試みがいくつかある。たとえば、選択肢のひとつとしてextern Cを拡張してCOMやXPCOM、C++/CXといったものを追加することが考えられるが、このオプションにはコンパイラの拡張機能を必要とするとともに、現代のC++では低レベルであるように感じる。&lt;/p&gt;
&lt;p&gt;C++11を実装している多くのコンパイラは、ラムダ式や可変引数テンプレートといった便利な機能を持っており、これらを使用して簡単に複数のコンパイラ間で動作するバイナリインタフェースを実装できます。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、以下の恩恵を受けるための、ライブラリの設計と実装について議論します：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部ツールを必要としない&lt;/li&gt;
&lt;li&gt;インタフェースを一度だけ定義し、その定義を実装とユーザーコードで使用する&lt;/li&gt;
&lt;li&gt;インタフェースは、簡単に実装でき、一度だけ定義すればよい&lt;/li&gt;
&lt;li&gt;そのインタフェースで&lt;code&gt;std::string&lt;/code&gt;、&lt;code&gt;std::vector&lt;/code&gt;、&lt;code&gt;std::pair&lt;/code&gt;を使用する&lt;/li&gt;
&lt;li&gt;現実的な戻り値で使用する(エラーコードではない)&lt;/li&gt;
&lt;li&gt;例外を使用する実装と使い方&lt;/li&gt;
&lt;li&gt;COMとバイナリ互換性を持つ&lt;/li&gt;
&lt;li&gt;インタフェースの継承をサポートする&lt;/li&gt;
&lt;li&gt;実装の継承をサポートする&lt;/li&gt;
&lt;li&gt;実装は、WindowsのVisual C++の実行ファイルとGCCの.dllでテストした&lt;/li&gt;
&lt;li&gt;実装は、LinuxのGCCの実行ファイルと、Clangの.soでテストした&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、上記の機能の実装について議論し、そのいくつかのトレードオフを見ていきます。私は、参加者との、異なるアプローチでこれよりうまく作る方法について議論するのを待ちわびている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#transactional-memory&#34; name=&#34;transactional-memory&#34;&gt;C++でのトランザクショナルメモリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Transactional Memory in C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-wong/&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++標準のSG5は、2種類のトランザクションに基いて&lt;a href=&#34;https://sites.google.com/site/tmforcplusplus/&#34; target=&#34;_blank&#34;&gt;V1.1 of the Draft Transactional Memory for C++&lt;/a&gt;を4年間取り組んでいる。&lt;/p&gt;
&lt;p&gt;この提案は、2種類のトランザクションをサポートする：&lt;/p&gt;
&lt;p&gt;分離トランザクション(isolated transaction)はいくつかの種類の安全性アノテーションを通じて、非トランザクションコード(と同様のトランザクション)と通常のトランザクションを通信できる。&lt;/p&gt;
&lt;p&gt;我々はさらに、完全なコンパイル時チェックから動的チャックまで、様々なレベルの安全性アノテーションをサポートするための異なる手法を示し、プログラマの負担を軽減させる。&lt;/p&gt;
&lt;p&gt;これがSG5の技術仕様としてのBrisol 2013の提案意図である。&lt;/p&gt;
&lt;p&gt;現在あるいくつかのTMは、時期尚早だと考えているが、ハードウェアサポートが間もなく来るだろう、ということを言わせてほしい。Intelは最近Haswellを発表したし、IBMのBG/Q、それ以前にはSunのRockもある。ソフトウェアTMサポートとしては、IntelはSTMのDraft 1.0をかなり前からサポートしているし、直近ではGCC 4.7がほぼ完全なDraft 1.1をサポートしている。&lt;/p&gt;
&lt;p&gt;それでもまだ早すぎると思う場合は、Hans Boehmの発見のひとつが、ロックはジェネリックプログラミングでは実用的ではない、ということだったと言わせてほしい。なぜなら、ロックの順序は一般的にインスタンス化されるまで見えないからだ。C++11で導入されたロック(とアトミック)では、この問題を回避するのが困難だ。トランザクショナルメモリは、この問題を解決するひとつの方法である。それは不規則なデータ構造や、読み取りを主に行うデータ構造(read-mostly structure)に対して細粒度ロックするのにも役立つ。&lt;/p&gt;
&lt;p&gt;このトークでは、我々は使用経験やパフォーマンスデータを含む、標準C++への提案を紹介する。&lt;/p&gt;
&lt;p&gt;トランザクショナルメモリが十分に速いことに、まだ疑問を持っている？多くのソフトウェアトランザクショナルメモリシステムは異なるパフォーマンス特性を持っているので、どれかはあなたのニーズを満たすと思う。&lt;/p&gt;
&lt;p&gt;TMは様々な形(ハードウェア、ソフトウェア、ハイブリッドシステム、ロック省略)で到来している。すでに多くの言語がTMをサポートしているので、C++にこれを提案するのはいい時期だろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#libcppa&#34; name=&#34;libcppa&#34;&gt;libcppa - C++11でのアクターセマンティックな設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;libcppa - Designing an Actor Semantic for C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/dominik-charousset/&#34; target=&#34;_blank&#34;&gt;Dominik Charousset&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/matthias-vallentin/&#34; target=&#34;_blank&#34;&gt;Matthias Vallentin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;並列ハードウェアで効率的にプログラムを実行させるには、並行性は必須である。しかし、並行ソフトウェアを書くことは、挑戦的であり、エラーが起こりやすい。C++はマルチスレッドプログラミングの標準的な設備、acquire/relaseセマンティクスによるアトミック操作とRAIIのミューテックスロッキングを提供するが、これらのプリミティブはあまりにも低レベルである。それらを正しくかつ効率的に使用するには、まだ専門的な知識と手作りが必要だ。アクターモデルは、暗黙的な通信を、明示的なメッセージパッシングメカニズムによる共有で置き換える。これは分散的な並行性として適用でき、事前に次元が決定されたスレッドプール内の全てのアクターをスケジュールした軽量アクターモデルの実装は、スレッドベースアプリケーションと同等のパフォーマンスを出すことができる。しかしアクターモデルは、ネイティブプログラミング言語のベンダー固有のソリューションには入れない。オープンソースライブラリであるlibcppaで我々は、C++11のパフォーマンスとリソース効率を持つアクターモデルによって、信頼性の高い分散システムを構築する能力を統合したい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/dominik_charousset_paper_cppnow2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#binary-compatibility&#34; name=&#34;binary-compatibility&#34;&gt;ライブラリ開発者が知るべきバイナリ互換性について&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Binary compatibility for library developers&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C標準のように、C++標準はコンパイラの重要なふるまいと、合法なプログラムを構成するものを規定している。しかし、ABIとバイナリ互換性に関する問題については、意図的にうまく避けられている。今でさえ、それぞれ独自に管理されるモジュールやダイナミックリンクに関する問題や経験について、あまり議論されていない。Cよりもはるかに複雑かつ強力なので、コンパイラはCよりもはるかにややこしいC++ABIを作る。(原文: Because it is much more complex and powerful than C, compilers implement a C++ ABI that is an order of magnitude more complex than C++. 訳註: Cのtypoか)また、Cとは異なり、単一のプラットフォーム(オペレーティングシステムとアーキテクチャ)であっても、C++のABIはコンパイラごとに異なる。&lt;/p&gt;
&lt;p&gt;未だライブラリ開発者はしばしばCやC++標準に定義されていないこの種の問題について、理解したり解決したりする必要に迫られる。これは決して不可能なことではなく、リリース間のバイナリ互換性を保証するための信頼できる単純なガイドラインやチェックリスト、ツールや作業が存在する。これらを利用して、複数のリリースにわたって、大きなライブラリの長期間以前のヴァージョンとの互換性を維持することが可能である。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションでは、この種の現実にある問題と主にQtやKDEで使われた解法について述べる。特に、Qt4がどうやって7年間にわたり、9つの機能リリースと数十個のパッチリリースをしてなおリリースバイナリの互換性を維持したのかについて示す。また、間違いとその修正についても示す。その後、どのようにコンパイラがABIを作るのかについて詳細な議論をしたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#yet-another-paradigm-shift&#34; name=&#34;yet-another-paradigm-shift&#34;&gt;さらなるパラダイムシフト? (並行のMeta4モデル)&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Keynote: yet another paradigm shift (yaps) ? (A Meta4 model of concurrency)   &lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/stanley-lippman/&#34; target=&#34;_blank&#34;&gt;Stanley Lippman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ビデオ： &lt;a href=&#34;http://www.youtube.com/watch?v=SLLOSAm-OS0&#34; target=&#34;_blank&#34;&gt;http://www.youtube.com/watch?v=SLLOSAm-OS0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特にC++の話として、C++の後ろに見え隠れする非常に先進的なアイデア/技術の兆候から、同型の多細胞生物の受精を例にとって、進化でも革新でもなく、単にmeta4layersの同期をとるだけというさらなるパラダイムシフトの提案に至るまでの言語のライフサイクルについて議論したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#spirit-x3&#34; name=&#34;spirit-x3&#34;&gt;Inside Spirit X3: C++11で再設計されたBoost.Spirit&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Inside Spirit X3: Redesigning Boost.Spirit for C++11&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/joel-de-guzman/&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon ’07、’08、’09、’10で行ったSpiritの使い方に関するチュートリアルは、大きな成功を収めた。この時間では、Spiritの設計と実装に焦点を当てたプレゼンテーションを行う。さらなる挑戦として、C++11の新機能のアドバンテージを活かして、Boost.Spiritを大きく再設計した。この実験的なバージョン(X3)の、ひとつの大きな目標は、C++の言語機能不足のために失われた「Classic」のエレガントなシンプルさを取り戻すことだ。この90分のプレゼンテーションでは、現代的なC++11コードで今汚いポイントに挑み、私の経験に基づくC++11の欠点を共有した上でC++1yの希望について話したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#weak-hiding&#34; name=&#34;weak-hiding&#34;&gt;C++コンセプトのための弱い隠蔽: プログラミング言語の名前バインディングについて推論するフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Weak Hiding for C++ Concepts: via a Framework for Reasoning about Name Binding in Programming Languages&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/larisse-voufo/&#34; target=&#34;_blank&#34;&gt;Larisse Voufo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++の名前探索とオーバーロード解決の規則は複雑で(伝統的なスコープ、ADL、テンプレート引数の推論とSFINAE、オーバーロード、それらの組み合わせ)、コンセプトを言語に追加すると、これらの規則がさらに複雑になります。コンセプト付きC++のために名前探索とオーバーロード解決の規則の最高の代替設計を行うことは、現在の規則が不透明であることから困難です。&lt;/p&gt;
&lt;p&gt;現在のものと提案中のもの、両方の規則を解説するために、プログラミング言語の名前探索(名前バインディングとも言う)のための解説システムのための統合フレームワークを紹介します。このフレームワークは、現在の規則を説明できるだけでなく、名前探索(とオーバーロード解決)に対してコンセプトの提案がどのような影響を与えるのか理解するのを用意にするためにも使用できます。このモデルは、異なる言語の微妙な違いや潜在的な拡張機能、ADLの複雑さ、演算子を使用する際の標準的な規則の誤解といったものを表現します。さらに、Clangの拡張であるConceptClangなどの既存のコンパイラに対して、C++のコンセプトの実装を調査することも可能にします。&lt;/p&gt;
&lt;p&gt;たとえば、C++にコンセプトが含まれていた最後のドラフト(N2914)での名前探索とオーバーロード解決の仕様では、制約テンプレートのところで、現在の規則の元で正しいコードを無効にしてしまいます。この問題が起きる原因は、制約名が、テンプレートの外で定義された名前と同じように扱われるからです。&lt;/p&gt;
&lt;p&gt;我々が提案するフレームワークは、「弱い隠蔽(Weak Hiding)」という別な選択肢をとります。これは周囲のスコープ(と関連する名前空間)にある名前が、テンプレート制約の名前のみを使用してオーバーロード解決に成功した場合のみ隠す、という中間のアプローチです。名前バインディングのための我々の統合フレームワークでは、このモデルは、名前バインディング、バインディングなし、(ADLのために)開く、弱い隠蔽という、4つのスコープの関係で表現され、そして関連するその他のアイディアは、言語と設計抽象的な最小限の2つの概念です。このプレゼンテーションでは、名前バインディングインフラストラクチャと主要な調査結果の要約をし、制約テンプレートを定義するための、弱い隠蔽の導入に焦点を当てます。はじめに、初心者と専門家両方の視点から、問題に対する実用的な例として、弱い隠蔽の必要性を示します。その後、我々のConceptClangが行ったいくつかの設計上の決定を説明します。このセッションが終わったあと、参加者は、現在のものと拡張案、両方のC++の名前探索のルールについてより良い理解が得られるでしょう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cpp11-qt5&#34; name=&#34;cpp11-qt5&#34;&gt;Qt5でC++11を使う： 課題と解法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11 use in Qt5: Challanges and Solutions&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/thiago-macieira/&#34; target=&#34;_blank&#34;&gt;Thiago Macieira&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Qt5は昨年12月にリリースされた、有名なQtフレームワークの最新メジャー版である。C++フレームワークであるので、Qtの開発はもちろんC++11に大きな影響を受け、C++11のおもしろい機能、特に高速なコードの作成や可読性を向上させるような機能を利用しようとした。コンパイラがC++11の機能を実装するほどには、Qtのようなフレームワークは早く実装できなかった。加えて、Qtは二つの問題に直面した。一つ目は、まだ利用しているユーザーがいるので昔のコンパイラとツールチェインをサポートする必要があったこと。二つ目は、Qt4と可能な限りソース互換性を維持するというのが、Qt5の目標ひとつだったことである。このような要求に応えるために、当面のあいだ、C++11の大規模な採用は見送ることなった。&lt;/p&gt;
&lt;p&gt;それゆえ、Qt開発者はどのC++11機能を使うべきでないか、どの機能を使うべきか、C++98/03コンパイラ互換をどうやって維持するかについて考える必要性にせまられた。このセッションでは、結局どういう決定を下したのか、また、C++98/03とC++11モードそれぞれでさまざまなコンパイラをサポートする措置について話そうと思う。Qtで適用した解決法、およびC++11とC++03で利用可能である巨大なC++クラスライブラリ構築を試みる際の一般的な考えかたについて知見が得られるだろう。このプレゼンテーションでは、ようするに我々のように、C++03コンパイラ互換性を維持したまま、ライブラリやアプリケーションをC++11に移植する必要にせまられた、C++開発者向けの実践的ガイドラインを示すことが狙いである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#thread-safe-bag&#34; name=&#34;thread-safe-bag&#34;&gt;スレッドセーフでスレッド中立なbag&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Thread-safe and Thread-neutral Bags&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/richard-saunders/&#34; target=&#34;_blank&#34;&gt;Richard Saunders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bagは多数のスレッドが処理を実行するために継続的かつ非同期にbagからデータを取り出すようなスレッドシステムで使う基本的なコンテナである。bagはキー操作(get)を持ち、概念上はシンプルであるが、スレッドセーフ(bagの状態は複数のスレッドからアクセスされても一貫性を保持する)かつスレッド中立(スレッド同士が競合しない)に実装しようとするととてつもなく難しくなる。&lt;/p&gt;
&lt;p&gt;このセッションではスレッド環境下でのbagの実装について、さまざまな角度から、特に、多数のスレッドがbagに絶えまないアクセスや、作業の性質、マシンに積んでいるプロセッサの数とタイプ、高速な生産者/消費者関係などについて見ていく。ただ一種類のbagではあらゆる要求を満足できないのは明らかだ。この論文ではbagに関して、アプリケーションの性質に応じて引き出しと戸棚という二つの抽象化を紹介している。これらの新しい抽象化を、スレッドセーフでスレッド中立なbagを担保しうるC++11のマルチスレッドまわりの機能を利用して実装する。いずれの実装についても人工のベンチマークと実際のアプリケーションで利用し十分な吟味を行った。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/04/saunders_paper_cppnow2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#practical-cpp11-odb&#34; name=&#34;practical-cpp11-odb&#34;&gt;実践C++11：ODBへのC++11サポート追加で学んだこと&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Practical C++11: What I Learned Adding C++11 Support to ODB&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-kolpackov/&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ORMにC++11サポートを加えていく過程で、新しい言語機能や他のコンパイラのサポート状況といった実践的な経験が得られた。また、想像できるかもしれないが、これは大変な仕事だった。このセッションでは、新しい言語機能について利用できる経験則について議論したい。&lt;/p&gt;
&lt;p&gt;このセッションでは、完全転送とオーヴァーロードはとても相性が悪い(また、その対処方法)、値渡しと参照渡し(また、左辺値参照か右辺値参照か)の使いわけ、範囲forループの内側について話すつもりである。また、C++98とC++11をサポートするクロスプラットフォームライブラリで、実際に遭遇した実装面での問題についても取りあげたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#bloomberg&#34; name=&#34;bloomberg&#34;&gt;応用階層的再利用: Bloomberg基盤ライブラリの利用&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Applied Hierarchical Reuse: Capitalizing on Bloomberg’s Foundation Libraries&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/john-lakos/&#34; target=&#34;_blank&#34;&gt;John Lakos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ライブラリの設計は大変な仕事である。特に、相互運用性のある組み換え可能なライブラリセットの設計ともなるといっそう困難である。複数のライブラリを機能面で分割すれば、それ固有の課題がでてくる。すなわち、ライブラリの機能はわかりやすく、冗長性は排除しなければならず、コンポーネントとライブラリにまたがるインターフェースと契約関係は、高性能なIDEがなくても容易に理解できるようにしなければならない、ということだ。さらに、ライブラリ間の依存性にはよく気をつけなければならない - ライブラリは首尾一貫して機能し、よく精査された語彙を定義、利用しながら、クライアントが必要とする機能分だけのコンパイル時間やリンク時間、実行ファイルサイズで済むものでなければならない。&lt;/p&gt;
&lt;p&gt;複数の相互運用可能なライブラリセット作成にも、それぞれのライブラリ作成と同様に多くの課題がある。そのライブラリセットは理解しやすく、利用しやすく、高性能で信頼性がなければならない。さらに、ライブラリ全体が共通の構造を取り、表現を根拠なく変えず、一貫した用語を使っていなければならない。ライブラリ全体でこのような高度な一貫性や性能、信頼性を達成することで、個々のライブラリにおける部分的な信頼性は非常に高くなる。さらに、単一のライブラリを作成する際にも、このような手法を採用すれば、かなりの恩恵にあずかれるだろう。&lt;/p&gt;
&lt;p&gt;小-中規模プロジェクト向けのソフトウェア方法論は多くあるが、これらをごく単純には大規模な開発にスケールすることはできない。このセッションでは、大規模開発における問題点や、実績のあるコンポーネントベースの方法論ではどうにもならない問題に対処すべく見いだし、Bloombergの実用的なアプリケーション開発を通じて洗練された関連技術について述べる。これらの方法論 - 三階層集約、非循環依存性、名詞句結合、高粒度機能分解、クラスカテオゴリ、限定的契約、コンポーネントレヴェルテスティングなど - の現実的応用については、最近リリースされたばかりのオープンソースディストリビューションであるBloomberg基盤ライブラリを利用して紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#boost-dispatch&#34; name=&#34;boost-dispatch&#34;&gt;Boost.Dispatch - 汎用タグディスパッチ基盤ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Dispatch - Generalized Tag Dispatching Infrastructure Library&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/joel-falcou/&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/mathias-gaunard/&#34; target=&#34;_blank&#34;&gt;Mathias Gaunard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;型制約を自由に組み合わせる種の関数特殊化を規定するのは、C++ではめんどうな仕事である。というのも、そのような制約はすぐにどんどん増えるし、どんどんややこしくなるからだ。この問題を解決するために、SFINAEやタグディスパッチなど様々なイディオムが利用されてきた。&lt;/p&gt;
&lt;p&gt;このセッションではBoost.Dispatchを紹介する。これは、タグやその関連性を定義するプロトコルを備え、任意のタグの組み合わせと関数実装とをマップし、自由で結合可能な方法で前述の特殊化リストを拡張できる、タグディスパッチの利用や管理を容易にする基盤ライブラリである。Boost.Dispatchの新しい利点は、関数の特性や型特性のより古典的な用法に加えてディスパッチを導くための構造上の情報を分類できる機能だ。&lt;/p&gt;
&lt;p&gt;このセッションではまずSFINAEや、C++でのオーヴァーロードとタグディスパッチの意味と、その限界についてざっと説明する。単純なライブラリ設計から、自明でない構造に依存する情報に基づいて、関数の最適な実装を選択するためのライブラリを利用する、実際の高効率コンピューティングコードにわたるサンプルとともに、Boost.Dispatchを紹介していく。さらに、ライブラリの実装についての詳細を見ていただき、未解決の課題について概説したい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#vienna&#34; name=&#34;vienna&#34;&gt;計算科学向けViennaライブラリについて&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Discussion of Selected Vienna-Libraries for Computational Science&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/karl-rupp/&#34; target=&#34;_blank&#34;&gt;Karl Rupp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CUDA、OpenCL、OpenMPが利用可能な線型代数ライブラリであるViennaCL、メッシュデータ構造ライブラリであるViennaGrid、データ保存を受けもつViennaData、シンボリック計算カーネルであるViennaMathといった直交するライブラリ群を紹介することで、計算科学のとっつきにくさに取り組む。結びに、有限要素法パッケージであるViennaFEM内で、これら直交するライブラリ群がどのように相互作用しているか考察する。このセッションの主眼は様々なプログラミング技法の適用について、またC++がいかに計算科学向けの言語になりうるかについてである。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/karl.rupp_.paper_.2013.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#alignment&#34; name=&#34;alignment&#34;&gt;C++のアラインメント: 利用法、制限、および拡張法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Alignment in C++: Use, Limitations, and Extension&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-spencer/&#34; target=&#34;_blank&#34;&gt;Michael Spencer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションではC++におけるアラインメントを調査する。まず最初に、C++11でのアラインメントまわりの変更について概説し、効果的な利用法について述べる。次にその制限について述べる。その次に、それら問題点に対処するために、アラインメントを型システムに載せることで解決する方法を提案する。最後に型安全性と実行時効率の恩恵について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#community-dev&#34; name=&#34;community-dev&#34;&gt;C++コミュニティの発展&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Community Development&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/jens-weller/&#34; target=&#34;_blank&#34;&gt;Jens Weller&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JensとJonは両名ともC++コミュニティの発展に意欲があり、C++カンファレンスに出席した経験がある。彼らはコミュニティの発展にはローカルグループこそがC++コミュニティ発展の鍵であると感じている。&lt;/p&gt;
&lt;p&gt;Jensは、ヨーロッパのC++Nowとも言えるMeeting C++の主催者として、またデュッセルドルフとベルリンのC++ユーザーグループを立ちあげた経験について紹介する。&lt;/p&gt;
&lt;p&gt;JonはシリコンバレーのACCU支部での経験や、シリコンバレーコードキャンプでのC++プログラミング経歴、C++Nowでの活動について紹介する。&lt;/p&gt;
&lt;p&gt;その後、パネルディスカッションスタイルで、質問やコメントを受けつけたり、聴講者の経験についてうかがう。&lt;/p&gt;
&lt;p&gt;ローカルでグループを立ちあげるコツや、個人的人脈やソーシャルメディアを通じてスピーカーや聴講者を募る方法、他のグループと連携する方法についても述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#dynamic&#34; name=&#34;dynamic&#34;&gt;動的なC++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/alex-fabijanic/&#34; target=&#34;_blank&#34;&gt;Alex Fabijanic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外部ソースから取り込むべき様々な型のデータには、データ型変換がつきものです。C++プログラマの皆さんは、リレーショナル・データベースやXMLデータベースからJSON形式やHTMLへのデータ変換をC++の型チェックという障壁を越えて、正確かつ効率的に、どのように変換されていますか？答えは型消去というテクニックを使用する事にあります。この講義では、最も一般的な C++型消去の手法について、列挙探査と比較を行います。&lt;/p&gt;
&lt;p&gt;上記の問題と同様に与えられた、歴史的なライブラリ（ANSI Cの共用体、&lt;code&gt;void*&lt;/code&gt;、マイクロソフト COMの&lt;code&gt;Variant&lt;/code&gt;型、&lt;code&gt;boost::variant&lt;/code&gt;、&lt;code&gt;boost::any&lt;/code&gt;、&lt;code&gt;boost::lexical_cast&lt;/code&gt;)と最近のライブラリ(&lt;code&gt;boost::type_erasure&lt;/code&gt;、Facebook &lt;code&gt;folly::dynamic&lt;/code&gt;)といった、開発トレンド(保留中の &lt;code&gt;boost::any&lt;/code&gt; というC++標準案を含む)、それは、C++言語の静的な型システムという性質を回避する手法が必要であることを示唆しています。この問題に関する解決法は複数存在します。この講義では、&lt;code&gt;boost::variant&lt;/code&gt;、&lt;code&gt;boost::any&lt;/code&gt;、&lt;code&gt;boost::type_erasure&lt;/code&gt;、&lt;code&gt;folly::dynamic&lt;/code&gt;、&lt;code&gt;Poco::Dynamic&lt;/code&gt;、これらに焦点を当てて掘り下げます。設計デザインと機能だけでなく、各ライブラリの長所と短所についても検討します。パフォーマンスベンチマークの比較も同様に検討されます。&lt;/p&gt;
&lt;p&gt;型安全はC++の重要な要素です。型消去は、現代のソフトウェア開発のために必要なテクニックです。この講義では、これら重要な型消去のライブラリの比較検討を行います。&lt;/p&gt;
&lt;p&gt;＊ Type Erasure を型消去と訳してます&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#debruijn&#34; name=&#34;debruijn&#34;&gt;DeBruijn Bind: シンプルさを維持するより強力なbind&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DeBruijn Bind: A more powerful bind that retains its simplicity&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/david-sankel/&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.LambdaやBoost.Phoenixのような、より強力なライブラリがあるなかでも、Boost.Bindはその非常に単純な構文と、学習のハードルが低いという点でその立ち位置を守っている。その構文はBoost.MPLのなかでコンパイル時variantとして利用されている。&lt;/p&gt;
&lt;p&gt;しかし、テンプレート実引数とともに使うため、または、&lt;code&gt;boost::protect&lt;/code&gt;を使いはじめるために、&lt;code&gt;boost::bind&lt;/code&gt;のネストに手を染めると、この単純さは&lt;code&gt;boost::bind&lt;/code&gt;のセマンティクスとその限界については不鮮明になってしまう。&lt;/p&gt;
&lt;p&gt;このセッションでは、解析を行ない、Boost.Bindのセマンティクスとは何かについて数学的に正しい理解に到達することを目的とする。ひととおりセマンティクスについて学べば、Boost.Bindがカヴァーしている要求を満たし、再帰可能であり、学習のハードルが低い単純な構文を維持する、説得力のある代替案の設計についての見識が得られるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#multi-threading&#34; name=&#34;multi-threading&#34;&gt;C++11とBoostを利用したマルチスレッディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Multi-Threading With C++11 and Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/rob-stewart/&#34; target=&#34;_blank&#34;&gt;Rob Stewart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルでは、マルチスレッドコードを記述するためのC++11とBoostの機能を利用した多くの例をもとに、より深くその効用についいて段階的に学んでいく。&lt;/p&gt;
&lt;p&gt;例としてスレッドセーフキューについても取りあげ、独立したスケジュール上で並列タスクを実行するためにスレッドを利用したり、長時間実行中の並列タスクに割り込みを掛けてみる。これらの例をもとにスレッドやミューテックス、条件変数などの利用法を示す。C++11とBoostの機能的相違点についても議論するつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#concept-lite&#34; name=&#34;concept-lite&#34;&gt;軽量コンセプト: 述語による制約テンプレート&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Concepts Lite: Constraining Templates with Predicates&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/andrew-sutton/&#34; target=&#34;_blank&#34;&gt;Andrew Sutton&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このトークでは、C++14に提案されている新言語機能である「テンプレート制約(またの名を軽量コンセプト)」について話します。制約は、テンプレートにおいてテンプレート引数が使えるかどうかを判定するための述語です。&lt;/p&gt;
&lt;p&gt;制約を使用して要件を直接示すことによって、テンプレートの宣言を改善できます。もちろん、制約に基いて関数オーバーロードすることもできます。制約は、型のエラーを使用時にすぐ捕捉できるため、コンパイルエラーのスタックを短いスクロールで確認できるようになることを意味します。&lt;/p&gt;
&lt;p&gt;言語機能としては、テンプレート制約は最小限で複雑でないものに抑え、テンプレート使用の正確さではなく、テンプレート定義の正確さを強化します。これは段階的かつ簡単に、既存のコードベースに採用できることを意味します。&lt;/p&gt;
&lt;p&gt;このトークは一般的なデータ構造、メンバ関数とコンストラクタ、オーバーロード、クラステンプレートの特殊化、制約の定義といった例を通して、制約をどのように使用するかを説明します。また、私が普段のプログラミングで制約を使用してきた経験についても説明します。これは制約のいいアイデアと、それほどよくないアイデアの両方を含みます。&lt;/p&gt;
&lt;p&gt;GCC 4.8ベースの実験的なコンパイラは、みなさんがすでに使えるよう公開してあります。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#html5&#34; name=&#34;html5&#34;&gt;ママ見て “C++を使ってデータベース更新からHTML5が生成されたよ”, 自動化して!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Look ma, “update DB to HTML5 using C++”, no hands!&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/alex-fabijanic/&#34; target=&#34;_blank&#34;&gt;Alex Fabijanic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ウェブを取り巻く環境は急速に変化しています。AJAXや非同期JSONの登場により、ユーザ・インタフェイスの応答性は、大幅に改善されてきました。この流れの基礎となるデータ・トランスポートのメカニズムは、まだ、リクエスト/レスポンスによるポーリング（プル）・モデルに基づいています。WebSocket規格は、ネットの先のストレージから標準となるHTML5インタフェイスへ、イベント・ドリブンなプッシュ・モデルというシームレスな接続の最後の障壁を取り除きました。流れとして、データ転送はイベント・ドリブン・モデルを使用し、リクエスト/レスポンス・モデルで行われていたネットワークおよびウェブサーバのオーバーヘッドを下げ、パフォーマンスの改善を標準規格に準拠して行う事ができます。講義の最初に、POCOフレームワーク・ネット・ライブラリを使用して、WebSocket HTML5ページを生成するHTTPサーバを構築します。次に、POCOデータ・ライブラリを使用して、SQLデータベースと連帯する機能をHTTPサーバに追加し、コールバック・フックを確立します。そのフックは、透過的にデータベースのデータ更新からウェブ・ページ変更を引き起こすためにパスを開きます。このソリューション・電子ブロックの構成要素である、データ型消去のための &lt;code&gt;Poco::Dynamic&lt;/code&gt;モジュール、動的フォーマット出力のための&lt;code&gt;Poco::Data::RowFormatter&lt;/code&gt;クラス、を詳細に説明します。&lt;/p&gt;
&lt;p&gt;この講義は、いくつかの鋭い問題に現実的解決案を提示します - 効率的かつ独立して転送されたデータ型からエンドユーザにシームレスウェブにネットワーク経由でストレージからデータを提供します。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#odb&#34; name=&#34;odb&#34;&gt;C++(11)のためのORマッパー：ODB&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ODB, an ORM for C++(11)&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/boris-kolpackov/&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ODBは、C++によるオブジェクト・リレーショナル・マッピング(ORM)システムのライブラリで、クロス・プラットフォームかつクロス・データベースなオープンソースです。&lt;/p&gt;
&lt;p&gt;このライブラリを使用すると、テーブル・カラム・SQLや、リレーショナル・マッピングのコードを手作業で書く事なく、C++のオブジェクトをリレーショナル・データベースに格納できます。&lt;/p&gt;
&lt;p&gt;Boostカンファレンス2011より数ヶ月前に、私はODBを導入しました。今回は我々が過去2年間に行った成果をお見せしたいと思います。講義の最初では、ODBの助けを借りて、リレーショナルデータベースにC++のオブジェクトを格納することが、いかに簡単できるかを話します。次に多様な興味深いトピック、C++11サポート、BoostとQtプロファイル、ポリモーフィズム、楽観的な同時実行制御、およびマルチデータベースサポートについて話します。私は、これからも、データベース・スキーマ革命！という野心的な困難に取り組むつもりです。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#fusion&#34; name=&#34;fusion&#34;&gt;Fusionで世界の謎を解く&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Solving World Problems with Fusion&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/michael-caisse/&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンパイル時MPLと実行時タプルの融合。Boost.Fusionはメタプログラミング世界のSTLである。FusionはBoostライブラリの内部的な機構を提供し、私たち自身のソースの一般的な要素となっている。&lt;/p&gt;
&lt;p&gt;この90分のセッションでは、Boost.Fusionライブラリの現実世界でのユースケースを探求する。具体的には、ライブラリインタフェースのシンプル化、宣言的なユーザーエクスペリエンス、効率的で非侵入的なハンドリングの例を見ていく。&lt;/p&gt;
&lt;p&gt;参加者は、いくつかの実用的な使用パターンの理解を得てさらなる先に進んで行くでしょう。ぜひSpirit、Xpressive、Geometry、Accumulators、odeint、Proto、Phoenix、MSMを自分のソースに取り入れる方法を学んでみてほしい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#dds&#34; name=&#34;dds&#34;&gt;モダンなC++向けのデータ分散サーヴィス(DDS: Data Distribution Service)の標準化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Standardizing the Data Distribution Service (DDS) API for Modern C++&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/sumant-tambe/&#34; target=&#34;_blank&#34;&gt;Sumant Tambe&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++復権は多くの工業分野で広まっている。アプリケーション移植性の視点からC++を対象にした国際的なコンピュータシステム標準は、迅速にモダンなC++を導入してきている。国際標準化機構のObject Management Group(OMG)では、DDS-PSM-CxxとIDL2C++11標準が時代の先を行っている。DDS-PSM-Cxxは、高性能な分散リアルタイムシステム開発向けの主要なデータ分散サーヴィス(DDS)標準の関連標準である。正式には&#34;ISO/IEC C++ 2003 Language Platform Specific Mapping (PSM) for DDS&#34;として知られるDDS-PSM-Cxx標準は、2012/12に策定完了した。DDS-PSM-Cxxはモダンで、自然で、STLと親和性があり、表現力が高く、安全で、効率的なDDSプログラミング向けに可搬性のあるC++APIを提供している。DDS-PSM-CxxはC++03をターゲットにしており、C++11環境移行を可能にすべく特別な準備をしている。このセッションではDDS-PSM-Cxx標準の&#34;なぜ&#34; &#34;どうして&#34;について述べる。OMG標準化作業部会の投票委員と主要な貢献者が登壇する予定である。&lt;/p&gt;
&lt;p&gt;このプレゼンテーションはDDS - リアルタイム分散システム向けのデータ中心の出版-購読型アーキテクチャの基礎を説明するところから始める。DDSと組み合わせたモダンなC++で記述した&#34;Hello World!&#34;アプリケーションとともに、DDS-PSM-Cxx標準の動機や問題点、高次構造について示す。また、規格に合致しているベンダー実装の当分の代替のサポートやベンダー固有拡張のための文脈的手掛かりといった、標準の興味深い点について深く掘りさげていく。この標準はBoostを直接的に利用していないものの、いくつかのBoostライブラリからアイディアを拝借している。このプレゼンテーションでは、DDSアプリケーション向けのクリーンで安全かつ効率的なAPIを提供するための、種々のC++03イディオム(例えば、RAII、型消去、型安全列挙、メソッドチェイン)の利用についても詳しく説明していく。さらに、聴者の興味を引くであろう、APIを構築する上で重要な点である例外安全の考慮についても述べる。特に、例外安全なAPIを設計する上で、ムーヴセマンティクスが如何に有用かご覧いただけるだろう。最後に、C++03規格に合致しているアプリケーションが、C++11環境でも合法となるように、標準に加えた特別なルールについて議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#member-access-operator&#34; name=&#34;member-access-operator&#34;&gt;メンバーアクセス演算子のオーヴァーロード&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Overloading the Member Access Operator&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/sebastian-redl/&#34; target=&#34;_blank&#34;&gt;Sebastian Redl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接メンバーアクセス演算子(&lt;code&gt;operator.&lt;/code&gt;)のオーヴァーロードは通常またはメタプログラミングでおもしろいユースケースがある。この演算子のオーヴァーロードの古典的な利用法は、アロー演算子のオーヴァーロードと同じく、別のオブジェクトを参照させたい場合に利用することである。&lt;/p&gt;
&lt;p&gt;このセッションでは、メタプログラミングを利用してプログラマが別の名前を利用できるようにする別の方法を紹介する。Clangコンパイラを利用したこの機能の実験的実装を紹介し、この実装のユースケースや、この機能の有用性、問題点、これを実装するにあたって得られた知見について述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cern&#34; name=&#34;cern&#34;&gt;CERNでの対話的で内省的なC++&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interactive, Introspected C++ at CERN&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/vassil-vassilev/&#34; target=&#34;_blank&#34;&gt;Vassil Vassilev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CERNは、世界最大の素粒子物理学研究所である。そのような科学的ブレイクスルーを作るために、約15PB/yearを処理している。ROOTフレームワークのユニークな能力は物理学者がデータ解析するのをより効率的で、計算的で、賢いストレージを可能にする。ROOTの最新バージョンのコアはClingである。これは対話的なC++インタプリタで、C++11もサポートしている。Clingは、以前まで使用していたROOTの伝統的なメインユーザーインタフェースを置き換える。Clingは、Clang/LLVMインフラストラクチャ上に構築される。このインタプリタはそれだけでなく、ROOTのシリアライズ、デシリアライズ、C++のオブジェクト指向データの操作にも使用され、それでいて初心者がC++をより早く学ぶのを支援してくれる。&lt;/p&gt;
&lt;p&gt;C++のような静的言語のインタプリタを構築するのは、決して簡単ではない。私はClingの要件を説明し、その後コンパイラフレームワーク上にインタプリタを実装することに挑戦する。C++をより対話的な言語に変えるために、C++標準のいくつかの概念を説明する。インタプリタを使用して、型のイントロスペクション機構を簡単に説明する。C++の文脈解析で、ランタイムの力を改善する方法を提案する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#haskell&#34; name=&#34;haskell&#34;&gt;Haskellの力でMPLを強化しよう&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boosting MPL with Haskell elements&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/abel-sinkovics/&#34; target=&#34;_blank&#34;&gt;Abel Sinkovics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HaskellとC++テンプレートメタプログラミングの類似性が指摘されている[1,2]一方で、Haskellのほとんどの要素がテンプレートに導入されていない。これらをいくらかでも導入すれば、メタプログラミングはより使いやすくなり、テンプレートメタプログラミングツールセットであるBoost.MPLの強化につながるだろう。&lt;/p&gt;
&lt;p&gt;Haskellを含む関数プログラミング言語で利用されている式を、コードを読みやすくするために、そして構築しやすくするために利用してみよう。これはC++テンプレートメタプログラミングに対しても同じ目的で適用できるはずである。&lt;/p&gt;
&lt;p&gt;関数型プログラムを記述するとき、とりわけ、Haskellのdo notationとMonadの組み合わせは、書かなければならない鋳型コードの量を削減できる強力なツールである。コンパイル時計算にこの要素を導入すれば、これを利用したテンプレートメタプログラムの可読性の向上に寄与するだろう。&lt;/p&gt;
&lt;p&gt;多くのプログラミング言語について、リスト内包表記はリスト変換の理解に寄与する。リスト内包表記を実装するためにHaskellのList monadとdo notationを利用が利用されるように、テンプレートメタプログラミングでも同様にこれらを使って実装できる。&lt;/p&gt;
&lt;p&gt;エラーハンドリングはEither monadを利用すれば単純化できる。構文糖を混ぜることで、monadや例外ハンドリングがC++テンプレートメタプログラムで実装されていることを意識せずに、テンプレートメタプログラムにおいてもこのような例外ハンドリングが理解でき、利用可能である。&lt;/p&gt;
&lt;p&gt;これらのツールはBoost.MPL ライブラリを基礎として構築され、その拡張として利用されるので、既にBoost.MPLを利用しているメタプログラムに容易に展開可能である。&lt;/p&gt;
&lt;p&gt;このセッションで紹介するツールはMetamonadライブラリの構成要素である。Metamonadライブラリについては以下のリンクを参照すること:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://abel.web.elte.hu/mpllibs/metamonad&#34; target=&#34;_blank&#34;&gt;http://abel.web.elte.hu/mpllibs/metamonad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sabel83/mpllibs&#34; target=&#34;_blank&#34;&gt;https://github.com/sabel83/mpllibs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションは高度なので、Boost.MPLに精通していることが望ましい。&lt;/p&gt;
&lt;p&gt;参考文献:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;[1] Stuart Golodetz – Functional programming using c++ templates (part 1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://accu.org/index.php/journals/1422&#34; target=&#34;_blank&#34;&gt;http://accu.org/index.php/journals/1422&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[2] Bartosz Milewski – What does Haskell have to do with C++?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/&#34; target=&#34;_blank&#34;&gt;http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#object-transmission&#34; name=&#34;object-transmission&#34;&gt;Boost.AsioとBoost.Serialization: オブジェクト受け渡しのデザインパターン&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Asio and Boost.Serialization: Design Patterns for Object Transmission&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bryce-adelstein-lelbach/&#34; target=&#34;_blank&#34;&gt;Bryce Adelstein-Lelbach&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/jeroen-habraken/&#34; target=&#34;_blank&#34;&gt;Jeroen Habraken&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++でネットワークプログラミングするには、他のネットワーク終端へ受けわたしできる、再構築可能なバイトシーケンスとして、C++オブジェクトを表現する方法が必要である。PODのような単純なオブジェクトなら、シリアライズするのが一般的だろう。&lt;/p&gt;
&lt;p&gt;多態オブジェクトのような、より複雑なC++構造については、シリアライズする方法はより困難になる。このセッションでは、Boostにある二つの強力なライブラリであるAsioとSerializationについて、巨大な配列を扱えるC++ネットワークコードを構築するという観点から、その有用性について議論していく。&lt;/p&gt;
&lt;p&gt;このセッションではBoost.MPIとHPX(分散/並列プログラミング用のC++ランタイムシステム)を使って、Boost.AsioとBoost.Serializationを利用したオブジェクト変換を行う方法についても議論する。また、ほんの少しだが、別の解法についても議論するつもりだ。&lt;/p&gt;
&lt;p&gt;このセッションは、ネットワークプログラミングに従事している、もしくは興味がある(けれどもBoost.AsioやBoost.Serializationについてよく知らない)方を対象にしている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#cppnow-2014&#34; name=&#34;cppnow-2014&#34;&gt;C++Now 2014の準備&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Preparation of C++Now 2014&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participants/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participants/jon-kalb/&#34; target=&#34;_blank&#34;&gt;Jon Kalb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来年の会議にむけた計画委員会を早期に発足させる。もしご提案や、ご支援いただける方はぜひご参加ください。&lt;/p&gt;
&lt;p&gt;このセッションにはスライドはない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#hetero&#34; name=&#34;hetero&#34;&gt;静的型付け言語における、動的で再帰的なヘテロ型&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic, Recursive, Heterogeneous Types in Statically-Typed Languages&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/richard-saunders/&#34; target=&#34;_blank&#34;&gt;Richard Saunders&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participant/clinton-jeffery/&#34; target=&#34;_blank&#34;&gt;Clinton Jeffery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今日のソフトウェアはいろいろな言語で記述されている。すなわち Python、C++、Perl、Java、Javascript、Lua、Unicon、C言語などが、複雑なシステムの別個のコンポーネントを構成する環境のなかに混在している。このような言語の急激な拡散により、動的型づけ言語のコンセプトが静的型づけ言語に流入していく。&lt;/p&gt;
&lt;p&gt;動的言語によく見られる要素として、動的で、再帰的な、ヘテロな辞書構造が挙げられる。たとえば、Pythonのdict、Perlのhash、Javascriptのobject、Luaのtable、JSONにおけるIcon/Unicon tableはこの種の抽象化の実現であるし、より低水準なものとしては、XMLは言語に依存しない動的辞書構造と言えるだろう。C++やJavaのような静的型づけ言語は、スジがいい動的辞書構造の設計と実装に苦労してきた。さて、このセッションでは、C++言語の静的型に特有の機能を &lt;em&gt;採用&lt;/em&gt; し、動的構築を行なうためのシンプルで新規性のある解法で、いかにC++で辞書構造を表現するかについて考察する。その機能とは型推論、ユーザー定義の型変換、型選択、オーヴァーロードである。&lt;/p&gt;
&lt;p&gt;これらのこと組みあわせて、動的言語における動的辞書の操作性に近づけるべく、逆説的だがこれらの静的な機能から、C++からの操作が非常に容易な動的辞書構造を構築する。&lt;/p&gt;
&lt;p&gt;注意：これらのテクニックには特別なリフレクション機能やライブラリを必要としない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/saunders-jeffery.pdf&#34; target=&#34;_blank&#34;&gt;paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#projucer&#34; name=&#34;projucer&#34;&gt;Projucer: C++とLLVM JIT エンジンを利用したライブコーディング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Projucer: Live coding with C++ and the LLVM JIT engine&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/julian-storer/&#34; target=&#34;_blank&#34;&gt;Julian Storer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それぞれのクラスを連続的にリコンパイルし実行するために、Projucer IDE がいかにしてClangとLLVM JITエンジンを利用したC++コードのリファクタリングとリアルタイム実行を成しとげたのか、その裏側からごらんいただこう。&lt;/p&gt;
&lt;p&gt;JUCE GUI toolkitライブラリを利用しているこのProjucerは、C++プロジェクトの編集やアセンブルを行なうためのIDEである。Projucerは、Clangを利用してコンパイルを行ない、ユーザーコードベースのAST(Abstract Syntax Tree: 抽象構文木)を走査することで、適切なGUIクラスを決定し、スタンドアロンの実体としてインスタンス化する。このインスタンスはそのコードが編集された際、即座に更新される。これらのGUIクラスを動的に生成されるコードにラップすることで、ドラッグやリサイズといった一般的なGUI操作は、元のコードを動的にリファクタリングすることによって機能しその上で実行される。&lt;/p&gt;
&lt;p&gt;実際の動作についてのムービーは&lt;a href=&#34;http://youtu.be/imkVkRg-geI&#34; target=&#34;_blank&#34;&gt;こちら&lt;/a&gt;。より詳細については&lt;a href=&#34;http://rawmaterialsoftware.com/viewtopic.php?f=12&amp;amp;t=9793&#34; target=&#34;_blank&#34;&gt;私のサイト&lt;/a&gt;を参照のこと。&lt;/p&gt;
&lt;p&gt;C++通向きに、もっと細かいことや、諸問題、このシステムを効率的にするために使った狡猾なトリック、そしてClangやLLVMの特徴について掘り下げてみるつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#matrix&#34; name=&#34;matrix&#34;&gt;EigenとBoost Protoライブラリを用いた有限要素マトリックス式の組み立て&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Building finite-element matrix expressions with Boost Proto and the Eigen library&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/bart-janssens/&#34; target=&#34;_blank&#34;&gt;Bart Janssens&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルでは、我々がドメイン特化言語を開発するにあたり障害となった二つの問題、すなわちBoost.Proto内での外部Expression Template Library(ここではEigen)の利用と、ユーザー定義関数の導入についていかに解決したかを示す。&lt;/p&gt;
&lt;p&gt;どちらの話についても、我々の有限要素マトリックスのコードとは関係のない、一般的な計算機様のプログラムで紹介するつもりである。これはステップバイステップ方式のBoost.Protoのチュートリアルになるだろう。最後に&lt;a href=&#34;http://coolfluid.github.com/&#34; target=&#34;_blank&#34;&gt;Coolfluid 3 code&lt;/a&gt;にあるアプリケーションを例にとって、Protoのようなライブラリが、実際のコードにどのような利点をもたらすかを示す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cppnow.org/files/2013/03/janssens.abstract.pdf&#34; target=&#34;_blank&#34;&gt;Extended Abstract&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#deadlock-prevention&#34; name=&#34;deadlock-prevention&#34;&gt;侵入的動的解析を使用したリソースデッドロック防止システム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A system for resource deadlock prevention using intrusive dynamic analysis&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participant/louis-dionne/&#34; target=&#34;_blank&#34;&gt;Louis Dionne&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ミューテックス等を使用して共有データへ同期にアクセスするという旧来の方法は、2つ以上のスレッドがお互いに再帰的にブロックをしてしまう、リソースのデッドロックを可能にしてしまう。&lt;/p&gt;
&lt;p&gt;このようなバグは特定の状況下でしか発生しないため、多くの場合、その摘発は困難なものとなる。&lt;/p&gt;
&lt;p&gt;このトークでは、intrusive dynamic analysis(侵入的動的解析?)を使用して潜在的なリソースデッドロックを事前に発見するシンプルなフレームワークを、私達がどのように実装したかを説明する。&lt;/p&gt;
&lt;p&gt;また、そのフレームワークを既存のコードとどのように統合するかも説明する。&lt;/p&gt;
&lt;p&gt;そして最終的には、このプロジェクトをC++のより汎用的なdynamic analysisフレームワークにする可能性をもつ、プロジェクトの進化について議論しよう。&lt;/p&gt;
&lt;p&gt;マルチスレッドあるいはdynamic analysisについて興味のあるプログラマ向け。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Boostの未来&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Future of Boost&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://cppnow.org/participants/dave-abrahams/&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://cppnow.org/participants/beman-dawes/&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostとC++ Now!のリーダー達が将来どうなるかについて話し、質問に答える。&lt;/p&gt;
&lt;p&gt;このセッションにスライドはない。&lt;/p&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, Usagi Ito, hotwatermorning, Miyuki OKI, zak&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mem_fn.hpp -- mem_fn : composeへのリンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html"/>
      <id>9857e008c50abe964c2735ee330e487f60e005b5:archive/boost_docs/libs/mem_fn.md</id>
      <updated>2015-01-17 00:25:04 +0900</updated>
      
        <content type="html">&lt;h1&gt;mem_fn.hpp&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34;&gt;FAQ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34;&gt;インタフェース&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34;&gt;実装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34;&gt;ファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34; name=&#34;purpose&#34;&gt;目的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::mem_fn&lt;/code&gt; は、標準関数である&lt;code&gt;std::mem_fun&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt;の一般化である。&lt;code&gt;mem_fn&lt;/code&gt;は、2つ以上の引数をとる メンバ関数へのポインタをサポートし、また&lt;code&gt;mem_fn&lt;/code&gt;の戻す関数オブジェクトは第一引数に、 (訳注: そのメンバ関数の属するクラスのインスタンスを指すような) ポインタ、参照、スマートポインタをとることができる。 &lt;code&gt;mem_fn&lt;/code&gt;は、メンバ変数へのポインタも、引数をとらず自身への定数参照を 戻す関数とみなすことによってサポートする。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;の目的は2つある。一つ目は、コンテナにスマートポインタが格納されている場合であっても、 次のような&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;見慣れた文法によって、メンバ関数の呼び出しを可能にすることである。&lt;/p&gt;
&lt;p&gt;二つ目は、メンバ関数へのポインタを関数オブジェクトのように取り扱いたいライブラリ開発者に、 実装の道具として使用して貰うことである。例えば、あるライブラリは次のようにしてより便利な &lt;code&gt;for_each&lt;/code&gt;アルゴリズムを提供することができ、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;It&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; for_each(It first, It last, R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(first, last, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(pmf));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムは次のようにして手軽に利用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;for_each(v.begin(), v.end(), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムの機能を文書化する際には、単に次のように書けば良い：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;template&amp;lt;class It, class R, class T&amp;gt;&lt;/code&gt;
&lt;code&gt;void for_each(It first, It last, R (T::*pmf) ());&lt;/code&gt;
&lt;strong&gt;結果:&lt;/strong&gt; &lt;code&gt;std::for_each(first, last, boost::mem_fn(pmf));&lt;/code&gt; と同等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ここで、 &lt;code&gt;boost::mem_fn&lt;/code&gt; の部分はこのページへのリンクとするとよいだろう。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bindのドキュメント&lt;/a&gt; にそのような例があるので参照のこと。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; は1つの引数(メンバ関数へのポインタ)をとり、標準あるいは独自の アルゴリズムに渡すのに適した関数オブジェクトを戻す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X
{
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f();
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;h&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X &lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;k&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;戻される関数オブジェクトは、引数のメンバ関数ポインタと同じ引数をとることに加え、 インスタンスを表すための「柔軟な」第一引数をとる。&lt;/p&gt;
&lt;p&gt;関数オブジェクトが、適切なクラス(上の例では &lt;code&gt;X&lt;/code&gt;)を指すポインタでも参照でも ない第一引数&lt;code&gt;x&lt;/code&gt;をもって呼ばれた場合、関数オブジェクトは&lt;code&gt;get_pointer(x)&lt;/code&gt; を用いて&lt;code&gt;x&lt;/code&gt;からポインタを得ようとする。 スマートポインタの作者は、自分たちのスマートポインタ向けの適切な&lt;code&gt;get_pointer&lt;/code&gt;関数 を定義(overload)しておくことで、それを&lt;code&gt;mem_fn&lt;/code&gt;対応とすることができる。&lt;/p&gt;
&lt;p&gt;[注意: &lt;code&gt;get_pointer&lt;/code&gt; の戻り値はポインタでなくともよい。 &lt;code&gt;(x-&amp;gt;*pmf)(...)&lt;/code&gt;という形式でメンバ関数が呼び出せるなら、どんなオブジェクトでも問題ない。]&lt;/p&gt;
&lt;p&gt;[注意: ライブラリは、&lt;code&gt;get_pointer&lt;/code&gt; の非限定的 (訳注:名前空間を明示しない) 呼び出しを行なう。 そのため、引数依存検索の過程では、オーバーロードされた&lt;code&gt;boost::get_pointer&lt;/code&gt;関数群に加えて、 そのスマートポインタが定義された名前空間内の&lt;code&gt;get_pointer&lt;/code&gt;関数群も検索対象になる。]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;が戻す全ての関数オブジェクトは、&lt;code&gt;result_type&lt;/code&gt;なる&lt;code&gt;typedef&lt;/code&gt;を開示する。 この&lt;code&gt;typedef&lt;/code&gt;は、メンバ関数の戻り型を表す。メンバ変数を渡した場合には、&lt;code&gt;result_type&lt;/code&gt; はそのメンバ変数の型の定数参照として定義される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34; name=&#34;faq&#34;&gt;FAQ&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34; name=&#34;Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。単純な使い方では、&lt;code&gt;mem_fn&lt;/code&gt; は標準のアダプタが提供しないいくつかの機能を提供する。 &lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;Boost.Compose&lt;/a&gt; と標準のアダプタを組み合わせるような複雑な使い方をしている場合は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;&lt;code&gt;boost::bind&lt;/code&gt;&lt;/a&gt; を使用するように書き換えることで、&lt;code&gt;mem_fn&lt;/code&gt;の恩恵を自動的に受けることができる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34; name=&#34;Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いいえ。そうする強い理由がないならすべきではない。&lt;code&gt;mem_fn&lt;/code&gt; は、標準のアダプタに 非常に良く似ているが、100%の互換性があるわけではない。特に、&lt;code&gt;mem_fn&lt;/code&gt;は、標準の アダプタとは違って &lt;code&gt;std::[const_]mem_fun[1][_ref]_t&lt;/code&gt; 型のオブジェクトを戻さないので、 標準の &lt;code&gt;argument_type&lt;/code&gt; 及び &lt;code&gt;first_argument_type&lt;/code&gt; という (nested) &lt;code&gt;typedef&lt;/code&gt; を 用いて第一引数の型を記述することが (完全には) できない。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。&lt;code&gt;#define BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; とすれば可能である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;特定のベンダへの依存を避けるため、可搬性のない拡張は、一般にデフォルトでオフにされるべきである。 もし &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; がデフォルトで有効であったなら、あなたはそうとは気づかずに その拡張を使ってしまい、結果としてあなたのコードの可搬性が損なわれるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34; name=&#34;interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34; name=&#34;synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost
{

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ());

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2&lt;/span&gt;&lt;/i&gt;&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-5&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-6&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 実際には、より多くの引数をとるような関数が、更にいくつかオーバーロードされている&lt;/span&gt;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34; name=&#34;requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Synopsis で述べられた全ての &lt;em&gt;unspecified-N&lt;/em&gt; 型は &lt;code&gt;CopyConstructible&lt;/code&gt; (コピーコンストラクト可能) かつ &lt;code&gt;Assignable&lt;/code&gt; (代入可能) であること。そのためのコピーコンストラクタ及び代入演算子 は例外を送出しないこと。 &lt;em&gt;unspecified-N&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;mem_fn&lt;/code&gt; に渡されたメンバ関数ポインタの戻り型、と定義されること (Synopsis での &lt;code&gt;R&lt;/code&gt;)。 &lt;em&gt;unspecified-2-1&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;R const &amp;amp;&lt;/code&gt; 、と定義されること。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34; name=&#34;get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34; name=&#34;mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-1&lt;/span&gt;&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt;あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; uyNlhujYReTbRXHtDsDleGSLjMHySlXjunspecified&lt;span style=&#34;color: #666666&#34;&gt;-2u&lt;/span&gt;yNlhujYReTbRXHtDsDleGSLjMHySlXj mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified&lt;span style=&#34;color: #666666&#34;&gt;-2-1&lt;/span&gt;&lt;/i&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;t.*pm&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;get_pointer(t)-&amp;gt;*pm&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-3&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-4&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-5&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; unspecified&lt;span style=&#34;color: #666666&#34;&gt;-6&lt;/span&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34; name=&#34;implementation&#34;&gt;実装&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34; name=&#34;files&#34;&gt;ファイル&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;boost/mem_fn.hpp (メインヘッダ)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_cc.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_vw.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_template.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_test.cpp (テスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_derived_test.cpp (派生オブジェクトでのテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_fastcall_test.cpp (&lt;code&gt;__fastcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_stdcall_test.cpp (&lt;code&gt;__stdcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_void_test.cpp (戻りが&lt;code&gt;void&lt;/code&gt;であるケースのテスト)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34; name=&#34;dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Config&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34; name=&#34;number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;この実装では、8つまでの引数をとるメンバ関数がサポートされている。これは、設計に固有の 制限という訳ではなく、実装の詳細である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34; name=&#34;stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いくつかのプラットフォームでは、 &lt;strong&gt;呼び出し規則&lt;/strong&gt; (どのように関数が起動されるかの規則: 引数はどのように渡されるのか、戻り値はどのように扱われるのか、もしスタックを使用したなら、 誰がそれを奇麗にするのか) の異なるような何種類かのメンバ関数を作成できる。&lt;/p&gt;
&lt;p&gt;例えば、Windows API の関数と、COMインタフェースのメンバ関数は、 &lt;code&gt;__stdcall&lt;/code&gt; という呼び出し規則を用いるし、 Borland の VCL コンポーネントは &lt;code&gt;__fastcall&lt;/code&gt; を用いる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__stdcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__fastcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_FASTCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;[注意: これは可搬性のない拡張であり、インタフェースの一部ではない。]&lt;/p&gt;
&lt;p&gt;[注意: いくつかのコンパイラは、 &lt;code&gt;__stdcall&lt;/code&gt; キーワードに対して最小限のサポートしか提供していない。]&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get_pointer&lt;/code&gt;ベースの設計は、Rene Jageによる、特性クラスを用いて &lt;code&gt;mem_fn&lt;/code&gt;を ユーザ定義のスマートポインタに適合させるという提案に影響されたものである。&lt;/p&gt;
&lt;p&gt;フォーマルレビューの期間に、Richard Crossley、 Jens Maurer、 Ed Brey、その他の方々の示唆によって、たくさんの 改良があった。レビューマネージャは Darin Adler であった。&lt;/p&gt;
&lt;p&gt;Steve Anichini は、COMインタフェースが &lt;code&gt;__stdcall&lt;/code&gt; を使用していることを指摘した。&lt;/p&gt;
&lt;p&gt;Dave Abrahams は、不完全なコンパイラにおいても &#34;戻り値なし&#34; をサポートすべく、&lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;mem_fn&lt;/code&gt; を改良した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2001, 2002 by Peter Dimov and Multi Media Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 SATO Yusuke &lt;a href=&#34;mailto:y-sato@y-sa.to&#34;&gt;y-sato@y-sa.to&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>コンセプト・チェックの利用 -- concept_check : リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/concept_check/using_concept_check.html"/>
      <id>72303f86627d5f6317602edde95035bc6bff0acf:archive/boost_docs/libs/concept_check/using_concept_check.md</id>
      <updated>2015-01-17 00:24:31 +0900</updated>
      
        <content type="html">&lt;h1&gt;コンセプト・チェックの利用&lt;/h1&gt;
&lt;p&gt;各コンセプトに対して、与えられた型 (あるいは型の集合) がコンセプトをモデル化していることを確かめるために使用することができる、何らかのコンセプト・チェック用クラスが存在する。 Boost コンセプト・チェック・ライブラリ (BCCL) は、C++ 標準ライブラリの中で使用される全てのコンセプト＋αを対象とした、コンセプト・チェック用クラスを含んでいる。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/reference.html&#34;&gt;リファレンス&lt;/a&gt; セクションに、このコンセプト・チェック用クラスをリストしてある。 さらに、他の Boost ライブラリも、ライブラリ独自の特別なコンセプトに対応するコンセプト・チェック用クラスを付随している。 例えば、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/graph_concepts.md.nolink&#34;&gt;graph concept&lt;/a&gt; および &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/property_map.md.nolink&#34;&gt;property map concept&lt;/a&gt; がある。 さらに、クラス・テンプレートや関数テンプレートを記述する者は、既存のコンセプトでカバーされていない要求事項を表現する必要のある場合は常に、新しいコンセプト・チェック用クラスを作成すべきである。 その方法は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;コンセプト・チェック用クラスの作成&lt;/a&gt; セクションで説明する。&lt;/p&gt;
&lt;p&gt;BCCL のコンセプト・チェック用クラスの例として、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; クラスを挙げる。 このクラスは、C++ 標準 20.1.1 に記述されている &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) 要求事項および、SGI STL で文書化されている &lt;a href=&#34;http://www.sgi.com/tech/stl/EqualityComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;EqualityComparable&lt;/code&gt;&lt;/a&gt; (等値比較可能) コンセプトに相当する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; EqualityComparableConcept;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;テンプレート引数 &lt;code&gt;T&lt;/code&gt; はチェック対象の型と意図されている。 すなわち、&lt;code&gt;EqualityComparableConcept&lt;/code&gt; の目的は、&lt;code&gt;T&lt;/code&gt; に対して与えられたテンプレート引数が 等値比較可能コンセプトをモデル化しているかどうか確認することである。&lt;/p&gt;
&lt;p&gt;個々のコンセプト・チェック用クラスには、該当するコンセプトにおいて有効な式を内包する &lt;code&gt;constraints()&lt;/code&gt; という名前のメンバー関数がある。 ある型が &lt;code&gt;EqualityComparable&lt;/code&gt; (等値比較可能) であるかどうかチェックするためには、その型でコンセプト・チェック用クラスのインスタンスを生成し、次に、コンパイラに、実際に &lt;code&gt;constraints()&lt;/code&gt; 関数を実行することなくコンパイルさせる方法を見つける必要がある。 Boost コンセプト・チェック・ライブラリは、これを容易にする2つのユーティリティ： &lt;code&gt;function_requires()&lt;/code&gt; と &lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; を定義している。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;function_requires()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;function_requires()&lt;/code&gt; 関数は関数本体の中で使用できる。また、&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロはクラス定義本体で使用できる。 &lt;code&gt;function_requires()&lt;/code&gt; 関数は引数をとらないが、コンセプト・チェック用クラスを受けるためのテンプレート・パラメータを有する。 これは、以下に示すように、インスタンス化されたコンセプト・チェック用クラスを明示的にテンプレート引数として与えられなければならないことを意味する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; generic_library_function(T x)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; EqualityComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  foo f;
  generic_library_function(f);
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; マクロは、ある型がコンセプトをモデル化しているかどうかチェックするために、クラス定義の内部で使用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In my library:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; generic_library_class
{
  BOOST_CLASS_REQUIRE(T, boost, EqualityComparableConcept);
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
};

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// In the user&#39;s code:  &lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;foo&lt;/span&gt; {
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;//... &lt;/span&gt;
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;() {
  generic_library_class&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;foo&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; glc;
  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ...&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;例&lt;/h2&gt;
&lt;p&gt;以前の &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html#motivating_example&#34;&gt;動機の例&lt;/a&gt; に対してコンセプト・チェックを応用する場合、良いやり方として、テンプレート・パラメータ型が &lt;a href=&#34;http://www.sgi.com/tech/stl/RandomAccessIterator.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; をモデル化していることを確認するために &lt;code&gt;std::stable_sort()&lt;/code&gt; の一番上に &lt;code&gt;function_requires()&lt;/code&gt; を挿入することが一つ挙げられる。 さらに、&lt;code&gt;std::stable_sort()&lt;/code&gt; は、イレテータの &lt;code&gt;value_type&lt;/code&gt; が&lt;a href=&#34;http://www.sgi.com/tech/stl/LessThanComparable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;LessThanComparable&lt;/code&gt; (未満比較可能)&lt;/a&gt; を満足することが必要であるから、これをチェックするために、重ねて &lt;code&gt;function_requires()&lt;/code&gt; を使用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;RandomAccessIter&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; stable_sort(RandomAccessIter first, RandomAccessIter last)
{
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; RandomAccessIteratorConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;RandomAccessIter&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;value_type value_type;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; LessThanComparableConcept&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;value_type&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンセプトによっては複数の型を処理するものがある。 この場合、対応するコンセプト・チェック用クラスは複数のテンプレート・パラメータを持つことになる。 以下の例は、&lt;code&gt;function_requires()&lt;/code&gt; を、２つの型パラメータ（プロパティ・マップ型とそのキーとなる型）をとる &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; コンセプトに対して使用する方法を示す。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;IncidenceGraph&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Buffer&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;BFSVisitor&lt;/span&gt;, 
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ColorMap&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; breadth_first_search(IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; g, 
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor s, 
  Buffer&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; Q, BFSVisitor vis, ColorMap color)
{
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; graph_traits&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;IncidenceGraph&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;vertex_descriptor Vertex;
  function_requires&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; ReadWritePropertyMap&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ColorMap, Vertex&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BOOST_CLASS_REQUIRE&lt;/code&gt; の使用例として、&lt;code&gt;std::vector&lt;/code&gt; が有すべきコンセプト・チェックを考察する。 要素型に対して当てはめる要求事項の一つは、それが &lt;a href=&#34;http://www.sgi.com/tech/stl/Assignable.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Assignable&lt;/code&gt; (割当可能)&lt;/a&gt;でなければならない、ということである。 これは、&lt;code&gt;std::vector&lt;/code&gt; の定義の一番上に&lt;code&gt;BOOST_CLASS_REQUIRE(T, boost, AssignableConcept)&lt;/code&gt;を挿入することにより、チェックすることができる。&lt;/p&gt;
&lt;p&gt;コンセプト・チェックは、ジェネリック・ライブラリの実装者が使用するために設計されているが、エンドユーザーにおいても有用である。 往々にして、ある型が特定のコンセプトをモデル化しているかどうか、不明確な場合がある。 こういうケースでは、問題の型とコンセプトを対象として &lt;code&gt;function_requires()&lt;/code&gt; を使用する、小さなプログラムを作成することで容易にチェックできる。 ファイル &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/stl_concept_check.cpp.html&#34;&gt;stl_concept_checks.cpp&lt;/a&gt; は、STL コンテナにコンセプト・チェックを適応する実例となっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check/creating_concepts.html&#34;&gt;次へ：「コンセプト・チェック用クラスの作成」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/concept_check.html&#34;&gt;前へ：「はじめに」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000 &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;(&lt;a href=&#34;mailto:jsiek@osl.iu.edu&#34;&gt;jsiek@osl.iu.edu&lt;/a&gt;) Andrew Lumsdaine(&lt;a href=&#34;mailto:lums@osl.iu.edu&#34;&gt;lums@osl.iu.edu&lt;/a&gt;)&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Distjoint Sets（互いに素な集合） -- disjoint_sets : リンク切れを修正(#29)</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets.html"/>
      <id>0876aae3f9108a6832681a1e3c182fa8d8448f4e:archive/boost_docs/libs/disjoint_sets.md</id>
      <updated>2015-01-17 00:22:20 +0900</updated>
      
        <content type="html">&lt;h1&gt;Distjoint Sets（互いに素な集合）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/disjoint_sets/disjoint_sets.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、互いに素な集合（素集合）の演算に 順位による和集合 および パス圧縮 を提供する。disjoint-sets のデータ構造は、素集合の S = {S&lt;sub&gt;1&lt;/sub&gt;, S&lt;sub&gt;2&lt;/sub&gt;, ..., S&lt;sub&gt;k&lt;/sub&gt;} というコレクションを維持する。 各集合は、集合のいくつかの要素である 代表値 によって識別される。 集合は、Parent プロパティマップの中の符号化された有向木によって表わされる。 2つの発見的手法: 「順位による和集合」 および 「パス圧縮」 は、 演算を高速化するのに使われる  [&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#tarjan83&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/disjoint_sets/bibliography.html#clr90&#34;&gt;2&lt;/a&gt;]。&lt;/p&gt;
&lt;h2&gt;Where Defined&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;boost/disjoint_sets.hpp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Rank&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;値型が整数型で、キー型が集合の要素型と等しい &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Parent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadWritePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadWritePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルで、かつ、キー型および値型は集合の要素型と等しくなければならない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;disjoint_sets&lt;/code&gt; に対する典型的な使用法の手本は &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/kruskal_minimum_spanning_tree.md.nolink&#34;&gt;&lt;code&gt;kruskal_minimum_spanning_tree()&lt;/code&gt;&lt;/a&gt; アルゴリズムで見ることができる。 この例では、&lt;code&gt;union_set()&lt;/code&gt; の代わりに &lt;code&gt;link()&lt;/code&gt; を呼び出す。 なぜなら、&lt;code&gt;u&lt;/code&gt; および &lt;code&gt;v&lt;/code&gt; が &lt;code&gt;find_set()&lt;/code&gt; から得られ、したがって、既にそれら集合の代表値であるからだ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;...
disjoint_sets&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Rank, Parent, FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; dsets(rank, p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (ui  &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; vertices(G).first; ui &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; vertices(G).second; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;ui)
  dsets.make_set(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;ui);
...
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;while&lt;/span&gt; ( &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;Q.empty() ) {
  e &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; Q.front();
  Q.pop();
  u &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(source(e));
  v &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; dsets.find_set(target(e));
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; ( u &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v ) {
    &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;out&lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; e;
    dsets.link(u, v);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;メンバ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(Rank r, Parent p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;disjoint_sets(const disjoint_sets&amp;amp; x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;コピーコンストラクタ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void make_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Element x&lt;/code&gt; を含む単集合を作成する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void link(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; で表わされる 2つの集合を結合する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void union_set(Element x, Element y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; を含む 2つの集合を結合する。 これは、&lt;code&gt;link(find_set(x),find_set(y))&lt;/code&gt; に相当する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class Element&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;Element find_set(Element x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素 &lt;code&gt;x&lt;/code&gt; を含む集合のための代表値を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;std::size_t count_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;素集合の個数を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;template &amp;lt;class ElementIterator&amp;gt;&lt;/code&gt;&lt;br /&gt; &lt;code&gt;void compress_sets(ElementIterator first, ElementIterator last)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;すべての要素の親がその代表値であるように親ツリーを平滑化する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Complexity&lt;/h2&gt;
&lt;p&gt;時間計算量は、O(m alpha(m,n)) である。alpha は逆アッカーマン関数、 m は disjoint-set の演算（&lt;code&gt;make_set()&lt;/code&gt;、&lt;code&gt;find_set()&lt;/code&gt;、および &lt;code&gt;link()&lt;/code&gt;）の総数、n は要素数である。 alpha 関数はとても遅く、log 関数よりもはるかに遅くなる。&lt;/p&gt;
&lt;p&gt;参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_connected_components.md.nolink&#34;&gt;&lt;code&gt;incremental_connected_components()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;ID,InverseID,FindCompress&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このクラスは、順位および親のプロパティのための記憶領域を内部で管理する。 記憶領域は、要素IDにより索引付けされた配列の中にある。ゆえに、ID および InverseID ファンクタを必要とする。 順位および親のプロパティは、構築中に初期化される、 したがって、各要素は自動的に集合の中にある（従って、このクラスのオブジェクトを &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/graph/incremental_components.md.nolink#sec:initialize-incremental-components&#34;&gt;&lt;code&gt;initialize_incremental_components()&lt;/code&gt;&lt;/a&gt; 関数で初期化することは必要でない。）。 このクラスは、頂点プロパティを格納する場所を提供しない &lt;code&gt;edge_list&lt;/code&gt; グラフの（動的）接続している構成要素を計算する場合に特に有用である。&lt;/p&gt;
&lt;h2&gt;Template Parameters&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;パラメータ&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;デフォルト&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0からN（集合中の要素の総数）までの整数に要素を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;InverseID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要素に整数を対応付ける &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/property_map/ReadablePropertyMap.md.nolink&#34;&gt;&lt;code&gt;ReadablePropertyMap&lt;/code&gt;&lt;/a&gt; のモデルでなければならない。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boost::identity_property_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FindCompress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代表値の検索およびパス圧縮関数オブジェクトのうちの 1つであるべきだ。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;representative_with_full_path_compression&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Members&lt;/h2&gt;
&lt;p&gt;このクラスは、以下のメンバだけでなく &lt;code&gt;disjoint_sets&lt;/code&gt; のすべてのメンバも持っている。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;disjoint_sets_with_storage(size_type n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;,
                           ID id &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; ID(),
                           InverseID inv &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; InverseID())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;コンストラクタ。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ElementIterator&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; disjoint_sets_with_storage&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;
  normalize_sets(ElementIterator first, ElementIterator last)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;各集合の代表値が最も小さな ID を備えた要素になるように代表値を再整理する。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事後条件: &lt;code&gt;v &amp;gt;= parent[v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事前条件: 素集合の構造は圧縮されていなければならない。 &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_path_halving&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; と同じ構成要素のための代表的な頂点を検索するファンクタである。 代表値木を横断している間、ファンクタは、さらに木の高さを短くするためにパス二分技術を適用する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;representative_with_full_path_compression&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Parent&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これは、要素 &lt;code&gt;x&lt;/code&gt; が属する集合のための代表的な要素を検索するファンクタである。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;Element &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(Parent p, Element x)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2000&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/people/jeremy_siek.htm&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:jsiek@lsc.nd.edu&#34;&gt;jsiek@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~llee1&#34; target=&#34;_blank&#34;&gt;Lie-Quan Lee&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:llee1@lsc.nd.edu&#34;&gt;llee1@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lsc.nd.edu/~lums&#34; target=&#34;_blank&#34;&gt;Andrew Lumsdaine&lt;/a&gt;, Univ.of Notre Dame (&lt;a href=&#34;mailto:lums@lsc.nd.edu&#34;&gt;lums@lsc.nd.edu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Japanese Translation Copyright (C) 2003 IKOMA Yoshiki &lt;a href=&#34;mailto:ikoma@mb.i-chubu.ne.jp&#34;&gt;ikoma@mb.i-chubu.ne.jp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>