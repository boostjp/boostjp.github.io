<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-05-02T23:02:41.786442</updated>
  <id>8d0935fe-5ecf-4fc3-bdc3-c5f511514c4c</id>

  
    <entry>
      <title>Boost 1.58.0リリースノート -- 1.58.0リリースノート：既知の不具合を追記</title>
      <link href="http://boostjp.github.io/document/version/1_58_0.html"/>
      <id>b83b720a4cec72e5b44ad566586e023b886b628b:document/version/1_58_0.md</id>
      <updated>2015-04-30 13:47:55 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost 1.58.0リリースノート&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/website/blob/master/feed/history/boost_1_58_0.qbk&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/website/blob/master/feed/history/boost_1_58_0.qbk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_58_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_58_0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/&#34; target=&#34;_blank&#34;&gt;https://github.com/boostorg/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリからのビルド方法は、egtraさんのブログを参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「&lt;a href=&#34;http://dev.activebasic.com/egtra/2013/12/03/620/&#34; target=&#34;_blank&#34;&gt;Modularized Boost（GitHubへ移行したリポジトリ）を使用する&lt;/a&gt;」&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;既知の不具合&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Pythonは次のバージョン向けにビルドすることが出来ない: 3.0.X, 3.1.X, 3.2.X, 3.3.X&lt;ul&gt;
&lt;li&gt;2.Xもしくは3.4以降にはこの問題はない&lt;/li&gt;
&lt;li&gt;Git上では次の&lt;a href=&#34;https://github.com/boostorg/python/commit/3e405b6fd5db5615bbef241763de070118222ca7&#34; target=&#34;_blank&#34;&gt;コミット&lt;/a&gt;で修正された&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;パッチ&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/patches/1_58_0/0001-Fix-exec_file-for-Python-3-3.4.patch&#34; target=&#34;_blank&#34;&gt;0001-Fix-exec_file-for-Python-3-3.4.patch&lt;/a&gt; (libs/python ディレクトリ以下で適用する)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/endian/&#34; target=&#34;_blank&#34;&gt;Endian&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;プロセッサのエンディアンに関係なく、適切なバイトオーダーに変換する型と関数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/sort/&#34; target=&#34;_blank&#34;&gt;Sort&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;一般的な状況でO(n*log(n))よりも高速な、ハイブリッドな基数ソートであるスプレッドソート(spreadsort)を含む。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#asio&#34;&gt;Asio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#chrono&#34;&gt;Chrono&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#container&#34;&gt;Container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#context&#34;&gt;Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#conversion&#34;&gt;Conversion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#datetime&#34;&gt;DateTime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#flyweight&#34;&gt;Flyweight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#function&#34;&gt;Function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#functional-factory&#34;&gt;Functional/Factory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#fusion&#34;&gt;Fusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#geometry&#34;&gt;Geometry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#hash&#34;&gt;Hash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#interprocess&#34;&gt;Interprocess&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#intrusive&#34;&gt;Intrusive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#lexical-cast&#34;&gt;Lexical Cast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#log&#34;&gt;Log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#math&#34;&gt;Math&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#move&#34;&gt;Move&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#multi-index&#34;&gt;Multi-index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#multiprecision&#34;&gt;Multiprecision&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#optional&#34;&gt;Optional&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#phoenix&#34;&gt;Phoenix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#predef&#34;&gt;Predef&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#random&#34;&gt;Random&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#thread&#34;&gt;Thread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#type_erasure&#34;&gt;TypeErasure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#type_index&#34;&gt;TypeIndex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#units&#34;&gt;Units&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#unordered&#34;&gt;Unordered&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#variant&#34;&gt;Variant&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#asio&#34; name=&#34;asio&#34;&gt;Asio&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10744&#34; target=&#34;_blank&#34;&gt;#10744&lt;/a&gt; Windowsの&lt;code&gt;ConnextEx&lt;/code&gt;関数によって生成されるエラー値を、他の環境でも使えるようマッピングした&lt;/li&gt;
&lt;li&gt;新たなマクロ&lt;code&gt;BOOST_ASIO_DISABLE_CONNECTEX&lt;/code&gt;を追加した。これを使用することによって、&lt;code&gt;ConnectEx&lt;/code&gt;を明示的に無効にできる。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10624&#34; target=&#34;_blank&#34;&gt;#10624&lt;/a&gt; &lt;code&gt;windows::object_handle&lt;/code&gt;の競合状態を修正。これは、破棄に対する操作待ちで起きていた。&lt;/li&gt;
&lt;li&gt;FreeBSD環境でのIPv6アドレスの構文解析を修正。末尾にスコープIDが付いているときに、変換時に&lt;code&gt;EINVAL&lt;/code&gt;が原因で失敗していた。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/9465&#34; target=&#34;_blank&#34;&gt;#9465&lt;/a&gt;, &lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11070&#34; target=&#34;_blank&#34;&gt;#11070&lt;/a&gt; Asioのデフォルト可視性を使用した際に起こる、共有ライブラリの可視性問題について回避策を導入。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10828&#34; target=&#34;_blank&#34;&gt;#10828&lt;/a&gt; メモリ内のキーを読み込む際に、パスワードのコールバックを呼び出すようSSLラッパーを変更。&lt;/li&gt;
&lt;li&gt;SSLのエラーキューが各操作の前にクリアした際に起こる、SSLエラーの誤報を修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ssl::stream&amp;lt;&amp;gt;&lt;/code&gt;が擬似的(spurious)に「短く読み込んだ(short read)」エラーを出力する可能性があったバグを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10088&#34; target=&#34;_blank&#34;&gt;#10088&lt;/a&gt; SSLエンジンの冗長なヌルポインタチェックを削除&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10690&#34; target=&#34;_blank&#34;&gt;#10690&lt;/a&gt; TLS v1.1と1.2を無効にするオプションを追加&lt;/li&gt;
&lt;li&gt;非推奨だったOpenSSLの&lt;code&gt;ERR_remove_state&lt;/code&gt;関数の使用を削除&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/8835&#34; target=&#34;_blank&#34;&gt;#8835&lt;/a&gt;, &lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10884&#34; target=&#34;_blank&#34;&gt;#10884&lt;/a&gt; ClangでのC++11機能の欠陥を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10982&#34; target=&#34;_blank&#34;&gt;#10982&lt;/a&gt; g++での、C++11の&lt;code&gt;std::addressof&lt;/code&gt;の欠陥を修正&lt;/li&gt;
&lt;li&gt;マルチキャストのテストでの、&lt;code&gt;join_group&lt;/code&gt;の失敗を非致命的に変更&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11116&#34; target=&#34;_blank&#34;&gt;#11116&lt;/a&gt; AsioのテストをBoost.Testから分離した&lt;/li&gt;
&lt;li&gt;チュートリアルで、結果をフラッシュするために&lt;code&gt;std::endl&lt;/code&gt;を使用するよう修正&lt;/li&gt;
&lt;li&gt;Clangのinteger sanitizerで報告された、符号なし整数のオーバーフローを修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yield_context&lt;/code&gt;を使用した非同期操作で、ムーブのみ可能な型を返せるようにした&lt;/li&gt;
&lt;li&gt;初期化関数から完了ハンドラを再入的(reentrant)に呼び出せるようにするため、&lt;code&gt;yield_context&lt;/code&gt;を変更した&lt;/li&gt;
&lt;li&gt;最新のWindows SDKで動作するように、Windows Runtimeの検出方法を更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#chrono&#34; name=&#34;chrono&#34;&gt;Chrono&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;バージョン2.0.5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10778&#34; target=&#34;_blank&#34;&gt;#10778&lt;/a&gt; &lt;code&gt;boost::chrono&lt;/code&gt;の&lt;code&gt;duration&lt;/code&gt;クラスが、&lt;code&gt;TriviallyCopyable&lt;/code&gt;でないために&lt;code&gt;std::atomic&lt;/code&gt;に格納できない問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10840&#34; target=&#34;_blank&#34;&gt;#10840&lt;/a&gt; テストコードtest_7868.cppにおいて、&lt;code&gt;puts()&lt;/code&gt;関数の呼び出しが&lt;code&gt;std::&lt;/code&gt;修飾されていなかった問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10851&#34; target=&#34;_blank&#34;&gt;#10851&lt;/a&gt; テストコードtime_point_output.cppにおいて、&lt;code&gt;puts()&lt;/code&gt;関数の呼び出しが&lt;code&gt;std::&lt;/code&gt;修飾されていなかった問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10893&#34; target=&#34;_blank&#34;&gt;#10893&lt;/a&gt; ドキュメントの細かな誤字を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10992&#34; target=&#34;_blank&#34;&gt;#10992&lt;/a&gt; ChronoのIO state saverが、Boost.IO state saverと一貫していない問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10995&#34; target=&#34;_blank&#34;&gt;#10995&lt;/a&gt; &lt;code&gt;duration_put::put_value()&lt;/code&gt;で、少数が切り捨てられる問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11006&#34; target=&#34;_blank&#34;&gt;#11006&lt;/a&gt; &lt;code&gt;time_fmt_io_saver&lt;/code&gt;のインスタンス化がコンパイルエラーになる問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11012&#34; target=&#34;_blank&#34;&gt;#11012&lt;/a&gt; chrono_io v2において、&lt;code&gt;boost::chrono::duration&amp;lt; boost::rational&amp;lt;int&amp;gt; &amp;gt;&lt;/code&gt;がコンパイルエラーになる問題を修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#container&#34; name=&#34;container&#34;&gt;Container&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;実験的に&lt;code&gt;small_vector&lt;/code&gt;クラスを追加&lt;ul&gt;
&lt;li&gt;小さな要素数に最適化された&lt;code&gt;vector&lt;/code&gt;。テンプレートパラメータで指定された要素数の領域を事前に確保することにより、その要素数を超えない限り、&lt;code&gt;insert()&lt;/code&gt;／&lt;code&gt;push_back()&lt;/code&gt;でメモリ確保を行わない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static_vector&lt;/code&gt;とは異なり、フリーストアからメモリ確保し、キャパシティを超えた領域の拡張が可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h&#34; target=&#34;_blank&#34;&gt;LLVMのSmallVectorクラス&lt;/a&gt;を参考にしている&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依存関係を大規模に見なおした。現在、Boost.Containerは、とても基本的なユーティリティのみをBoost.CoreとBoost.Intrusiveに依存する。プリプロセスされたコードのサイズが小さくなっているため、コンパイル時間が改善する。&lt;/li&gt;
&lt;li&gt;ランダムアクセスイテレータを持つコンテナ(&lt;code&gt;basic_string&lt;/code&gt;以外)に、&lt;code&gt;nth()&lt;/code&gt;、&lt;code&gt;index_of()&lt;/code&gt;メンバ関数を追加。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nth()&lt;/code&gt;は、指定されたインデックスの要素を指すイテレータを取得するメンバ関数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index_of()&lt;/code&gt;は、指定されたイテレータが指す要素のインデックスを取得するメンバ関数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++17の&lt;code&gt;allocator_traits&amp;lt;Allocator&amp;gt;::is_always_equal&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;コンテナのコンストラクタを、以下の仕様に基づいて更新：&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2210&#34; target=&#34;_blank&#34;&gt;2210. Missing allocator-extended constructor for allocator-aware containers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9931&#34; target=&#34;_blank&#34;&gt;#9931&lt;/a&gt; 再度開かれたチケット「&lt;code&gt;flat_map::insert(ordered_unique_range_t...)&lt;/code&gt;に&lt;code&gt;move_iterator&lt;/code&gt;を渡せない」を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11076&#34; target=&#34;_blank&#34;&gt;#11076&lt;/a&gt; container/detail/copy_move_algo.hppで、&lt;code&gt;memmove()&lt;/code&gt;と&lt;code&gt;memcpy()&lt;/code&gt;を名前空間修飾なしに呼び出していた問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10790&#34; target=&#34;_blank&#34;&gt;#10790&lt;/a&gt; Boost.Containerのコンテナに&lt;code&gt;long long&lt;/code&gt;を指定するとコンパイルエラーになる問題を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10808&#34; target=&#34;_blank&#34;&gt;#10808&lt;/a&gt; &lt;code&gt;vector&lt;/code&gt;の等値比較演算子が壊れていたので修正&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;ソースの破壊的変更&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scoped_allocator_adaptor&lt;/code&gt;クラスの&lt;code&gt;propagate_on_container_copy_assignment&lt;/code&gt;、&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;、&lt;code&gt;propagate_on_container_swap&lt;/code&gt;が、&lt;code&gt;::boost::integral_constant&amp;lt;bool, true/false&amp;gt;&lt;/code&gt;ではなくなった。これは、MPLへの依存を減らすため、および&lt;code&gt;std::integral_constant&lt;/code&gt;との相互運用保証がなかったためである。&lt;code&gt;boost::true_type&lt;/code&gt;／&lt;code&gt;boost::false_type&lt;/code&gt;を仮定したコードはコンパイルが通らなくなる。ワークアラウンドとして、内部の&lt;code&gt;::value&lt;/code&gt;定数を使用して&lt;code&gt;::boost::integral_constant&amp;lt;bool, scoped_allocator_adaptor&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&amp;gt;&lt;/code&gt;のように書くことで、問題を回避できる。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#context&#34; name=&#34;context&#34;&gt;Context&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ARM/iOS (32ビット + 64ビット) をサポート&lt;/li&gt;
&lt;li&gt;C++14向けに&lt;code&gt;execution_context&lt;/code&gt;クラスを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#conversion&#34; name=&#34;conversion&#34;&gt;Conversion&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10780&#34; target=&#34;_blank&#34;&gt;#10780&lt;/a&gt; &lt;code&gt;polymorphic_pointer_downcast()&lt;/code&gt;関数と&lt;code&gt;polymorphic_pointer_cast()&lt;/code&gt;関数を追加した(Boris Rasin氏に感謝)&lt;/li&gt;
&lt;li&gt;例外を送出する全ての関数が、&lt;code&gt;boost::throw_exception()&lt;/code&gt;を使用するようにした&lt;/li&gt;
&lt;li&gt;ドキュメントを更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#datetime&#34; name=&#34;datetime&#34;&gt;DateTime&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;to_time_t()&lt;/code&gt;関数を復活&lt;/li&gt;
&lt;li&gt;変数&lt;code&gt;v_type&lt;/code&gt;の名前を&lt;code&gt;var_type&lt;/code&gt;に変更。AIXのシステム変数と衝突していたため。&lt;/li&gt;
&lt;li&gt;ドキュメントを修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#flyweight&#34; name=&#34;flyweight&#34;&gt;Flyweight&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::hash&lt;/code&gt;と&lt;code&gt;boost::hash&lt;/code&gt;でのハッシュサポートを追加。&lt;ul&gt;
&lt;li&gt;この機能は&lt;code&gt;BOOST_FLYWEIGHT_DISABLE_HASH_SUPPORT&lt;/code&gt;をdefineすることによって無効化できる。この無効化機能は、ユーザーが&lt;code&gt;flyweight&lt;/code&gt;クラスを自前でハッシュサポートしていた場合のためにある。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;メンテナンス上の修正をいくつか行った&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#function&#34; name=&#34;function&#34;&gt;Function&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10585&#34; target=&#34;_blank&#34;&gt;#10585&lt;/a&gt; C++11の右辺値、Boost.Moveの右辺値、両方の関数を受け取れるようにした&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#functional-factory&#34; name=&#34;functional-factory&#34;&gt;Functional/Factory&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;小さな破壊的変更&lt;/strong&gt;&lt;/span&gt; : アロケータを使用すべきでないことを示すためのデフォルトテンプレートパラメータを、&lt;code&gt;boost::none_t&lt;/code&gt;から&lt;code&gt;void&lt;/code&gt;に変更。これは、Boost.Optionalへの依存をなくすための変更。&lt;ul&gt;
&lt;li&gt;引き続き&lt;code&gt;boost::none_t&lt;/code&gt;を使用したい場合は、&lt;code&gt;BOOST_FUNCTIONAL_FACTORY_SUPPORT_NONE_T&lt;/code&gt;をdefineすること。ただし、この互換性のための機能は、将来のリリースから削除される可能性があることに注意。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#fusion&#34; name=&#34;fusion&#34;&gt;Fusion&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/fusion/pull/12&#34; target=&#34;_blank&#34;&gt;GitHub PR #12&lt;/a&gt; Fusionのシーケンスを&lt;code&gt;boost::hash&lt;/code&gt;で使えるように&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/fusion/pull/51&#34; target=&#34;_blank&#34;&gt;GitHub PR #51&lt;/a&gt; &lt;code&gt;std::reference_wrapper&lt;/code&gt; をサポート&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::tuple&lt;/code&gt; をサポート&lt;ul&gt;
&lt;li&gt;&lt;code&gt;convert&lt;/code&gt;、&lt;code&gt;mpl::clear&lt;/code&gt;の実装を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/fusion/pull/54&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;GitHub PR #54&lt;/code&gt;&lt;/a&gt; Fusionアダプタでの暗黙的な型推論をサポート&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ADAPT_STRUCT&lt;/code&gt;、&lt;code&gt;ADAPT_ADT&lt;/code&gt;、&lt;code&gt;ADAPT_ASSOC_&lt;/code&gt;マクロで、メンバ変数の型を書かなくてよくなった&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9813&#34; target=&#34;_blank&#34;&gt;ticket 9813&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/fusion/pull/14&#34; target=&#34;_blank&#34;&gt;GitHub PR #14&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/fusion/pull/23&#34; target=&#34;_blank&#34;&gt;GitHub PR #23&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/fusion/pull/26&#34; target=&#34;_blank&#34;&gt;GitHub PR #26&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/fusion/pull/58&#34; target=&#34;_blank&#34;&gt;GitHub PR #58&lt;/a&gt; C++11/14 constexprのサポート&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10190&#34; target=&#34;_blank&#34;&gt;ticket 10190&lt;/a&gt; &lt;code&gt;std::declval()&lt;/code&gt;の代わりに&lt;code&gt;boost::declval()&lt;/code&gt;を使用するようにした&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8622&#34; target=&#34;_blank&#34;&gt;ticket 8622&lt;/a&gt; &lt;code&gt;boost::blank&lt;/code&gt;を使用するのをやめた&lt;/li&gt;
&lt;li&gt;いくつかの&lt;code&gt;result_of&lt;/code&gt;をSFINAE-friendlyに&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10443&#34; target=&#34;_blank&#34;&gt;ticket 10443&lt;/a&gt; &lt;code&gt;fusion::result_of::invoke&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/fusion/pull/35&#34; target=&#34;_blank&#34;&gt;GitHub PR #35&lt;/a&gt; &lt;code&gt;fusion::result_of::copy&lt;/code&gt;、&lt;code&gt;fusion::result_of::move&lt;/code&gt;、&lt;code&gt;fusion::result_of::swap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/fusion/pull/41&#34; target=&#34;_blank&#34;&gt;GitHub PR #41&lt;/a&gt; &lt;code&gt;fusion::result_of::at_c&lt;/code&gt;、&lt;code&gt;fusion::result_of::at&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7304&#34; target=&#34;_blank&#34;&gt;ticket 7304&lt;/a&gt; &lt;code&gt;result_of::size::value&lt;/code&gt;と&lt;code&gt;result_of::size::type::value&lt;/code&gt;の型が同じになった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/6507&#34; target=&#34;_blank&#34;&gt;ticket 6507&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7651&#34; target=&#34;_blank&#34;&gt;ticket 7651&lt;/a&gt; &lt;code&gt;result_of::at&amp;lt;Seq, N&amp;gt;::type&lt;/code&gt;は、&lt;code&gt;N&lt;/code&gt;がシーケンスの要素数未満の場合にのみ定義されるようになった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8457&#34; target=&#34;_blank&#34;&gt;ticket 8457&lt;/a&gt; インクルード漏れを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/6090&#34; target=&#34;_blank&#34;&gt;ticket 6090&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5324&#34; target=&#34;_blank&#34;&gt;ticket 5324&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/fusion/pull/33&#34; target=&#34;_blank&#34;&gt;GitHub PR #33&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/fusion/pull/53&#34; target=&#34;_blank&#34;&gt;GitHub PR #53&lt;/a&gt;, &lt;a href=&#34;https://github.com/boostorg/fusion/pull/56&#34; target=&#34;_blank&#34;&gt;GitHub PR #56&lt;/a&gt; 多くのドキュメントを修正 &amp;amp; 改善&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下の記事も参照：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://flast.hateblo.jp/entry/2015/03/07/181046&#34; target=&#34;_blank&#34;&gt;Boost.Fusion 1.58 updates - にゃははー&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#geometry&#34; name=&#34;geometry&#34;&gt;Geometry&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新たなアルゴリズム&lt;code&gt;num_segments&lt;/code&gt;を追加。このアルゴリズムは、ジオメトリのセグメント数を返す。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_valid&lt;/code&gt;アルゴリズムに、新たなオーバーロードを追加。これは2番目の引数で&lt;code&gt;string&lt;/code&gt;の参照を受け取り、ジオメトリの有効性と無効正に関するメッセージで埋める。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_valid&lt;/code&gt;アルゴリズムに、新たなオーバーロードを追加。これは2番目の引数で&lt;code&gt;enum&lt;/code&gt;の参照を受け取り、ジオメトリの有効性と無効性に関する値を設定する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disjoint&lt;/code&gt;と&lt;code&gt;intersects&lt;/code&gt;に、以下のジオメトリの組み合わせサポートを追加：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;point&lt;/code&gt;/&lt;code&gt;multipoint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipoint&lt;/code&gt;/&lt;code&gt;multipoint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipoint&lt;/code&gt;/&lt;code&gt;segment&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipoint&lt;/code&gt;/&lt;code&gt;box&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;改善&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Buffer&lt;/code&gt;に、&lt;code&gt;linestring&lt;/code&gt;のためのflat-endサポートを追加。&lt;ul&gt;
&lt;li&gt;Buffer now supports flat-ends for linestrings with a bend close to the start (such that buffered segment crosses flat-end).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Buffer&lt;/code&gt;のパフォーマンスを大幅に向上させた。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Polygon&lt;/code&gt;の&lt;code&gt;Partition&lt;/code&gt;のパフォーマンスを大幅に向上させた。全てのオーバーレイ操作が改善する可能性がある。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解決したチケット&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8379&#34; target=&#34;_blank&#34;&gt;#8379&lt;/a&gt; 行列式の比較結果が間違っている&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10108&#34; target=&#34;_blank&#34;&gt;#10108&lt;/a&gt; ジオメトリの一つの点にtouchする特定の状況において、オーバーレイ操作がエラーになる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10201&#34; target=&#34;_blank&#34;&gt;#10201&lt;/a&gt; 座標系の比較に、別な関数を使用する提案(wontfix : 問題はあるけれど、いまは修正できない)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10467&#34; target=&#34;_blank&#34;&gt;#10467&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10863&#34; target=&#34;_blank&#34;&gt;#10863&lt;/a&gt; テンプレートパラメータ名がtermios.hの&lt;code&gt;B0&lt;/code&gt;マクロと衝突している&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10640&#34; target=&#34;_blank&#34;&gt;#10640&lt;/a&gt; CCW Polygonにおいて、&lt;code&gt;buffer()&lt;/code&gt;の結果が間違っている&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10666&#34; target=&#34;_blank&#34;&gt;#10666&lt;/a&gt; MSVCコンパイラの警告C4127 : 「条件式が定数になっている」を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10747&#34; target=&#34;_blank&#34;&gt;#10747&lt;/a&gt; 再スケジューリングが、areal/arealの設定操作が原因でエラーになっている&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10770&#34; target=&#34;_blank&#34;&gt;#10770&lt;/a&gt; &lt;code&gt;Buffer&lt;/code&gt;が巨大な距離、もしくはrough round joinで失敗する。失敗する場所は、凹所(concavities)の交差しないところ&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10658&#34; target=&#34;_blank&#34;&gt;#10658&lt;/a&gt; &lt;code&gt;sym_difference&lt;/code&gt;が、&lt;code&gt;int&lt;/code&gt;のポリゴンに対して間違った結果を生成する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10835&#34; target=&#34;_blank&#34;&gt;#10835&lt;/a&gt; &lt;code&gt;multilinestring&lt;/code&gt;と&lt;code&gt;polygon&lt;/code&gt;の&lt;code&gt;difference&lt;/code&gt;が、間違った結果を生成する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10861&#34; target=&#34;_blank&#34;&gt;#10861&lt;/a&gt; &lt;code&gt;Rtree&lt;/code&gt;の&lt;code&gt;Value&lt;/code&gt;がポインタを含む&lt;code&gt;pair&lt;/code&gt;もしくは&lt;code&gt;tuple&lt;/code&gt;であり、&lt;code&gt;Geometry&lt;/code&gt;デフォルト比較の&lt;code&gt;equal_to&lt;/code&gt;を使用している場合に、コンパイルエラーになる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10887&#34; target=&#34;_blank&#34;&gt;#10887&lt;/a&gt; &lt;code&gt;Linear&lt;/code&gt;/&lt;code&gt;MultiPolygon&lt;/code&gt;の&lt;code&gt;within()&lt;/code&gt;と&lt;code&gt;relate()&lt;/code&gt;が、不正な結果になる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10890&#34; target=&#34;_blank&#34;&gt;#10890&lt;/a&gt; &lt;code&gt;Point&lt;/code&gt;/&lt;code&gt;Segment&lt;/code&gt;の&lt;code&gt;disjoint()&lt;/code&gt;が不正な結果になる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10904&#34; target=&#34;_blank&#34;&gt;#10904&lt;/a&gt; &lt;code&gt;relate_cartesian_segments&lt;/code&gt;戦略において、最上位次元のセグメントの計算が間違っている&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10912&#34; target=&#34;_blank&#34;&gt;#10912&lt;/a&gt; &lt;code&gt;Areal&lt;/code&gt;/&lt;code&gt;Areal&lt;/code&gt;の&lt;code&gt;within()&lt;/code&gt;と&lt;code&gt;relate()&lt;/code&gt;が、不正な結果になる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10951&#34; target=&#34;_blank&#34;&gt;#10951&lt;/a&gt; WindowsのIntelコンパイラにおいて、&lt;code&gt;/bigobj&lt;/code&gt;フラグを設定するとテストに失敗する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10957&#34; target=&#34;_blank&#34;&gt;#10957&lt;/a&gt; 様々な関係操作において、アサーションが失敗し、不正な結果を出力する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10958&#34; target=&#34;_blank&#34;&gt;#10958&lt;/a&gt; &lt;code&gt;L&lt;/code&gt;/&lt;code&gt;L&lt;/code&gt;と&lt;code&gt;L&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;dijoint()&lt;/code&gt;が、不正な結果になる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10959&#34; target=&#34;_blank&#34;&gt;#10959&lt;/a&gt; &lt;code&gt;no_rescale_policy&lt;/code&gt;を使用すると、&lt;code&gt;get_turns()&lt;/code&gt;がアサーションに失敗する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10960&#34; target=&#34;_blank&#34;&gt;#10960&lt;/a&gt; &lt;code&gt;L&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;get_turns()&lt;/code&gt;が不正な結果になる。turnが不足している。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10961&#34; target=&#34;_blank&#34;&gt;#10961&lt;/a&gt; &lt;code&gt;L&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt;の&lt;code&gt;get_turns()&lt;/code&gt;が不正な結果になる。linear spikeのtrunが不正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11112&#34; target=&#34;_blank&#34;&gt;#11112&lt;/a&gt; Solarisプラットフォームのマクロ名との衝突により、コンパイルエラーになる&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11121&#34; target=&#34;_blank&#34;&gt;#11121&lt;/a&gt; 整数座標系(integral coordinates)の&lt;code&gt;difference()&lt;/code&gt;が不正な結果になる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;multipoint&lt;/code&gt;/&lt;code&gt;polygon&lt;/code&gt;、&lt;code&gt;multipoint&lt;/code&gt;/&lt;code&gt;multipolygon&lt;/code&gt;の距離の計算でのバグを修正(point内部のarealジオメトリを誤って検出していた)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flatten_iterator&lt;/code&gt;の代入演算子で、アクセス違反するバグを修正&lt;/li&gt;
&lt;li&gt;Cartesian segment-segmentの交差戦略のバグを修正。ひとつのセグメントの点への縮退(degenerate)が、ほかへの縮退をしないセグメントと同一線上にあるときに起こる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;centroid()&lt;/code&gt;のバグを修正。たとえばゼロ面積のようなものを計算したときに、非決定的な結果になる&lt;/li&gt;
&lt;li&gt;限られたポイント数のjoinでの、&lt;code&gt;buffer&lt;/code&gt;のバグを修正。&lt;/li&gt;
&lt;li&gt;鋭いコーナーの周りにある限られたポイント数のround joinでの、&lt;code&gt;buffer&lt;/code&gt;のバグを修正&lt;/li&gt;
&lt;li&gt;大きなバッファ距離のjoinでの、&lt;code&gt;buffer&lt;/code&gt;のバグを修正&lt;/li&gt;
&lt;li&gt;ポイント数を追加するround endでの、&lt;code&gt;buffer&lt;/code&gt;のバグを修正&lt;/li&gt;
&lt;li&gt;大きなバッファ距離のflat endでの、&lt;code&gt;buffer&lt;/code&gt;のバグを修正&lt;/li&gt;
&lt;li&gt;大きな負のバッファ距離のinterior ringでの、&lt;code&gt;buffer&lt;/code&gt;のバグを修正&lt;/li&gt;
&lt;li&gt;input rangeが空である場合に、&lt;code&gt;closing_iterator&lt;/code&gt;が動作しないバグを修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multilinestring&lt;/code&gt;を含む閉じたシンプルなlinestringがハンドリングされない、&lt;code&gt;is_simple&lt;/code&gt;のバグを修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rtree&lt;/code&gt;の、イテレータの組もしくはRangeを受け取るコンストラクタ(パッキングアルゴリズム)のバグを修正。破棄済みの一時オブジェクトへの参照を使用していた。これは、&lt;code&gt;distance()&lt;/code&gt;と&lt;code&gt;comparable_distance()&lt;/code&gt;にも影響する。このバグは、&lt;code&gt;rtree&lt;/code&gt;もしくは&lt;code&gt;distance()&lt;/code&gt;アルゴリズムで、アサーション失敗やセグメンテーションフォルトなど、予期しない動作をする可能性がある。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rtree&lt;/code&gt;の&lt;code&gt;count()&lt;/code&gt;メンバ関数のバグを修正。破棄済みの一時オブジェクトの参照を使用していた。このバグが起こると、大きの場合に&lt;code&gt;0&lt;/code&gt;が返る。&lt;/li&gt;
&lt;li&gt;Rangeのハンドリング関係のバグを修正。いくつかのアルゴリズムで、非コンテナのRangeをジオメトリとして扱った場合に、コンパイルが通ってしまうことを防止する(Samuel Debionneに感謝)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#hash&#34; name=&#34;hash&#34;&gt;Hash&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/functional/pull/3&#34; target=&#34;_blank&#34;&gt;GitHub PR #3&lt;/a&gt; strict aliasing違反を修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#interprocess&#34; name=&#34;interprocess&#34;&gt;Interprocess&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;コンパイル時の依存関係を削減した。Boost.Containerの変更に対する更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostorg/interprocess/pull/13&#34; target=&#34;_blank&#34;&gt;GitHub PR #13&lt;/a&gt; HaikuはXSI共有メモリを持っていないため、このライブラリを使用できない&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#intrusive&#34; name=&#34;intrusive&#34;&gt;Intrusive&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;とくにフックとイテレータのために、コンパイルの依存関係、ヘッダ、Boost.Preprocessorの使用を削減。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/6720&#34; target=&#34;_blank&#34;&gt;Boost Trac #6720&lt;/a&gt; statelessラムダを使用すると、VC11 Beta環境において&lt;code&gt;intrusive::unordered_set::clear_and_dispose&lt;/code&gt;のコンパイルに失敗する&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10771&#34; target=&#34;_blank&#34;&gt;#10771&lt;/a&gt; &lt;code&gt;slist&lt;/code&gt;の&lt;code&gt;remove_if&lt;/code&gt;が壊れている&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10853&#34; target=&#34;_blank&#34;&gt;#10853&lt;/a&gt; 提案文書に従って&lt;code&gt;pointer_traits&lt;/code&gt;のドキュメントを記載&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10987&#34; target=&#34;_blank&#34;&gt;#10987&lt;/a&gt; &lt;code&gt;any_xxx_node_traits&lt;/code&gt;は参照を返すべきではない&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#lexical-cast&#34; name=&#34;lexical-cast&#34;&gt;Lexical Cast&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5660&#34; target=&#34;_blank&#34;&gt;ticket 5660&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/6975&#34; target=&#34;_blank&#34;&gt;ticket 6975&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10639&#34; target=&#34;_blank&#34;&gt;ticket 10639&lt;/a&gt; 浮動小数点数の変換に&lt;code&gt;std::stream&lt;/code&gt;を使用するようにした。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#log&#34; name=&#34;Log&#34;&gt;Log&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;スレッドIDのフォーマットを修正&lt;/li&gt;
&lt;li&gt;プロセスIDのフォーマットを修正&lt;/li&gt;
&lt;li&gt;GNU Hurdでのビルド失敗を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11016&#34; target=&#34;_blank&#34;&gt;ticket 11016&lt;/a&gt; ファイルシステムの空き領域が使い尽くされている場合の、text file sink backendの間違った挙動を修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11106&#34; target=&#34;_blank&#34;&gt;ticket 11106&lt;/a&gt; &lt;code&gt;attribute_set::insert()&lt;/code&gt;がいくつかの場合で正しくない挙動をしており、以前に挿入した要素を見つけられなくなっていたのを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11148&#34; target=&#34;_blank&#34;&gt;ticket 11148&lt;/a&gt; 属性値集合に多くの属性値が挿入された際に &lt;code&gt;attribute_value_set::size()&lt;/code&gt; が正しくない挙動をしていたのを修正&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;より詳細な変更は、&lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/log/doc/html/log/changelog.html&#34; target=&#34;_blank&#34;&gt;Changelog&lt;/a&gt;を参照。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#math&#34; name=&#34;math&#34;&gt;Math&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2つの特殊関数&lt;code&gt;trigamma()&lt;/code&gt;と&lt;code&gt;polygamma()&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;楕円積分のコード(Elliptic integral code)に、Carlsonの最新アルゴリズムを使うよう、大規模な更新を行った。この変更によって、以前よりも安定し、より正確になり、若干高速になるはずだ。CarlsonのRG積分のサポートも追加した。&lt;/li&gt;
&lt;li&gt;楕円積分の機能として、&lt;code&gt;ellint_d()&lt;/code&gt;、&lt;code&gt;jacobi_zeta()&lt;/code&gt;、&lt;code&gt;heuman_lambda()&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;名前空間内で定義している定数は、&lt;code&gt;constexpr&lt;/code&gt;に準拠したコンパイラであれば&lt;code&gt;constexpr&lt;/code&gt;定数として定義するようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10901&#34; target=&#34;_blank&#34;&gt;#10901&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ベータ関数、ガンマ関数、および楕円積分で、見かけ上のアンダーフローとオーバーフローが起こる様々なケースを修正。Rocco Romeo氏に感謝。&lt;/li&gt;
&lt;li&gt;3引数版の&lt;code&gt;legendre_p()&lt;/code&gt;と&lt;code&gt;legendre_q()&lt;/code&gt;関数に、最後の引数としてポリシーが指定されなかった場合に、オーバーロードされないように修正した。&lt;/li&gt;
&lt;li&gt;不完全な&lt;code&gt;beta()&lt;/code&gt;関数の、いくつかの死んだコードを整理(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10985&#34; target=&#34;_blank&#34;&gt;#10985&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;極値pdfの巨大な値の入力を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10938&#34; target=&#34;_blank&#34;&gt;#10938&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ドキュメントに使用しているグラフと方程式の画像を、PNGからSVGに切り替えた&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#move&#34; name=&#34;move&#34;&gt;Move&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BOOST_MOVE_BASE&lt;/code&gt;ユーティリティを追加した&lt;/li&gt;
&lt;li&gt;&lt;code&gt;adl_move_swap()&lt;/code&gt;ユーティリティを追加した&lt;/li&gt;
&lt;li&gt;他のBoostライブラリへの依存関係を削減し、軽量化した。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/11044&#34; target=&#34;_blank&#34;&gt;#11044&lt;/a&gt; &lt;code&gt;boost::rv&lt;/code&gt;が&lt;code&gt;union&lt;/code&gt;から継承するケースがあったので修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#multi-index&#34; name=&#34;multi-index&#34;&gt;Multi-index&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;検索で&lt;code&gt;key_type&lt;/code&gt;の一時オブジェクトが作られる状況を効率化した。以下のようなケースだ：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; multi_index_container&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string,
    indexed_by&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;
      ordered_unique&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;identity&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;multi_t&lt;/span&gt;;
  ...
  &lt;span style=&#34;color: #B00040&#34;&gt;multi_t&lt;/span&gt; m&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;...;
  m.find(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;boost&#34;&lt;/span&gt;); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// std::stringではなくconst char*として渡される&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これまでのバージョンでは、&lt;code&gt;find&lt;/code&gt;操作では&lt;code&gt;std::string&lt;/code&gt;型の一時オブジェクトがいくつか作られていた。十分に高度なコンパイラでは、一時オブジェクトはひとつだけ作られるようになった。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;メンテナンス上の修正を行った&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#multiprecision&#34; name=&#34;multiprecision&#34;&gt;Multiprecision&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10993&#34; target=&#34;_blank&#34;&gt;#10993&lt;/a&gt; &lt;code&gt;frexp()&lt;/code&gt;関数は、Expression templateを常に使わないようにした&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10924&#34; target=&#34;_blank&#34;&gt;#10924&lt;/a&gt; Cygwinやその他のプラットフォームでの&lt;code&gt;cpp_dec_float&lt;/code&gt;のサポートを改善した。&lt;code&gt;long double&lt;/code&gt;のサポートが欠如していた。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10990&#34; target=&#34;_blank&#34;&gt;#10990&lt;/a&gt; &lt;code&gt;noexcept&lt;/code&gt;のサポートを改善し、さらなるテストを追加した。&lt;/li&gt;
&lt;li&gt;Intel 15.0とSolaris 12.4向けの、様々なワークアラウンドを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#optional&#34; name=&#34;optional&#34;&gt;Optional&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ドキュメントの改善および、IO操作とヘッダファイルについての記載&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::none_t&lt;/code&gt;は即値の&lt;code&gt;0&lt;/code&gt;から変換できなくなった。これは&lt;code&gt;optional&amp;lt;rational&amp;lt;int&amp;gt;&amp;gt; oi = 0&lt;/code&gt;の様な例で値を格納していないoptionalのオブジェクトが生成されるのを防ぐためである&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_OPTIONAL_CONFIG_NO_RVALUE_REFERENCES&lt;/code&gt;を定義することでムーヴセマンティックスを無効化できるようにした。これは&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10399&#34; target=&#34;_blank&#34;&gt;ticket 10399&lt;/a&gt;のためのワークアラウンドである&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10825&#34; target=&#34;_blank&#34;&gt;ticket 10825&lt;/a&gt; &lt;code&gt;optional_io.hpp&lt;/code&gt;のインクルードを忘れていた際に、&lt;code&gt;optional&lt;/code&gt;をストリームに渡すとリンクタイムエラーとなっていたのをコンパイルエラーとするように改良&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11087&#34; target=&#34;_blank&#34;&gt;ticket 11087&lt;/a&gt; &lt;code&gt;U&lt;/code&gt;が&lt;code&gt;T&lt;/code&gt;に代入若しくは変換できない場合に&lt;code&gt;optional&amp;lt;U&amp;gt;&lt;/code&gt;を&lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;に代入できてしまっていたのを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10839&#34; target=&#34;_blank&#34;&gt;ticket 10839&lt;/a&gt; &lt;code&gt;optional&amp;lt;T&amp;amp;&amp;gt;&lt;/code&gt;の値をmoveできなかった問題を修正&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#phoenix&#34; name=&#34;phoenix&#34;&gt;Phoenix&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;バージョン3.2.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;オプショナルな拡張として、遅延リストを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;新たなコード例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::bind()&lt;/code&gt;と&lt;code&gt;boost::phoenix::bind()&lt;/code&gt;の互換性を示すためのコード例&lt;code&gt;bind_goose&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10927&#34; target=&#34;_blank&#34;&gt;#10927&lt;/a&gt; &lt;code&gt;phoenix/test/stdlib/cmath.cpp&lt;/code&gt;での&lt;code&gt;fabs()&lt;/code&gt;関数の呼び出しに、&lt;code&gt;std::&lt;/code&gt;修飾が抜けていた&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11085&#34; target=&#34;_blank&#34;&gt;#11085&lt;/a&gt; &lt;code&gt;phoenix/test/function/function_tests.cpp&lt;/code&gt;での&lt;code&gt;pow()&lt;/code&gt;関数の呼び出しに、&lt;code&gt;std::&lt;/code&gt;修飾が抜けていた&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bind&lt;/code&gt;と&lt;code&gt;lambda&lt;/code&gt;と&lt;code&gt;let&lt;/code&gt;の、いくつかのテストケースが失敗していたので修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#predef&#34; name=&#34;predef&#34;&gt;Predef&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;バージョン1.2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio 2015のバージョン番号が間違っていたので修正&lt;/li&gt;
&lt;li&gt;Haiku OSを判定するためのマクロ名が&lt;code&gt;BOOST_OS_BEOS&lt;/code&gt;になっていたので、&lt;code&gt;BOOST_OS_HAIKU&lt;/code&gt;に修正。&lt;/li&gt;
&lt;li&gt;Android OSでのエンディアン判定が間違っていたので修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predef_check&lt;/code&gt;プログラムと、ビルド構成チェックのためのBBv2インテグレーションを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#random&#34; name=&#34;random&#34;&gt;Random&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E9%9D%9E%E5%BF%83%E3%82%AB%E3%82%A4%E4%BA%8C%E4%B9%97%E5%88%86%E5%B8%83&#34; target=&#34;_blank&#34;&gt;非心カイ二乗分布&lt;/a&gt;である&lt;code&gt;non_central_chi_squared_distribution&lt;/code&gt;クラスを追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#thread&#34; name=&#34;thread&#34;&gt;Thread&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;バージョン4.5.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;実験的な新機能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/9600&#34; target=&#34;_blank&#34;&gt;#9600&lt;/a&gt; Async: &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4088.pdf&#34; target=&#34;_blank&#34;&gt;n4088&lt;/a&gt;ベースの&lt;code&gt;task_region&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10611&#34; target=&#34;_blank&#34;&gt;#10611&lt;/a&gt; emplace版の&lt;code&gt;promise::set_value&lt;/code&gt;と&lt;code&gt;emplace make_ready_future&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10826&#34; target=&#34;_blank&#34;&gt;#10826&lt;/a&gt; スケジューラによるExecutorを追加&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11048&#34; target=&#34;_blank&#34;&gt;#11048&lt;/a&gt; 継続ベースの&lt;code&gt;serial_executor&lt;/code&gt;を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/6787&#34; target=&#34;_blank&#34;&gt;#6787&lt;/a&gt; システム時刻が巻き戻った時に&lt;code&gt;boost::thread::sleep()&lt;/code&gt;がハングしていたのを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10734&#34; target=&#34;_blank&#34;&gt;#10734&lt;/a&gt; &lt;code&gt;submit&lt;/code&gt;関数が異なるExecutorで異なる挙動をしていたのを修正。方や例外を投げ、方やエラーを握りつぶしていた(thread_executorとinline_executor)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10736&#34; target=&#34;_blank&#34;&gt;#10736&lt;/a&gt; タスクが投げた例外を握りつぶしていた。一貫性の為に&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3785.pdf&#34; target=&#34;_blank&#34;&gt;N3785&lt;/a&gt;で提案された様に&lt;code&gt;std::terminate&lt;/code&gt;を呼ぶ&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10737&#34; target=&#34;_blank&#34;&gt;#10737&lt;/a&gt; &lt;code&gt;serial_executor&lt;/code&gt;において、タスクが例外を投げた場合に永遠に待ち続けるのを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10822&#34; target=&#34;_blank&#34;&gt;#10822&lt;/a&gt; AndroidでBoost.Threadがコンパイル出来なかったのを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10824&#34; target=&#34;_blank&#34;&gt;#10824&lt;/a&gt; 1.57において、Windows XP SP2以前との互換性に問題があったのを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10963&#34; target=&#34;_blank&#34;&gt;#10963&lt;/a&gt; &lt;code&gt;future&amp;lt;future&amp;lt;T&amp;gt;&amp;gt;::then&lt;/code&gt;を実装した&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10964&#34; target=&#34;_blank&#34;&gt;#10964&lt;/a&gt; &lt;code&gt;future&amp;lt;future&amp;lt;T&amp;gt;&amp;gt;::unwrap().then()&lt;/code&gt;のデッドロックを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10968&#34; target=&#34;_blank&#34;&gt;#10968&lt;/a&gt; &lt;code&gt;async()&lt;/code&gt;が返す&lt;code&gt;future&lt;/code&gt;への&lt;code&gt;future::then()&lt;/code&gt;はブロックしなくなった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10971&#34; target=&#34;_blank&#34;&gt;#10971&lt;/a&gt; &lt;code&gt;shared_future::get()&lt;/code&gt;と&lt;code&gt;shared_future::get_or()&lt;/code&gt;はconst修飾された&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10972&#34; target=&#34;_blank&#34;&gt;#10972&lt;/a&gt; &lt;code&gt;shared_future::then()&lt;/code&gt;を複数回呼んでも問題なくなった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10979&#34; target=&#34;_blank&#34;&gt;#10979&lt;/a&gt; &lt;code&gt;make_ready_future&lt;/code&gt;に渡された&lt;code&gt;reference_wrapper&amp;lt;T&amp;gt;&lt;/code&gt;を&lt;code&gt;T&amp;amp;&lt;/code&gt;に推論するようになった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/10996&#34; target=&#34;_blank&#34;&gt;#10996&lt;/a&gt; Windowsで&lt;code&gt;thread::physical_concurrency()&lt;/code&gt;が失敗していたのを修正&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11035&#34; target=&#34;_blank&#34;&gt;#11035&lt;/a&gt; Androidで&lt;code&gt;BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE&lt;/code&gt;が定義されていなかった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/11053&#34; target=&#34;_blank&#34;&gt;#11053&lt;/a&gt; &lt;code&gt;run_thread_exit_callbacks&lt;/code&gt;で純粋仮想関数の呼び出しが行われていたのを修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#type_erasure&#34; name=&#34;type_erasure&#34;&gt;TypeErasure&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MSVC12でのコンパイルエラーを修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#type_index&#34; name=&#34;type_index&#34;&gt;TypeIndex&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;プラットフォームがサポートしている場合、リンク時のアサーションを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#units&#34; name=&#34;units&#34;&gt;Units&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;任意の次元における基底単位を修正(&lt;a href=&#34;https://github.com/boostorg/units/commit/423adb31c1eb9687d21a8af5506830a0de53a464&#34; target=&#34;_blank&#34;&gt;commit 423adb&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#unordered&#34; name=&#34;unordered&#34;&gt;Unordered&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;状態を持ったアロケータを使った際のmove代入演算子の修正 (&lt;code&gt;propagate_on_container_move_assign&lt;/code&gt;) (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10777&#34; target=&#34;_blank&#34;&gt;#10777&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;バケットの数を計算する際にオーバーフローする可能性があったのを修正 &lt;a href=&#34;https://github.com/boostorg/unordered/pull/4&#34; target=&#34;_blank&#34;&gt;pull request 4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;その他の変更については&lt;a href=&#34;http://www.boost.org/doc/libs/master/doc/html/unordered/changes.html&#34; target=&#34;_blank&#34;&gt;changelog&lt;/a&gt;を参照のこと&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_58_0.html#variant&#34; name=&#34;variant&#34;&gt;Variant&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&#34;color:red&#34;&gt;&lt;strong&gt;破壊的変更&lt;/strong&gt;&lt;/span&gt;: 取得関数(&lt;code&gt;boost::get&amp;lt;U&amp;gt;(VariantT)&lt;/code&gt;及び&lt;code&gt;boost::polymorphic_get&amp;lt;U&amp;gt;(VariantT)&lt;/code&gt;)について、コンパイル時に検査を行う様に変更。新しい取得関数は&lt;code&gt;U&lt;/code&gt;が&lt;code&gt;VariantT&lt;/code&gt;に格納でき無い場合コンパイルエラーとなる。&lt;code&gt;BOOST_VARIANT_USE_RELAXED_GET_BY_DEFAULT&lt;/code&gt;を定義することでデフォルトの挙動を戻すことが出来る。&lt;code&gt;get.hpp&lt;/code&gt;、&lt;code&gt;polymorphic_get.hpp&lt;/code&gt;及び&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/547&#34; target=&#34;_blank&#34;&gt;#547&lt;/a&gt;を参照のこと&lt;/li&gt;
&lt;li&gt;不足していた比較関数を追加 &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8620&#34; target=&#34;_blank&#34;&gt;#8620&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10811&#34; target=&#34;_blank&#34;&gt;#10811&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ドキュメントの修正 &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10273&#34; target=&#34;_blank&#34;&gt;#10273&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10653&#34; target=&#34;_blank&#34;&gt;#10653&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clangで可変長テンプレートを有効に &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/10832&#34; target=&#34;_blank&#34;&gt;#10832&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;VisitorにてC++14の自動的な戻り値の型推論をできるようにした。これにより&lt;code&gt;boost::apply_visitor&lt;/code&gt;でgeneric lambdasを使用することができるようになる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;auto&lt;/span&gt; str &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;apply_visitor(
      [](&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;auto&lt;/span&gt; v) {
          &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lexical_cast&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;(v);
      },
      variant_instance
  );
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要なテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang: 3.4&lt;/li&gt;
&lt;li&gt;Clang, C++14: 3.5, 3.6&lt;/li&gt;
&lt;li&gt;GCC: 4.4.7, 4.9.2&lt;/li&gt;
&lt;li&gt;GCC, C++98: 4.8.1, 4.8.2&lt;/li&gt;
&lt;li&gt;GCC, C++11: 4.4.7, 4.8.4, 4.9.2&lt;/li&gt;
&lt;li&gt;GCC, C++14: 4.9.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw: 4.4.7, 4.5.4, 4.6.3, 4.7.3, 4.8.2&lt;/li&gt;
&lt;li&gt;Visual C++: 8.0, 9.0, 10.0, 11.0, 12.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC: 4.2.1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC: 4.4.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;追加して含まれるテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang: 3.0, 3.1, 3.2, 3.3, 3.4&lt;/li&gt;
&lt;li&gt;Clang, C++14: 3.5, 3.6&lt;/li&gt;
&lt;li&gt;GCC: 4.4.7, 4.6.4, 4.7.3, 4.8.1, 4.9.2, 5.0.0 (experimental)&lt;/li&gt;
&lt;li&gt;GCC, C++11: 4.4.7, 4.8.4, 4.9.2&lt;/li&gt;
&lt;li&gt;GCC, C++14: 4.9.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw: 4.4.7, 4.5.4, 4.6.4, 4.7.3&lt;/li&gt;
&lt;li&gt;Visual C++: 8.0, 9.0, 10.0, 11.0, 12.0, 14.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Android&lt;ul&gt;
&lt;li&gt;Clang: 3.4, 3.5&lt;/li&gt;
&lt;li&gt;GCC: 4.8, 4.9&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FreeBSD:&lt;ul&gt;
&lt;li&gt;GCC: 4.2.1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;QNX:&lt;ul&gt;
&lt;li&gt;QCC: 4.4.2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Flast&#34; target=&#34;_blank&#34;&gt;Kohei Takahashi&lt;/a&gt;, &lt;a href=&#34;https://github.com/faithandbrave&#34; target=&#34;_blank&#34;&gt;Akira Takahashi&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Kohei Takahashi</name>
        <email>flast@flast.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>BoostCon 2010 -- boostcon/2010 表示崩れを修正</title>
      <link href="http://boostjp.github.io/boostcon/2010.html"/>
      <id>7cd239e3d786bca2e82b0b6ee9600c1db7739772:boostcon/2010.md</id>
      <updated>2015-04-30 13:36:53 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;BoostCon 2010&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/&#34; target=&#34;_blank&#34;&gt;2010 Program - boostcon&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/2010_presentations&#34; target=&#34;_blank&#34;&gt;BoostCon 2010 Presentations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#clang-lib&#34;&gt;Clang: オープンソースのC++コンパイラライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#generic-programming-graph-lib&#34;&gt;ジェネリックプログラミングとBoost Graph Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#geometry&#34;&gt;幾何学のためのジェネリックプログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#instantiations-must-go&#34;&gt;Instantiations Must Go!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-update&#34;&gt;C++0x update&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#exception-safety&#34;&gt;C++での例外使用に関するガイドラインの再考 - 例外安全なコードを効果的に設計するための10の助言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-rad-framework&#34;&gt;RAD Spiritのためのフレームワーク&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#is-boost-broken&#34;&gt;Is Boost Broken?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#data-structure-visualizers&#34;&gt;Data Structure Visualizers in Visual Studio 2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#alabaster&#34;&gt;Boost.Alabaster: A Law Based Tester&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tool-builder&#34;&gt;C++ Tool-Builders Workshop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-concurrency&#34;&gt;C++0x Concurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#basic-lock-free&#34;&gt;Lock-freeプログラミングの基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tboost-stm&#34;&gt;TBoost.STMエンジン: コミット時無効化を使用したSoftware Transactional Memoryの効率化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-v2&#34;&gt;Using Spirit V2: Qi and Karma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#boost-test&#34;&gt;Production use of Boost.Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#asio-based-flash-xml-server&#34;&gt;An Asio Based Flash XML Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#msm-v2&#34;&gt;The Meta State Machine Library V2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#overview-of-transactional-memory&#34;&gt;Transactional Memoryの概観&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#ame-pattern-library&#34;&gt;AME Patterns Library: モデリング、認識、シーケンシャルパターンの統合のためのジェネリックライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#type-erasure&#34;&gt;Type Erasure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#dsel-design&#34;&gt;Protoによる実用的なDSELの設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#network-library-implementation&#34;&gt;柔軟なヘッダオンリーC++ネットワークライブラリ実装の手法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#mime&#34;&gt;A MIME library for Boost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#nt2&#34;&gt;The Numerical Template Toolbox : 高性能コンピューティングのための加速(Boost)されたGeneric配列ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#functional-programming&#34;&gt;C++による関数型プログラミング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#logic&#34;&gt;C++による論理型パラダイム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#qt&#34;&gt;QtとBoostによるクロスプラットフォーム開発&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-history-and-evolution&#34;&gt;Spiritの歴史と進化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#future-of-boost&#34;&gt;Future of Boost Panel ’10&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#clang-lib&#34; name=&#34;clang-lib&#34;&gt;Clang: オープンソースのC++コンパイラライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Clang: An Open-Source C++ Compiler Library&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Clangは、C言語ファミリー(C, C++, Objective-C)のための新たなオープンソースコンパイラフロントエンドである。&lt;br /&gt;
C++コンパイラとして、Clangは速く提供できる生産品質なコンパイラであり、省メモリ使用、表現力豊かな診断、標準一致に関する強い関心で、低レベル仮想マシン(Low Level Virtual Machine ： LLVM)を通じて、様々な構造のためにコード生成を最適化した。&lt;/p&gt;
&lt;p&gt;しかし、Clangはコンパイラを超えるものである。&lt;br /&gt;
再使用可能なC++コンパイラライブラリとして設計され、Clangは大きなC++開発ツールを作るためのプラットフォームである。&lt;br /&gt;
Clang内部のデータ構造は、プログラムソースコードに関する完全な構文情報(マクロを含む、正確な位置情報)とセマンティクス(解決されたオーバーロード関数呼び出し、暗黙の変換)、両方を提供する。&lt;br /&gt;
その、Boost互換で、BSDライクなオープンソースライセンスは、新たなC++言語機能とアイデアのための潜在的な実験場としてや、C++コードを完全に、正しく構文解析することに依存するあらゆるツールのための理想的なベースにもなる。&lt;/p&gt;
&lt;p&gt;このトークでは、Clangコンパイラを導入し、その豊かな内部のデータ構造がどれほど大きなユーザーエクスペリアンスを提供するか、次に、Clangに基づく開発ツールを作るためのアーキテクチャ、主要なデータ構造と、ライブラリのチュートリアルに焦点をあてる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#generic-programming-graph-lib&#34; name=&#34;generic-programming-graph-lib&#34;&gt;ジェネリックプログラミングとBoost Graph Library&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming And the Boost Graph Library&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jeremy-siek&#34; target=&#34;_blank&#34;&gt;Jeremy Siek&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;グラフのアルゴリズムとデータ構造は、インターネットパケットルーティング、分子生物学、科学的なコンピューティング、電話ネットワーク設計などの多様な領域の問題を解決するが伝統的なグラフライブラリ設計は、十分な柔軟性を提供することに失敗していた。&lt;br /&gt;
Boost Graph Library(BGL)はSTLをグラフドメインに適用し、グラフ問題を解決するための非常に柔軟で効率的なライブラリとなった。&lt;br /&gt;
しかし、BGLは使うのが難しいため、このチュートリアルではプログラミングの基本原則を学び、それらがBGLでどう適用されるのかを学んでいく。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#href&#34; name=&#34;geometry&#34;&gt;計算幾何のためのジェネリックプログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Programming for Geometry&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#barend-gehrels&#34; target=&#34;_blank&#34;&gt;Barend Gehrels&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#bruno-lalande&#34; target=&#34;_blank&#34;&gt;Bruno Lalande&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#mateusz-loskot&#34; target=&#34;_blank&#34;&gt;Mateusz Loskot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Geometryは、現代のC++ジェネリックプログラミング手法を使用して設計された。&lt;br /&gt;
タグディスパッチはいたるところで使用され、メタ関数、テンプレートメタプログラミング、Traitsおよびコンセプトチェックを組み合わせた。&lt;br /&gt;
この講義では、タグディスパッチによって通常ではとれない値をとるなどの、手法を一歩一歩説明し、どのようにそれを使用することができるか、他の技術を組み合わせることができるかを解説する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#instantiations-must-go&#34; name=&#34;instantiations-must-go&#34;&gt;Instantiations Must Go!&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#matt-calabrese&#34; target=&#34;_blank&#34;&gt;Matt Calabrese&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#zachary-laine&#34; target=&#34;_blank&#34;&gt;Zachary Laine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon 2009では、メタ関数を簡単に書くための取り組みで変なことをしていたが、あとで多くの専門家と話してそれが不可能であることがわかった。一方、彼らは時々ゾッとするようなTMPのコードをより通常の関数プログラミングのようなコードで書き、大部分のメタ関数のテンプレート定義(宣言ではない)をインスタンス化する必要性を取り除くおもしろい手法を発見した。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-update&#34; name=&#34;cpp0x-update&#34;&gt;C++0x update&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-wong&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon 2009から継続して、最新コンパイラの実装状況に関するレポートと、C++0x機能に関する最新ニュースについての詳細を伝える。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#exception-safety&#34; name=&#34;exception-safety&#34;&gt;C++での例外使用に関するガイドラインの再考 - 例外安全なコードを設計するための10の助言&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Demystifying C++ Exceptions – 10 Tips to Effectively Design Exception-Safe Code&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#ken-joyner&#34; target=&#34;_blank&#34;&gt;Ken Joyner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例外安全なコードを書くことが挑戦的であることは有名である。これは、多くの開発者に、例外の使用が避けられるべきであると結論させる。しかし、この結論に関する問題は、開発者が例外を使わずにエラー安全なコードを書くことがより簡単であると仮定しているということである。私は、この仮定が間違っていると考える。その代わりに、私は実際には、多くの開発者がエラー安全なコードを書くというわけではないと考えている。そして、例外は発生するエラーを無視することは、より挑戦的になる。(あなたのプログラムが未処理例外で終わるので処理しなければならない)&lt;/p&gt;
&lt;p&gt;エラー安全なコードを書くのは例外の使用のあるなしにかかわらず、やりがいがある。そして、エラー安全なコードを書かないのは予測できない、不安定なコードをもたらす。&lt;/p&gt;
&lt;p&gt;この論文は、(いくつかの修正をした)例外安全性のレベルを再文書化した例外安全推奨を提供する。これは、会社や開発者が必要とする、安全性のレベルを達成するために従うべき実質的なガイドラインの包括的なマニュアルとなる。特定の推奨とともに例外を使用することで、エラー安全なコードを書くことを、例外を使用することへの付加的な利益を加えるとともに、挑戦的なことをしないで済むアシスタントライブラリを提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-rad-framework&#34; name=&#34;spirit-rad-framework&#34;&gt;RAD Spiritのためのフレームワーク&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Framework for RAD Spirit&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-de-guzman&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#hartmut-kaiser&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;従来のパーサージェネレータと比較したBoost Spiritパーサーの魅力は、それがC++に埋め込まれることである。ライブラリのユーザーは、C++コードにおいてExpression Templateを使ってパーサー文法を直接指定する。このアプローチには利点もあるが、同時に問題もある。&lt;/p&gt;
&lt;p&gt;最も目に付く問題点は、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コンパイル時間が長い&lt;/li&gt;
&lt;li&gt;エラーメッセージを理解するのが難しい&lt;/li&gt;
&lt;li&gt;パーサーのデバッグとテストが難しい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という点である。&lt;/p&gt;
&lt;p&gt;小さな構文解析については、これらは許容できる。しかし、アクティブな開発の8年後、より複雑な構文解析の中で使用されるポイントに来た。2と3はどうにか、Protoを使用することで軽減できる。しかしそれは、ライブラリがもはや役に立たない点にコンパイル時間を増大させる。&lt;/p&gt;
&lt;p&gt;EBNF/PEG式を受け入れて、すぐに実行可能であるパーサーかC++ Boost Spiritコードを出力するツールを持つことはおもしろい。RADツールは、パーサーを記述することをできるだけ容易にする。&lt;/p&gt;
&lt;p&gt;私たちは、そのようなツールの設計と開発を示したい。明らかに、この「動的なSpirit」ツールは「静止なSpirit」を使用して書かれるだろう。これはSpiritを使用した、本当に実用的な例になるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#is-boost-broken&#34; name=&#34;is-boost-broken&#34;&gt;Is Boost Broken?&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#robert-ramey&#34; target=&#34;_blank&#34;&gt;Robert Ramey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostのいいところ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;形式的なレビュープロセスによるライブラリ品質と完全性の「証明」&lt;/li&gt;
&lt;li&gt;形式的なテスト、リリースプロセスの実施による信頼できる実装の「証明」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostは拡張性が高くない&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;テスト時間が長く、より長くなる・・・&lt;/li&gt;
&lt;li&gt;有名でないコンパイラをテストすることは難しい&lt;/li&gt;
&lt;li&gt;現在のテストはコンパイラ設定(RTTIのON/OFF、デバッグ/リリース、STLライブラリなど)のすべての可能な組み合わせを扱うことができるというわけではない&lt;/li&gt;
&lt;li&gt;より多くのライブラリが追加されるとき、インストールが面倒で、壊れやすくなる&lt;/li&gt;
&lt;li&gt;したがって、新規ユーザーがひとつのライブラリだけを使い始める場合でも、　Boostを使うための「コスト」と「オーバーヘッド」は時間とともに増加する。しかし、ひとつのライブラリをテスト／使用するための方法がない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostのアイデンティティの危機&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コアユーティリティの唯一のライブラリ？&lt;ul&gt;
&lt;li&gt;i) ツールがテスト、リリース、配置を行う&lt;/li&gt;
&lt;li&gt;ii) ライブラリのサブセットのテスト、リリース、配置が必要であると考えられる&lt;/li&gt;
&lt;li&gt;iii) 全てのライブラリのためのひとつのバージョンを振る&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;あるいは、独立、分離されたライブラリのグループ(現在大きい)？&lt;ul&gt;
&lt;li&gt;i) 多く、あるいはほとんどのライブラリが他のBoostライブラリのサブセットにだけ依存する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私の議論は、Boostが前者として始まり、後者へ向かって進化していきそうだということである。&lt;br /&gt;
Boostにとってすばらしい10年だったが、成功し続けるためには進化しなければならないだろう。&lt;br /&gt;
この発表では、私が、Boostがどのように変わらなければならないと思うかを説明する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#data-structure-visualizers&#34; name=&#34;data-structure-visualizers&#34;&gt;Data Structure Visualizers in Visual Studio 2010&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#stephan-t-lavavej&#34; target=&#34;_blank&#34;&gt;Stephan T. Lavavej&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多くのSTLクラスが説明を複雑にした。デバッグをより簡単にするために、Visual Studio 2005と2008は、人間が読めるようにSTLオブジェクトを表示する「Visualizer」を持っていた。誰でも、Boostクラスのような他の型のためのVisualizerを書くことができる。これはアンドキュメントで、サポートもされないが、非常に有用になりえる。&lt;/p&gt;
&lt;p&gt;この発表は、&lt;code&gt;shared_ptr&lt;/code&gt;、&lt;code&gt;function&lt;/code&gt;および&lt;code&gt;map&lt;/code&gt;の表示を改善するためにVisualizerを書く方法について説明し、Visual Studio 2010の新しい特徴を利用する方法を紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#alabaster&#34; name=&#34;alabaster&#34;&gt;Boost.Alabaster: A Law Based Tester&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joachim-faulhaber&#34; target=&#34;_blank&#34;&gt;Joachim Faulhaber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これは、形式的に規定された法則あるいは公理に基づいて自動テストを提供する、Boostライブラリのための提案である。&lt;br /&gt;
テストシステムは3部から成る。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;法則のインスタンス化変数を表わす型の並び上のクラステンプレートとして公理または法則を表現することを可能にする法則概念。&lt;/li&gt;
&lt;li&gt;与えられた法則と与えられた型の並び用の法則インスタンス化を任意に生成する、法則インスタンス用のジェネレーター。&lt;/li&gt;
&lt;li&gt;法則違反を選択し、単純性順序によってそれらを格納するフィルタ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost Interval Containerライブラリの開発のために、Boost.Alabasterのプロトタイプは法則に基づいた開発(law based development)に使用された。手法とツールとしての法則に基づいたテスト(law based testing)は、多くの面で有益であることが判明した:&lt;/p&gt;
&lt;p&gt;形式仕様の探究はより深く根付いた設計決定を生じさせ、より耐久性のある設計に結びつく。進化のプロセスでは、一般的なソフトウェアに関してあなたが即座に作った公理で開発を始められなかったとしても、ソフトウェア開発(法則のテスト)では前部(仕様)が抽象化と抽象推論を引っ張り出す。法則に基づいた開発プロセスは、ソフトウェアだけでなくそのソフトウェアに関して保証することができる形式上のプロパティももたらす。それらのプロパティの検証はいつでも繰り返す(replicate)ことができる。テストは、退屈で愛されなかった義務から抽象と設計の品質を促進する非常にクリエイティブなプロセスへと変形される。法則に基づいたテストは、従来の単体テストが提示することができる利点をすべて持ち、それを超える方法である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tool-builder&#34; name=&#34;tool-builder&#34;&gt;C++ Tool-Builders Workshop&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： ワークショップ&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多くの専門家のように、プログラマは、生産性を改善する様々なツールを使用し、プロジェクト特有のニーズに焦点を当てた自分のツールを作るだろう。不運にも、C++プログラマのために、よいC++ツールの構築は、C++コードを解析する固有の複雑さによって非常に複雑になる。C++の全てを解析することができるオープンソースライブラリの不足と結び付けられたこの複雑さは、C++ツールを他の言語でそれらに相当するものより劣らせていた。Clang( &lt;a href=&#34;http://clang.llvm.org&#34; target=&#34;_blank&#34;&gt;http://clang.llvm.org&lt;/a&gt; )は、大きなC++開発ツールを構築することをより簡単にすることによりこの不均衡に焦点を当てたサポートを意図した新たなオープンソースC++コンパイラライブラリである。&lt;/p&gt;
&lt;p&gt;このハンズオンワークショップでは、出席者は、新たなC++ツールを構築するためにClangライブラリを使用する方法を学習する。私たちはまず、C++プログラムを解析および識別する面白いプログラム構築から始める。そこから私たちは、その抽象構文ツリーによって語彙の構造(トークン、マクロのインスタンス化など)から意味的な構造(クラス、関数、式、テンプレートなど)までClangがどのようにプログラムを表わすかを知るだろう。最後に、私たちは手を汚して、Clangを使用して、あるC++ツールを構築する。私たちが構築する実際のツールは出席者によって決定されるだろう。しかし、可能性は以下のものを含んでいる:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;プロジェクト絶対コーディング標準、&lt;/li&gt;
&lt;li&gt;特定のオーバーロードが選ばれた理由の説明、&lt;/li&gt;
&lt;li&gt;クラスを自動的に生成するシリアライズコード、&lt;/li&gt;
&lt;li&gt;Boostライブラリから抽出するドキュメンテーション、&lt;/li&gt;
&lt;li&gt;あるいは、対話的にテンプレートやプリプロセッサのメタプログラムをデバッグする&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;といったものを強化する。&lt;/p&gt;
&lt;p&gt;プログラム委員会は以下のことに注意する:&lt;/p&gt;
&lt;p&gt;私は、Clangに基づいた2つの異なるセッションを提案している。&lt;br /&gt;
90分の発表(「Clang: An Open-Source C++ Compiler Library」)は、Clangをコンパイラ、ライブラリおよびオープンソースプロジェクトと評するだろう:&lt;br /&gt;
これはあまり深く話せないため、実際には概要である。&lt;/p&gt;
&lt;p&gt;ワークショップは、去年のDaveによるハンズオンBoost++0xワークショップに沿った単なる実験ではない:&lt;br /&gt;
今年、私たちは、出席者にBoosterが使用するべきクールなツールを構築させることができるかどうか確かめたい。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#cpp0x-concurrency&#34; name=&#34;cpp0x-concurrency&#34;&gt;C++0x Concurrency&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-wong&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この話では、私はBoostCon 09でのC++0x並列性の議論に引き続いて話していくつもりである。&lt;br /&gt;
とくに、C++のメモリモデル、新たなC++0xライブラリを通じて並列性がどのように扱われるか、スレッド管理、スレッド間のデータ共有、同期並列操作に関して話す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#basic-lock-free&#34; name=&#34;basic-lock-free&#34;&gt;Lock-freeプログラミングの基礎&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Basics of Lock-free Programming&lt;/li&gt;
&lt;li&gt;スピーカー ： Tony Van Eerd&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基礎から始め、共有データにアクセスするという問題を示し、ゆっくり問題を露出させていき、問題へのLock-freeによる解決策を示す。この話は以下を含む：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始性についての説明&lt;/li&gt;
&lt;li&gt;CAS命令とCASループについての説明&lt;/li&gt;
&lt;li&gt;Double-Checked-Locking Pattern(DCLP)の危険性とそれを避ける方法(メモリバリア)の説明&lt;/li&gt;
&lt;li&gt;read-request queueとwrite-request queueのアイデアに基づき、どのように複数のCPUが働くか理解できるモデルを提示しメモリバリアを説明する&lt;/li&gt;
&lt;li&gt;Lock free stackを提示する&lt;/li&gt;
&lt;li&gt;ABAと、それを回避する方法についての説明&lt;/li&gt;
&lt;li&gt;Lock-freeプログラミング(楽観的なrelaxed memory operation)におけるいくつかの最前線開発に触れる&lt;/li&gt;
&lt;li&gt;BoostとC++0xがどのようにLock-freeプログラミングに影響するかについて触れる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#tboost-stm&#34; name=&#34;tboost-stm&#34;&gt;TBoost.STMエンジン:コミット時無効化を使用したSoftware Transactional Memoryの効率化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Reducing the Integration Complexity of Software Transactional Memory with TBoost.STM&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#vicente-j-botet-escriba&#34; target=&#34;_blank&#34;&gt;Vicente J. Botet Escriba&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#justin-gottschlich&#34; target=&#34;_blank&#34;&gt;Justin Gottschlich&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dwight-y-winkler&#34; target=&#34;_blank&#34;&gt;Dwight Y. Winkler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ここでは、具体的なTBoost.STMの内部エンジンの現状、トランザクションコンフリクトの検出、トランザクションがコミットできるかどうかを決定するプロセスを調査する。多くのtransactional memory(TM)は矛盾検知の最適化に専念するが、ほぼ全てのTMがトランザクションのコミット段階で同じ矛盾検知戦略を行う。つまり、彼らはコミット時に検証を行うのである。そこでは、トランザクションが、以前にコミットされたトランザクションによってコンフリクトチェックされる。コミット時検証(commit-time validation)が限られた競合を示す作業量に対して効率的な間、それは競合した作業量のために並列性をきびしく制限できる。&lt;/p&gt;
&lt;p&gt;ここでは、TBoost.STMがこのモデルからどう逸れるかを説明し、コミット時無効化(commit-time invalidation)を使用することでコミットする前に飛行中(コミットされていない)トランザクションがそれらのコンフリクトを全て解決する戦略について話す。コミット時無効化は競合マネージャ(CM:contention manager)にコミット時検証を通じて利用不可能なデータを供給し、CMが決定にBoost Concurrencyを作ることを可能にする。コミット時無効化はまた、メモリ集約的なトランザクションのためにコミット時検証より著しく少ない操作を必要とし、動的に検出されたread-onlyトランザクションのための操作と保証、どんなトランザクションでもO(N)時間で完全な不透明性を保証する(インクリメンタルな検証のO(N^2)より速い)。作業量競合の実験結果は、私たちの効率的なコミット時無効化されたSTMは、TL2(最高水準のSTM)より3倍速かった。&lt;/p&gt;
&lt;p&gt;しかし、コミット時無効化だけでは不十分である。プログラマはそれらがこの競合検出戦略の利点を完全に利用するために実行している作業量のための効率的な競合マネージャに書く方法を知らなければならない。私たちは、プログラマがどのように自身の競合マネージャに書くか、そして正しい競合マネージャが実行される作業量に基づくTBoost.STMの性能を根本的にどうしたら向上させることができるかを調査する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-v2&#34; name=&#34;spirit-v2&#34;&gt;Using Spirit V2: Qi and Karma&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-caisse&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;機械、センサー、機材、クライアント/サーバーコミュニケーション、ファイル形式でさえ...コミュニケーションストリームの解析と生成はどこでも見るだろう。多くの場合、これらのタスクはその場限りの解決策を勧めるのに十分に単純であるか、あるいは小さい。Spirit 2.1ライブラリは、それらの「quick hacks」に取り組むのに十分に単純で、AST生成のために容易に拡張できる十分な機能のモデルを提供する。&lt;/p&gt;
&lt;p&gt;このセッションは、Spiritライブラリのパーサーとジェネレーター(Qi/Karma)による現実の経験を調査する。様々な製品の中で使用された、様々な小型/中型のパーサー/ジェネレーターを見るとともに、私たちは「rules-of-thumb」、およびQi/Karmaを持ったパーサー/ジェネレータードメインに取り組むためのガイドラインを確立するだろう。このセッションは、使用可能なXMLパーサーと、単純化されたXPathのようなノード抽出器の実装で終える。&lt;/p&gt;
&lt;p&gt;このセッションは、いくつかのレクチャーと、多くのチュートリアルを含む。&lt;br /&gt;
出席者は、知識と、Spirit Qi/Karmaで解析し生成することを始めるツールを持ち帰るだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#boost-test&#34; name=&#34;boost-test&#34;&gt;Production use of Boost.Test&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#gennadiy-rozental&#34; target=&#34;_blank&#34;&gt;Gennadiy Rozental&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このセッションでは、プロダクションコンポーネントにおいてのBoost.Testの様々な使用法のシナリオをカバーする。&lt;br /&gt;
とくに、以下の主題をカバーする：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関数実行を保護する&lt;code&gt;execution_monitor&lt;/code&gt;の使用法。&lt;/li&gt;
&lt;li&gt;高水準なプログラム実行保護のための&lt;code&gt;program_execution_monitor&lt;/code&gt;の使用法。様々な配置オプション。&lt;ul&gt;
&lt;li&gt;(New) 浮動小数点例外の取り扱い。&lt;/li&gt;
&lt;li&gt;(New) コールバックでの罠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(New) 生産コンポーネントにおけるBoostテストツールの使用法。&lt;/li&gt;
&lt;li&gt;単体テストにおいて：実装自体の内部を構築コンポーネントユニットテストする2つのアプローチ：&lt;ul&gt;
&lt;li&gt;a) コンパイル時のスイッチを使用する&lt;/li&gt;
&lt;li&gt;b) コンソールテスト実行と、共有ライブラリとして組み込まれた実装を使用する&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#asio-based-flash-xml-server&#34; name=&#34;asio-based-flash-xml-server&#34;&gt;An Asio Based Flash XML Server&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#michael-caisse&#34; target=&#34;_blank&#34;&gt;Michael Caisse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reactiveシステムはいたるところで見つけられる。多くの待ちスレッドでそれらを実装する誘惑は強くなりえる。しかし、結果はほとんどいつも期待はずれである。&lt;/p&gt;
&lt;p&gt;Boost.Asioライブラリは、特定のクラスがネットワーク、シリアルポートI/O、タイマー、およびその他に向けられている状態で非同期なリソースを扱うためのフレームワークを提供する。このセッションでは、様々なシリアル入出力ハードウェアコンポーネントから接続されたFlashディスプレイへのデータストリームを送るサーバーを構築するつもりである。以前のセッションのときに開発したQiパーサーとKarmaジェネレータは、それらの適切な目的地へとシャッフルされるASTを作成するのに使われるだろう。&lt;/p&gt;
&lt;p&gt;この講演/チュートリアルは、Flash XML Socketからサーバーを組み合わせてデータストリーミングし、要求を受け取ることができるようにAsio、Spirit、Fusion、Phoenix、Smart_ptr、Thread、FunctionとBindを含むライブラリを使用するだろう。&lt;br /&gt;
出席者は、彼ら自身のAsioベースサーバーを作成するために、Asioモデルと様々な実装パターンを理解することになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#msm-v2&#34; name=&#34;msm-v2&#34;&gt;The Meta State Machine Library V2&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#christophe-henry&#34; target=&#34;_blank&#34;&gt;Christophe Henry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BoostCon09でのMSM v1に関する私のアーティクルは、MDD(モデル駆動開発)アプローチと呼ばれるMDA(モデル駆動アーキテクチャ)を促進するというゴールをもつライブラリの主な特徴を示した。具体的に、その話はMSMの記述的に表現する性質を主張した。この論文は初めに、メインサポートされたUML機能を要約し、MSM v2によって提供される新たなフロントエンドでのそれらの使用法を示すだろう。第2部では、MDDコンテキストにおいて使用可能なより多くの能力の提供により、いまMSMがどのようにMDD法をより先に進めさせたかを知ることになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#overview-of-transactional-memory&#34; name=&#34;overview-of-transactional-memory&#34;&gt;Transactional Memoryの概観&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Overview of Transactional Memory Day&lt;/li&gt;
&lt;li&gt;スピーカー ： Tatiana Shpeisman&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Transactional Memory(TM)は並列プログラミングを単純化し、制限のない実行モデルをサポートする現代の並列制御パラダイムである。この終日セッションは、それらの最近のTM研究開発について議論するために業界と学会のエキスパートを集める。Boost、IBM、Intel、Microsoft、およびSun Microsystemsから招待された講演者は、最新作の概要を提供してくれるだろう。セッションは彼らがTMの短期的、あるいは長期的な挑戦についての考えを示すところでパネルディスカッションを締めくくる。最後に、聴衆からの質問に答える。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#ame-pattern-library&#34; name=&#34;ame-pattern-library&#34;&gt;AME Patterns Library: モデリング、認識、シーケンシャルパターンの統合のためのジェネリックライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AME Patterns Library: a generic library for modeling, recognition, and synthesis of sequential patterns&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#stjepan-rajko&#34; target=&#34;_blank&#34;&gt;Stjepan Rajko&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このチュートリアルは、モデリング、認識、シーケンシャルパターンの統合のためのオープンソースのジェネリックC++ライブラリであるAMEパターンライブラリについて発表する。&lt;/p&gt;
&lt;p&gt;このライブラリは、ジェスチャーや音声認識などのアプリケーション、およびそのようなパターンの統合に役立つ。また、隠れマルコフモデル(Hidden Markov Model)などのモデルのための汎用ライブラリとして使用することができる。コンセプトベースのジェネリックプログラミングの使用は、ライブラリに大きな柔軟性を与える。パターン解析が多くのドメインにまたがるので、それは役立つだろう。&lt;/p&gt;
&lt;p&gt;また、このライブラリはさらに、プログラミングの計算量、柔軟性、汎用性、およびコンパイルタイムの異なるトレードオフを提供する、いくつかのAPIレベルを提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#type-erasure&#34; name=&#34;type-erasure&#34;&gt;Type Erasure&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#nevin-liber&#34; target=&#34;_blank&#34;&gt;Nevin Liber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ Template Metaprogrammingで見つかった定義から始め、Type Erasureとは何かと、それがどのような利点とコストがあるかについて話す。継承ベースのインタフェースから、それをType Erasureで変換する例から始める。Boost.AnyとBoost.Functionの簡易実装をカバーする予定だ。&lt;/p&gt;
&lt;p&gt;regular型とクラスの概念について触れる。( &lt;a href=&#34;http://stlab.adobe.com/wiki/index.php/Image:2008_06_26_classes_that_work.pdf&#34; target=&#34;_blank&#34;&gt;http://stlab.adobe.com/wiki/index.php/Image:2008_06_26_classes_that_work.pdf&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;それと共に、Copyable/Assignable型のコンテナを使用することでBoost.shared_ptrとBoost.Pointer Containerを比較する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#dsel-design&#34; name=&#34;dsel-design&#34;&gt;Protoによる実用的なDSELの設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Practical DSEL Design with Proto&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#eric-niebler&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この発表は、Boost.Protoで有用なDSELを急速に構築する方法に注目する。&lt;/p&gt;
&lt;p&gt;このセッションは、数個の現実世界のDSELの設計と実装に踏み出すだろう。簡単な例(例えば、Boost.Assignのmake_list_of())から始めて、中級(例えば、Howard Hinnantのfutureグループ)、最後に、単純化されたPhoenixライブラリの設計について解説する。現実世界のライブラリ設計問題への解決策に重点を置く。特定の現実世界の問題を通じて、ProtoによってC++でそれを実装する価値があるように、一般的なDSELの価値が明白になるだろう。また、コンパイル時間とテンプレートのエラーメッセージについて議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#network-library-implementation&#34; name=&#34;network-library-implementation&#34;&gt;柔軟なヘッダオンリーC++ネットワークライブラリ実装の手法&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Techniques in Flexible Header-Only C++ Network Library Implementations&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dean-michael-berris&#34; target=&#34;_blank&#34;&gt;Dean Michael Berris&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この論文は、Boost.Asio上に単純ではあるが強力なヘッダオンリーC++ネットワークライブラリを提供するcpp-netlibプロジェクトによって使用された様々な手法に重点を置く。&lt;/p&gt;
&lt;p&gt;一般的なプログラミング法則に従うベストプラクティスから発生している一方、使用される手法のうちのいくつかは他の既存のライブラリから借りられる。この論文は、共通メッセージ型、型安全なURIパーサーおよびオブジェクト表現の非常にモジュラーで柔軟な実装を達成するために使用されるイディオムと同様にライブラリの異なる部品の構成およびセマンティクス的に一貫したHTTPクライアントを強調することを目標とする。&lt;/p&gt;
&lt;p&gt;この論文は、ライブラリの様々なモジュールの実装の全体にわたって使用される現代C++の手法に関する調査と、同様にcpp-netlibプロジェクトへの入門として役立つ。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#mime&#34; name=&#34;mime&#34;&gt;A MIME library for Boost&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#marshall-clow&#34; target=&#34;_blank&#34;&gt;Marshall Clow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： lecture&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;インターネットプロトコル中のデータをカプセル化する最も一般的な方法はMIME(Multipurpose Internet Mail Extensions:多目的インターネットメール拡張)を使用することである。このフォーマットはHTTP、emailおよび他の多くのプロトコルの中で使用される。&lt;/p&gt;
&lt;p&gt;私は、作成、解析、およびMIME構造の操作のために、Boostを包含するという視点から開始し、このライブラリを作る際の設計選択について話そう。(提案された)Boost.MIMEライブラリはDean Michael Berrisのネットワークライブラリによって使用される(だろう)。&lt;/p&gt;
&lt;p&gt;MIME処理ライブラリは、(スレッド、ネットワークI/Oおよび状態マシンを合わせた)ネットワークプロトコルを実装するために必要とされる基本ビルディングブロックのうちの1つである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#nt2&#34; name=&#34;nt2&#34;&gt;The Numerical Template Toolbox:高性能コンピューティングのための加速(Boost)されたGeneric配列ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Numerical Template Toolbox:BOOST’ed Generic Array Library for High Performance Computing&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-falcou&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jean-thierry-lapreste&#34; target=&#34;_blank&#34;&gt;Jean-Thierry Lapreste&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配列のようなデータ構造上での集中的、あるいは非自明なコンピューティングを行うことは、科学的なコンピューティング、ビデオゲーム開発、および他のフィールドで最も一般的なタスクのうちのひとつである。この事実は、そのようなタスクを行うために、ツール、言語、そしてライブラリといったかなりの数のものによってバックアップされる。私たちが自身をC++に基づいた解決策に制限する場合、1ダース以上のライブラリはテンプレートメタプログラミングに基づいたBlitz++やEigen2といったBLAS/LAPACKのC++バインディングが存在している。これらのライブラリの全てが良いパフォーマンス、または良い抽象化を提供する場合、そられのどれも非常に多くのユーザー型に適合するようには思えない。&lt;/p&gt;
&lt;p&gt;ここで私たちは、Numeric Template Toolbox(NT2)を提供する。これはテンプレートメタプログラミングで、配列に基づいた演算ライブラリで、直感的であるが拡張可能なユーザーAPIと開発者SDKを提供している間に、メモリハンドリングと自動的な並行処理のようなアーキテクチャの懸念に関して良い性能を出すためにrock-solid実装を目指す。また、全体のライブラリ設計とパフォーマンスのためにBoost.Components(MPI, Proto, Fusion, PP, Serialization, etc...)を使用しているという付加価値を強調する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#functional-programming&#34; name=&#34;functional-programming&#34;&gt;C++による関数型プログラミング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Functional Programming in C++&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#david-sankel&#34; target=&#34;_blank&#34;&gt;David Sankel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;関数型プログラミング(FP)手法は、一般的で、簡潔で、合成可能で、正確なコードを生成する。最近まで、これらの手法の多くは学究的な世界と難解プログラミング言語(esoteric programming language)の領域に制限されていた。新たなC++とboostでの開発は最終的にこれらの高度な技術にアクセス可能にする。&lt;/p&gt;
&lt;p&gt;このセッションの最初では、いま可能なFP手法のHowとWhyを調査する。私たちは代数のデータ型、ポイントフリー高階関数、純粋、ジェネリックプログラミング、型族(Type Families)、圏論および実用的な関数記号をカバーする。&lt;/p&gt;
&lt;p&gt;セッションの第2部では、FPの事例研究について話す。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1に、運動コントローラーに基づいた組み込みドメイン特化言語(EDSL)。&lt;/li&gt;
&lt;li&gt;第2に、他に類を見ないジェネリックなXMLシリアライズフレームワーク。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#logic&#34; name=&#34;logic&#34;&gt;C++による論理型パラダイム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Logic Paradigm for C++&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#roshan-naik&#34; target=&#34;_blank&#34;&gt;Roshan Naik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;論理型パラダイム(LP)は、オブジェクト指向、命令型、関数型のパラダイムと比較して、主流言語では表現をほとんど見ない、強力でチューリング完全なプログラミングパラダイムである。&lt;br /&gt;
LPは時々、プログラミングの聖杯と呼ばれるものへのコンピュータ科学の重要なアプローチである。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「ユーザーが問題を延べ、コンピュータがそれを解決する」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理論の起源は、アリストテレスが論理的な推論に厳格さをもたらすために形式論理を構築した約紀元前300年までさかのぼる。ラッセルとホワイトヘッドが数学をすべて実行することができるかもしれないことを示した時、理論は、現代の論理へ最近(1900年の初め)成熟した。&lt;/p&gt;
&lt;p&gt;この話は、Boostへ提案することを目的とする新たなオープンソースライブラリであるCastorを中心に展開する。LPをサポートするBoostの能力の拡張に加えて、これはBoostプログラマがLPと関数型のパラダイムからの機能を組み合わせて、イテレータや範囲の必要なしでストリーム、アルゴリズムおよびコンテナの統合を可能にするだろう。&lt;/p&gt;
&lt;p&gt;この話は、C++でLPの基本的な入門を提供する。そして、あなたをこのパラダイムについて考えるようにするための多くの例が続く。私たちは、既存のBoostとC++の概念で、それがどのように自然に混じるか話す。最後に、プログラマが自由にパラダイムを混合しマッチすることができる場合に強力なマルチパラダイム解決がどのように出現するか確かめるために範囲を広げる。LPのきれいで深い統合が、C++を源泉とする多くのデザインパターンがいまだ発見されていないことがこの話で明確になるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#qt&#34; name=&#34;qt&#34;&gt;QtとBoostによるクロスプラットフォーム開発&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cross-platform development with Qt and Boost&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joao-p-r-abecasis&#34; target=&#34;_blank&#34;&gt;Joao P. R. Abecasis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このワークショップの意図は、Qtライブラリの簡潔な概要と、QtとBoostを混合するための現在の現実的解決策を提供することである。&lt;/p&gt;
&lt;p&gt;とくに私は、MOCモデルとQObjectモデル(BoostとQtを混合したプロジェクトのための構造システムインテグレーション)を調べ、Boostベースのコンポーネントを小さなサンプルアプリケーションに基づくQObjectシグナル/スロット実装に融合させる様相を調査するつもりである。&lt;/p&gt;
&lt;p&gt;私は、相互運用問題と、それがどのように改善することができるかについてBoostコミュニティからフィードバックを集めたいと考えている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#spirit-history-and-evolution&#34; name=&#34;spirit-history-and-evolution&#34;&gt;Spiritの歴史と進化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Spirit: History and Evolution&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#joel-de-guzman&#34; target=&#34;_blank&#34;&gt;Joel de Guzman&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#hartmut-kaiser&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2010&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今年、私たちは、90年代初期に非常に大きいGUIライブラリから枝分かれし、2001年にBoostデビューしたSpiritの10周年を祝福する。Spiritは、控えめな7ヘッダファイルのライブラリから成長して最も洗練されたBoostライブラリのうちの一つとなり、途中からBoost.Fusion, Boost.Phoenix, Boost.Wave, Boost.Protoライブラリの培養器となった。&lt;/p&gt;
&lt;p&gt;私たちは、歴史的観点からSpirit(そして、それに刺激されたライブラリ)を紹介したい。この発表は、およそ10年間で少なくても4つのライブラリへと発展させ、演算子を虐待し、クレイジーなテンプレートメタプログラムを好む、正真正銘のマッドサイエンティストであるBoost作者の経験と観点から、起爆剤を提供することを目標とする。もちろん、あちこちでC++トリックを誇示するのであれば、私たちはそれを助けることはできないが、私たちがそれを行うのと同じくらい、できるだけ簡単にすることができる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2010.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Future of Boost Panel ’10&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#dave-abrahams&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#beman-dawes&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#jeff-garland&#34; target=&#34;_blank&#34;&gt;Jeff Garland&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/previous-years/2010-program/#douglas-gregor&#34; target=&#34;_blank&#34;&gt;Douglas Gregor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： パネル&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostには、メーリングリストの話題上で、丁寧で、役立つポストを適度に走らせる少数のモデレーターグループがある。さらに、彼らはウェブサイト、ソースリポジトリ、および他の行政機構の内部を管理する。また、大事なことを一つ言い残していましたが、モデレータは、Boostを促進するための委員会を監督する非公式の幹部の役割を務める。&lt;/p&gt;
&lt;p&gt;このセッションでは、モデレータにそれぞれBoostの将来のビジョンに関して5分ずつ話してもらう。しかし、セッションの大部分は聴衆からの質問と提案に専念するだろう。これは、Boostコミュニティの方向性に関して何でも聞けて、提案できる絶好のチャンスである。例えば、特別な政策、ツール、あるいはあなたの考えを採用する。&lt;/p&gt;
&lt;h2&gt;翻訳者&lt;/h2&gt;
&lt;p&gt;Akira Takahashi&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>BoostCon 2011 -- boostcon/2011 表示崩れを修正</title>
      <link href="http://boostjp.github.io/boostcon/2011.html"/>
      <id>b2ef65d510bb7048015de505c8507562a611a198:boostcon/2011.md</id>
      <updated>2015-04-30 13:32:41 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;BoostCon 2011&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://boostcon.boost.org/program/sessions/&#34; target=&#34;_blank&#34;&gt;http://boostcon.boost.org/program/sessions/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/2011_presentations&#34; target=&#34;_blank&#34;&gt;BoostCon 2011 Presentations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳プロジェクト&lt;/h2&gt;
&lt;p&gt;BoostCon 2011の資料を翻訳しています。&lt;/p&gt;
&lt;p&gt;翻訳したデータは各自でどこかに公開(たとえばGoogle Docs、slideshareなど)し、リンクを貼ってください。&lt;/p&gt;
&lt;p&gt;参加者は常時募集しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/eldesh/proposed-boost-btreelibraryja&#34; target=&#34;_blank&#34;&gt;The Proposed Boost B-tree Library(eldesh)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/faithandbrave/boostsimd&#34; target=&#34;_blank&#34;&gt;Practical SIMD acceleration with Boost.SIMD(akira)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#ready-fo-ipv6&#34;&gt;IPv6の準備はできてる？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#utree&#34;&gt;万能ツリーによるAST構築&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#mpi-openmp&#34;&gt;自動ハイブリッドMPI+OpenMPコード生成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-generic&#34;&gt;Boost.Generic: コンセプトを使用しないコンセプト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-infrastructure&#34;&gt;Boostインフラストラクチャ ワークショップ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-process&#34;&gt;Boost.Process：C++によるプロセス管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-units&#34;&gt;Boost.Units&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#cpp0x-status&#34;&gt;C++0xの進行状況&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-asio-extension&#34;&gt;Boost.Asio拡張の作成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#skoot&#34;&gt;Skootによる設計の旅。ピア指向ジェネリックネットワークライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#geneva&#34;&gt;Genevaライブラリによる分散パラメトリック最適化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#fast-numerical-computation&#34;&gt;C++による高速数値計算 ： 遅延コード生成(LzCG)のためのExpression Templateとその先へ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#funding-boost&#34;&gt;国内、国際的な研究プログラムや基金を通じた、Boost開発の資金調達について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#future-of-boost&#34;&gt;Boostの未来 - パネルディスカッション2011&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#range-unicode&#34;&gt;Rangeのためのジェネリックな変換と分割 : Unicodeのためのソリューション&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#proto-edsl-design&#34;&gt;Protoを楽しむ - C++ EDSLデザインのハンズオンチュートリアル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#haskell-pseudo-cpp&#34;&gt;Haskell - C++テンプレートメタプログラミングのための擬似言語&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#intel-tm&#34;&gt;IntelのC++ Software Transactional Memory CompilerとC++でのトランザクション言語構築のドラフト仕様について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#mpl-graph&#34;&gt;MPL.Graphの紹介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#lock-free-data-structure&#34;&gt;ロックフリープログラミング パート2：データ構造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#cell-broadband&#34;&gt;Boostベースの並列通信ライブラリによる、セルブロードバンドエンジンのアーキテクチャをマスターする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#odb-boost&#34;&gt;ODBとBoostによるオブジェクトリレーショナルマッピング&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#gcc-plugins&#34;&gt;GCCプラグインによるC++解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#phoenix-v3&#34;&gt;Phoenix V3の概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-simd&#34;&gt;Boost.SIMDを用いる実用的なSIMDアクセラレーション&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#real-workd-spirit-qi&#34;&gt;現実世界におけるSpirit.Qi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#sweep-line-algorithm&#34;&gt;平面上の点、線分、多角形中間軸のボロノイ図における掃引線アルゴリズム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#b-tree&#34;&gt;Boostに提案されたB木ライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#think-async&#34;&gt;非同期について考える ： Boost.Asioを使用したアプリケーション設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#thread-shared-variables&#34;&gt;C++0xのスレッドと共有変数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#xml-processing&#34;&gt;C++のマルチパラダイムデザインによるネイティブXML処理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#why-cpp0x-is-awesomest-network-programming&#34;&gt;C++0xはなぜネットワークプログラミングのための、最高の中の最高の言語なのか&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#ready-fo-ipv6&#34; name=&#34;ready-fo-ipv6&#34;&gt;IPv6の準備はできてる？&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Are You Ready for IPv6?&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#christopher-kohlhoff&#34; target=&#34;_blank&#34;&gt;Christopher Kohlhoff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/wed/IPv6.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/wed/IPv6.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/are-you-ready-for-ipv6-5364812&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/are-you-ready-for-ipv6-5364812&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それはニュースの中にあった：IPv4アドレス空間が枯渇する。&lt;br /&gt;
その解決策は新たなインターネット・プロトコル、IPv6である。IPv6は長い間存在していたが、その使用を命じた政府機関のためのコードを開発しない限り、それについて今まで心配する必要がなかった。&lt;/p&gt;
&lt;p&gt;これは一夜の変更では済まないだろう。&lt;br /&gt;
IPv4はまだ数年は使われるだろうし、ネットワークアプリケーションは両方のプロトコルをサポートしなければならないだろう。&lt;/p&gt;
&lt;p&gt;この発表は、ネットワーク開発者が知る必要のあるIPv6の基本をカバーする。&lt;/p&gt;
&lt;p&gt;Boost.AsioのIPv6のサポートを見て回り、独立したBoost.Asioベースのネットワークアプリケーションプロトコルを独立させること、およびIPv6を用意するためのいくつかの設計戦略について議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#utree&#34; name=&#34;utree&#34;&gt;万能ツリーによるAST構築&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AST Construction with the Universal Tree&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#bryce-lelbach&#34; target=&#34;_blank&#34;&gt;Bryce Lelbach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/fri/utree_talk.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/fri/utree_talk.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/ast-construction-with-the-universal-tree-5266608&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/ast-construction-with-the-universal-tree-5266608&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Spiritのコードベースに最近追加された&lt;code&gt;utree&lt;/code&gt;は、抽象構文木を表現するための設計されたジェネリックなデータ構造である。QiとKarmaへのバインディングは、Boost.Spiritによるパーサー、ジェネレータ開発の強力なツールとなる。この発表では、抽象構文木を構築、操作するための、パース／ジェネレートの4つのユースケースを示す：XML、シンボル式(S式)、JSONとCライクなソースコード。&lt;/p&gt;
&lt;p&gt;Spiritによる&lt;code&gt;utree&lt;/code&gt;の統合の詳細、および&lt;code&gt;utree&lt;/code&gt;中心のSpiritパーサー／ジェネレータの記述について議論する。さらに、他の内部表現(XMLのためのDOMツリー、JSONオブジェクトのための連想配列、小さなCソースコードのシンプルなVMバイトコード)に、utree ASTをコンパイルする設計手本をカバーする。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#mpi-openmp&#34; name=&#34;mpi-openmp&#34;&gt;自動ハイブリッドMPI+OpenMPコード生成&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Automatic Hybrid MPI+OpenMP Code Generation&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#joel-falcou&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#khaled-hamidouche&#34; target=&#34;_blank&#34;&gt;Khaled Hamidouche&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/tue/bsppp.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/tue/bsppp.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/automatic-hybrid-mpi-openmp-code-generation-5349961&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/automatic-hybrid-mpi-openmp-code-generation-5349961&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マルチプロセッサー市場の出現は、大規模並列コンピュータのアーキテクチャを根本的に変えた。何千ものスレッドによるハイパフォーマンスコンピューティングプラットフォームが展開されている。このコンテキストでは、ハイブリッドなMPI + OpenMPアプローチの使用はそのようなアーキテクチャにふさわしいプログラミングモデルと見なされる。しかし、パフォーマンスの改善が示される場合もあれば、示されない場合もある。ハイブリッドなMPIおよびOpenMPアプリケーションのパフォーマンスに影響している要因は多く、複雑で、相互の関係にある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MPI通信効率 ： アプリケーションは、MPI通信の種類(一対一、集団)、メッセージサイズ、接続や帯域といったネットワークの問題に関係がある。&lt;/li&gt;
&lt;li&gt;OpenMP並列効率 ： クリティカルセクションプリミティブを使用すると、OpenMPスレッド管理のオーバーヘッドやfalse sharingによってパフォーマンスが悪化する。&lt;/li&gt;
&lt;li&gt;MPIとOpenMPの相互作用 ： MPI通信部分の内部のロードバランシング、および使用されていないスレッドの問題は、並列度を低下させる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;両方のコードを書くことは、普通のHPCアプリケーションよりも専門技術の高いレベルを必要とするかもしれない。&lt;/p&gt;
&lt;p&gt;したがって、これらの新しいシステムへの効率的な利用は、重要な挑戦である。また、アプリケーションに責任を負う科学者およびエンジニアは、一般に、あまりHPCの専門家ではなく、通常、彼らはコードに新しい変化を持ち出すことや新たなプログラミングパラダイムを学ぶことはしたがらない。彼らは、効果的な自動並列化ツールとライブラリといった点での解決策を必要としている。&lt;/p&gt;
&lt;p&gt;この発表では、我々は2つの、相互関係のある異なるレベルの問題を解決を試みる。&lt;/p&gt;
&lt;p&gt;まず我々はバルク同期並列(Bulk Synchronous Parallelism ： BSP)パラダイムをすぐに導入し、それがいつ、そしてなぜ、ハイブリッドシステムの適当なプログラミングモデルと見なすことができるかを解説する。&lt;/p&gt;
&lt;p&gt;その後、我々はBSP++を紹介する。これは、BSPモデルに基づいた並列アプリケーションの迅速で容易な設計を可能にするBoostを用いたC++ライブラリである。我々は、BSP API、Lambda、PhoenixやMPIを含む、一般的に用いられるBoostライブラリに対するその相互作用、いくつかの実装詳細について記述し、いくつかの例を示す。&lt;/p&gt;
&lt;p&gt;最後に我々は、BSP++、Boost.Spirit、および Clang/LLVMによって構築された並列のプログラミングフレームワークであるBSPGenを紹介する。BSPGenは、XMLで書かれた小さなアプリケーションの記述と、並列化されていないCもしくはC++の関数から、実行時コストの先行評価とほぼ最適なOpenMPとMPIの間のバランスを決定するための配置空間の小さな探索に基づく、完全はハイブリッド並列のアプリケーションを生成することができる。実装詳細と例を提供する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-generic&#34; name=&#34;boost-generic&#34;&gt;Boost.Generic: コンセプトを使用しないコンセプト&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Generic: Concepts without Concepts&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#matt-calabrese&#34; target=&#34;_blank&#34;&gt;Matt Calabrese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/thu/Boost.Generic.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/thu/Boost.Generic.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : coming soon...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;コンセプトはおそらく、C++0xの中で最も望ましい機能のうちの一つだった。それによってプログラマはとくに、コメントではなくコードによるコンセプトの直接指定、コンセプトベースオーバーロード、テンプレートエラーメッセージの改善を含む、ジェネリックプログラミングの直接的な言語サポートを約束された。2009年のworking paperからのコンセプトの削除で、多くのプログラマが、将来のC++標準に、かなりの失望を残すことになった。&lt;/p&gt;
&lt;p&gt;しかし、10年以上の間、直接の言語サポートなしでC++プログラマは、Boost Graph Libraryを含む非常に強力なジェネリックライブラリをなんとか作ることができた。Boost Concept Check Libraryは、コンセプトの必要条件を検証するプロセスを実現可能にした。しかし、C++0xでコンセプトを削除したまま、事態をさらに1ステップ進めることは可能である。努力し、ライブラリはよりシンプルな、より特定のコンパイル時アサート、コンセプト要件を表現し、チェックするより強力な方法、ユーザー指定された自動で明示的なコンセプトマップのための設備と、ユーザーがコンセプトを書くためのコンセプトベースな関数テンプレートのオーバーロードを書く方法、人々が言語機能に期待するかもしれないものに驚くほど近いユーザビリティなども全てを提供することができ、提供する。&lt;/p&gt;
&lt;p&gt;この話は(レビュー前の)Boost.Genericへの入門である。&lt;/p&gt;
&lt;p&gt;コンセプト、コンセプトマップ、コンセプトベース関数テンプレートオーバーロードを作成するためのC++0xライブラリであり、Boost Concept Check Libraryを潜在的に置き換える、もしくは賞賛することを意図する。発表は、ライブラリの歴史、および短い入門に続き、パラダイムに慣れていない人々のためのジェネリックプログラミングの基本を最初に簡潔にカバーし、ライブラリを可能にするための根底にあるトリックへの導入に続く。その後、聴衆はBoost.Genericの基本的な使用法を示され、すでに提供されているコンセプトの要件チェックのためのコンパイル時アサートを指定する方法、それらのコンセプトに単純なコンセプトマップを作成する方法と、それら自身のアルゴリズムのためにコンセプトベースのオーバーロードを書く方法を示す。最後に、聴衆はBoost.Genericによる標準コンセプトの実装を通じて、標準との比較を見て回るだろう。&lt;/p&gt;
&lt;p&gt;「Boost.Generic ： コンセプトのないコンセプト」は、ライブラリ開発者、ユーザーの両方のためを意図する。それはC++の任意の合理的な量の経験を持ったプログラマにアクセス可能であるに違いない。基本アイデアは話の最初の数分でカバーされるが、ジェネリックプログラミングについての熟知が高く推奨される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#&#34; name=&#34;boost-infrastructure&#34;&gt;Boostインフラストラクチャ ワークショップ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost Infrastructure Workshop&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#dave-abrahams&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： ワークショップ&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostのコードとコミュニティがあったこと、あり続けたことで大成功した。しかし、操作性において我々のcode baseと同じ割合では発展していない。テストはより速くなりえる、インストールはより容易になりえる、ドキュメントの生成はより賢くなりえる、レビューはより多くの参加を得ることができ、そしてライブラリの維持はより楽しくなりえる。何年もの間、我々はこれらの問題に対処する方法について話したが、しかし我々は実際に変化をもたらすために合意と推進力を発生させられなかった。このワークショップは、これらに正面から何かをするチャンスだ。&lt;/p&gt;
&lt;p&gt;我々は方針を作成するために毎日90分間会合し、ツールを作成し、次の10年を通じてBoostの進化をサポートすることができるWebサービスを準備した。具体的なゴールは、カンファレンス参加者との間でのプロトタイプと有用な改善の実装で、より広いコミュニティの合意を獲得し、BoostConのあとすぐにBoostに採用されるされることである。我々には一週間しかない、したがって、生産力を最大限にするために、関心ある個々のトピックの小さなグループで活動する。Boostが採択することができるという方向へ率いることを保証するために、いくつかの短い投票を行い、その週を通じてBoostのメーリングリストでフィードバックを求めるだろう。&lt;/p&gt;
&lt;p&gt;十分なBoostモデレータおよびリリースマネージャー達は、カンファレンスに続く数ヶ月で、受け取ったアイデアを前身させるためにBoostConに出席することを計画する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-process&#34; name=&#34;boost-process&#34;&gt;Boost.Process ： C++によるプロセス管理&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Process: Process management in C++&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#boris-schaeling&#34; target=&#34;_blank&#34;&gt;Boris Schaeling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/fri/Boost.Process.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/fri/Boost.Process.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/boost-process-process-management-in-c-5368233&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/boost-process-process-management-in-c-5368233&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Process はシステムのプロセス管理のためのライブラリである。これはシェルコマンドの実行や、子プロセスの生成、子プロセスに対する環境変数あるいは入出力ストリームの設定、子プロセスとの同期・非同期での通信、そして子プロセス終了の待機（あるいは強制終了）に使うことができる。&lt;/p&gt;
&lt;p&gt;発表パートではBoost.Processの進歩、設計上の決定、改良点に焦点を当てる。チュートリアルパートではBoost.Processが提案するいくつかのツールと、それらがどのようにプロセス管理で使われるかを説明する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-units&#34; name=&#34;boost-units&#34;&gt;Boost.Units&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Units&lt;/li&gt;
&lt;li&gt;スピーカー ：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#steven-watanabe&#34; target=&#34;_blank&#34;&gt;Steven Watanabe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/boost-units-5364809&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/boost-units-5364809&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.Units はコンパイル時次元解析、単位変換のための自由度の高いライブラリである。これは、ユーザーがある単位の量を表現すると捉えた値の作成、無意味な操作の禁止、必要な場面での変換の適用によりプログラミングエラーを軽減するために設計された。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#cpp0x-status&#34; name=&#34;cpp0x-status&#34;&gt;C++0xの進行状況&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++0x Progress and Status&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#michael-wong&#34; target=&#34;_blank&#34;&gt;Michael Wong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式： レクチャー&lt;/li&gt;
&lt;li&gt;トラック： I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/mon/cpp0x_overview.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/mon/cpp0x_overview.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/c-0x-progress-and-status-5349952&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/c-0x-progress-and-status-5349952&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++0xの批准を今年にひかえ、BoostCon2010での更新から(2010-現在)議論の的になっている問題や、これまでの批准の進捗、前回の更新から追加されたさまざまな新機能について詳細を述べるとともに、巻き起こった議論について、またその問題をどのように解決しようとしたかについて、1.5時間頂いてレヴューを行なう。&lt;/p&gt;
&lt;p&gt;話者は、長年、IBMでカナダのC++標準化委員会のメンバーを務めてきた者だ。中程度のC++の知識がある者を対象にしているが、もちろん、どなたでも聴講可能である。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-asio-extension&#34; name=&#34;boost-asio-extension&#34;&gt;Boost.Asio拡張の作成&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Creating Boost.Asio extensions&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#boris-schaeling&#34; target=&#34;_blank&#34;&gt;Boris Schaeling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：  チュートリアル&lt;/li&gt;
&lt;li&gt;トラック：Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/wed/creating_boost_asio_extensions.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/wed/creating_boost_asio_extensions.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ソースコード : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/tree/master/wed/asio_extentions&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/tree/master/wed/asio_extentions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/creating-boost-asio-extensions-5364822&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/creating-boost-asio-extensions-5364822&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boost.AsioはBoost C++ librariesの有名なポータブルネットワークライブラリである。&lt;br /&gt;
このライブラリが、Boost.Netという名前にならなかったのには理由がある。Boost.Asioの真の力は非同期的な操作を実装するためのフレームワークたりえる点である。ネットワーク機能はその非同期的な操作のよい実例の一つにすぎない。&lt;/p&gt;
&lt;p&gt;このチュートリアルでは、どのようにBoost.Asioを拡張することができるか、ということと、どうやって非同期的な処理を実装するかについて述べる。&lt;br /&gt;
まずは、既存の拡張である、ファイルやディレクトリを監視するディレクトリモニタを紹介する。&lt;br /&gt;
また、このフレームワークに適合しない非同期的な操作を紹介し、Boost.Asioの制限について示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#skoot&#34; name=&#34;skoot&#34;&gt;Skootによる設計の旅。ピア指向ジェネリックネットワークライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Design Journeys with Skoot, a Peer Oriented Generic Networking Library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#cliff-green&#34; target=&#34;_blank&#34;&gt;Cliff Green&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：チュートリアル&lt;/li&gt;
&lt;li&gt;トラック：Track I 2011&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/design-journeys-with-skoot-a-peer-oriented-generic-networking-library-5258057&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/design-journeys-with-skoot-a-peer-oriented-generic-networking-library-5258057&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;効率的で、エレガントで、汎用的なC++ライブラリを完成させるまでの道程は、決して平坦ではない。GPSが壊れたかのように道を誤り、暗い路地をすり抜ける羽目になり、非常にストレスがたまる。&lt;br /&gt;
それと同時に、APIの設計を固めたり、利用箇所全てで機能性を検証することは、刺激的で満足のいく旅路となるだろう。&lt;br /&gt;
このプレゼンテーションでは、数々の設計上のトレードオフについて、またSkoot libraryで利用しているBoost librariesについて議論する。&lt;/p&gt;
&lt;p&gt;Skootは、分散環境やピア指向の処理環境で利用しやすい、C++のネットワーキングライブラリである。&lt;br /&gt;
また、TCP、UDPプログラミングにおける様々な通信パターンや利用法を単純化し抽象化する。&lt;br /&gt;
Skootは、Asio、Function、Bind、Shared(とWeak)Pointer、そしてOptionalといった多くのライブラリを利用している。&lt;br /&gt;
多くのC++開発者は汎用ライブラリの完成形だけを注視して、そこに至るまでの議論を軽視する傾向がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ある種のtype erasureに対し、テンプレート化クラスが意味があるのはどんな時か？&lt;/li&gt;
&lt;li&gt;非常に強力なテンプレート関数や関数オブジェクトがあるのに、多くのC++開発者がテンプレートクラスだけをありがたがるのは何故か？    &lt;/li&gt;
&lt;li&gt;いつでもデストラクトされる可能性のあるオブジェクトへの参照を有効にしつづける方法は？&lt;/li&gt;
&lt;li&gt;Boost libraryの魔法、Bindとは何か？ なぜそれがモミ林にいるキンキラの吸血鬼よりすばらしいのか？&lt;ul&gt;
&lt;li&gt;(訳註：モミは吸血鬼を封印する効果があるとされている。吸血鬼は光にも弱いため、&#34;glittering vampire in a forest of fir trees&#34;は二重の意味でありえない。これと対比させる事で、Bindの&#34;魔法&#34;の強力さを示している)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++で仮想テンプレートメンバ関数が必要になった場合、どうすればいいのか？&lt;/li&gt;
&lt;li&gt;Asioの実装者である、Chris Kohlhoffはノーベル賞か何かを受賞すべきか？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらの疑問はSkoot開発中に湧き、解決されていったが、これらを説明することで、Boost導師と言える領域に達していない開発者を啓発することができると思う。&lt;br /&gt;
このプレゼンテーションは、汎用的なテンプレートを基礎にした設計技法を学んでいる、また、FunctionとBind(と、その他のライブラリ)を基本構成要素としてどう利用するかについて興味があるような、熟練したC++開発者向けである。&lt;br /&gt;
ライブラリの使用方法や、API設計や洗練、また良いユニットテストの作成についても議論する。&lt;/p&gt;
&lt;p&gt;(人物紹介：Bio: Cliffは現在SeattleにあるBoeingに勤務する、経験豊かなC++開発者である。&lt;br /&gt;
氏の開発経歴の中で主なものは、ネットワーキングと複数のプログラミング言語での可用性の高い分散処理である。また、Prologに愛着を持っていることも付記しておく。&lt;br /&gt;
Cliffは、複数の新興企業に勤務した経歴がある。これらは今やすべて破産、買収されたが、実勢価格の自社株購入権を失った時でも、安定した給料を高く買われている。)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#geneva&#34; name=&#34;geneva&#34;&gt;Genevaライブラリによる分散パラメトリック最適化&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Distributed parametric optimization with the Geneva library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#ruediger-berlich&#34; target=&#34;_blank&#34;&gt;Ruediger Berlich&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：チュートリアル&lt;/li&gt;
&lt;li&gt;トラック：Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/mon/boostcon2011_geneva.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/mon/boostcon2011_geneva.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/distributed-parametric-optimization-with-the-geneva-library-5349954&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/distributed-parametric-optimization-with-the-geneva-library-5349954&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションではBoost libraryに大きく依存している分散最適化アルゴリズムのオープンソースライブラリであるGenevaを紹介する。&lt;br /&gt;
Genevaは現在、勾配降下法、進化アルゴリズム、群アルゴリズムをカバーしており、まもなく焼きなまし法が追加されることになっている。&lt;br /&gt;
すべてのアルゴリズムは、候補となるソリューションが最適化アルゴリズムを自由に切り替えられるように、同じデータ構造に作用する。&lt;br /&gt;
Genevaはグリッド環境、クラウド環境、マルチコアシステム、クラスター上でも、大規模なパラメトリック最適化問題を解くことができる。&lt;br /&gt;
このライブラリは、同時に最適化問題に取り組む数百のクライアントでテストされている。&lt;br /&gt;
使用しているライブラリは、Boost.Serialization、Threads、Conversion、Date/Time、Function、Bindなど多岐にわたる。&lt;br /&gt;
このプレゼンテーションでは、ユーザーの視点から、Geneva library自体について、また、Boostで培われた経験について論じる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#fast-numerical-computation&#34; name=&#34;fast-numerical-computation&#34;&gt;C++による高速数値計算：遅延コード生成(LzCG)のためのExpression Templateとその先へ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Fast numerical computation in C++:Expression Templates and Beyond to Lazy Code Generation (LzCG)&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#bojan-nikolic&#34; target=&#34;_blank&#34;&gt;Bojan Nikolic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/thu/fast_numerical.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/thu/fast_numerical.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/fast-numerical-computation-in-c-expression-templates-and-beyond-to-lazy-code-generation-lzcg-5260438&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/fast-numerical-computation-in-c-expression-templates-and-beyond-to-lazy-code-generation-lzcg-5260438&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Expression templateは、数値計算において、強力な最適化を可能にするC++の機能である。&lt;/p&gt;
&lt;p&gt;Expression templateはBoost.uBLASや、他の有名なC++の数値計算ライブラリ (例えば、先駆けであるBlitz++やArmadilloなど) に用いられている。ATLASやFFTWのような&#34;標準&#34;となるC++で書かれたライブラリはまだない。なぜないのか? このチュートリアルの最初の章では、私は数値計算における最適化の挑戦について、最適化のためにどのようにしてexpression templateが使われているのか、そして、expression templateの使用を妨げる根本的な要因についてレビューを行う。&lt;/p&gt;
&lt;p&gt;2つめの章では、私はいくつかの数値計算フレームワークが、どのようにして、一般にC++-onlyのライブラリで達成されているよりも高いパフォーマンスを達成しているかについて紹介する。それらのライブラリでの重要な特徴は、複雑なコード生成、実行されるハードウエアへの正確な適応、そして、実行前に多くの異なる実装の性能を計る能力をもつことである。&lt;/p&gt;
&lt;p&gt;最後に、私は、どのようにすればC++のパフォーマンスを、Expression templateによってもたされるそれよりも高くできるかについて論議する。私は新しい開発途中のフレームワークを用いて、実際にどのように動いているかのデモを行う。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#funding-boost&#34; name=&#34;funding-boost&#34;&gt;国内、国際的な研究プログラムや基金を通じた、Boost開発の資金調達について&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Funding Boost development through national and international research programs and funds&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#ruediger-berlich&#34; target=&#34;_blank&#34;&gt;Ruediger Berlich&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：パネルディスカッション&lt;/li&gt;
&lt;li&gt;トラック：Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/thu/BoostCon2011Funding.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/thu/BoostCon2011Funding.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このプレゼンテーションでは、まず、Boostの開発をサポートする目的で、国内・国際的な研究プログラムや資金を活用するための実現可能な方法について議論する。&lt;/p&gt;
&lt;p&gt;ゴールは3部構成である：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boostの開発に役立てるために、国内、国際的な研究資金調達スキーム(NSFやEuropean Unionなど…)を活用するために、多国間の連携に向けて取り組み始めるには&lt;/li&gt;
&lt;li&gt;Boostを、世界各地の大学や工業大学でコンピュータサイエンス教育のカリキュラムで取りあげられるような標準的なトピックにするためには&lt;/li&gt;
&lt;li&gt;Boost開発に科学分野からの新しい参加者を取り込むには&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#future-of-boost&#34; name=&#34;future-of-boost&#34;&gt;Boostの未来 - パネルディスカッション2011&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Future of Boost Panel ’11&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#dave-abrahams&#34; target=&#34;_blank&#34;&gt;Dave Abrahams&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#beman-dawes&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#jeff-garland&#34; target=&#34;_blank&#34;&gt;Jeff Garland&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#eric-niebler&#34; target=&#34;_blank&#34;&gt;Eric Niebler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：パネルディスカッション&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Boostには、本筋の議論や、尊重すべき、また有用なメーリングリストを維持するために、ポストの承認と管理を含むメーリングリストの運用を行っている小規模のモデレータグループがいる。&lt;/p&gt;
&lt;p&gt;このグループは、Webサイトや、ソースリポジトリの管理やその他の管理業務も遂行している。&lt;/p&gt;
&lt;p&gt;また、少なくとも、Boostに関することを促進するために、委員会を監督する非公式幹部としての役割をも果す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#range-unicode&#34; name=&#34;range-unicode&#34;&gt;Rangeのためのジェネリックな変換と分割:Unicodeのためのソリューション&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generic Conversion and Segmentation for Ranges: a Solution for Unicode&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#mathias-gaunard&#34; target=&#34;_blank&#34;&gt;Mathias Gaunard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/wed/unicode.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/wed/unicode.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一貫した世界のライティングシステムのうちのほとんどが通る、テキストを表現し、操作する業界標準であるUnicodeに対処するBoostでのソリューションの数多くの需要は常にあった。この話では、我々は、Google Summer of Code 2009で開始したソリューションを示す。Rangeのコンセプトに基づいて、計量で、非侵入的で、柔軟で、ジェネリックで、潜在的にlazyである。&lt;/p&gt;
&lt;p&gt;アルゴリズムをジェネリックにするために、全てが書き直された。また、それによって、このライブラリはいかなる既存のUnicodeソリューションにも依存しない。このライブラリは、いくつかの外部データを要求するが、ライブラリがそれ自身のデータベースに埋め込むにも関わらず、ライブラリを別のデータベースとリンクするために使用することができる明快で安定したABIがある。&lt;/p&gt;
&lt;p&gt;Unicodeライブラリのニーズは、スピンオフとして別のライブラリに至った：Convertライブラリは、N to M変換を使用して、容易にRangeを変換し、分割することを可能にするライブラリであり、Rangeを正格もしくはlazyにイテレートする。また、それはSIMDによって加速された変形の開発を助ける設備を提供する。このライブラリは、最初はUnicodeのために作られたが、我々はそれを文字エンコーディング変換と無関係な様々なものに使用することができることを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#proto-edsl-design&#34; name=&#34;proto-edsl-design&#34;&gt;Protoを楽しむ - C++ EDSLデザインのハンズオンチュートリアル&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Getting Jiggy with Proto — Hands-on Tutorial on C++ EDSL Design&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#joel-falcou&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/mon/proto.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/mon/proto.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/getting-jiggy-with-proto-hands-on-tutorial-on-c-edsl-design-5368236&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/getting-jiggy-with-proto-hands-on-tutorial-on-c-edsl-design-5368236&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Embedded Domain Specific Languagesは、中小の大きさの問題を宣言的で効率的な手段で扱うための設計として、実際に選ばれることが増えている。とりわけ、C++はBoost.Protoのようなライブラリのおかげで、そのような開発の親言語として、本当に興味深い。&lt;/p&gt;
&lt;p&gt;このチュートリアルは、現実的なシチュエーションでのクイックスタートとなり、Boost.Protoを用いたコードが美しく小さく効率的であることをデモすることに焦点を当てている。&lt;/p&gt;
&lt;p&gt;チュートリアルは以下の要素から構成される:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;短いライブラリの基本的なブロックのプレゼンテーション        &lt;/li&gt;
&lt;li&gt;単純な計算機のコードから、拡張可能なコアを持つ解析関数の微分を行うシステムのプロトタイプまでのガイド付きの練習問題。この問題は、Protoを用いてEDSLを構築するいくつかの段階と、Proto特有のイディオムについて示す。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参加者はテンプレートメタプログラミングに関する知識を持つ中級か上級のC++ユーザが望ましい。昨年のEric NieblerによるProtoに関する発表を見るのもよいだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#haskell-pseudo-cpp&#34; name=&#34;haskell-pseudo-cpp&#34;&gt;Haskell - C++テンプレートメタプログラミングのための擬似言語&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Haskell – The Pseudocode Language for C++ Template Metaprogramming&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#bartosz-milewski&#34; target=&#34;_blank&#34;&gt;Bartosz Milewski&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 :&lt;ul&gt;
&lt;li&gt;Part1 &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/tue/haskell/Bartosz1.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/tue/haskell/Bartosz1.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part2 &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/tue/haskell/Bartosz2.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/tue/haskell/Bartosz2.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part3 &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/tue/haskell/Bartosz3.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/tue/haskell/Bartosz3.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/haskell-the-pseudocode-language-for-c-template-metaprogramming-5258033&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/haskell-the-pseudocode-language-for-c-template-metaprogramming-5258033&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++テンプレートメタプログラミングは使うのも解析するのもデバッグするのも難しいが、それはだいたいコンパイル時のC++が関数型言語的で構文がゲロいからである。うまくメタプログラミングするコツは、関数型プログラミングに精通して、C++メタプログラムのための擬似言語を作ることであるが、実のところ既にそのための言語はあり、そいつはHaskellとか言われている。このセッションではまず、そのHaskellで書いたコードと等価なC++のメタコードを並べることでHaskellがどんな言語かを紹介する。その後、Haskellを使った複雑なC++メタプログラムの読み書きの方法を示す。最後はC++における「実行できるテンプレート」の説明で、モナドとは何か、どうやってそれを使うかを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#intel-tm&#34; name=&#34;intel-tm&#34;&gt;IntelのC++ Software Transactional Memory CompilerとC++でのトランザクション言語構築のドラフト仕様について&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Intel’s C++ Software Transactional Memory Compiler and the Draft Specification of Transactional Language Constructs for C++&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#justin-gottschlich&#34; target=&#34;_blank&#34;&gt;Justin Gottschlich&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：チュートリアル&lt;/li&gt;
&lt;li&gt;トラック：Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/tue/boostcon_tm_spec.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/tue/boostcon_tm_spec.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/intel-s-c-software-transactional-memory-compiler-and-the-draft-specification-of-transactional-language-constructs-for-c-5254333&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/intel-s-c-software-transactional-memory-compiler-and-the-draft-specification-of-transactional-language-constructs-for-c-5254333&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;トランザクションメモリ(TM)を利用すれば、プログラマからは複雑な共有メモリ管理が隠蔽されるため、並行プログラミングが容易になる。このセッションでは、最新のC++でのトランザクション言語構築のドラフト仕様について、ならびに、インテルのC++ software transactional memory (STM) compilerでの実装例について紹介する。&lt;/p&gt;
&lt;p&gt;Boost libraryの作者は高度に最適化され、極度にタイプセーフなソフトウェアを実装することを目標としている。&lt;br /&gt;
このセッションでは、厳格なタイプセーフと最適化を達成するために、Intel C++ STM compilerでどのようにトランザクションが利用されているかについて詳細に述べる。&lt;br /&gt;
特に、テンプレート宣言やラムダ式、コピーコンストラクタ、そして基本的な関数やクラスでどのようにトランザクションが利用されているか紹介する。&lt;br /&gt;
また、リラックス・トランザクションの概念について紹介し、この概念を用いて、取り消し不能なアクション(例えば、I/Oのように実行前に戻せないアクション)をどう扱うとよいかについて示す。&lt;/p&gt;
&lt;p&gt;最後に、最新のC++でのトランザクション言語構築のドラフトと、Intel’s C++ STM compilerのロードマップについて述べる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#mpl-graph&#34; name=&#34;mpl-graph&#34;&gt;MPL.Graphの紹介&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Introducing MPL.Graph&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#gordon-woodhull&#34; target=&#34;_blank&#34;&gt;Gordon Woodhull&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：チュートリアル&lt;/li&gt;
&lt;li&gt;トラック：Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/thu/mpl.graph.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/thu/mpl.graph.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/introducing-mpl-graph-5262812&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/introducing-mpl-graph-5262812&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MPLメタプログラミングとBGLグラフコンセプトの過激な合いの子である、MPL.Graphがコンパイル時にメタデータのグラフを作成し走査するためのBoostライブラリとして提案された。&lt;/p&gt;
&lt;p&gt;グラフのデータ構造とアルゴリズムは様々な目的でコンパイルタイムに適用できる。例えば、クラス階層や、Expression Templateツリー、ステートマシンや文法は完全にコンパイルタイムに処理できるグラフである。また、呼び出しグラフや、オブジェクトの所有権、オブジェクト間のポインターは、部分的にコンパイルタイムに処理できるが、残りはランタイムに処理する必要があるグラフである。&lt;/p&gt;
&lt;p&gt;これらは全て、グラフのアルゴリズムを実行するために、標準的なグラフインターフェイスを適用することができるか、計算されたグラフから作り出される。仕様および分析にコンパイルタイムグラフを使用すれば、抽象化の無駄なランタイムサイクル回避でき、概念的な明快さと抽象化（一度&#34;メタ&#34;の壁を乗り越えられれば）が向上する。&lt;/p&gt;
&lt;p&gt;今のところ、MPL.GraphはBGLの&lt;code&gt;incidence_list&lt;/code&gt;と&lt;code&gt;adjacency_list&lt;/code&gt;データ構造と、&lt;code&gt;breadth_first_search&lt;/code&gt;と&lt;code&gt;depth_first_search&lt;/code&gt;アルゴリズムのコンパイルタイムバージョンを提供している。このライブラリはBoost.MSMで、リージョン(連結成分)と到達不能な状態とを区別するために、いまのところはサブライブラリとして使用されている。このトークではMPL.Graphの新しい用法を紹介する。(例えば、文法や、Fusion Graphとして知られるヘテロなグラフデータ構造など) また、最終的な目標である、コンパイルタイムグラフでランタイムグラフを記述する、&#34;グラフのグラフ&#34;といえるメタグラフについて少しだけ紹介する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#lock-free-data-structure&#34; name=&#34;lock-free-data-structure&#34;&gt;ロックフリープログラミング パート2： データ構造&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lockfree Programming Part 2: Data Structures&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#tony-van-eerd&#34; target=&#34;_blank&#34;&gt;Tony Van Eerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：チュートリアル&lt;/li&gt;
&lt;li&gt;トラック：Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/wed/lockfree_2011_slides.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/wed/lockfree_2011_slides.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/lockfree-programming-part-2-data-structures-5258642&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/lockfree-programming-part-2-data-structures-5258642&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;まず昨年夏の話の概要から始め、昨年中断したところ - ロックフリープログラミングの&#34;FCD(恐怖、必然性、そしてかなりの嘘)&#34;について更に深めるところから再開する。&lt;/p&gt;
&lt;p&gt;今回はデータ構造を主題にするつもりだ。まずは、単純なロックフリースタックから始め、このスタックのABA問題(訳註：see &lt;a href=&#34;http://en.wikipedia.org/wiki/ABA_problem&#34; target=&#34;_blank&#34;&gt;http://en.wikipedia.org/wiki/ABA_problem&lt;/a&gt;)について、その後、様々なロックフリーキューについて議論する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#cell-broadband&#34; name=&#34;cell-broadband&#34;&gt;Boostベースの並列通信ライブラリによる、セルブロードバンドエンジンのアーキテクチャをマスターする&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mastering the Cell Broadband Engine architecture through a Boost based parallel communication library&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#joel-falcou&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#lionel-lacassagne&#34; target=&#34;_blank&#34;&gt;Lionel Lacassagne&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#sebastian-schaetz&#34; target=&#34;_blank&#34;&gt;Sebastian Schaetz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/tue/cell_mpi.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/tue/cell_mpi.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/mastering-the-cell-broadband-engine-architecture-through-a-boost-based-parallel-communication-library-5349964&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/mastering-the-cell-broadband-engine-architecture-through-a-boost-based-parallel-communication-library-5349964&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;セルブロードバンドエンジン(CBE)は、内部のリングバスによって接続しているPowerPCプロセッサと、8ベクトル共同処理要素(8 vector co-processing elemens)を組み合わせる、組み込みシステムである。それは、マルチメディア、シグナルプロセッシング、ハイパフォーマンスコンピューティングなどのアプリケーションにふさわしいプラットフォームである。&lt;/p&gt;
&lt;p&gt;現行のセルプロセッサ(PowerXCell 8i)は、204.8 GFlop/sの最大の単精度のパフォーマンスと、102.4 GFlops/sの倍精度のパフォーマンスで規定される。この巨大な計算力とアーキテクチャのパワー効率(IBM BladeCenter QS22のための1ワットあたり0.87の倍精度GFlops/s)の観点から、グラフィック処理装置(graphics processing units:GPGPU)上の現代のx86マルチコアアーキテクチャおよび汎用計算(general-purpose computation)の適切な代わりであった。これらの利点にも関わらず、セルプロセッサの採用は期待されたよりも遅かった。我々は、これがアーキテクチャの新たな性質、およびその複雑性を抽象化する、便利なツールの不足に起因すると考える。&lt;/p&gt;
&lt;p&gt;この話では、我々は、セルアーキテクチャのための効率的なアプリケーションの開発を単純化するライブラリを作る努力を示す。我々は、基礎となるハイパフォーマンスアルゴリズムで直感的なインタフェースを作るために、現代のC++コンセプト、および多くのBoostライブラリ(MPL, PP, Function, Spirit)をどのように利用するかを示す。我々は、セルアーキテクチャと、我々がどのようにそれをマスターしたかにともなう調整について議論する。&lt;/p&gt;
&lt;p&gt;我々のライブラリの不可欠な部品は、メッセージパッシングに基づくCBEのシステムデザインに向いているプログラミングモデルである。我々の実装はBoost.MPIインタフェースに基づく非同期通信を含んでおり、また、パフォーマンスは集合的な操作(collective operations)を最適化した。&lt;/p&gt;
&lt;p&gt;また、我々は非同期データ転送、およびマルチバッファリングをサポートする、分散コンテナと、セグメント化されたイテレータの実装を示す。さらに、我々は制限のあるリソースを持ったシステムに特に適している、Boost.Testのあとに設計された計量の単体テストモジュールのデモを示す。&lt;/p&gt;
&lt;p&gt;最後に、我々はそのようなアーキテクチャのためのソフトウェアエコシステムの実行可能性を評価し、また、Boostの設計にどのように影響を受けたか、そのようなシステムからのパフォーマンスにコテ入れし、おそらく、そのような特定の組み込みハードウェア上のBoostの将来に関する議論を始めることができる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#odb-boost&#34; name=&#34;odb-boost&#34;&gt;ODBとBoostによるオブジェクトリレーショナルマッピング&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Object-relational mapping with ODB and Boost&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#boris-kolpackov&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/thu/orm_with_odb_and_boost.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/thu/orm_with_odb_and_boost.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/object-relational-mapping-with-odb-and-boost-5364825&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/object-relational-mapping-with-odb-and-boost-5364825&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ODBは、C++のためのオープンソースで、クロスプラットフォームなクロスデータベースオブジェクトリレーショナルマッピング(ORM)システムである。同様の機能を提示する他のライブラリと異なり、ODBは、永続クラス(persistent classes)とC++クラス宣言から、それらのデータベース表現との間の変換を行うコードを自動的に生成する。また、ODBは高度にカスタマイズ可能である。人気のあるフレームワーク、BoostやQtのようなライブラリの基本型、スマートポインタ、およびコンテナのようなコンポーネントは、標準のバージョンと合わせて永続クラスでシームレスに使用することができる。&lt;/p&gt;
&lt;p&gt;話の前半は、ODBシステムの基本概念とワークフローを導入する。後半は、BoostのためのODBプロファイル、永続Boost値型(例えば&lt;code&gt;boost::gregorian::date&lt;/code&gt;)のサポートを行うライブラリ、スマートポインタ(例えば&lt;code&gt;boost::shared_ptr&lt;/code&gt;)およびコンテナ(例えば&lt;code&gt;boost::optional&lt;/code&gt;、&lt;code&gt;boost::unordered_set&lt;/code&gt;)に注目する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#gcc-plugins&#34; name=&#34;gcc-plugins&#34;&gt;GCCプラグインによるC++解析&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Parsing C++ with GCC plugins&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#boris-kolpackov&#34; target=&#34;_blank&#34;&gt;Boris Kolpackov&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/tue/parsing_cxx_with_gcc_plugins.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/tue/parsing_cxx_with_gcc_plugins.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/parsing-c-with-gcc-plugins-5349971&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/parsing-c-with-gcc-plugins-5349971&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GNU Compiler Collection(GCC)は、成熟し、広く使用されたC++コンパイラ実装を持ったオープンソースでクロスプラットフォームなコンパイラスイートである。GCCのバージョン4.5.0は、コンパイラコンポーネントの再利用と同様に、コンパイルプロセスのカスタマイズを許可する、新たな動的なプラグインアーキテクチャを追加した。この発表のゴールは、GCCプラグインを使用して、C++を解析する方法を示すことである。&lt;/p&gt;
&lt;p&gt;この話は、解析された翻訳単位の内部表現と、GCCプラグインアーキテクチャのハイレベルな概要から始まる。その後、C++宣言が存在することに関する情報の表示をするための、単純なプラグインの実装を示す。この話は、主翻訳単位、アプリケーション特有のプラグマと属性のハンドリング、プログラマティックなテンプレートインスタンス化に追加のC++コードを注入するなどのより高度な技術をカバーする。&lt;/p&gt;
&lt;p&gt;この発表は、Clang(最近全面的なC++98サポートを達成した別のC++コンパイラ実装)とGCCプラグインアーキテクチャの簡潔な比較なしでは不完全になる。この話は、Boostの、および(GCCプラグインを使用して実装することができる)より広いコンテキストで可能なおもしろいアプリケーションの迅速なブレーンストーミングセッションで締めくくる。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#phoenix-v3&#34; name=&#34;phoenix-v3&#34;&gt;Phoenix V3の概要&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Phoenix V3 –An Overview&lt;/li&gt;
&lt;li&gt;スピーカー： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#thomas-heller&#34; target=&#34;_blank&#34;&gt;Thomas Heller&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#hartmut-kaiser&#34; target=&#34;_blank&#34;&gt;Hartmut Kaiser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/mon/phoenix_v3.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/mon/phoenix_v3.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/phoenix-v3-an-overview-5250984&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/phoenix-v3-an-overview-5250984&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Phoenixは次世代のインラインの無名多態関数オブジェクト生成器となるだろう。V3ではBoost.Bind と Boost.Lambdaの機能が合成された新しいライブラリとなった。このライブラリを記述する際、後方互換性を保持したまま前述したライブラリ(訳註：BindとLambda)の制限を修正した。このセッションの目的は、C++における関数プログラミングが、いかに重要かつエレガントかについて概説することだ。セッションの第一部では、Phoenixで定義されたDomain Specific Embedded Language (DSEL)について述べる。DSELは演算子のオーヴァーロードと標準C++関数で構成されている。PhoenixがC++を模倣した言語を定義したのは、潜在的なユーザーが関数プログラミングに入門するハードルを下げるためだ。一方、既存のC++コードは(関数オブジェクトとして知られる)高階関数に依存している。たとえば、C++標準ライブラリはあるアルゴリズムの挙動を変更するために高階関数を使っている。第二部では関数オブジェクトの代わりにどうPhoenixを利用するか、また、Phoenix expression内でどう既存のユーザーコードを有効にするかについて例示する。しかし、Phoenixの真の力はこんなものではない。Phoenixは前のセクションで議論したように、式をデータとして扱う (C++においては)ユニークな機構を備えている。これによって、C++の標準的な手法ではなく、ユーザーの好みに応じた手法でPhoenixを利用できる。潜在的なユーザーにPhoenixを軸に展開する将来的なアプリケーションの見識を得ていただくために、このセッションの締めくくりとして、これらの機構についての概説をするつもりである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#boost-simd&#34; name=&#34;boost-simd&#34;&gt;Boost.SIMDによる実用的なSIMDアクセラレーション&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Practical SIMD acceleration with Boost.SIMD&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#joel-falcou&#34; target=&#34;_blank&#34;&gt;Joel Falcou&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#mathias-gaunard&#34; target=&#34;_blank&#34;&gt;Mathias Gaunard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;li&gt;プレゼンテーション資料 ： &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/thu/simd.pdf&#34; target=&#34;_blank&#34;&gt;Practical SIMD acceleration with Boost.SIMD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日本語版資料 ： &lt;a href=&#34;http://www.slideshare.net/faithandbrave/boostsimd&#34; target=&#34;_blank&#34;&gt;Practical SIMD acceleration with Boost.SIMD(ja)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/practical-simd-acceleration-with-boost-simd-5261117&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/practical-simd-acceleration-with-boost-simd-5261117&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SIMDマシン - 同じ命令で複数の要素からなるデータを並列に計算する能力を持つマシン - は、今日では、スーパーコンピュータからデスクトップコンピュータやモバイルコンピュータまで、ありふれたものとなっている。&lt;br /&gt;
数値計算のツールやライブラリは、SIMDを使用することによって計算速度を向上させることができるが、今のところ、C++デベロッパのための、最小で高レベルな、プラットフォームに依存しないインターフェイスを提供するライブラリはないといえるだろう。&lt;/p&gt;
&lt;p&gt;このチュートリアルで、我々はレビュー待ちの状態にあるBoost.SIMDライブラリについて紹介し、技術的な挑戦と、どのようにBoost.SIMDを用いて、一般的な、あるいは、あまり一般的でない問題に適用させるのかについて解説する。&lt;br /&gt;
解説では、我々のライブラリが、全ての種類のアルゴリズムを高速化するという点や、ペナルティがないようにSIMDハードウエアをちょうどよく抽象化するという点においての有用さについて述べる。&lt;/p&gt;
&lt;p&gt;Boost.SIMDの設計は、可能な限り軽量になるように、また、巨大な数値計算ライブラリNT2の一部となるように作られている。&lt;br /&gt;
NT2は、テーブルや行列を作るために、SMP、MPI、GPGPUの技術と一緒にBoost.SIMDを用いている。&lt;br /&gt;
Boost.SIMDはSIMDのみを扱う専用ライブラリとして作られている。&lt;br /&gt;
したがって、Boost.SIMDの主たる抽象化はSIMDレジスタである。(例えば、SIMDプロセッサによって処理される基本となる単位)&lt;br /&gt;
また、Boost.SIMDはプラットフォームに依存しない高レベルインターフェイスを提供するが、ローレベルな問題はユーザにとって主な関心事のままである。&lt;/p&gt;
&lt;p&gt;Boost.SIMDは、一定のコードパターンを認識し、最も効率的な解法への射影をするように、Boost.Proto DESLフレームワークを用いている。例えば、Altivecと未来の世代のx86環境に存在する積和命令や、与えられた範囲で必要とされる値を検出するために用いている。&lt;/p&gt;
&lt;p&gt;さらに、このライブラリは、与えられたアーキテクチャのプリミティブに適正に簡単に特殊化でき、新しいターゲットや関数を作成することができる強力な外部ディスパッチ機構を供えている。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#real-workd-spirit-qi&#34; name=&#34;real-workd-spirit-qi&#34;&gt;現実世界におけるSpirit.Qi&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Spirit.Qi in the Real World&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#robert-stewart&#34; target=&#34;_blank&#34;&gt;Robert Stewart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/tue/spirit_qi_in_the_real_world.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/tue/spirit_qi_in_the_real_world.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/spirit-qi-in-the-real-world-5254335&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/spirit-qi-in-the-real-world-5254335&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spiritの過去のセッションは、Spiritの導入や、チュートリアルによって現実の利用に注目した。実際のSpirit.Qiパーサーを書く際、速い段階で「悪魔は細部に宿る」ということに気付くだろう。思考錯誤によって、あるいはおそらくSpiritメーリングリストによって発見しなければならない特別なケース、トリック、イディオムがある。それには時間がかかり、便利とは限らないかもしれない。このセッションに、我々は&lt;code&gt;printf()&lt;/code&gt;(スタイルフォーマット文字列)のためのSpirit.Qiパーサーの開発を通じて見て回るだろう。結果として型安全で効率的な、&lt;code&gt;printf()&lt;/code&gt;の置き換えになるだろう。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#sweep-line-algorithm&#34; name=&#34;sweep-line-algorithm&#34;&gt;平面上の点、線分、多角形中間軸のボロノイ図における掃引線アルゴリズム&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sweep-Line Algorithm for Voronoi Diagrams of Points, Line Segments and Medial Axis of Polygons in the Plane&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#lucanus-simonson&#34; target=&#34;_blank&#34;&gt;pLucanus Simonson&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#andrii-sydorchuk&#34; target=&#34;_blank&#34;&gt;Andrii Sydorchuk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：チュートリアル&lt;/li&gt;
&lt;li&gt;トラック：Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/thu/voronoi_diagram_of_line_segments.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/thu/voronoi_diagram_of_line_segments.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/sweep-line-algorithm-for-voronoi-diagrams-of-points-line-segments-and-medial-axis-of-polygons-in-the-plane-5368229&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/sweep-line-algorithm-for-voronoi-diagrams-of-points-line-segments-and-medial-axis-of-polygons-in-the-plane-5368229&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;平面上の交点のないセグメントと点の集合を入力値とするボロノイ図を演算するアルゴリズムについて述べる。&lt;/p&gt;
&lt;p&gt;点のボロノイ図の演算を行なうFortuneによる平面掃引アルゴリズムを踏まえて、理論値であるO(n log n)の計算量を維持したまま、このアルゴリズムを線分に適用できるように拡張した。&lt;br /&gt;
線分に対するボロノイ図は、多角形中間軸を自明に生成することができ、VSLI、CAD、CAMの製造など、さまざまな適用が考えられる。&lt;br /&gt;
効率を犠牲することなく数値堅牢性を保証するアプローチについても議論するつもりである。&lt;br /&gt;
lazy-exact arithmeticに基づく堅牢な述語を用いることで、このアルゴリズムが整数座標入力について確実に正しい結果を返すことを示す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#b-tree&#34; name=&#34;b-tree&#34;&gt;Boostに提案されたB木ライブラリ&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The Proposed Boost B-tree Library&lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#beman-dawes&#34; target=&#34;_blank&#34;&gt;Beman Dawes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式：チュートリアル&lt;/li&gt;
&lt;li&gt;トラック：Track II 2011&lt;/li&gt;
&lt;li&gt;プレゼン資料：&lt;a href=&#34;https://github.com/boostcon/2011_presentations/blob/master/tue/proposed_b_tree_library.pdf&#34; target=&#34;_blank&#34;&gt;The Proposed Boost B-tree Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日本語版資料：&lt;a href=&#34;http://www.slideshare.net/eldesh/proposed-boost-btreelibraryja&#34; target=&#34;_blank&#34;&gt;The Proposed Boost B-tree Library(ja)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ： &lt;a href=&#34;http://blip.tv/boostcon/the-proposed-boost-b-tree-library-5349968&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/the-proposed-boost-b-tree-library-5349968&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B木はデータベースやファイルシステム、ディスクに記憶される連想コンテナなどに利用される、どこにでもあるデータ構造である。&lt;/p&gt;
&lt;p&gt;このセッションではB木について、また、ディスクに記憶されるB木による&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;multimap&lt;/code&gt;、&lt;code&gt;multiset&lt;/code&gt;ライブラリについて紹介する。&lt;br /&gt;
まずB木を概略的に説明し、提案されたライブラリコンテナとC++標準の関連するコンテナとの関連について示す。すなわち、実装されているインターフェースや、落し穴、可変長データ、パフォーマンス、また、このライブラリの実装がどこまで進んでいるかについて紹介する。&lt;br /&gt;
フィードバックや議論する時間も設ける予定だ。&lt;/p&gt;
&lt;p&gt;このセッション終了時には、参加者した方々がご自身のアプリケーションにこのライブラリを利用することができるようになり、このライブラリがBoostに正式実装されるよう、さらなるフィードバックしていただけるようになるはずである。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#think-async&#34; name=&#34;think-async&#34;&gt;非同期について考える ： Boost.Asioを使用したアプリケーション設計&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Thinking Asynchronously: Designing Applications with Boost.Asio  &lt;/li&gt;
&lt;li&gt;スピーカー：&lt;a href=&#34;http://boostcon.boost.org/program/speakers#christopher-kohlhoff&#34; target=&#34;_blank&#34;&gt;Christopher Kohlhoff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： 講義&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/mon/thinking_asynchronously.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/mon/thinking_asynchronously.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/thinking-asynchronously-designing-applications-with-boost-asio-5250947&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/thinking-asynchronously-designing-applications-with-boost-asio-5250947&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最初から、Boost.Asioは本心では、フレームワークとしてではなく、ツールキットとして設計された。ライブラリは1セットの基礎、汎用的なビルディングブロックの提供に注目する。タスクを検討するために、一つ以上の正しい方法があり、また、ライブラリは特定の書き方を強制しない。&lt;/p&gt;
&lt;p&gt;この発表では、我々は、問題を設計するためにどのように非同期の考え方を適用することができるかを考えていく。我々は、設計代案、共通の罠と落とし穴、それと複合操作によって計算量を攻撃する方法を見ることになるだろう。この話はまた、最適化、およびパフォーマンスと拡張性を管理するために、Boost.Asioが提供するツールをカバーするだろう。&lt;/p&gt;
&lt;p&gt;この話は、出席者がBoost.Asioにある程度基礎的なレベルのなじみがあると仮定する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#thread-shared-variables&#34; name=&#34;thread-shared-variables&#34;&gt;C++0xのスレッドと共有変数&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Threads and Shared Variables in C++0x&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#hans-boehm&#34; target=&#34;_blank&#34;&gt;Hans Boehm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： キーノート&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/wed/boehm-boostcon11.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/wed/boehm-boostcon11.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/hans-boehm-threads-and-shared-variables-in-c-0x-keynote-5250902&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/hans-boehm-threads-and-shared-variables-in-c-0x-keynote-5250902&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++0xの規格ドラフトは、言語へスレッドを導入し、スレッド間で共有される変数の意味を念入りに定義する。設計は、デフォルトでマルチスレッドのプログラムがスレッドの単純な割り込み実行に基づいたセマンティクス(つまり、順序一貫性:sequential consistency)を保証するべきであるという考えに基づく。間違ったものや無意味であるものとして、我々がデータレース(通常の共有変数への、ほとんどの種類の非保護同時アクセス)を考察するという理由だけで、これは効率的な実行を許可する。ドラフトは代わりに、とくにID付けされたオブジェクトにアクセスを許可するアトミック操作の広範囲なコレクションをサポートする。&lt;/p&gt;
&lt;p&gt;我々は、C++0xのスレッドサポートの概要を示し、次に、共有変数セマンティクスを定義するメモリモデルとアトミックライブラリの相互作用に注目する。過去の慣例とできるだけ一致するように心がけたが、我々は多くの難題と、驚きに遭遇した。我々は、コピーしないために試みた過去の誤りのいくつかに言及する。&lt;/p&gt;
&lt;p&gt;これは、Sarita Adve、Lawrence Crowl、Paul McKenney、Clark Nelson、Herb Sutter、他の多くの方との共同作業について説明する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#xml-processing&#34; name=&#34;xml-processing&#34;&gt;C++のマルチパラダイムデザインによるネイティブXML処理&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Toward Native XML Processing Using Multi-paradigm Design in C++  &lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#aniruddha-gokhale&#34; target=&#34;_blank&#34;&gt;Aniruddha Gokhale&lt;/a&gt;, &lt;a href=&#34;http://boostcon.boost.org/program/speakers#sumant-tambe&#34; target=&#34;_blank&#34;&gt;Sumant Tambe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track I 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/mon/leesa_boostcon.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/mon/leesa_boostcon.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/toward-native-xml-processing-using-multi-paradigm-design-in-c-5254288&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/toward-native-xml-processing-using-multi-paradigm-design-in-c-5254288&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XMLプログラミングは、抽象、分割、プログラミングスタイル、およびイディオムの、それ自身の規則によって強力なデータ処理パラダイムとして出現した。経験を積んだXMLプログラマが求めるものは、それらの生産性がXMLプログラミングのドメイン固有パターンとプラクティスの使用を許可する言語とツールの有効性に依存する。しかし、これらのツールが与えられたXMLスキーマの静的に型付けされた、用語特化のオブジェクトモデル(vocabulary-specific object model)を自動的に生成するため、オブジェクト指向のコミュニティは専用XML言語よりもXMLデータバインディングツールを好む。不運にも、これらのツールはたいてい、純粋なオブジェクト指向の法則を使用して、XMLプログラミングの抽象的概念を統合する際の困難さのために、経験を積んだXMLプログラマの期待するものを避ける。この話は、C++のマルチパラダイムプログラミング能力の新たな適用によって、この普及しているギャップがどのように縮小されるのかを実証する。項目として、ジェネリックプログラミング、メタプログラミング、ジェネレーティブプログラミング、戦略プログラミング(strategic programming)、およびC++によってサポートされた演算子オーバーロードがネイティブで型付けされたXMLプログラミングをどのようにともに可能にするのかを話す。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon/2011.html#why-cpp0x-is-awesomest-network-programming&#34; name=&#34;why-cpp0x-is-awesomest-network-programming&#34;&gt;C++0xはなぜネットワークプログラミングのための、最高の中の最高の言語なのか&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Why C++0x is the Awesomest Language for Network Programming&lt;/li&gt;
&lt;li&gt;スピーカー ： &lt;a href=&#34;http://boostcon.boost.org/program/speakers#christopher-kohlhoff&#34; target=&#34;_blank&#34;&gt;Christopher Kohlhoff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;形式 ： チュートリアル&lt;/li&gt;
&lt;li&gt;トラック ： Track II 2011&lt;/li&gt;
&lt;li&gt;発表資料 : &lt;a href=&#34;https://github.com/boostcon/2011_presentations/raw/master/thu/Awesomest.pdf&#34; target=&#34;_blank&#34;&gt;https://github.com/boostcon/2011_presentations/raw/master/thu/Awesomest.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;発表ビデオ : &lt;a href=&#34;http://blip.tv/boostcon/why-c-0x-is-the-awesomest-language-for-network-programming-5368225&#34; target=&#34;_blank&#34;&gt;http://blip.tv/boostcon/why-c-0x-is-the-awesomest-language-for-network-programming-5368225&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;警告 ： これは臆病な人のための話ではない。最先端の言語機能があり、ハックがあり、言語の乱用があるだろう。このセッションは椅子を投げておわるかもしれない。&lt;/p&gt;
&lt;p&gt;スリルを求めるオタクにとって、それは楽しい旅であるべきだ。我々は、新たなC++0x言語とライブラリ機能のうちいくつかがどのように大きな位置を占めるのかを見ていく。また、いくつかのそれと古いものは、簡潔で、表現力があり、効率的なネットワークプログラムを作るためにBoost.Asioと連携することができる。&lt;/p&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, Norihisa Fujita, zak, DigitalGhost&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost 1.55.0 リリースノート -- Boost 1.55.0リリースノート： 表示崩れを修正</title>
      <link href="http://boostjp.github.io/document/version/1_55_0.html"/>
      <id>d4d57e777b8c661031baa49bf084a6d7669b28ce:document/version/1_55_0.md</id>
      <updated>2015-04-22 15:42:15 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost 1.55.0 リリースノート&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;本家リリースノート：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/svn/boost/website/public_html/live/feed/history/boost_1_55_0.qbk&#34; target=&#34;_blank&#34;&gt;https://svn.boost.org/svn/boost/website/public_html/live/feed/history/boost_1_55_0.qbk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/users/history/version_1_55_0.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/users/history/version_1_55_0.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Predef&lt;ul&gt;
&lt;li&gt;Rene Rivera氏作のこのライブラリには、C、C++、Objective C、Objective C++で提供されているマクロや、それらに存在するヘッダ内で定義されているマクロをまとめた情報をもとに、コンパイラやアーキテクチャ、OS、ライブラリ、その他のヴァージョン番号がひととおり定義されている。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ライブラリ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#accumulators&#34;&gt;Accumulators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#any&#34;&gt;Any&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#asio&#34;&gt;Asio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#atomic&#34;&gt;Atomic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#chrono&#34;&gt;Chrono&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#circular-buffer&#34;&gt;Circular Buffer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#config&#34;&gt;Config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#container&#34;&gt;Container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#context&#34;&gt;Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#coroutine&#34;&gt;Coroutine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#filesystem&#34;&gt;Filesystem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#fusion&#34;&gt;Fusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#geometry&#34;&gt;Geometory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#graph&#34;&gt;Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#hash&#34;&gt;Hash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#interprocess&#34;&gt;Interprocess&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#intrusive&#34;&gt;Intrusive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#lexical-cast&#34;&gt;Lexical cast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#log&#34;&gt;Log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#math&#34;&gt;Math&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#move&#34;&gt;Move&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#multiprecision&#34;&gt;Multiprecision&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#multi-index&#34;&gt;Multi-index Containers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#mpi&#34;&gt;MPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#phoenix&#34;&gt;Phoenix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#polygon&#34;&gt;Polygon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#property-map&#34;&gt;PropertyMap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#rational&#34;&gt;Rational&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#smart-pointer&#34;&gt;SmartPtr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#thread&#34;&gt;Thread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#timer&#34;&gt;Timer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#type-traits&#34;&gt;Type Traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#unordered&#34;&gt;Unordered&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#utility&#34;&gt;Utility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#variant&#34;&gt;Variant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#wave&#34;&gt;Wave&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#xpressive&#34;&gt;Xpressive&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;更新ツール&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Quickbook(#quickbook)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ニュース&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本バージョンよりいくつかの古いコンパイラのサポートが終了した&lt;/li&gt;
&lt;li&gt;新しくサポートされる最低環境は以下の通り。なお他のコンパイラに変更はない&lt;ul&gt;
&lt;li&gt;Digitial Mars 8.41&lt;/li&gt;
&lt;li&gt;GCC 3.3&lt;/li&gt;
&lt;li&gt;Intel 6.0&lt;/li&gt;
&lt;li&gt;Visual C++ 7.1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;なお、更に以下のコンパイラのサポートを終了することも考えている。もし使用しているのであればメーリングリストで知らせてほしい&lt;ul&gt;
&lt;li&gt;Metrowoks C++ (ie. codewarrior)&lt;/li&gt;
&lt;li&gt;SunPro 5.3 またはそれ以前&lt;/li&gt;
&lt;li&gt;Borland C++ Builder 2006 (bcc 5.82) またはそれ以前&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Visual Studio 2013／Visual C++ 12.0での既知の問題&lt;/h2&gt;
&lt;p&gt;Visual Studio 2013がリリースされた時期が、Boostのリリースプロセスの遅い段階であったため、いくつかの未解決問題が存在する。これは以下の通り：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serializationがコンパイルできない。&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;のインクルードが不足しているためである。&lt;/li&gt;
&lt;li&gt;Boost.Containerの&lt;code&gt;allocator_traits&lt;/code&gt;から&lt;code&gt;has_member_function_callable_with&lt;/code&gt;を使用するとコンパイルエラーになる(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9332&#34; target=&#34;_blank&#34;&gt;#9332&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;いくつかのライブラリで&lt;code&gt;initializer_list&lt;/code&gt;のオーバーロードが曖昧になり、コンパイルエラーになる。これはVisual C++のバグであり、現在有効な回避策は見つかっていない。UnorderedとMulti-Indexの関数オーバーロードでその問題が発生する。&lt;/li&gt;
&lt;li&gt;Threadの&lt;code&gt;ex_scoped_thread&lt;/code&gt;がコンパイルに失敗する(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9333&#34; target=&#34;_blank&#34;&gt;#9333&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#accumulators&#34; name=&#34;accumulators&#34;&gt;Accumulators&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ドキュメントの誤字を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7915&#34; target=&#34;_blank&#34;&gt;#7915&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;MSVCでの警告を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8850&#34; target=&#34;_blank&#34;&gt;#8850&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;average&lt;/code&gt;を&lt;code&gt;fdiv&lt;/code&gt;に名称変更 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8262&#34; target=&#34;_blank&#34;&gt;#8262&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#any&#34; name=&#34;any&#34;&gt;Any&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bad_any_cast&lt;/code&gt;を、モジュール間で見えるようにした (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8751&#34; target=&#34;_blank&#34;&gt;#8751&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clear()&lt;/code&gt;メンバ関数を追加&lt;/li&gt;
&lt;li&gt;不足していた&lt;code&gt;BOOST_NOEXCEPT&lt;/code&gt;を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt; rvaluesの問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9215&#34; target=&#34;_blank&#34;&gt;#9215&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#asio&#34; name=&#34;asio&#34;&gt;Asio&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Windowsランタイム向けに、限定的なポートを実装した。このサポートは、言語拡張機能を有効にする必要がある。ポートはWindowsランタイムAPIによって公開される制限機能により、以下の制限事項も付いてくる：&lt;ul&gt;
&lt;li&gt;コア機能である&lt;code&gt;io_service&lt;/code&gt;、&lt;code&gt;strand&lt;/code&gt;、バッファ、複合操作、タイマー等は、今まで通り動作する。&lt;/li&gt;
&lt;li&gt;ソケットは、クライアントTCP側のみサポートする。&lt;/li&gt;
&lt;li&gt;クライアント側TCPソケットの明示的なバインディングは、サポートされない。&lt;/li&gt;
&lt;li&gt;ソケットでは&lt;code&gt;cancel()&lt;/code&gt;関数をサポートしない。非同期操作は、クローズによってのみキャンセルを行うことになるだろう。&lt;/li&gt;
&lt;li&gt;null bufferを使用した操作はサポートされない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tcp::no_delay&lt;/code&gt;、&lt;code&gt;socket_base::keep_alive&lt;/code&gt;オプションのみサポートされる。&lt;/li&gt;
&lt;li&gt;名前解決はサーバー名をサポートせず、番号のみ。例として、&#34;http&#34;ではなく&#34;80&#34;を使用する必要がある。&lt;/li&gt;
&lt;li&gt;ほとんどの名前解決クエリフラグは、効果を持たない。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(Boost 1.54.0から導入された)レギュレッションテストを、いくつかの環境向けに修正。&lt;code&gt;async_connect()&lt;/code&gt;からのエラーが完了ハンドラに伝達されていなかった(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8795&#34; target=&#34;_blank&#34;&gt;#8795&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;(Boost 1.54.0から導入された)Windows向けの、&lt;code&gt;io_service&lt;/code&gt;が複数スレッドから着火されるケースのレギュレッションテストを修正。バグが発生した際、非同期操作の結果は正しくないとして破棄され、代わりに&lt;code&gt;0&lt;/code&gt;が使用されていた。TCPソケットでは、見かけ上(spurious)のファイル終端通知で起きていた(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8933&#34; target=&#34;_blank&#34;&gt;#8933&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;ハンドラトラッキングのバグを修正。いくつかのハンドラIDが正しく出力されていなかった(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8808&#34; target=&#34;_blank&#34;&gt;#8808&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;非同期&lt;code&gt;accept&lt;/code&gt;操作のテストに使用する比較がコンパイルエラーになっていた問題を修正。符号なしソケット記述子が正しく動作するようになった(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8752&#34; target=&#34;_blank&#34;&gt;#8752&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;すでに発生されたシグナルに対する&lt;code&gt;async_wait&lt;/code&gt;を開始した際、完了ハンドラにシグナル番号が正しく確実に渡されるようにした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8738&#34; target=&#34;_blank&#34;&gt;#8738&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;GCC 4.8の、未使用&lt;code&gt;typedef&lt;/code&gt;警告を抑制(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8980&#34; target=&#34;_blank&#34;&gt;#8980&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;default invocation hookで使用するハンドラの、ムーブ最適化を有効にした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8624&#34; target=&#34;_blank&#34;&gt;#8624&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;重複する&lt;code&gt;async_write_at&lt;/code&gt;操作を発行すべきではない問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8669&#34; target=&#34;_blank&#34;&gt;#8669&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Windowsの&lt;code&gt;HANDLE&lt;/code&gt;を、同期&lt;code&gt;read&lt;/code&gt;の&lt;code&gt;GetOverlappedResult&lt;/code&gt;によって返される、非致命的な&lt;code&gt;ERROR_MORE_DATA&lt;/code&gt;を取り扱うように変更。&lt;/li&gt;
&lt;li&gt;Visual C++は言語拡張として「&lt;code&gt;generic&lt;/code&gt;」をキーワードとして扱う。これを回避するために、名前空間名を&lt;code&gt;cpp_generic&lt;/code&gt;に変更。&lt;/li&gt;
&lt;li&gt;Boost 1.54でサポートされた&lt;code&gt;async_result&lt;/code&gt;の結果を取り逃すという、いくつかの非同期操作の問題を修正。とくに、buffer streamテンプレートを、現在のハンドラパターンに従うように更新した(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9000&#34; target=&#34;_blank&#34;&gt;#9000&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9001&#34; target=&#34;_blank&#34;&gt;#9001&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Visual Studio 2012向けに、ムーブサポートを有効にした(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8959&#34; target=&#34;_blank&#34;&gt;#8959&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;Visual Studio 2012向けに、&lt;code&gt;use_future&lt;/code&gt;サポートを追加した。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8758&#34; target=&#34;_blank&#34;&gt;#8758&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;いくつかの、不要なハンドラのコピーを排除した。&lt;/li&gt;
&lt;li&gt;その他、コードとドキュメントの小さな問題を修正した。&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8347&#34; target=&#34;_blank&#34;&gt;#8347&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8950&#34; target=&#34;_blank&#34;&gt;#8950&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8953&#34; target=&#34;_blank&#34;&gt;#8953&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8965&#34; target=&#34;_blank&#34;&gt;#8965&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8997&#34; target=&#34;_blank&#34;&gt;#8997&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#atomic&#34; name=&#34;atomic&#34;&gt;Atomic&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;x86ターゲットのGCC、MSVCおよびその互換コンパイラに対して、64ビットアトミック操作のサポートを追加。このサポートは、ターゲットCPUの要求するインストラクションがコンパイル時にわかる場合に有効になる&lt;/li&gt;
&lt;li&gt;x86-64ターゲットのGCCと互換コンパイラに対して、128ビットアトミック操作のサポートを追加。このサポートは、ターゲットCPUの要求するインストラクションがコンパイル時にわかる場合に有効になる。このサポートは、新たなマクロ&lt;code&gt;BOOST_ATOMIC_INT128_LOCK_FREE&lt;/code&gt;でテストできる&lt;/li&gt;
&lt;li&gt;GCC環境で、より効率的な&lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt;の実装を追加。これはGCC 4.7以降で導入された&lt;code&gt;__atomic*&lt;/code&gt;インストラクションを使用する&lt;/li&gt;
&lt;li&gt;ARM v7のサポートを追加。Thumb 2のサポートを改善&lt;/li&gt;
&lt;li&gt;GCCとその互換コンパイラに、x32ターゲットのサポートを追加(たとえば、64ビット x86で32ビットポインタを使用できるような環境)&lt;/li&gt;
&lt;li&gt;Boost.Threadへの依存を削除&lt;/li&gt;
&lt;li&gt;False Sharingを避けるために、内部的なロックプールに適切なパディングとアラインメントが含まれるようになった&lt;/li&gt;
&lt;li&gt;Windows上のIntelコンパイラのコンパイル問題を修正。Windows上の重複した内部マクロを削除&lt;/li&gt;
&lt;li&gt;いくつかのコードを、使用可能な場合にC++11機能を使用するようリファクタリング&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#chrono&#34; name=&#34;chrono&#34;&gt;Chrono&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.52と1.53でchrono_ioが文字列を正しくパースできていない問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7868&#34; target=&#34;_blank&#34;&gt;#7868&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/chrono/stopwatches/formatters/base_formatter.hpp&lt;/code&gt;のtypoを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9028&#34; target=&#34;_blank&#34;&gt;#9028&lt;/a&gt;)&lt;ul&gt;
&lt;li&gt;[訳者註]: &lt;code&gt;=&lt;/code&gt;とするべきところ&lt;code&gt;==&lt;/code&gt;としていたため、&lt;code&gt;duration_style&lt;/code&gt;を変更出来ないでいた&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;std::tmを初期化していなかったのを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9147&#34; target=&#34;_blank&#34;&gt;#9147&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#circular-buffer&#34; name=&#34;circular-buffer&#34;&gt;Circular Buffer&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Moveによりムーブセマンティクスをサポートした (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7888&#34; target=&#34;_blank&#34;&gt;#7888&lt;/a&gt;)&lt;ul&gt;
&lt;li&gt;これによりCircular Bufferはムーブ可能かつコピー不可能な型をサポートする&lt;/li&gt;
&lt;li&gt;ただし&lt;code&gt;noexcept&lt;/code&gt;なムーブコンストラクタかつムーブ代入演算子の両方が実装されている必要がある&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ドキュメントの改良&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BOOST_NO_EXCEPTIONS&lt;/code&gt;指定されているとコンパイル出来ない問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5362&#34; target=&#34;_blank&#34;&gt;#5362&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;不要な&lt;code&gt;const&lt;/code&gt;に対する警告を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7025&#34; target=&#34;_blank&#34;&gt;#7025&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;MSVCにおいて、Circular Buffer以外で定義されたコンマ演算子によって警告が出るのを抑制 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7950&#34; target=&#34;_blank&#34;&gt;#7950&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#config&#34; name=&#34;config&#34;&gt;Config&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;破壊的変更&lt;/strong&gt;： 古いコンパイラのサポートを終了した&lt;/li&gt;
&lt;li&gt;新しいサポート対象は以下のバージョン及びそれ以後のみである。なお、他のコンパイラに変更はない&lt;ul&gt;
&lt;li&gt;Digital Mars 8.41&lt;/li&gt;
&lt;li&gt;GCC 3.3&lt;/li&gt;
&lt;li&gt;Intel C++ 6.0&lt;/li&gt;
&lt;li&gt;Visual C++ 7.1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#config&#34; name=&#34;container&#34;&gt;Container&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SCARYイテレータを実装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flat_set&lt;/code&gt;と&lt;code&gt;flat_map&lt;/code&gt;のイテレータがランダムアクセスイテレータであることが言及されていないのを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8269&#34; target=&#34;_blank&#34;&gt;#8269&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;clangの&lt;code&gt;-Wimplicit-fallthrough&lt;/code&gt;によってswitch-caseでwarningが出力されるのを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8473&#34; target=&#34;_blank&#34;&gt;#8473&lt;/a&gt;)&lt;ul&gt;
&lt;li&gt;[訳者註] warningを抑制する&lt;code&gt;BOOST_FALLTHROUGH&lt;/code&gt;マクロが (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8408&#34; target=&#34;_blank&#34;&gt;#8408&lt;/a&gt;) で提案されている。用例は次の通り：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;switch&lt;/span&gt; (cond) {
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;case&lt;/span&gt; A:
    ... ;
    BOOST_FALLTHROUGH;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;case&lt;/span&gt; B:
    ... ;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;break&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++11で&lt;code&gt;std::map&lt;/code&gt;に新規追加されたコンストラクタと同様のものを追加 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8892&#34; target=&#34;_blank&#34;&gt;#8892&lt;/a&gt;)&lt;ul&gt;
&lt;li&gt;[訳者註] 例えば次のようなものである&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;explicit&lt;/span&gt; flat_map( &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Allocator &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;a )
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flat_set::insert&lt;/code&gt;の呼び出しが曖昧になっていた問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9009&#34; target=&#34;_blank&#34;&gt;#9009&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scoped_allocator_adaptor&lt;/code&gt;とともに使用した場合、コピーでSEGVる問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9064&#34; target=&#34;_blank&#34;&gt;#9064&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ソート済みの非ユニークなシーケンスをflat_setに挿入するとクラッシュする問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9092&#34; target=&#34;_blank&#34;&gt;#9092&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flat_multimap::insert(itr,itr)&lt;/code&gt;でリークする問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9108&#34; target=&#34;_blank&#34;&gt;#9108&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#context&#34; name=&#34;context&#34;&gt;Context&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;スタックが正しくアラインメントされていないことにより、SSE2のIntrinsic命令によってセグメンテーションフォルトが起きる問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8650&#34; target=&#34;_blank&#34;&gt;#8650&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#coroutine&#34; name=&#34;coroutine&#34;&gt;Coroutine&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新しいインターフェイス(unidirectional data transfer)を追加&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_55_0/libs/coroutine/doc/html/unidirect.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_55_0/libs/coroutine/doc/html/unidirect.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;所謂Generatorの実装である。以下に簡単なコード例を示す&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;coroutines&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;coroutine&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;pull_type gen(
    [](boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;coroutines&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;coroutine&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;push_type &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;yield)
    {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; {&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;}) yield(i);
    });
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;…&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; gen) std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;これまでのように&lt;code&gt;coroutine&lt;/code&gt;の&lt;code&gt;caller&lt;/code&gt;から&lt;code&gt;callee&lt;/code&gt;に値を渡すことができない単方向(unidirectional)のインターフェイスとなる&lt;/p&gt;
&lt;p&gt;このインターフェイスを実装したことにより、従来の双方向なインターフェイスは &lt;strong&gt;非推奨&lt;/strong&gt; となった
ただし、&lt;code&gt;BOOST_COROUTINES_OLD&lt;/code&gt;マクロを定義することで古いインターフェイスも従来通り使用可能となる。
- Jamfile.v2でのターゲット名が間違っていることによって、ビルドができない問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8782&#34; target=&#34;_blank&#34;&gt;#8782&lt;/a&gt;)
- Windows環境でのauto-linkを有効にした (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8801&#34; target=&#34;_blank&#34;&gt;#8801&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#filesystem&#34; name=&#34;filesystem&#34;&gt;Filesystem&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Android環境でコンパイルエラーになる問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8706&#34; target=&#34;_blank&#34;&gt;#8706&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#fusion&#34; name=&#34;fusion&#34;&gt;Fusion&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fusion::map&lt;/code&gt;の&lt;code&gt;convert&lt;/code&gt;がコンパイルエラーになる問題を修正。&lt;code&gt;map_tag&lt;/code&gt;に対する&lt;code&gt;convert_impl&lt;/code&gt;の特殊化を実装 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8759&#34; target=&#34;_blank&#34;&gt;#8759&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#geometry&#34; name=&#34;geometry&#34;&gt;Geometry&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;機能追加&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;centroid()&lt;/code&gt;に、&lt;code&gt;segment type&lt;/code&gt;のサポートを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intersects()&lt;/code&gt;と&lt;code&gt;disjoints()&lt;/code&gt;に、Segment-BoxとLinestring-Boxのサポートを追加&lt;/li&gt;
&lt;li&gt;パッキングアルゴリズムを使用した&lt;code&gt;rtee&lt;/code&gt;の作成を追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;contains()&lt;/code&gt;と&lt;code&gt;covers()&lt;/code&gt;に、空間クエリ述語(spatial query predicates)を追加&lt;/li&gt;
&lt;li&gt;イテレーティブクエリを追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;いくつかのケースで、コンセプトに違反して&lt;code&gt;.back()&lt;/code&gt;と&lt;code&gt;.clear()&lt;/code&gt;が呼ばれていた。報告された例を修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cart_intersect&lt;/code&gt;、&lt;code&gt;get_turn_info&lt;/code&gt;、&lt;code&gt;handle_tangencies&lt;/code&gt;、&lt;code&gt;enrich_intersection_info&lt;/code&gt;で、一貫性のあるサイド情報を使用するようにした。これは(必要に応じて)6ポイントのみの整数、4 or 3セグメント上でのズームに切り替えることによって行われる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解決したチケット&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;スパイクによって引き起こされる、Intersectionで自己交差が生成される問題を修正した (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/6958&#34; target=&#34;_blank&#34;&gt;#6958&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;直前ステップのスパイクによって引き起こされる、不正な入力例外(invalid input exception)問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8364&#34; target=&#34;_blank&#34;&gt;#8364&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8365&#34; target=&#34;_blank&#34;&gt;#8365&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::geometry::model::point&lt;/code&gt;の単一引数コンストラクタに、&lt;code&gt;explicit&lt;/code&gt;を付けた (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8969&#34; target=&#34;_blank&#34;&gt;#8369&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ドキュメントにメンバ変数が記載されるよう、doxygen_xml2qbkツールを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8825&#34; target=&#34;_blank&#34;&gt;#8825&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;スパイクによって引き起こされる、triangle-triangleのintersectionが失敗する問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8652&#34; target=&#34;_blank&#34;&gt;#8652&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;boost/geometry/strategies/intersection.hpp&amp;gt;&lt;/code&gt;が自身のファイルをインクルードしていたので修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9047&#34; target=&#34;_blank&#34;&gt;#9047&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#graph&#34; name=&#34;graph&#34;&gt;Graph&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;バンドルプロパティとして&lt;code&gt;void&lt;/code&gt;型は許可していなかったが、指定できてしまっていた(たとえば、&lt;code&gt;VertexProperties&lt;/code&gt;テンプレートパラメータへのグラフ型指定で)。現在は、静的アサートで完全に禁止した。代わりに&lt;code&gt;boost::no_property&lt;/code&gt;を使用すること&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depth_first_search&lt;/code&gt;に、ビジターイベントポイント&lt;code&gt;finish_edge&lt;/code&gt;のサポートを追加。この変更は、そのメンバ関数を持たないビジターとの下位互換性を持つ (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/5269&#34; target=&#34;_blank&#34;&gt;#5269&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Sunコンパイラでのビルドテストを無効にした&lt;/li&gt;
&lt;li&gt;マルチソース頂点のサポートを、非名前付きパラメータ版の&lt;code&gt;breadth_first_visit&lt;/code&gt;、&lt;code&gt;breadth_first_search&lt;/code&gt;、&lt;code&gt;dijkstra_shortest_paths&lt;/code&gt;、&lt;code&gt;dijkstra_shortest_paths_no_init&lt;/code&gt;に追加した。これはまだドキュメントに記載していない。これを使用する場合は、それらの関数の単一頂点パラメータを、同じ型を指す2つのInput Iteratorで置き換える&lt;/li&gt;
&lt;li&gt;Louis Dionneのコントリビュートにより、Hawick circuitsアルゴリズムを追加した (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8433&#34; target=&#34;_blank&#34;&gt;#8433&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Maciej Piechotkaのコントリビュートにより、edge coloringアルゴリズムを追加した (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8317&#34; target=&#34;_blank&#34;&gt;#8317&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Piotr Wygockiのコントリビュートにより、min-cost max-flowアルゴリズムを追加した&lt;/li&gt;
&lt;li&gt;以下のバグ、および機能リクエストを修正した：&lt;ul&gt;
&lt;li&gt;ヘッダーファイルのインクルード順に依存していた問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8791&#34; target=&#34;_blank&#34;&gt;#8791&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;GCCでの未使用変数警告を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8877&#34; target=&#34;_blank&#34;&gt;#8877&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8986&#34; target=&#34;_blank&#34;&gt;#8986&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prim_minimum_spanning_tree&lt;/code&gt;に、辺の重みとして負の値を入れると、予期しないエラーが発生する問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9012&#34; target=&#34;_blank&#34;&gt;#9012&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dijkstra_shortest_paths&lt;/code&gt;の擬似コードが間違っていたので修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9080&#34; target=&#34;_blank&#34;&gt;#9080&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#hash&#34; name=&#34;hash&#34;&gt;Hash&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sunコンパイラが複雑なSFINAE構文をコンパイル出来なかった問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8822&#34; target=&#34;_blank&#34;&gt;#8822&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;SVCで無限ループとして推論され警告されてしまうのを抑制 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8568&#34; target=&#34;_blank&#34;&gt;#8568&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#interprocess&#34; name=&#34;interprocess&#34;&gt;Interprocess&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSVCのSTLの実装の問題によりリークする問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7156&#34; target=&#34;_blank&#34;&gt;#7156&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;interprocess::shared_ptr&lt;/code&gt;の代入演算子の実装の問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7164&#34; target=&#34;_blank&#34;&gt;#7164&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ドキュメントの修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8277&#34; target=&#34;_blank&#34;&gt;#8277&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;GCCにてコンパイルできない問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8976&#34; target=&#34;_blank&#34;&gt;#8976&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;マルチプロセスなブラウザを開くと&lt;code&gt;condition_variable&lt;/code&gt;が加速する問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9008&#34; target=&#34;_blank&#34;&gt;#9008&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;PPCのCASに渡す引数の順番が正しくなかったのを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9065&#34; target=&#34;_blank&#34;&gt;#9065&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;MSVCにて&lt;code&gt;realloc&lt;/code&gt;という関数が意図しないマクロ置き換えされるのを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9073&#34; target=&#34;_blank&#34;&gt;#9073&lt;/a&gt;)&lt;ul&gt;
&lt;li&gt;[訳者註] この&lt;code&gt;realloc&lt;/code&gt;は標準の&lt;code&gt;realloc&lt;/code&gt;ではなく、Interprocessの内部で定義される関数である&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#intrusive&#34; name=&#34;intrusive&#34;&gt;Intrusive&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;破壊的変更&lt;/strong&gt;&lt;/span&gt; &lt;code&gt;splay&lt;/code&gt;コンテナの &lt;code&gt;xxx_dont_splay&lt;/code&gt;関数を廃止した。また、&lt;code&gt;splay_set_hook&lt;/code&gt;も廃止した。この代替として、&lt;code&gt;bs_set_hook&lt;/code&gt;を利用すること。いずれもBoost 1.56で削除予定である&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;ABI変更&lt;/strong&gt;&lt;/span&gt; ハッシュコンテナの&lt;code&gt;end&lt;/code&gt;イテレータがバケット配列の&lt;code&gt;end&lt;/code&gt;よりひとつ後ろを指すよう実装されていた (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8698&#34; target=&#34;_blank&#34;&gt;#8698&lt;/a&gt;)。このため、バケット配列の隣に値を挿入したときにひどいバグが発生していた。&lt;code&gt;end&lt;/code&gt;イテレータはバケット配列の先頭を指すように修正した&lt;/li&gt;
&lt;li&gt;テンプレートおよびデバッグシンボルの削減のために大規模なリファクタリングを行った。MSVCのデバッグモードで生成されるテストオブジェクトファイルサイズが約半分になった。Identical COMDAT Folding (ICF)がないコンパイラでもサイズ削減に寄与するはずである&lt;/li&gt;
&lt;li&gt;SCARYイテレータを実装した &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#lexical-cast&#34; name=&#34;lexical-cast&#34;&gt;Lexical cast&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::bad_alloc&lt;/code&gt;例外は&lt;code&gt;boost::bad_lexical_cast&lt;/code&gt;に変換されなくなった。(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8966&#34; target=&#34;_blank&#34;&gt;#8966&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::numeric_limits&lt;/code&gt;の128bit整数型に対する特殊化された値が変換のために必要になった場合に、それをチェックする&lt;code&gt;static assert&lt;/code&gt;を追加。128bit整数型をサポートしているかどうかを判定するために&lt;code&gt;BOOST_HAS_INT128&lt;/code&gt;を使用するように変更。(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8790&#34; target=&#34;_blank&#34;&gt;#8790&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ドキュメントを改善し、さらに多くの使用例を追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#log&#34; name=&#34;log&#34;&gt;Log&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;修正点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BOOST_LOG_WITHOUT_DEFAULT_FACTORIES&lt;/code&gt;環境設定マクロを追加した。このマクロを定義すると、設定パーサでのフォーマッタファクトリとデフォルトフィルタのコンパイルをしないようになる。これにより、設定パーサのサポートを維持したままバイナリサイズを削減できる可能性がある&lt;/li&gt;
&lt;li&gt;パーサを書きなおして生成されるバイナリサイズを削減した。この修正により、あいまいな入力や正しくない入力の検出精度が向上し、より堅牢になった&lt;/li&gt;
&lt;li&gt;以下のヘッダを廃止予定にした。これらのヘッダは将来のリリースで削除される。また、内容については他のライブラリに移譲した&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost/log/utility/intrusive_ref_counter.hpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/log/utility/explicit_operator_bool.hpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/log/utility/empty_deleter.hpp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows上で&lt;code&gt;QueryPerformanceCounter&lt;/code&gt; APIを利用した場合、激しいスレッド間競合により、&lt;code&gt;timer&lt;/code&gt;アトリビュートが間違った時間になってしまう問題を修正&lt;/li&gt;
&lt;li&gt;パース済みフィルターとあるアトリビュートの組み合わせを防止するフィルターパーサのバグを修正&lt;/li&gt;
&lt;li&gt;デフォルトシンクとフォーマッタ間でスレッドIDの書式が違う問題を修正&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;完了したチケット&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android上で&lt;code&gt;posix_memalign&lt;/code&gt;が宣言されていない (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/8815&#34; target=&#34;_blank&#34;&gt;#8815&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Mingw w64上でコンパイルできない (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/8819&#34; target=&#34;_blank&#34;&gt;#8819&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/log/detail/spin_mutex.hpp&lt;/code&gt;が&lt;code&gt;pthread_&lt;/code&gt;系関数からのエラーを完全に無視している (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/8915&#34; target=&#34;_blank&#34;&gt;#8915&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libs/log/src/once_block.cpp&lt;/code&gt;が&lt;code&gt;pthread_&lt;/code&gt;系関数からのエラーをほとんど無視している (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/8917&#34; target=&#34;_blank&#34;&gt;#8917&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Sun Studio 12.3で&lt;code&gt;attribute_value_set.cpp&lt;/code&gt;がコンパイルできない (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/9139&#34; target=&#34;_blank&#34;&gt;#9139&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Sun Studio 12.3で&lt;code&gt;boost/log/detail/snprintf.hpp&lt;/code&gt;が&lt;code&gt;snprintf&lt;/code&gt;と&lt;code&gt;vsnprintf&lt;/code&gt;が定義されていないためコンパイルできない (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/9140&#34; target=&#34;_blank&#34;&gt;#9140&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Sun Studio 12.3で&lt;code&gt;boost::log::aux::light_function&lt;/code&gt;がビルドできない (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/9153&#34; target=&#34;_blank&#34;&gt;#9153&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;solaris studio 12.3でstlport4を利用するとき、&lt;code&gt;&amp;lt;cstudio&amp;gt;&lt;/code&gt;をインクルードすれば&lt;code&gt;fflush&lt;/code&gt;は&lt;code&gt;std&lt;/code&gt;名前空間にあるが、&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;をインクルードしても&lt;code&gt;std&lt;/code&gt;名前空間にある(&lt;code&gt;using&lt;/code&gt;しているだけ)ので、&lt;code&gt;std::&lt;/code&gt;を指定しなければならない (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/9155&#34; target=&#34;_blank&#34;&gt;#9155&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;詳細は&lt;a href=&#34;http://www.boost.org/libs/log/doc/html/log/changelog.html&#34; target=&#34;_blank&#34;&gt;変更履歴&lt;/a&gt;を参照のこと&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#math&#34; name=&#34;math&#34;&gt;Math&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多数の警告を抑制。（主にGCC-4.8とMSVCからのもの）(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8384&#34; target=&#34;_blank&#34;&gt;#8384&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8855&#34; target=&#34;_blank&#34;&gt;#8855&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9107&#34; target=&#34;_blank&#34;&gt;#9107&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9109&#34; target=&#34;_blank&#34;&gt;#9109&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;PGIでのコンパイルエラーを修正。 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8333&#34; target=&#34;_blank&#34;&gt;#8333&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;PGIで、&lt;code&gt;erf&lt;/code&gt;関数が不正な値を生成する原因となる、定数初期化の問題を修正。 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8621&#34; target=&#34;_blank&#34;&gt;#8621&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;C++の関数と同じ名前で定義されているC99のいくつかのマクロでマクロ展開されてしまうのを防止。 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8732&#34; target=&#34;_blank&#34;&gt;#8732&lt;/a&gt;, &lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8733&#34; target=&#34;_blank&#34;&gt;#8733&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;自由度が巨大な（&lt;code&gt;integer&lt;/code&gt;で表現可能な値よりも大きな）場合でもStudentのT分布が正しく振る舞うように修正。(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8873&#34; target=&#34;_blank&#34;&gt;#8873&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;プラットフォームで&lt;code&gt;long double&lt;/code&gt;がサポートされていない場合でも、いくつかのコア関数で&lt;code&gt;long double&lt;/code&gt;が使用できるようにした。(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8940&#34; target=&#34;_blank&#34;&gt;#8940&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;確率変数が無限大の時に不正な尺度母数や位置母数のエラーを捕捉できるように、分布関数のエラーハンドリングを修正。(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9126&#34; target=&#34;_blank&#34;&gt;#9126&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Intel C++ 14の不完全な&lt;code&gt;&amp;lt;tuple&amp;gt;&lt;/code&gt;のためのワークアラウンドを追加。(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9083&#34; target=&#34;_blank&#34;&gt;#9083&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;楕円積分の中で行われる、引数を約分する処理の整合性を向上。(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9104&#34; target=&#34;_blank&#34;&gt;#9104&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ベータ関数がarcsineもしくはStudentのT分布である時に、逆不完全ベータ関数の結果で桁落ちが発生してしまうバグを修正。([訳注]：訳に自信ないのでダブルチェックお願いします)&lt;/li&gt;
&lt;li&gt;一種のベッセル関数ならびにK関数の連分数で擬似的な(Spurious)オーバーフローやアンダーフローが発生する問題を修正。([訳注]：訳に自信ないのでダブルチェックお願いします)&lt;/li&gt;
&lt;li&gt;Thomas Luuによる、非中央のカイ二乗分布変位値の改善を追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#move&#34; name=&#34;move&#34;&gt;Move&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ドキュメントの誤りを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7952&#34; target=&#34;_blank&#34;&gt;#7952&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;MoveのTraitsを改善 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8764&#34; target=&#34;_blank&#34;&gt;#8764&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::move&lt;/code&gt;と&lt;code&gt;boost::forward&lt;/code&gt;に&lt;code&gt;noexcept&lt;/code&gt;指定をつけた (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8765&#34; target=&#34;_blank&#34;&gt;#8765&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;C++98/03で&lt;code&gt;BOOST_MOVABLE_BUT_NOT_COPYABLE&lt;/code&gt;マクロを適用すると正しく動作しない問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8842&#34; target=&#34;_blank&#34;&gt;#8842&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost/move/algorithm.hpp&lt;/code&gt;で自身をインクルードしていた (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8979&#34; target=&#34;_blank&#34;&gt;#8979&lt;/a&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#msm&#34; name=&#34;msm&#34;&gt;Meta State Machine&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新機能&lt;/strong&gt; : interrupt stateは中断を終了させるためのイベント列をサポートした。&lt;/li&gt;
&lt;li&gt;例外を無効にしたgcc-4.2でコンパイルが通らなかった問題を修正。(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8686&#34; target=&#34;_blank&#34;&gt;#8686&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#multiprecision&#34; name=&#34;multiprecision&#34;&gt;Multiprecision&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Serialization サポートの追加&lt;/li&gt;
&lt;li&gt;GCC による警告を抑制 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8872&#34; target=&#34;_blank&#34;&gt;#8872&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pow&lt;/code&gt; の引数に大きな値を設定した際に発生するバグを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8809&#34; target=&#34;_blank&#34;&gt;#8809&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pow&lt;/code&gt; で &lt;code&gt;0&lt;/code&gt; のべき乗を計算した場合のバグを修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8798&#34; target=&#34;_blank&#34;&gt;#8798&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpp_int&lt;/code&gt; の IO で &lt;code&gt;CHAR_BIT&lt;/code&gt; 以下の値の出力 (文字列への変換) が正常に行われていなかった問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8745&#34; target=&#34;_blank&#34;&gt;#8745&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpp_int&lt;/code&gt; で固定サイズのときに左シフトをするとオーバフローが発生する問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8741&#34; target=&#34;_blank&#34;&gt;#8741&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpp_int&lt;/code&gt; で発生する警告を抑制 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8748&#34; target=&#34;_blank&#34;&gt;#8748&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;C99 のマクロが必要になる関数を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8732&#34; target=&#34;_blank&#34;&gt;#8732&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpp_int&lt;/code&gt; で &lt;code&gt;INT_MIN&lt;/code&gt;, &lt;code&gt;LONG_MIN&lt;/code&gt; 等の構築が失敗する問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8711&#34; target=&#34;_blank&#34;&gt;#8711&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#multi-index&#34; name=&#34;multi-index&#34;&gt;Multi-Index Container&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.MultiIndexのC++11標準準拠度向上&lt;ul&gt;
&lt;li&gt;&lt;code&gt;multi_index_container&lt;/code&gt;を効率的にムーヴできるようになった&lt;/li&gt;
&lt;li&gt;Initializer listのサポート&lt;/li&gt;
&lt;li&gt;&lt;code&gt;emplace&lt;/code&gt;系関数のサポート&lt;/li&gt;
&lt;li&gt;コピー不可の要素(&lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt;など)をサポート。また、要素と互換性のある型のイテレータについて、無駄なコピーをせず、&lt;code&gt;[first,last)&lt;/code&gt;の形式で範囲挿入できるようになった&lt;/li&gt;
&lt;li&gt;ランダムアクセスインデックスへの&lt;code&gt;shrink_to_fit()&lt;/code&gt;実装&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11以前のコンパイラでの制限については&lt;a href=&#34;http://www.boost.org//libs/multi_index/doc/compiler_specifics.htmll&#34; target=&#34;_blank&#34;&gt;compiler specifics&lt;/a&gt;参照のこと&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以下のクラスは&lt;strong&gt;非推奨&lt;/strong&gt;になった：&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/libs/multi_index/doc/reference/key_extraction.html#member_offset&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;member_offset&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/libs/multi_index/doc/reference/key_extraction.html#const_mem_fun_explicit&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;const_mem_fun_explicit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/libs/multi_index/doc/reference/key_extraction.html#const_mem_fun_explicit&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;mem_fun_explicit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/libs/multi_index/doc/reference/key_extraction.html#composite_key_result_equal_to&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;composite_key_result_equal_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/libs/multi_index/doc/reference/key_extraction.html#composite_key_result_less&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;composite_key_result_less&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/libs/multi_index/doc/reference/key_extraction.html#composite_key_result_greater&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;composite_key_result_greater&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/libs/multi_index/doc/reference/key_extraction.html#composite_key_result_hash&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;composite_key_result_hash&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;その他修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#mpi&#34; name=&#34;mpi&#34;&gt;MPI&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MPI の非推奨な関数を入れ替え&lt;/li&gt;
&lt;li&gt;マルチスレッド初期化のサポートを追加&lt;/li&gt;
&lt;li&gt;in-prace collectives の追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#phoenix&#34; name=&#34;phoenix&#34;&gt;Phoenix&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;phonenix::funcion&lt;/code&gt;のコンストラクタを&lt;code&gt;constexpr&lt;/code&gt;にした (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9049&#34; target=&#34;_blank&#34;&gt;#9049&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#polygon&#34; name=&#34;polygon&#34;&gt;Polygon&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sebastien Loriotによるパッチで、VoronoiベンチマークのCGAL部分を更新した。&lt;/li&gt;
&lt;li&gt;(Intelからのパッチにより、)&lt;code&gt;polygon_90_set_data&lt;/code&gt;に多角形分解機能(polygon decomposition capability)を追加した。&lt;/li&gt;
&lt;li&gt;Tracチケットのバグ修正：&lt;ul&gt;
&lt;li&gt;Polygonと&lt;code&gt;range/algorithm&lt;/code&gt;が衝突する問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8197&#34; target=&#34;_blank&#34;&gt;#8197&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#property-map&#34; name=&#34;property-map&#34;&gt;Property Map&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dynamic_properties&lt;/code&gt;オブジェクトを非破壊的に &lt;code&gt;.property(name, pm)&lt;/code&gt; メソッドチェインで構築できるようになった&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;dynamic_properties()
  .property(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;color&#34;&lt;/span&gt;, color_map)
  .property(&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;pos&#34;&lt;/span&gt;, position_map)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生ポインタをプロパティマップとして利用できないようにした。これは以前、Visual Studioでしばしば失敗したためである。このような用法はBoost.Graphの例やテストにあったが全て削除した。&lt;code&gt;graph&lt;/code&gt;で&lt;code&gt;vertex&lt;/code&gt;プロパティを使う際(この機能のもっとも一般的な利用法である)には次のように記述する：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_iterator_property_map(
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;pointer or container .begin() iterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;,
  get(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vertex_index, &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;graph object&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;(註：このコードで&lt;code&gt;get()&lt;/code&gt;の名前空間が省略されているのはコードを汎化する上で重要である)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;graph&lt;/code&gt;以外では、以下のように記述するとよい&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_iterator_property_map(
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;pointer&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;,
  boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;typed_identity_property_map&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;size_t&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;boost/property_map/property_map.hpp&amp;gt;&lt;/code&gt;の151行目と159行目にはコメントアウトした&lt;code&gt;static&lt;/code&gt;アサーションがあるが、これを有効にすることで、ユーザーコード中にあるこのような廃止予定のポインタの用法を検出することができる&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#rational&#34; name=&#34;rational&#34;&gt;Rational&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++11モードでコンパイルする場合、Boost.Testが&lt;code&gt;lowest&lt;/code&gt;と&lt;code&gt;max_digits10&lt;/code&gt;のどちらかを参照するため、C++11で追加された&lt;code&gt;std::numeric_limits&lt;/code&gt;のメンバ、&lt;code&gt;lowest&lt;/code&gt;と&lt;code&gt;max_digits10&lt;/code&gt;をユニットテストコードに追加した。&lt;/li&gt;
&lt;li&gt;C++11でナローイングがエラーになるため、内部変数の初期化でナローイングがおこらないように修正した。これにより &lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/5855&#34; target=&#34;_blank&#34;&gt;#5855&lt;/a&gt; が解決された。 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#smart-pointer&#34; name=&#34;smart-pointer&#34;&gt;SmartPtr&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Logから抽出された&lt;code&gt;boost/smart_ptr/intrusive_ref_counter.hpp&lt;/code&gt;ヘッダーが加えられた。このヘッダーはユーザーのクラスに&lt;code&gt;intrusive_ptr&lt;/code&gt;サポートを加えるミックスイン基底クラスを実装する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#thread&#34; name=&#34;thread&#34;&gt;Thread&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;機能追加&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8519&#34; target=&#34;_blank&#34;&gt;#8519&lt;/a&gt; 同期: completion function（バリアの待機完了時に呼ばれる関数）の機能を追加して&lt;code&gt;barrier&lt;/code&gt;クラスを更新。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8515&#34; target=&#34;_blank&#34;&gt;#8515&lt;/a&gt; 非同期: &lt;code&gt;shared_future::then&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8615&#34; target=&#34;_blank&#34;&gt;#8615&lt;/a&gt; 非同期: &lt;code&gt;make_future&lt;/code&gt;/&lt;code&gt;make_shared_future&lt;/code&gt;を&lt;code&gt;make_ready_future&lt;/code&gt;に置き換え。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8627&#34; target=&#34;_blank&#34;&gt;#8627&lt;/a&gt; 非同期: &lt;code&gt;future&amp;lt;&amp;gt;::unwrap&lt;/code&gt;メンバ関数と&lt;code&gt;unwrap&lt;/code&gt;するコンストラクタを追加。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8677&#34; target=&#34;_blank&#34;&gt;#8677&lt;/a&gt; 非同期: &lt;code&gt;future&amp;lt;&amp;gt;::get_or&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8678&#34; target=&#34;_blank&#34;&gt;#8678&lt;/a&gt; 非同期: &lt;code&gt;future&amp;lt;&amp;gt;::fallback_to&lt;/code&gt;を追加。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8891&#34; target=&#34;_blank&#34;&gt;#8891&lt;/a&gt; &lt;code&gt;upgrade_to_unique_lock&lt;/code&gt;に&lt;code&gt;mutex()&lt;/code&gt;メンバ関数が無かったので追加。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8955&#34; target=&#34;_blank&#34;&gt;#8955&lt;/a&gt; &lt;code&gt;future&lt;/code&gt;から効率的に&lt;code&gt;exception_ptr&lt;/code&gt;を取得したいという要望に対応。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7461&#34; target=&#34;_blank&#34;&gt;#7461&lt;/a&gt; &lt;code&gt;count_to_release&lt;/code&gt;が&lt;code&gt;0&lt;/code&gt;のときに&lt;code&gt;detail::win32::ReleaseSemaphore&lt;/code&gt;が呼ばれてしまう問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8070&#34; target=&#34;_blank&#34;&gt;#8070&lt;/a&gt; &lt;code&gt;GetTickCount&lt;/code&gt;より適切な&lt;code&gt;GetTickCount64&lt;/code&gt;を使用するように変更。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8768&#34; target=&#34;_blank&#34;&gt;#8768&lt;/a&gt; win32で稀に&lt;code&gt;condition_variable&lt;/code&gt;が永遠に&lt;code&gt;wait&lt;/code&gt;してしまう問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8817&#34; target=&#34;_blank&#34;&gt;#8817&lt;/a&gt; Windows CE用のコードによって、mingw w64環境でコンパイルができない問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8943&#34; target=&#34;_blank&#34;&gt;#8943&lt;/a&gt; Window上のIntel C++ Composer XE 2013で&lt;code&gt;boost::call_once&lt;/code&gt;を使用したコードのコンパイルに失敗する問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8931&#34; target=&#34;_blank&#34;&gt;#8931&lt;/a&gt; &lt;code&gt;external_locking&lt;/code&gt;のリファレンスにtypoがあったのを修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9029&#34; target=&#34;_blank&#34;&gt;#9029&lt;/a&gt; ドキュメントの誤植を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9073&#34; target=&#34;_blank&#34;&gt;#9037&lt;/a&gt; gcc &lt;code&gt;-Wshadow&lt;/code&gt;でコンパイルしたときに&lt;code&gt;conditional_variable{,_fwd}.hpp&lt;/code&gt;で警告が発生する問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9041&#34; target=&#34;_blank&#34;&gt;#9041&lt;/a&gt; Boost.Threadの動的共有オブジェクトがBoost.Atomicへのシンボル参照を解決できない問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9048&#34; target=&#34;_blank&#34;&gt;#9048&lt;/a&gt; &lt;code&gt;boost::scoped_thread&lt;/code&gt;の可変長テンプレート引数を使用するコンストラクタが使いにくい問題を修正。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9079&#34; target=&#34;_blank&#34;&gt;#9079&lt;/a&gt; Windows環境で、Condition variableが永遠にwaitしてしまう問題を修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#timer&#34; name=&#34;timer&#34;&gt;Timer&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Intel compilerで&lt;code&gt;progress.hpp&lt;/code&gt;がコンパイルできない問題を修正(&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8956&#34; target=&#34;_blank&#34;&gt;#8956&lt;/a&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#type-traits&#34; name=&#34;type-traits&#34;&gt;Type Traits&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;is_copy_contructible&lt;/code&gt;トレイト追加 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8802&#34; target=&#34;_blank&#34;&gt;#8802&lt;/a&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#unordered&#34; name=&#34;unordered&#34;&gt;Unordered&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;以下の警告を修正&lt;ul&gt;
&lt;li&gt;未使用の変数への警告 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8851&#34; target=&#34;_blank&#34;&gt;#8851&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;未使用の&lt;code&gt;typedef&lt;/code&gt;への警告 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8874&#34; target=&#34;_blank&#34;&gt;#8874&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;いくつかの&lt;code&gt;detail&lt;/code&gt;な関数がADLによってエクスポートされてしまうのを修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#utility&#34; name=&#34;utility&#34;&gt;Utility&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boost::result_of&lt;/code&gt;で、デフォルトでTR1のプロトコルを使うようにし、もしこの関数オブジェクトがサポートしていない場合(たとえばC++11のラムダ関数)には&lt;code&gt;decltype&lt;/code&gt;を使うように設定できるようになった。このモードを利用するには&lt;code&gt;BOOST_RESULT_OF_USE_TR1_WITH_DECLTYPE_FALLBACK&lt;/code&gt;環境設定マクロを定義する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boost::base_from_member&lt;/code&gt;クラステンプレートのC++11対応度向上。このクラスはコンパイラが右辺値参照、可変引数テンプレート、関数テンプレートのデフォルト実引数機能を備えている際に、コンストラクタ実引数の完全転送を実装する&lt;/li&gt;
&lt;li&gt;Boost.Logから&lt;code&gt;boost/utility/explicit_operator_bool.hpp&lt;/code&gt;と&lt;code&gt;boost/utility/empty_deleter.hpp&lt;/code&gt;を受け継いだ。それぞれ、&lt;code&gt;bool&lt;/code&gt;への明示的な型変換演算子となにもしないデリータを定義するためのユーティリティである&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#variant&#34; name=&#34;variant&#34;&gt;Variant&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt; rvalueをコンストラクタ/代入演算子の仮引数にしたときコンパイルできない問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8988&#34; target=&#34;_blank&#34;&gt;#8988&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ある&lt;code&gt;variant&lt;/code&gt;クラステンプレートが&lt;code&gt;nothrow&lt;/code&gt;コピーコンストラクタと例外を送出するムーヴコンストラクタを持っている場合に、ムーヴ代入演算子がコンパイルできない問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8772&#34; target=&#34;_blank&#34;&gt;#8772&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;例外が無効の環境下でのコンパイルに対応 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8717&#34; target=&#34;_blank&#34;&gt;#8717&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;到達不能コード警告を解消 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8665&#34; target=&#34;_blank&#34;&gt;#8665&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;重複したコードを削除 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/7601&#34; target=&#34;_blank&#34;&gt;#7601&lt;/a&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#wave&#34; name=&#34;wave&#34;&gt;Wave&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Waveドライバーが0xFFFFui64トークンを不適切に処理する問題を修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8848&#34; target=&#34;_blank&#34;&gt;#8848&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;ドキュメントに&lt;code&gt;--c++0x&lt;/code&gt;オプションが記載されていたが、実際には不正なオプションになる。ドキュメント表記を&lt;code&gt;--c++11&lt;/code&gt;に修正 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/9098&#34; target=&#34;_blank&#34;&gt;#9098&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#xpressive&#34; name=&#34;xpressive&#34;&gt;Xpressive&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不完全なキャラクタセットについて&lt;code&gt;assert&lt;/code&gt;ではなく例外を投げるようにした (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8843&#34; target=&#34;_blank&#34;&gt;#8843&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;未使用の&lt;code&gt;typedef&lt;/code&gt;削除 (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8880&#34; target=&#34;_blank&#34;&gt;#8880&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sequence_stack.hpp&lt;/code&gt;で&lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;のかわりにRAIIを使うようにした (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8882&#34; target=&#34;_blank&#34;&gt;#8882&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;clangの&lt;code&gt;-Wimplicit-fallthrough&lt;/code&gt;診断がきちんと動くようにした (&lt;a href=&#34;https://svn.boost.org/trac/boost/ticket/8474&#34; target=&#34;_blank&#34;&gt;#8474&lt;/a&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/document/version/1_55_0.html#quickbook&#34; name=&#34;quickbook&#34;&gt;Quickbook&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Quickbook 1.6の言語実装を完了した。詳細は以下を参照&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/quickbook/versions.html#quickbook.versions.1_6&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/release/doc/html/quickbook/versions.html#quickbook.versions.1_6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;＜ライブラリ名＞&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;新機能&lt;/strong&gt; (必要であれば分類分けをする)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;＜追加、変更、削除内容＞ (&lt;a href=&#34;http://svn.boost.org/trac/boost/ticket/0&#34; target=&#34;_blank&#34;&gt;#0&lt;/a&gt;) (←svn.boost.orgのissuesへのリンク)&lt;/li&gt;
&lt;li&gt;＜追加、変更、削除内容＞ (&lt;a href=&#34;https://svn.boost.org/trac/boost/changeset/0&#34; target=&#34;_blank&#34;&gt;r0&lt;/a&gt;) (←svn.boost.orgのcommitへのリンク)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;バグ修正&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;破壊的変更&lt;/strong&gt;&lt;/span&gt;： 赤文字+ボールドではっきりと分かるように&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span style=&#34;color:red;&#34;&gt;&lt;strong&gt;ABI変更&lt;/strong&gt;&lt;/span&gt;： これも赤文字で&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[訳注] 本家ノートの記述が不十分であると考えるときは、適宜注釈を入れる&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;参照： &lt;a href=&#34;http://blog.example.com/path/to/references&#34; target=&#34;_blank&#34;&gt;必要であれば外部の文献へのリンクを挿入する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;テスト済みコンパイラ&lt;/h2&gt;
&lt;p&gt;主要なテストコンパイラ:
- Linux:
    - Clang: 3.3, 3.2, 3.1, 3.0
    - Clang, C++11, libc++: 3.4, 3.3
    - GCC: 4.8.1, 4.7.3, 4.6.3, 4.5.3, 4.4.7
    - GCC, C++11: 4.8.1
    - GCC, C++98: 4.8.1
- OS X:
    - GCC: 4.2
    - Apple Clang: 5.0
    - Apple Clang, C++11: 5.0
- Windows:
    - GCC, mingw: 4.8.0, 4.7.2, 4.6.3, 4.5.4, 4.4.7
    - Visual C++: 11.0, 10.0, 9.0&lt;/p&gt;
&lt;p&gt;追加して含まれるテストコンパイラ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS X:&lt;ul&gt;
&lt;li&gt;Apple Clang: 5.0&lt;/li&gt;
&lt;li&gt;Apple Clang, C++11: 5.0&lt;/li&gt;
&lt;li&gt;Clang: trunk&lt;/li&gt;
&lt;li&gt;Clang, C++11: trunk&lt;/li&gt;
&lt;li&gt;GCC: 4.2.1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Linux:&lt;ul&gt;
&lt;li&gt;Clang: 3.3, 3.2, 3.1, 3.0, trunk&lt;/li&gt;
&lt;li&gt;Clang, C++11: 3.4&lt;/li&gt;
&lt;li&gt;Clang, C++11, libc++: 3.4, 3.3&lt;/li&gt;
&lt;li&gt;GCC: 4.9.0 (experimental), 4.8.1, 4.7.3, 4.6.4, 4.5.3, 4.4.7&lt;/li&gt;
&lt;li&gt;GCC, C++11: 4.8.1&lt;/li&gt;
&lt;li&gt;GCC, C++98: 4.8.1&lt;/li&gt;
&lt;li&gt;Intel: 13.0.1, 12.1.6&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows:&lt;ul&gt;
&lt;li&gt;GCC, mingw: 4.8.0, 4.7.2, 4.6.3, 4.5.4, 4.4.7&lt;/li&gt;
&lt;li&gt;Visual C++: 11.0, 10.0, 9.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻訳&lt;/h2&gt;
&lt;p&gt;Akira Takahashi, Kohei Takahashi, Yuta Hirokawa, zak, sscrisk, hotwatermorning&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>シグナル／スロット -- シグナルの自動コネクション管理： 参照URLがリンクになっていなかった(URLの自動リンクはGitHub Flavored Markdownの拡張機能)ので、リンク先タイトルの表記とともに修正。</title>
      <link href="http://boostjp.github.io/tips/signals.html"/>
      <id>492bcb309e231d0a1fd00d03c62e2016b1352d6f:tips/signals.md</id>
      <updated>2015-04-21 18:31:13 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;シグナル／スロット&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;イベント処理などで使われるシグナル／スロットには、&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/signals2.html&#34; target=&#34;_blank&#34;&gt;Boost Signals2 Library&lt;/a&gt;を使用する。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#connect-multiple-functions&#34;&gt;複数の関数を登録する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#disconnect&#34;&gt;スロットを切断する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#return-value&#34;&gt;シグナル呼び出しの戻り値&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#customize-return-value&#34;&gt;シグナル呼び出しの戻り値をカスタマイズする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#automatic-connection-management&#34;&gt;自動コネクション管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#connect-multiple-functions&#34; name=&#34;connect-multiple-functions&#34;&gt;複数の関数を登録する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Signals2のシグナルには、&lt;code&gt;connect()&lt;/code&gt;関数によって、複数の関数を接続することができる。&lt;/p&gt;
&lt;p&gt;シグナルの関数呼び出し演算子によって、接続した関数全てを呼び出すことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/signals2/signal.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/bind.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Point {
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, y;
    Point(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; x(x), y(y) {}
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Button&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signals2&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signal&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Point&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; clicked;

    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;click&lt;/span&gt;()
    {
        clicked(Point(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;)); &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 呼び出し&lt;/span&gt;
    }
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;MainView&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; on_clicked(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Point&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p)
    {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;MainView : clicked&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SubView&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; on_clicked(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Point&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p)
    {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;SubView : clicked&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    MainView mainView;
    SubView subView;

    Button button;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クリックイベントの登録&lt;/span&gt;
    button.clicked.connect(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;MainView&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_clicked, &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;mainView, _1));
    button.clicked.connect(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;SubView&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_clicked, &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;subView, _1));

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クリックした&lt;/span&gt;
    button.click();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;MainView : clicked
SubView : clicked
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#disconnect&#34; name=&#34;disconnect&#34;&gt;スロットを切断する&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;スロットを切断するには、&lt;code&gt;connect()&lt;/code&gt;関数の戻り値であるコネクションを保持しておき、コネクションの&lt;code&gt;disconnect()&lt;/code&gt;メンバ関数を呼び出すことで、切断する。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/signals2/signal.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/bind.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Point {
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, y;
    Point(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; x(x), y(y) {}
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Button&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signals2&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signal&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Point&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; clicked;

    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;click&lt;/span&gt;()
    {
        clicked(Point(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;));
    }
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;MainView&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; on_clicked(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Point&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p)
    {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;MainView : clicked&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SubView&lt;/span&gt; {
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; on_clicked(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Point&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; p)
    {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;SubView : clicked&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    MainView mainView;
    SubView subView;

    Button button;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クリックイベントを登録&lt;/span&gt;
    button.clicked.connect(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;MainView&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_clicked, &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;mainView, _1));

    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signals2&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;connection con &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;
        button.clicked.connect(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;SubView&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;on_clicked, &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;subView, _1));

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// SubViewのスロットを切断&lt;/span&gt;
    con.disconnect();

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// クリックした&lt;/span&gt;
    button.click();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;MainView : clicked
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#return-value&#34; name=&#34;return-value&#34;&gt;シグナル呼び出しの戻り値&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;特に指定しなければ、シグナルを呼び出した時の戻り値は接続する関数の戻り値の&lt;code&gt;optional&lt;/code&gt;となり、最後に登録した関数の戻り値が戻される。また、関数が接続されていなければ無効値を戻す。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/html/boost/signals2/optional_last_value.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;optional_last_value()&lt;/code&gt;&lt;/a&gt;を参照。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/signals2/signal.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; y;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;minus&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; y;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;multiply&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; y;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;divide&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; y;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signals2&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signal&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; sig;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signals2&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signal&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; non_connect_sig;

    sig.connect(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;add);
    sig.connect(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;minus);
    sig.connect(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;multiply);
    sig.connect(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;divide);

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// boost::optional&amp;lt;int&amp;gt;が戻ってくる&lt;/span&gt;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;sig(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 無効値&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;optional&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; non_connect_result &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; non_connect_sig(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;non_connect_result) {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;invalid value&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;5
invalid value
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#customize-return-value&#34; name=&#34;customize-return-value&#34;&gt;シグナル呼び出しの戻り値をカスタマイズする&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::signals2::signal&lt;/code&gt;クラスの2番目のテンプレート引数&lt;code&gt;Combiner&lt;/code&gt;を変更することで、戻り値のカスタムが可能である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;numeric&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/signals2/signal.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 接続された複数の関数の戻り値の合計を戻す&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#ff0000&#34;&gt;custom_result_value&lt;/span&gt;
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; T result_type;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typename&lt;/span&gt; InputIterator&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
    result_type &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;operator&lt;/span&gt;()(InputIterator first, InputIterator last) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;
    {
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt;( first &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; last ) {
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; result_type();
        }
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;accumulate(first, last, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;);
    }
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; y;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;minus&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;-&lt;/span&gt; y;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;multiply&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; y;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;divide&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; y)
{
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; y;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signals2&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signal&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;), &lt;span style=&#34;color:#ff0000&#34;&gt;custom_result_value&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; sig;

    sig.connect(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;add);
    sig.connect(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;minus);
    sig.connect(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;multiply);
    sig.connect(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;divide);

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; sig(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;45
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/signals.html#automatic-connection-management&#34; name=&#34;automatic-connection-management&#34;&gt;自動コネクション管理&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;スマートポインタで管理されたオブジェクトのメンバ関数を登録する場合、&lt;code&gt;boost::signals2::signal::slot_type::track&lt;/code&gt;を用いることで、オブジェクトが破棄されるタイミングで自動的に切断させることができる。&lt;/p&gt;
&lt;p&gt;参照: &lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/signals2/tutorial.html#signals2.tutorial.connection-management&#34; target=&#34;_blank&#34;&gt;Automatic Connection Management (Intermediate) - Boost Signals 2 Library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/signals2/signal.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/make_shared.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Fuga&lt;/span&gt;{};

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Hoge&lt;/span&gt;
{
&lt;span style=&#34;color: #A0A000&#34;&gt;public:&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; Func(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;){
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Hoge::func()&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;(){
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;typedef&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signals2&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;signal&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt;(&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Fuga&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;)&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; signal_type; &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// signal型 &lt;/span&gt;
    signal_type sig;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// signal オブジェクト &lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; Fuga fuga;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 引数用 &lt;/span&gt;
    {
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;block start.&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// shared_ptrで管理しているオブジェクトのメンバ関数を登録  &lt;/span&gt;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// signal::slot_typeはbindのように引数の部分適用が可能.&lt;/span&gt;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// signal::slot_type::trackにスマートポインタを渡す事で&lt;/span&gt;
        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// オブジェクトが破棄されるタイミングで切断される &lt;/span&gt;
        boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Hoge&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; hoge &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;make_shared&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Hoge&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;();
        sig.connect(
            signal_type&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;slot_type(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Hoge&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;Func, hoge.get(), _1).track(hoge) 
        );
        sig(fuga);        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 登録した関数が正しく呼ばれる &lt;/span&gt;
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;block end.&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    }   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// ここで hoge が管理するオブジェクトが破棄され、自動的にsigから切断される &lt;/span&gt;
    sig(fuga);  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 切断後なので何もしない  &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;block start.
Hoge::func()
block end.
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>