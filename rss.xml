<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>boostjp : Boost日本語情報サイト</title>
  <link href="http://boostjp.github.io" />
  <updated>2015-10-10T19:24:15.141269</updated>
  <id>056fcd23-702b-4813-8091-e3a18e5cf8cb</id>

  
    <entry>
      <title>C++Now! -- cppnow/2015: C++Now 2015 タイトル一覧のみ</title>
      <link href="http://boostjp.github.io/cppnow.html"/>
      <id>ec693718df8abe0421372d6a358c487c1eccb962:cppnow.md</id>
      <updated>2015-10-10 19:23:08 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now!&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;2012年から、BoostConという名前で開催されていたカンファレンスがC++Now!という名前に変わりました。ここでは、C++Now!のセッション概要の翻訳、およびセッション資料のまとめを記載していきます。&lt;/p&gt;
&lt;p&gt;BoostConは以下のページを参照してください：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/boostcon.html&#34;&gt;BoostCon - boostjp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;各年のセッション概要翻訳&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2012.html&#34;&gt;C++Now! 2012&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2013.html&#34;&gt;C++Now! 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2014.html&#34;&gt;C++Now! 2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/cppnow/2015.html&#34;&gt;C++Now! 2015&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>C++Now! 2015 -- cppnow/2015: C++Now 2015 タイトル一覧のみ</title>
      <link href="http://boostjp.github.io/cppnow/2015.html"/>
      <id>ec693718df8abe0421372d6a358c487c1eccb962:cppnow/2015.md</id>
      <updated>2015-10-10 19:23:08 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;C++Now! 2015&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://cppnow2015.sched.org/grid/&#34; target=&#34;_blank&#34;&gt;http://cppnow2015.sched.org/grid/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;セッションリスト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Library in a Week: C++ Application Configuration&lt;/li&gt;
&lt;li&gt;Conference Keynote: Generic Programming with Concepts&lt;/li&gt;
&lt;li&gt;Parallel Computing: Strategies and Implications&lt;/li&gt;
&lt;li&gt;Testing Battle.net (before deploying to millions of players)&lt;/li&gt;
&lt;li&gt;Your CPU Is Binary&lt;/li&gt;
&lt;li&gt;Functional Geometry: Producing Pure Spaces&lt;/li&gt;
&lt;li&gt;Lessons Learned&lt;/li&gt;
&lt;li&gt;Type Deduction in C++14&lt;/li&gt;
&lt;li&gt;Yomm11: Open Multi-Methods for C++11&lt;/li&gt;
&lt;li&gt;constexpr: C++ At Compile Time&lt;/li&gt;
&lt;li&gt;Biicode, a C/C++ dependency manager with a hosting service&lt;/li&gt;
&lt;li&gt;Boost 2.0&lt;/li&gt;
&lt;li&gt;Conference Keynote: Numerical Weather Prediction: Facing the Future with C++&lt;/li&gt;
&lt;li&gt;On the design and Boost-based implementation of two new C++ libraries for atmospheric research&lt;/li&gt;
&lt;li&gt;Thinking Portable: Why and how to make your C++ cross platform&lt;/li&gt;
&lt;li&gt;Why in heaven there is no dependency management for C++?&lt;/li&gt;
&lt;li&gt;Boost.Compute: A library for GPU/parallel-computing&lt;/li&gt;
&lt;li&gt;Developing EDSL&#39;s for Boost.Spirit&lt;/li&gt;
&lt;li&gt;Back to the Future&lt;/li&gt;
&lt;li&gt;Large-Scale C++: Advanced Levelization Techniques, Parts I &amp;amp; II&lt;/li&gt;
&lt;li&gt;switchAny - A Practical Exercise in Template Metaprogramming&lt;/li&gt;
&lt;li&gt;New Build System for New C++&lt;/li&gt;
&lt;li&gt;The Price of Shared Pointers or Why Passing them by-reference can be Useful&lt;/li&gt;
&lt;li&gt;Conference Keynote: Ranges for the Standard Library&lt;/li&gt;
&lt;li&gt;A review of C++ 11/14 only Boost libraries - Fiber, AFIO, DI and APIBind&lt;/li&gt;
&lt;li&gt;Type-safe configuration library&lt;/li&gt;
&lt;li&gt;How we reason about procedural programs&lt;/li&gt;
&lt;li&gt;Modern generic programming using the Tick and Fit libraries&lt;/li&gt;
&lt;li&gt;Functions Want To Be Free&lt;/li&gt;
&lt;li&gt;Boostache Exposed - the internals of Boost&#39;s template engine&lt;/li&gt;
&lt;li&gt;Lock-free by Example: Towards an Interesting Lock-free MPMC Queue&lt;/li&gt;
&lt;li&gt;Big Projects, and CMake, and Git, Oh My!&lt;/li&gt;
&lt;li&gt;Debugging using an exact recording of a program&#39;s execution.&lt;/li&gt;
&lt;li&gt;Details Matter&lt;/li&gt;
&lt;li&gt;The Rule of Seven (Plus or Minus Two): Modern C++ Boilerplate&lt;/li&gt;
&lt;li&gt;Parallelizing the Standard Template Library(STL)&lt;/li&gt;
&lt;li&gt;C++ metaprogramming: a paradigm shift&lt;/li&gt;
&lt;li&gt;Fun with C11 generic selection expression&lt;/li&gt;
&lt;li&gt;IIFE In C++ For Performance and Safety&lt;/li&gt;
&lt;li&gt;Better Code: Concurrency&lt;/li&gt;
&lt;li&gt;Using Spirit X3&lt;/li&gt;
&lt;li&gt;An Overview on Encryption in C++&lt;/li&gt;
&lt;li&gt;C++17 coroutines for app and library developers&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;セッション資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/boostcon/cppnow_presentations_2015&#34; target=&#34;_blank&#34;&gt;C++Now! Presentations 2015&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>yoh</name>
        <email>kawasaki.liamg@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.勉強会 #18 大阪 -- URL追加</title>
      <link href="http://boostjp.github.io/study_meeting/study18.html"/>
      <id>fb0ff870715808e4ddfec2f240272f5831d30063:study_meeting/study18.md</id>
      <updated>2015-10-10 15:30:56 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost.勉強会 #18 大阪&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;開催日時&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2015/10/10(土) 11:00〜18:00&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;開催場所&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;株式会社Aiming 大阪スタジオ&lt;/li&gt;
&lt;li&gt;〒530-0011 大阪府大阪市北区大深町3-1 グランフロント大阪タワーB 18階&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;募集ページ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://osakaboostjp.doorkeeper.jp/events/30797&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #18 大阪 | Doorkeeper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;主催者&amp;amp;スタッフ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/fadis_&#34; target=&#34;_blank&#34;&gt;@fadis_&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;タイムテーブル&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;時間&lt;/th&gt;
&lt;th&gt;発表内容&lt;/th&gt;
&lt;th&gt;発表者&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;12:30〜&lt;/td&gt;
&lt;td&gt;開場&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13:00〜13:10&lt;/td&gt;
&lt;td&gt;会場諸注意&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13:15〜13:45&lt;/td&gt;
&lt;td&gt;区間演算ライブラリを開発した話&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/_EnumHack&#34; target=&#34;_blank&#34;&gt;@_EnumHack&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14:00〜14:30&lt;/td&gt;
&lt;td&gt;ナウなヤングにバカうけのイカしたタグ付き共用体&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/decimalbloat&#34; target=&#34;_blank&#34;&gt;@decimalbloat&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14:45〜15:25&lt;/td&gt;
&lt;td&gt;pre-Kona文書の動向&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/EzoeRyou&#34; target=&#34;_blank&#34;&gt;@EzoeRyou&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15:40〜16:20&lt;/td&gt;
&lt;td&gt;C++14世代のメタプログラミング Boost.Hana&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/ignis_fatuus&#34; target=&#34;_blank&#34;&gt;@ignis_fatuus&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16:35〜17:35&lt;/td&gt;
&lt;td&gt;Proxygen&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/fadis_&#34; target=&#34;_blank&#34;&gt;@fadis_&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17:35〜18:00&lt;/td&gt;
&lt;td&gt;後片付け&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Twitterハッシュタグ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/search?q=%23boostjp&#34; target=&#34;_blank&#34;&gt;#boostjp&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;発表資料&lt;/h2&gt;
&lt;h3&gt;区間演算ライブラリを開発した話&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/study_meeting&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/LoliGothick/Interval-Analysis&#34; target=&#34;_blank&#34;&gt;Cranberries Interval-Library for C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ナウなヤングにバカうけのイカしたタグ付き共用体&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/digitalghost/ss-53762226&#34; target=&#34;_blank&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dechimal/TaggedUnion&#34; target=&#34;_blank&#34;&gt;TaggedUnion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;pre-Kona文書の動向&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ezoeryou.github.io/boost-benkyo-18&#34; target=&#34;_blank&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++14世代のメタプログラミング Boost.Hana&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/study_meeting&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Proxygen&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/study_meeting&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon</name>
        <email>melt@e-ml.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>Boost.勉強会 #18 大阪 -- 勉強会のテーブルや資料を追加</title>
      <link href="http://boostjp.github.io/study_meeting/study18.html"/>
      <id>41c8536c97e0e10dd93f5b458b64c6b114c81d01:study_meeting/study18.md</id>
      <updated>2015-10-10 14:40:11 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;Boost.勉強会 #18 大阪&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;h2&gt;開催日時&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2015/10/10(土) 11:00〜18:00&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;開催場所&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;株式会社Aiming 大阪スタジオ&lt;/li&gt;
&lt;li&gt;〒530-0011 大阪府大阪市北区大深町3-1 グランフロント大阪タワーB 18階&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;募集ページ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://osakaboostjp.doorkeeper.jp/events/30797&#34; target=&#34;_blank&#34;&gt;Boost.勉強会 #18 大阪 | Doorkeeper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;主催者&amp;amp;スタッフ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/fadis_&#34; target=&#34;_blank&#34;&gt;@fadis_&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;タイムテーブル&lt;/h2&gt;
&lt;table border=&#34;1&#34; bordercolor=&#34;#888&#34; style=&#34;border-collapse:collapse&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;時間&lt;/th&gt;
&lt;th&gt;発表内容&lt;/th&gt;
&lt;th&gt;発表者&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;12:30〜&lt;/td&gt;
&lt;td&gt;開場&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13:00〜13:10&lt;/td&gt;
&lt;td&gt;会場諸注意&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13:15〜13:45&lt;/td&gt;
&lt;td&gt;区間演算ライブラリを開発した話&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/_EnumHack&#34; target=&#34;_blank&#34;&gt;@_EnumHack&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14:00〜14:30&lt;/td&gt;
&lt;td&gt;ナウなヤングにバカうけのイカしたタグ付き共用体&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/decimalbloat&#34; target=&#34;_blank&#34;&gt;@decimalbloat&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14:45〜15:25&lt;/td&gt;
&lt;td&gt;pre-Kona文書の動向&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/EzoeRyou&#34; target=&#34;_blank&#34;&gt;@EzoeRyou&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15:40〜16:20&lt;/td&gt;
&lt;td&gt;C++14世代のメタプログラミング Boost.Hana&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/ignis_fatuus&#34; target=&#34;_blank&#34;&gt;@ignis_fatuus&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16:35〜17:35&lt;/td&gt;
&lt;td&gt;Proxygen&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://twitter.com/fadis_&#34; target=&#34;_blank&#34;&gt;@fadis_&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17:35〜18:00&lt;/td&gt;
&lt;td&gt;後片付け&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Twitterハッシュタグ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/search?q=%23boostjp&#34; target=&#34;_blank&#34;&gt;#boostjp&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;発表資料&lt;/h2&gt;
&lt;h3&gt;区間演算ライブラリを開発した話&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/study_meeting&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ナウなヤングにバカうけのイカしたタグ付き共用体&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/digitalghost/ss-53762226&#34; target=&#34;_blank&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;pre-Kona文書の動向&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ezoeryou.github.io/boost-benkyo-18&#34; target=&#34;_blank&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C++14世代のメタプログラミング Boost.Hana&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/study_meeting&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Proxygen&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/study_meeting&#34;&gt;発表資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</content>
      
      <author>
        <name>melpon</name>
        <email>melt@e-ml.jp</email>
      </author>
    </entry>
  
    <entry>
      <title>mem_fn.hpp -- mem_fn : 引用の表示崩れを修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html"/>
      <id>f7a71c3268cd45b5f98bc18821c22e2865d07d52:archive/boost_docs/libs/mem_fn.md</id>
      <updated>2015-09-29 11:38:38 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;mem_fn.hpp&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34;&gt;FAQ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34;&gt;インタフェース&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34;&gt;実装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34;&gt;ファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34; name=&#34;purpose&#34;&gt;目的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::mem_fn&lt;/code&gt; は、標準関数である&lt;code&gt;std::mem_fun&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt;の一般化である。&lt;code&gt;mem_fn&lt;/code&gt;は、2つ以上の引数をとる メンバ関数へのポインタをサポートし、また&lt;code&gt;mem_fn&lt;/code&gt;の戻す関数オブジェクトは第一引数に、 (訳注: そのメンバ関数の属するクラスのインスタンスを指すような) ポインタ、参照、スマートポインタをとることができる。 &lt;code&gt;mem_fn&lt;/code&gt;は、メンバ変数へのポインタも、引数をとらず自身への定数参照を 戻す関数とみなすことによってサポートする。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;の目的は2つある。一つ目は、コンテナにスマートポインタが格納されている場合であっても、 次のような&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;見慣れた文法によって、メンバ関数の呼び出しを可能にすることである。&lt;/p&gt;
&lt;p&gt;二つ目は、メンバ関数へのポインタを関数オブジェクトのように取り扱いたいライブラリ開発者に、 実装の道具として使用して貰うことである。例えば、あるライブラリは次のようにしてより便利な &lt;code&gt;for_each&lt;/code&gt;アルゴリズムを提供することができ、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;It&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; for_each(It first, It last, R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(first, last, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(pmf));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムは次のようにして手軽に利用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;for_each(v.begin(), v.end(), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムの機能を文書化する際には、単に次のように書けば良い：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;It&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; for_each(It first, It last, R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ());

&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;結果&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(first, last, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(pmf)); &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;と同等。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;ここで、 &lt;code&gt;boost::mem_fn&lt;/code&gt; の部分はこのページへのリンクとするとよいだろう。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bindのドキュメント&lt;/a&gt; にそのような例があるので参照のこと。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; は1つの引数(メンバ関数へのポインタ)をとり、標準あるいは独自の アルゴリズムに渡すのに適した関数オブジェクトを戻す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X
{
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f();
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;h&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X &lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;k&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;戻される関数オブジェクトは、引数のメンバ関数ポインタと同じ引数をとることに加え、 インスタンスを表すための「柔軟な」第一引数をとる。&lt;/p&gt;
&lt;p&gt;関数オブジェクトが、適切なクラス(上の例では &lt;code&gt;X&lt;/code&gt;)を指すポインタでも参照でも ない第一引数&lt;code&gt;x&lt;/code&gt;をもって呼ばれた場合、関数オブジェクトは&lt;code&gt;get_pointer(x)&lt;/code&gt; を用いて&lt;code&gt;x&lt;/code&gt;からポインタを得ようとする。 スマートポインタの作者は、自分たちのスマートポインタ向けの適切な&lt;code&gt;get_pointer&lt;/code&gt;関数 を定義(overload)しておくことで、それを&lt;code&gt;mem_fn&lt;/code&gt;対応とすることができる。&lt;/p&gt;
&lt;p&gt;[注意: &lt;code&gt;get_pointer&lt;/code&gt; の戻り値はポインタでなくともよい。 &lt;code&gt;(x-&amp;gt;*pmf)(...)&lt;/code&gt;という形式でメンバ関数が呼び出せるなら、どんなオブジェクトでも問題ない。]&lt;/p&gt;
&lt;p&gt;[注意: ライブラリは、&lt;code&gt;get_pointer&lt;/code&gt; の非限定的 (訳注:名前空間を明示しない) 呼び出しを行なう。 そのため、引数依存検索の過程では、オーバーロードされた&lt;code&gt;boost::get_pointer&lt;/code&gt;関数群に加えて、 そのスマートポインタが定義された名前空間内の&lt;code&gt;get_pointer&lt;/code&gt;関数群も検索対象になる。]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;が戻す全ての関数オブジェクトは、&lt;code&gt;result_type&lt;/code&gt;なる&lt;code&gt;typedef&lt;/code&gt;を開示する。 この&lt;code&gt;typedef&lt;/code&gt;は、メンバ関数の戻り型を表す。メンバ変数を渡した場合には、&lt;code&gt;result_type&lt;/code&gt; はそのメンバ変数の型の定数参照として定義される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34; name=&#34;faq&#34;&gt;FAQ&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34; name=&#34;Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。単純な使い方では、&lt;code&gt;mem_fn&lt;/code&gt; は標準のアダプタが提供しないいくつかの機能を提供する。 &lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;Boost.Compose&lt;/a&gt; と標準のアダプタを組み合わせるような複雑な使い方をしている場合は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;&lt;code&gt;boost::bind&lt;/code&gt;&lt;/a&gt; を使用するように書き換えることで、&lt;code&gt;mem_fn&lt;/code&gt;の恩恵を自動的に受けることができる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34; name=&#34;Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いいえ。そうする強い理由がないならすべきではない。&lt;code&gt;mem_fn&lt;/code&gt; は、標準のアダプタに 非常に良く似ているが、100%の互換性があるわけではない。特に、&lt;code&gt;mem_fn&lt;/code&gt;は、標準の アダプタとは違って &lt;code&gt;std::[const_]mem_fun[1][_ref]_t&lt;/code&gt; 型のオブジェクトを戻さないので、 標準の &lt;code&gt;argument_type&lt;/code&gt; 及び &lt;code&gt;first_argument_type&lt;/code&gt; という (nested) &lt;code&gt;typedef&lt;/code&gt; を 用いて第一引数の型を記述することが (完全には) できない。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。&lt;code&gt;#define BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; とすれば可能である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;特定のベンダへの依存を避けるため、可搬性のない拡張は、一般にデフォルトでオフにされるべきである。 もし &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; がデフォルトで有効であったなら、あなたはそうとは気づかずに その拡張を使ってしまい、結果としてあなたのコードの可搬性が損なわれるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34; name=&#34;interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34; name=&#34;synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost
{

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_1&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ());

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_2&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_2_1&lt;/i&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_3&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_4&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_5&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_6&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 実際には、より多くの引数をとるような関数が、更にいくつかオーバーロードされている&lt;/span&gt;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34; name=&#34;requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Synopsis で述べられた全ての &lt;em&gt;unspecified-N&lt;/em&gt; 型は &lt;code&gt;CopyConstructible&lt;/code&gt; (コピーコンストラクト可能) かつ &lt;code&gt;Assignable&lt;/code&gt; (代入可能) であること。そのためのコピーコンストラクタ及び代入演算子 は例外を送出しないこと。 &lt;em&gt;unspecified-N&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;mem_fn&lt;/code&gt; に渡されたメンバ関数ポインタの戻り型、と定義されること (Synopsis での &lt;code&gt;R&lt;/code&gt;)。 &lt;em&gt;unspecified-2-1&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;R const &amp;amp;&lt;/code&gt; 、と定義されること。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34; name=&#34;get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34; name=&#34;mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_1&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt;あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_2&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_2_1&lt;/i&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;t.*pm&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;get_pointer(t)-&amp;gt;*pm&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_3&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_4&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_5&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_6&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34; name=&#34;implementation&#34;&gt;実装&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34; name=&#34;files&#34;&gt;ファイル&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;boost/mem_fn.hpp (メインヘッダ)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_cc.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_vw.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_template.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_test.cpp (テスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_derived_test.cpp (派生オブジェクトでのテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_fastcall_test.cpp (&lt;code&gt;__fastcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_stdcall_test.cpp (&lt;code&gt;__stdcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_void_test.cpp (戻りが&lt;code&gt;void&lt;/code&gt;であるケースのテスト)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34; name=&#34;dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Config&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34; name=&#34;number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;この実装では、8つまでの引数をとるメンバ関数がサポートされている。これは、設計に固有の 制限という訳ではなく、実装の詳細である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34; name=&#34;stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いくつかのプラットフォームでは、 &lt;strong&gt;呼び出し規則&lt;/strong&gt; (どのように関数が起動されるかの規則: 引数はどのように渡されるのか、戻り値はどのように扱われるのか、もしスタックを使用したなら、 誰がそれを奇麗にするのか) の異なるような何種類かのメンバ関数を作成できる。&lt;/p&gt;
&lt;p&gt;例えば、Windows API の関数と、COMインタフェースのメンバ関数は、 &lt;code&gt;__stdcall&lt;/code&gt; という呼び出し規則を用いるし、 Borland の VCL コンポーネントは &lt;code&gt;__fastcall&lt;/code&gt; を用いる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__stdcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__fastcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_FASTCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;[注意: これは可搬性のない拡張であり、インタフェースの一部ではない。]&lt;/p&gt;
&lt;p&gt;[注意: いくつかのコンパイラは、 &lt;code&gt;__stdcall&lt;/code&gt; キーワードに対して最小限のサポートしか提供していない。]&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get_pointer&lt;/code&gt;ベースの設計は、Rene Jageによる、特性クラスを用いて &lt;code&gt;mem_fn&lt;/code&gt;を ユーザ定義のスマートポインタに適合させるという提案に影響されたものである。&lt;/p&gt;
&lt;p&gt;フォーマルレビューの期間に、Richard Crossley、 Jens Maurer、 Ed Brey、その他の方々の示唆によって、たくさんの 改良があった。レビューマネージャは Darin Adler であった。&lt;/p&gt;
&lt;p&gt;Steve Anichini は、COMインタフェースが &lt;code&gt;__stdcall&lt;/code&gt; を使用していることを指摘した。&lt;/p&gt;
&lt;p&gt;Dave Abrahams は、不完全なコンパイラにおいても &#34;戻り値なし&#34; をサポートすべく、&lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;mem_fn&lt;/code&gt; を改良した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2001, 2002 by Peter Dimov and Multi Media Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 SATO Yusuke &lt;a href=&#34;mailto:y-sato@y-sa.to&#34;&gt;y-sato@y-sa.to&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>mem_fn.hpp -- コードブロック中の識別子修飾が壊れていたので修正</title>
      <link href="http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html"/>
      <id>248c365e6a1ad2aee2f3e793355361d33b3cea93:archive/boost_docs/libs/mem_fn.md</id>
      <updated>2015-09-29 11:34:51 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;mem_fn.hpp&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;ul&gt;
&lt;li&gt;翻訳元ドキュメント： &lt;a href=&#34;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&#34; target=&#34;_blank&#34;&gt;http://www.boost.org/doc/libs/1_31_0/libs/bind/mem_fn.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;目次&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34;&gt;FAQ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34;&gt;インタフェース&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34;&gt;実装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34;&gt;ファイル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#purpose&#34; name=&#34;purpose&#34;&gt;目的&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;boost::mem_fn&lt;/code&gt; は、標準関数である&lt;code&gt;std::mem_fun&lt;/code&gt; と &lt;code&gt;std::mem_fun_ref&lt;/code&gt;の一般化である。&lt;code&gt;mem_fn&lt;/code&gt;は、2つ以上の引数をとる メンバ関数へのポインタをサポートし、また&lt;code&gt;mem_fn&lt;/code&gt;の戻す関数オブジェクトは第一引数に、 (訳注: そのメンバ関数の属するクラスのインスタンスを指すような) ポインタ、参照、スマートポインタをとることができる。 &lt;code&gt;mem_fn&lt;/code&gt;は、メンバ変数へのポインタも、引数をとらず自身への定数参照を 戻す関数とみなすことによってサポートする。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;の目的は2つある。一つ目は、コンテナにスマートポインタが格納されている場合であっても、 次のような&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw));
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;見慣れた文法によって、メンバ関数の呼び出しを可能にすることである。&lt;/p&gt;
&lt;p&gt;二つ目は、メンバ関数へのポインタを関数オブジェクトのように取り扱いたいライブラリ開発者に、 実装の道具として使用して貰うことである。例えば、あるライブラリは次のようにしてより便利な &lt;code&gt;for_each&lt;/code&gt;アルゴリズムを提供することができ、&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;It&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; for_each(It first, It last, R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(first, last, boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(pmf));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムは次のようにして手軽に利用することができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;for_each(v.begin(), v.end(), &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Shape&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;draw);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;このアルゴリズムの機能を文書化する際には、単に次のように書けば良い：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;template&amp;lt;class It, class R, class T&amp;gt;&lt;/code&gt;
&lt;code&gt;void for_each(It first, It last, R (T::*pmf) ());&lt;/code&gt;
&lt;strong&gt;結果:&lt;/strong&gt; &lt;code&gt;std::for_each(first, last, boost::mem_fn(pmf));&lt;/code&gt; と同等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ここで、 &lt;code&gt;boost::mem_fn&lt;/code&gt; の部分はこのページへのリンクとするとよいだろう。 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;bindのドキュメント&lt;/a&gt; にそのような例があるので参照のこと。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; は1つの引数(メンバ関数へのポインタ)をとり、標準あるいは独自の アルゴリズムに渡すのに適した関数オブジェクトを戻す：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; X
{
    &lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; f();
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;g&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;h&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X &lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;k&lt;/span&gt;(std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; v)
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(v.begin(), v.end(), boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;mem_fn(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;X&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;f));
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;戻される関数オブジェクトは、引数のメンバ関数ポインタと同じ引数をとることに加え、 インスタンスを表すための「柔軟な」第一引数をとる。&lt;/p&gt;
&lt;p&gt;関数オブジェクトが、適切なクラス(上の例では &lt;code&gt;X&lt;/code&gt;)を指すポインタでも参照でも ない第一引数&lt;code&gt;x&lt;/code&gt;をもって呼ばれた場合、関数オブジェクトは&lt;code&gt;get_pointer(x)&lt;/code&gt; を用いて&lt;code&gt;x&lt;/code&gt;からポインタを得ようとする。 スマートポインタの作者は、自分たちのスマートポインタ向けの適切な&lt;code&gt;get_pointer&lt;/code&gt;関数 を定義(overload)しておくことで、それを&lt;code&gt;mem_fn&lt;/code&gt;対応とすることができる。&lt;/p&gt;
&lt;p&gt;[注意: &lt;code&gt;get_pointer&lt;/code&gt; の戻り値はポインタでなくともよい。 &lt;code&gt;(x-&amp;gt;*pmf)(...)&lt;/code&gt;という形式でメンバ関数が呼び出せるなら、どんなオブジェクトでも問題ない。]&lt;/p&gt;
&lt;p&gt;[注意: ライブラリは、&lt;code&gt;get_pointer&lt;/code&gt; の非限定的 (訳注:名前空間を明示しない) 呼び出しを行なう。 そのため、引数依存検索の過程では、オーバーロードされた&lt;code&gt;boost::get_pointer&lt;/code&gt;関数群に加えて、 そのスマートポインタが定義された名前空間内の&lt;code&gt;get_pointer&lt;/code&gt;関数群も検索対象になる。]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt;が戻す全ての関数オブジェクトは、&lt;code&gt;result_type&lt;/code&gt;なる&lt;code&gt;typedef&lt;/code&gt;を開示する。 この&lt;code&gt;typedef&lt;/code&gt;は、メンバ関数の戻り型を表す。メンバ変数を渡した場合には、&lt;code&gt;result_type&lt;/code&gt; はそのメンバ変数の型の定数参照として定義される。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#faq&#34; name=&#34;faq&#34;&gt;FAQ&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q1&#34; name=&#34;Q1&#34;&gt;mem_fnを、標準の std::mem_fun[_ref]アダプタのかわりに使用できるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。単純な使い方では、&lt;code&gt;mem_fn&lt;/code&gt; は標準のアダプタが提供しないいくつかの機能を提供する。 &lt;code&gt;std::bind1st&lt;/code&gt;、&lt;code&gt;std::bind2nd&lt;/code&gt;、&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/compose.html&#34;&gt;Boost.Compose&lt;/a&gt; と標準のアダプタを組み合わせるような複雑な使い方をしている場合は、 &lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/bind.html&#34;&gt;&lt;code&gt;boost::bind&lt;/code&gt;&lt;/a&gt; を使用するように書き換えることで、&lt;code&gt;mem_fn&lt;/code&gt;の恩恵を自動的に受けることができる。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q2&#34; name=&#34;Q2&#34;&gt;既に書いてしまったコード中のstd::mem_fun[_ref]を、 全てmem_fnで置き換えるべきか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いいえ。そうする強い理由がないならすべきではない。&lt;code&gt;mem_fn&lt;/code&gt; は、標準のアダプタに 非常に良く似ているが、100%の互換性があるわけではない。特に、&lt;code&gt;mem_fn&lt;/code&gt;は、標準の アダプタとは違って &lt;code&gt;std::[const_]mem_fun[1][_ref]_t&lt;/code&gt; 型のオブジェクトを戻さないので、 標準の &lt;code&gt;argument_type&lt;/code&gt; 及び &lt;code&gt;first_argument_type&lt;/code&gt; という (nested) &lt;code&gt;typedef&lt;/code&gt; を 用いて第一引数の型を記述することが (完全には) できない。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q3&#34;&gt;mem_fnは COM のメソッドに使えるか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;はい。&lt;code&gt;#define BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; とすれば可能である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#Q4&#34; name=&#34;Q4&#34;&gt;何故 BOOST_MEM_FN_ENABLE_STDCALL は最初から有効になっていないのか?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;特定のベンダへの依存を避けるため、可搬性のない拡張は、一般にデフォルトでオフにされるべきである。 もし &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; がデフォルトで有効であったなら、あなたはそうとは気づかずに その拡張を使ってしまい、結果としてあなたのコードの可搬性が損なわれるかもしれない。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#interface&#34; name=&#34;interface&#34;&gt;インタフェース&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#synopsis&#34; name=&#34;synopsis&#34;&gt;Synopsis&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; boost
{

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_1&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ());

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_2&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_2_1&lt;/i&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_3&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_4&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_5&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2));

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_6&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;);

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 実際には、より多くの引数をとるような関数が、更にいくつかオーバーロードされている&lt;/span&gt;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#requirements&#34; name=&#34;requirements&#34;&gt;必須事項&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Synopsis で述べられた全ての &lt;em&gt;unspecified-N&lt;/em&gt; 型は &lt;code&gt;CopyConstructible&lt;/code&gt; (コピーコンストラクト可能) かつ &lt;code&gt;Assignable&lt;/code&gt; (代入可能) であること。そのためのコピーコンストラクタ及び代入演算子 は例外を送出しないこと。 &lt;em&gt;unspecified-N&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;mem_fn&lt;/code&gt; に渡されたメンバ関数ポインタの戻り型、と定義されること (Synopsis での &lt;code&gt;R&lt;/code&gt;)。 &lt;em&gt;unspecified-2-1&lt;/em&gt; &lt;code&gt;::result_type&lt;/code&gt; は &lt;code&gt;R const &amp;amp;&lt;/code&gt; 、と定義されること。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#get_pointer&#34; name=&#34;get_pointer&#34;&gt;get_pointer&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; get_pointer(T &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; p)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#mem_fn&#34; name=&#34;mem_fn&#34;&gt;mem_fn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_1&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) ())
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt;あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_2&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) () &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;(t.*pmf)()&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)()&lt;/code&gt; と等価である(それ以外の場合)。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_2_1&lt;/i&gt; mem_fn(R T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pm)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t)&lt;/code&gt; は &lt;code&gt;t.*pm&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;get_pointer(t)-&amp;gt;*pm&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_3&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_4&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_5&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; あるいはその派生型の左辺値である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;R&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;T&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A1&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;A2&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;i&gt;unspecified_6&lt;/i&gt; mem_fn(R (T&lt;span style=&#34;color: #666666&#34;&gt;::*&lt;/span&gt;pmf) (A1, A2) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;戻り値： 関数オブジェクト &lt;code&gt;f&lt;/code&gt; を戻す。ここで、式 &lt;code&gt;f(t, a1, a2)&lt;/code&gt; は &lt;code&gt;(t.*pmf)(a1, a2)&lt;/code&gt; と等価である (&lt;code&gt;t&lt;/code&gt; が &lt;code&gt;T [const]&lt;/code&gt; あるいはその派生型である場合)。 あるいは &lt;code&gt;(get_pointer(t)-&amp;gt;*pmf)(a1, a2)&lt;/code&gt; と等価である（それ以外の場合）。&lt;/li&gt;
&lt;li&gt;例外： 送出しない。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#implementation&#34; name=&#34;implementation&#34;&gt;実装&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#files&#34; name=&#34;files&#34;&gt;ファイル&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;boost/mem_fn.hpp (メインヘッダ)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_cc.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_vw.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;boost/bind/mem_fn_template.hpp (mem_fn.hpp より使用される。直接インクルードしないこと。)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_test.cpp (テスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_derived_test.cpp (派生オブジェクトでのテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_fastcall_test.cpp (&lt;code&gt;__fastcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_stdcall_test.cpp (&lt;code&gt;__stdcall&lt;/code&gt;のテスト)&lt;/li&gt;
&lt;li&gt;libs/bind/test/mem_fn_void_test.cpp (戻りが&lt;code&gt;void&lt;/code&gt;であるケースのテスト)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#dependency&#34; name=&#34;dependency&#34;&gt;依存関係&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Boost.Config&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#number-of-arguments&#34; name=&#34;number-of-arguments&#34;&gt;引数の上限個数&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;この実装では、8つまでの引数をとるメンバ関数がサポートされている。これは、設計に固有の 制限という訳ではなく、実装の詳細である。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#stdcall&#34; name=&#34;stdcall&#34;&gt;&#34;&lt;strong&gt;stdcall&#34; と &#34;&lt;/strong&gt;fastcall&#34; のサポート&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;いくつかのプラットフォームでは、 &lt;strong&gt;呼び出し規則&lt;/strong&gt; (どのように関数が起動されるかの規則: 引数はどのように渡されるのか、戻り値はどのように扱われるのか、もしスタックを使用したなら、 誰がそれを奇麗にするのか) の異なるような何種類かのメンバ関数を作成できる。&lt;/p&gt;
&lt;p&gt;例えば、Windows API の関数と、COMインタフェースのメンバ関数は、 &lt;code&gt;__stdcall&lt;/code&gt; という呼び出し規則を用いるし、 Borland の VCL コンポーネントは &lt;code&gt;__fastcall&lt;/code&gt; を用いる。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__stdcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_STDCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mem_fn&lt;/code&gt; を &lt;code&gt;__fastcall&lt;/code&gt; メンバ関数に用いるには、mem_fn.hpp が (直接、あるいは間接的に) インクルードされる前に マクロ &lt;code&gt;BOOST_MEM_FN_ENABLE_FASTCALL&lt;/code&gt; を &lt;code&gt;#define&lt;/code&gt; する。&lt;/p&gt;
&lt;p&gt;[注意: これは可搬性のない拡張であり、インタフェースの一部ではない。]&lt;/p&gt;
&lt;p&gt;[注意: いくつかのコンパイラは、 &lt;code&gt;__stdcall&lt;/code&gt; キーワードに対して最小限のサポートしか提供していない。]&lt;/p&gt;
&lt;h3&gt;&lt;a href=&#34;http://boostjp.github.io/archive/boost_docs/libs/mem_fn.html#acknowledgements&#34; name=&#34;acknowledgements&#34;&gt;謝辞&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get_pointer&lt;/code&gt;ベースの設計は、Rene Jageによる、特性クラスを用いて &lt;code&gt;mem_fn&lt;/code&gt;を ユーザ定義のスマートポインタに適合させるという提案に影響されたものである。&lt;/p&gt;
&lt;p&gt;フォーマルレビューの期間に、Richard Crossley、 Jens Maurer、 Ed Brey、その他の方々の示唆によって、たくさんの 改良があった。レビューマネージャは Darin Adler であった。&lt;/p&gt;
&lt;p&gt;Steve Anichini は、COMインタフェースが &lt;code&gt;__stdcall&lt;/code&gt; を使用していることを指摘した。&lt;/p&gt;
&lt;p&gt;Dave Abrahams は、不完全なコンパイラにおいても &#34;戻り値なし&#34; をサポートすべく、&lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;mem_fn&lt;/code&gt; を改良した。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Copyright © 2001, 2002 by Peter Dimov and Multi Media Ltd. Permission to copy, use, modify, sell and distribute this document is granted provided this copyright notice appears in all copies. This document is provided &#34;as is&#34; without express or implied warranty, and with no claim as to its suitability for any purpose.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Japanese Translation Copyright © 2003 SATO Yusuke &lt;a href=&#34;mailto:y-sato@y-sa.to&#34;&gt;y-sato@y-sa.to&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の 複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」 に提供されており、いかなる明示的、暗黙的保証も行わない。また、 いかなる目的に対しても、その利用が適していることを関知しない。&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
    <entry>
      <title>無名関数 -- コードブロック中の識別子修飾が壊れていたので修正</title>
      <link href="http://boostjp.github.io/tips/lambda.html"/>
      <id>248c365e6a1ad2aee2f3e793355361d33b3cea93:tips/lambda.md</id>
      <updated>2015-09-29 11:34:51 +0900</updated>
      
        <content type="html">&lt;h1 itemprop=&#34;name&#34;&gt;無名関数&lt;/h1&gt;
&lt;div itemprop=&#34;articleBody&#34;&gt;&lt;p&gt;無名関数は、&lt;a href=&#34;http://www.boost.org/doc/libs/release/doc/html/lambda.html&#34; target=&#34;_blank&#34;&gt;Boost Lambda Library&lt;/a&gt; または、 &lt;a href=&#34;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/index.html&#34; target=&#34;_blank&#34;&gt;Boost Phoenix Library&lt;/a&gt; を使用することによって表現できる。&lt;/p&gt;
&lt;h2&gt;インデックス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lambda.html#basic-usage&#34;&gt;基本的な使い方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lambda.html#member-variable&#34;&gt;メンバ変数を扱う&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lambda.html#multiple-expressions&#34;&gt;2つ以上の式を書く&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lambda.html#basic-usage&#34; name=&#34;basic-usage&#34;&gt;基本的な使い方&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Lambdaによって無名関数を表現するには、&lt;code&gt;boost::lambda&lt;/code&gt;名前空間の&lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;_2&lt;/code&gt;というプレースホルダーと呼ばれる値を使用する。以下は、コンテナから特定の条件に一致した値を見つけ出す例である。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/range/algorithm/find_if.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;is_target_value&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; x) { &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;; }

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;
    v.push_back(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);
    v.push_back(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;);
    v.push_back(&lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;);

    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(v, is_target_value);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (it &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v.end())
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;it &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Not Found&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;これを、Boost.Lambdaを使用して書くと以下のようになる：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/lambda/lambda.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/range/algorithm/find_if.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;
    v.push_back(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;);
    v.push_back(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;);
    v.push_back(&lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;);

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lambda&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_1;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff0000&#34;&gt;boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(v, _1 &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;);&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (it &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v.end())
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;it &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Not Found&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_1&lt;/code&gt;という値は、「無名関数の第1引数」を意味し、この場合、コンテナの各要素が渡されることになる。&lt;/p&gt;
&lt;p&gt;Boost.Lambdaでは、&lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;_2&lt;/code&gt;のようなプレースホルダーに対して各種演算処理を適用するというスタイルで、無名関数を表現する。&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lambda.html#member-variable&#34; name=&#34;member-variable&#34;&gt;メンバ変数を扱う&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Lambdaでメンバ変数を扱うには、&lt;code&gt;operator-&amp;gt;*()&lt;/code&gt;を使用する。左辺はポインタである必要があるため、&lt;code&gt;&amp;amp;_1&lt;/code&gt;のように表記し、右辺にはメンバ変数ポインタを指定する。&lt;/p&gt;
&lt;p&gt;以下は、&lt;code&gt;Person&lt;/code&gt;クラスを要素とするコンテナから、&lt;code&gt;name&lt;/code&gt;メンバ変数をキーにして該当する要素を検索する処理である：&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/lambda/lambda.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/range/algorithm/find_if.hpp&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;struct&lt;/span&gt; Person {
    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; id;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string name;

    Person() &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; id(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;) {}
    Person(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; id, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; name) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; id(id), name(name) {}
};

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;()
{
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Person&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; v;
    v.push_back(Person(&lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Alice&#34;&lt;/span&gt;));
    v.push_back(Person(&lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Bob&#34;&lt;/span&gt;));
    v.push_back(Person(&lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Carol&#34;&lt;/span&gt;));

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;lambda&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;_1;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;Person&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;::&lt;/span&gt;iterator it &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;find_if(v, &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;_1 &lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;*&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;Person&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;name &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Alice&#34;&lt;/span&gt;);
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; (it &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; v.end())
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; it&lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt;id &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt;
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;Not Found&#34;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&#34;http://boostjp.github.io/tips/lambda.html#multiple-expressions&#34; name=&#34;multiple-expressions&#34;&gt;2つ以上の式を書く&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Boost.Phoenix のカンマ演算子を使用して、複数の式を書くことができる。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;codehilite&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/phoenix.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/range/irange.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;boost/range/algorithm/for_each.hpp&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #BC7A00&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color: #B00040&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;disp&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; n){
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;
}

&lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt;(){
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;namespace&lt;/span&gt; phx &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;phoenix;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;using&lt;/span&gt; phx&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;arg_names&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;arg1;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// カンマ演算子で複数の式を書く&lt;/span&gt;
    (
        phx&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;disp, arg1),        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// disp(10)&lt;/span&gt;
        phx&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;bind(&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;disp, arg1 &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; arg1)  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// disp(10 + 10)&lt;/span&gt;
    )(&lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;);

    &lt;span style=&#34;color: #B00040&#34;&gt;int&lt;/span&gt; sum &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;// 0～9 までの合計を計算する&lt;/span&gt;
    boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;for_each(boost&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;irange(&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;10&lt;/span&gt;), (
        std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; arg1 &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;,&#34;&lt;/span&gt;,
        phx&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ref(sum) &lt;span style=&#34;color: #666666&#34;&gt;+=&lt;/span&gt; arg1
    ));
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&#34;&lt;/span&gt;;
    std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; sum &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;endl;

    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;実行結果：&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;code&gt;10
20
0,1,2,3,4,5,6,7,8,9,
45
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/div&gt;</content>
      
      <author>
        <name>Akira Takahashi</name>
        <email>faithandbrave@gmail.com</email>
      </author>
    </entry>
  
</feed>