<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en"> <!--<![endif]-->
    <head>
        <meta charset="UTF-8">

        <title>graph</title>

        <meta name="viewport" content="width=device-width,initial-scale=1">

<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
<!-- <link rel="stylesheet" href="/static/css/root.css"> -->

<script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<!-- <script src="//platform.twitter.com/widgets.js"></script> -->

<!-- <script src="/static/js/root.js"></script> -->


        <!--[if lt IE 9]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

        <script>
            document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/,'js');
        </script>
    </head>
    <body>
<header>
  <nav class="navbar navbar-default" role="navigation">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#boostjp-navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">boostjp : Boost日本語情報サイト</a>
      </div>

      <div class="collapse navbar-collapse" id="boostjp-navbar-collapse">
        <form class="navbar-form navbar-right" role="search">
          <div class="form-group">
            <input type="text" class="form-control" placeholder="Search">
          </div>
          <button type="submit" class="btn btn-default">検索</button>
        </form>
      </div>
    </div>
  </nav>
</header>

        <main id="main" role="main">
            <div class="container-fluid">
<div class="row">
  <div class="col-md-2">
<ul><li><a href="/archive.html">archive</a></li><li><a href="/boostcon.html">boostcon</a></li><li><a href="/communities.html">communities</a></li><li><a href="/cppnow.html">cppnow</a></li><li><a href="/document.html">document</a></li><li><a href="/howtobuild.html">howtobuild</a></li><li><a href="/index.html">index</a></li><li><a href="/mailing-lists.html">mailing-lists</a></li><li><a href="/study_meeting.html">study_meeting</a></li><li><a href="/the-team.html">the-team</a></li><li><a href="/tips.html">tips</a></li><li><a href="/used_project.html">used_project</a></li><li><a href="/archive/cpp_online_reading.html">cpp_online_reading</a></li><li><a href="/archive/propose.html">propose</a></li><li><a href="/boostcon/2010.html">2010</a></li><li><a href="/boostcon/2011.html">2011</a></li><li><a href="/cppnow/2012.html">2012</a></li><li><a href="/cppnow/2013.html">2013</a></li><li><a href="/cppnow/2014.html">2014</a></li><li><a href="/document/boost-range-algorithm-kansu-no-susume.html">boost-range-algorithm-kansu-no-susume</a></li><li><a href="/document/boostserialization.html">boostserialization</a></li><li><a href="/document/version.html">version</a></li><li><a href="/editors_doc/start_editing.html">start_editing</a></li><li><a href="/project-updates/autoindextsurugacaizesareta.html">autoindextsurugacaizesareta</a></li><li><a href="/project-updates/boost1450ririsu.html">boost1450ririsu</a></li><li><a href="/project-updates/boost1460ririsu.html">boost1460ririsu</a></li><li><a href="/project-updates/boost1461ririsu.html">boost1461ririsu</a></li><li><a href="/project-updates/boost1470ririsu.html">boost1470ririsu</a></li><li><a href="/project-updates/boost1480ririsu.html">boost1480ririsu</a></li><li><a href="/project-updates/boost1490beta1ririsu.html">boost1490beta1ririsu</a></li><li><a href="/project-updates/boost1500ririsu.html">boost1500ririsu</a></li><li><a href="/project-updates/boost1510ririsu.html">boost1510ririsu</a></li><li><a href="/project-updates/boost1520ririsu.html">boost1520ririsu</a></li><li><a href="/project-updates/boost1530ririsu.html">boost1530ririsu</a></li><li><a href="/project-updates/boost1540ririsu.html">boost1540ririsu</a></li><li><a href="/project-updates/boost1550ririsu.html">boost1550ririsu</a></li><li><a href="/project-updates/boostalgorithmisaccepted.html">boostalgorithmisaccepted</a></li><li><a href="/project-updates/boostaligngatiaojianfukidecaizesareta.html">boostaligngatiaojianfukidecaizesareta</a></li><li><a href="/project-updates/boostassignv2garijekutosareta.html">boostassignv2garijekutosareta</a></li><li><a href="/project-updates/boostatomicgacaizesareta.html">boostatomicgacaizesareta</a></li><li><a href="/project-updates/boostbenkyoukai4nopejiwosakusei.html">boostbenkyoukai4nopejiwosakusei</a></li><li><a href="/project-updates/boostbounenkai2010noboshuupejiwosakusei.html">boostbounenkai2010noboshuupejiwosakusei</a></li><li><a href="/project-updates/boostchronogasaitakusareta.html">boostchronogasaitakusareta</a></li><li><a href="/project-updates/boostchrononorebyukaishi.html">boostchrononorebyukaishi</a></li><li><a href="/project-updates/boostcontainergacaizesareta.html">boostcontainergacaizesareta</a></li><li><a href="/project-updates/boostcontractgacaizesareta.html">boostcontractgacaizesareta</a></li><li><a href="/project-updates/boostcoroutinegacaizesareta.html">boostcoroutinegacaizesareta</a></li><li><a href="/project-updates/boostendianhatiaojianfukicaize.html">boostendianhatiaojianfukicaize</a></li><li><a href="/project-updates/boostgiliotoolboxkakuchougasaitakusareta.html">boostgiliotoolboxkakuchougasaitakusareta</a></li><li><a href="/project-updates/boostlocalelibrarygasaitakusareta.html">boostlocalelibrarygasaitakusareta</a></li><li><a href="/project-updates/boostlockfreegacaizesareta.html">boostlockfreegacaizesareta</a></li><li><a href="/project-updates/boostmianqianghui11dongjingwokaicui.html">boostmianqianghui11dongjingwokaicui</a></li><li><a href="/project-updates/boostmianqianghui12dabanwokaicui.html">boostmianqianghui12dabanwokaicui</a></li><li><a href="/project-updates/boostmianqianghui13xiantaiwokaicui.html">boostmianqianghui13xiantaiwokaicui</a></li><li><a href="/project-updates/boostmianqianghui14dongjinggakaicuisaremasu.html">boostmianqianghui14dongjinggakaicuisaremasu</a></li><li><a href="/project-updates/boostmianqianghui6zhahuangwokaicuishimashita.html">boostmianqianghui6zhahuangwokaicuishimashita</a></li><li><a href="/project-updates/boostmovegasaitakusareta.html">boostmovegasaitakusareta</a></li><li><a href="/project-updates/boostmultiprecisiongacaizesareta.html">boostmultiprecisiongacaizesareta</a></li><li><a href="/project-updates/boostodeintgacaizesareta.html">boostodeintgacaizesareta</a></li><li><a href="/project-updates/boostphoenixv3norebyushuuryou.html">boostphoenixv3norebyushuuryou</a></li><li><a href="/project-updates/boostregexnonihongoyakudokyumentowotsuika.html">boostregexnonihongoyakudokyumentowotsuika</a></li><li><a href="/project-updates/boostttigacaizesareta.html">boostttigacaizesareta</a></li><li><a href="/project-updates/boosttypeerasuregacaizesareta.html">boosttypeerasuregacaizesareta</a></li><li><a href="/project-updates/boostxintgarijekutosareta.html">boostxintgarijekutosareta</a></li><li><a href="/project-updates/boostxpressivenonihongodokyumentowotsuika.html">boostxpressivenonihongodokyumentowotsuika</a></li><li><a href="/project-updates/saitokoukai.html">saitokoukai</a></li><li><a href="/project-updates/typetraitsextensiongasaitakusareta.html">typetraitsextensiongasaitakusareta</a></li><li><a href="/project-updates/wuti.html">wuti</a></li><li><a href="/study_meeting/idea.html">idea</a></li><li><a href="/study_meeting/reversed_index.html">reversed_index</a></li><li><a href="/study_meeting/study1.html">study1</a></li><li><a href="/study_meeting/study10.html">study10</a></li><li><a href="/study_meeting/study11.html">study11</a></li><li><a href="/study_meeting/study12.html">study12</a></li><li><a href="/study_meeting/study13.html">study13</a></li><li><a href="/study_meeting/study14.html">study14</a></li><li><a href="/study_meeting/study15.html">study15</a></li><li><a href="/study_meeting/study16.html">study16</a></li><li><a href="/study_meeting/study2.html">study2</a></li><li><a href="/study_meeting/study3.html">study3</a></li><li><a href="/study_meeting/study4.html">study4</a></li><li><a href="/study_meeting/study5.html">study5</a></li><li><a href="/study_meeting/study6.html">study6</a></li><li><a href="/study_meeting/study7.html">study7</a></li><li><a href="/study_meeting/study8.html">study8</a></li><li><a href="/study_meeting/study9.html">study9</a></li><li><a href="/study_meeting/year-end-party2010-nagoya.html">year-end-party2010-nagoya</a></li><li><a href="/study_meeting/year-end-party2010-sapporo.html">year-end-party2010-sapporo</a></li><li><a href="/study_meeting/year-end-party2010-tokyo.html">year-end-party2010-tokyo</a></li><li><a href="/tips/array.html">array</a></li><li><a href="/tips/build.html">build</a></li><li><a href="/tips/build_link.html">build_link</a></li><li><a href="/tips/circular_buffer.html">circular_buffer</a></li><li><a href="/tips/config.html">config</a></li><li><a href="/tips/constcond_overload.html">constcond_overload</a></li><li><a href="/tips/cxx11-boost-mapping.html">cxx11-boost-mapping</a></li><li><a href="/tips/date_time.html">date_time</a></li><li><a href="/tips/dynamic_assert.html">dynamic_assert</a></li><li><a href="/tips/dynamic_bitset.html">dynamic_bitset</a></li><li><a href="/tips/dynamic_regex.html">dynamic_regex</a></li><li><a href="/tips/dynamic_type.html">dynamic_type</a></li><li><a href="/tips/filesystem.html">filesystem</a></li><li><a href="/tips/finite_state_machine.html">finite_state_machine</a></li><li><a href="/tips/foreach.html">foreach</a></li><li><a href="/tips/format.html">format</a></li><li><a href="/tips/function.html">function</a></li><li><a href="/tips/geometry.html">geometry</a></li><li><a href="/tips/graph.html">graph</a></li><li><a href="/tips/hashmap.html">hashmap</a></li><li><a href="/tips/ini.html">ini</a></li><li><a href="/tips/initialize.html">initialize</a></li><li><a href="/tips/interval_arithmetic.html">interval_arithmetic</a></li><li><a href="/tips/io_state.html">io_state</a></li><li><a href="/tips/iterator.html">iterator</a></li><li><a href="/tips/json.html">json</a></li><li><a href="/tips/lambda.html">lambda</a></li><li><a href="/tips/linear-algebra.html">linear-algebra</a></li><li><a href="/tips/list.html">list</a></li><li><a href="/tips/lockfree-queue.html">lockfree-queue</a></li><li><a href="/tips/lockfree-stack.html">lockfree-stack</a></li><li><a href="/tips/logging.html">logging</a></li><li><a href="/tips/math.html">math</a></li><li><a href="/tips/memory_mapped_file.html">memory_mapped_file</a></li><li><a href="/tips/move.html">move</a></li><li><a href="/tips/mpi.html">mpi</a></li><li><a href="/tips/multi_array.html">multi_array</a></li><li><a href="/tips/multi_index.html">multi_index</a></li><li><a href="/tips/multiprec-float.html">multiprec-float</a></li><li><a href="/tips/multiprec-int.html">multiprec-int</a></li><li><a href="/tips/named_parameter.html">named_parameter</a></li><li><a href="/tips/network.html">network</a></li><li><a href="/tips/noncopyable.html">noncopyable</a></li><li><a href="/tips/noncopyable_container.html">noncopyable_container</a></li><li><a href="/tips/operators.html">operators</a></li><li><a href="/tips/optional.html">optional</a></li><li><a href="/tips/parser.html">parser</a></li><li><a href="/tips/partial_eval.html">partial_eval</a></li><li><a href="/tips/priority_sort.html">priority_sort</a></li><li><a href="/tips/program_options.html">program_options</a></li><li><a href="/tips/random.html">random</a></li><li><a href="/tips/scope_guard.html">scope_guard</a></li><li><a href="/tips/serialize.html">serialize</a></li><li><a href="/tips/signals.html">signals</a></li><li><a href="/tips/smart_ptr.html">smart_ptr</a></li><li><a href="/tips/static_assert.html">static_assert</a></li><li><a href="/tips/static_regex.html">static_regex</a></li><li><a href="/tips/statistics.html">statistics</a></li><li><a href="/tips/string_algo.html">string_algo</a></li><li><a href="/tips/template_page.html">template_page</a></li><li><a href="/tips/thread.html">thread</a></li><li><a href="/tips/timer.html">timer</a></li><li><a href="/tips/tuple.html">tuple</a></li><li><a href="/tips/type_traits.html">type_traits</a></li><li><a href="/tips/unit_test.html">unit_test</a></li><li><a href="/tips/uuid.html">uuid</a></li><li><a href="/tips/variant.html">variant</a></li><li><a href="/tips/version.html">version</a></li><li><a href="/tips/xml.html">xml</a></li></ul>
  </div>
  <div class="col-md-10">
<h1>グラフ</h1>
<p>グラフ構造とそれに対する操作を行うには、<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/index.html" target="_blank">Boost Graph Library</a>を使用する。</p>
<h2>インデックス</h2>
<ul>
<li><a href="http://boostjp.github.io/tips/graph.html#define-graph">グラフ型を定義する</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#add-vertex-edge">頂点と辺を追加する</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#bundle-property">任意のクラスをプロパティにする</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#dijkstra-shortest-paths">ダイクストラ法で最短経路を求める</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#distance-map">最短経路の長さ(重みの合計)を求める</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#is-reachable">ある頂点に到達可能かどうかを調べる</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#simple-shortest-path">通過する辺が最も少ない経路を求める</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#isomorphism">2つのグラフが同型か判定する</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#minimum-spanning-tree">最小全域木を作る</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#topological-sort">トポロジカルソート</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#euler-path">一筆書きの経路を求める</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#write-graphviz">グラフをGraphviz形式(.dot)で出力する</a></li>
<li><a href="http://boostjp.github.io/tips/graph.html#read-graphviz">Graphviz形式(.dot)のデータを読み込む</a></li>
</ul>
<h2><a href="http://boostjp.github.io/tips/define-graph" name="define-graph">グラフ型を定義する</a></h2>
<p>Boost.Graphで標準的に使用する、グラフ構造のためのクラス<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/using_adjacency_list.html" target="_blank"><code><span style="color: #000">boost::adjacency_list</span></code></a>は、様々な目的に利用できるようカスタマイズが可能になっている。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class OutEdgeListS = vecS,
          class VertexListS = vecS,
          class DirectedS = directedS,
          class VertexProperties = no_property,
          class EdgeProperties = no_property,
          class GraphProperties = no_property,
          class EdgeListS = listS&gt;
class adjacency_list;</span></code></pre>
</p>
<p>設定例：</p>
<p>以下は、無向グラフを定義する例：</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">typedef
    boost::adjacency_list&lt;
        boost::listS,
        boost::vecS,
        boost::undirectedS
    &gt;
Graph;</span></code></pre>

有向グラフで、辺に重みを付ける例：</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">typedef
    boost::adjacency_list&lt;
        boost::listS,
        boost::vecS,
        boost::directedS,
        boost::no_property,
        boost::property&lt;boost::edge_weight_t, int&gt;
    &gt;
Graph;</span></code></pre>

テンプレートパラメータの説明：</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>パラメータ</th>
<th>説明</th>
<th>デフォルト</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">OutEdgeList</span></code></td>
<td>グラフの隣接構造(入辺と出辺)を表すためのコンテナを指定する</td>
<td><code><span style="color: #000">vecS</span></code> (<code><span style="color: #000">std::vector</span></code>)</td>
</tr>
<tr>
<td><code><span style="color: #000">VertexList</span></code></td>
<td>グラフの頂点集合を表すためのコンテナを指定する</td>
<td><code><span style="color: #000">vecS</span></code> (<code><span style="color: #000">std::vector</span></code>)</td>
</tr>
<tr>
<td><code><span style="color: #000">DirectedS</span></code></td>
<td>有向グラフか無向グラフかを選択する。<br /> <code><span style="color: #000">directedS</span></code> : 有向グラフ<br /> <code><span style="color: #000">undirectedS</span></code> : 無向グラフ<br /> <code><span style="color: #000">bidirectionalS</span></code> : 双方向グラフ(有向で、辺が2本)</td>
<td><code><span style="color: #000">directedS</span></code> (有向グラフ)</td>
</tr>
<tr>
<td><code><span style="color: #000">VertexProperties</span></code></td>
<td>頂点のカスタムプロパティを指定する</td>
<td><code><span style="color: #000">no_property</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">EdgeProperties</span></code></td>
<td>辺のカスタムプロパティを指定する</td>
<td><code><span style="color: #000">no_property</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">GraphProperties</span></code></td>
<td>グラフオブジェクトのカスタムプロパティを指定する</td>
<td><code><span style="color: #000">no_property</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">EdgeListS</span></code></td>
<td>グラフの辺リストを表すためのコンテナを指定する。 このコンテナは、<code><span style="color: #000">bidirectionalS</span></code>もしくは<code><span style="color: #000">undirectedS</span></code>の場合に実際に辺を格納するために使用され、<code><span style="color: #000">OutEdgeList</span></code>はコンテナの要素を指すオブジェクトを格納する。<code><span style="color: #000">directedS</span></code>の場合は<code><span style="color: #000">OutEdgeList</span></code>に直接格納されるため、このパラメータは使用しない。</td>
<td><code><span style="color: #000">listS</span></code> (<code><span style="color: #000">std::list</span></code>)</td>
</tr>
</tbody>
</table>
<p><strong>コンテナの選択</strong></p>
<p><code><span style="color: #000">OutEdgeList</span></code>, <code><span style="color: #000">VertexList</span></code>, <code><span style="color: #000">EdgeListS</span></code>パラメータでのコンテナの指定には、以下を指定できる：</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>指定可能なパラメータ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">vecS</span></code></td>
<td><code><span style="color: #000">std::vector</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">listS</span></code></td>
<td><code><span style="color: #000">std::list</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">slistS</span></code></td>
<td><code><span style="color: #000">std::slist</span></code> (非標準)</td>
</tr>
<tr>
<td><code><span style="color: #000">setS</span></code></td>
<td><code><span style="color: #000">std::set</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">multisetS</span></code></td>
<td><code><span style="color: #000">std::multiset</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">hash_setS</span></code></td>
<td><code><span style="color: #000">boost::unordered_set</span></code></td>
</tr>
<tr>
<td><code><span style="color: #000">hash_multisetS</span></code></td>
<td><code><span style="color: #000">boost::unordered_multiset</span></code></td>
</tr>
</tbody>
</table>
<p><strong>プロパティの選択</strong></p>
<p><code><span style="color: #000">VertexProperties</span></code>, <code><span style="color: #000">EdgeProperties</span></code>, <code><span style="color: #000">GraphProperties</span></code>に指定可能な、標準提供されているプロパティは以下：</p>
<p>頂点プロパティ</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>プロパティ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">vertex_index_t</span></code></td>
<td>順番</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_index1_t</span></code></td>
<td>順番</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_index2_t</span></code></td>
<td>順番</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_name_t</span></code></td>
<td>名前</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_distance_t</span></code></td>
<td>距離</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_root_t</span></code></td>
<td>ダイクストラや幅優先木での根を示す</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_all_t</span></code></td>
<td>頂点に関連づけられた全てのプロパティ</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_color_t</span></code></td>
<td>色</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_rank_t</span></code></td>
<td>ランク</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_predecessor_t</span></code></td>
<td>先行ノード</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_isomorphism_t</span></code></td>
<td>同型情報</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_invariant_t</span></code></td>
<td>不変量(<a href="http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E9%87%8F" target="_blank">Wikipedia:不変量</a>)</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_invariant1_t</span></code></td>
<td>不変量</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_invariant2_t</span></code></td>
<td>不変量</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_degree_t</span></code></td>
<td>次数(節点についてる辺の数)</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_out_degree_t</span></code></td>
<td>出次数(節点から出てる辺の数。無向の場合は次数と同じ)</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_in_degree_t</span></code></td>
<td>入次数(節点に入る辺の数。無効の場合は次数と同じ)</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_discover_time_t</span></code></td>
<td>深さ優先探索などでの発見された順番</td>
</tr>
<tr>
<td><code><span style="color: #000">vertex_finish_time_t</span></code></td>
<td>深さ優先探索などでの探索が終わった順番</td>
</tr>
</tbody>
</table>
<p>辺プロパティ</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>プロパティ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">edge_index_t</span></code></td>
<td>順番</td>
</tr>
<tr>
<td><code><span style="color: #000">edge_name_t</span></code></td>
<td>名前</td>
</tr>
<tr>
<td><code><span style="color: #000">edge_weight_t</span></code></td>
<td>重み</td>
</tr>
<tr>
<td><code><span style="color: #000">edge_weight2_t</span></code></td>
<td>重み</td>
</tr>
<tr>
<td><code><span style="color: #000">edge_capacity_t</span></code></td>
<td>キャパシティ</td>
</tr>
<tr>
<td><code><span style="color: #000">edge_residual_capacity_t</span></code></td>
<td>残りキャパシティ</td>
</tr>
<tr>
<td><code><span style="color: #000">edge_reverse_t</span></code></td>
<td>最大流アルゴリズムで使用する、向きが逆になった辺か否かを示す</td>
</tr>
<tr>
<td><code><span style="color: #000">edge_all_t</span></code></td>
<td>辺に関連づけられた全てのプロパティ</td>
</tr>
</tbody>
</table>
<p>グラフプロパティ</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>プロパティ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span style="color: #000">graph_name_t</span></code></td>
<td>名前</td>
</tr>
<tr>
<td><code><span style="color: #000">graph_all_t</span></code></td>
<td>グラフ自体に関連づけられた全てのプロパティ</td>
</tr>
</tbody>
</table>
<h2><a href="http://boostjp.github.io/tips/add-vertex-edge" name="add-vertex-edge">頂点と辺を追加する</a></h2>
<p>頂点と辺を追加する方法としては、コンストラクタを使用するものと、<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/MutableGraph.html" target="_blank"><code><span style="color: #000">boost::add_vertex()</span></code>関数と<code><span style="color: #000">boost::add_edge()</span></code>関数</a>を使用して動的に追加するものの2つがある。</p>
<p><strong>1. コンストラクタを使用する</strong></p>
<p>Boost.Graphのグラフ構造クラスは、コンストラクタで辺の範囲と頂点数をとる。</p>
<p>これを使用することで、シンプルにグラフを構築できる。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

enum { A, B, C, D, E, N };
const std::string name = "ABCDE";

int main()
{
    const std::vector&lt;Edge&gt; edges = {
        {A, B}, {A, C}, {A, D},
        {B, E}, {C, E}, {D, E}
    };

    const Graph g(edges.begin(), edges.end(), N);

    boost::print_graph(g, name.c_str());
}</span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">A --&gt; B C D 
B --&gt; E 
C --&gt; E 
D --&gt; E 
E --&gt; 
</span></code></pre></p>
<p><strong>2. 動的に追加する</strong></p>
<p>コンストラクタは初期化時のみ使用可能なため、動的に頂点や辺を追加する必要がある場合には、頂点と追加する<code><span style="color: #000">boost::add_vertex()</span></code>関数、辺を追加する<code><span style="color: #000">boost::add_edge()</span></code>関数を使用する。</p>
<p>頂点を追加する<code><span style="color: #000">boost::add_vertex()</span></code>関数は、<code><span style="color: #000">for</span></code>文や<code><span style="color: #000">while</span></code>文でループして、必要な頂点数分だけ呼び出して使用する。戻り値として、頂点記述子が返される。</p>
<p>辺を追加する<code><span style="color: #000">boost::add_edge()</span></code>関数は、追加する辺の2つの頂点を指定して使用する。順番は、<code><span style="color: #000">source</span></code>、<code><span style="color: #000">target</span></code>の順である。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">add_edge</span>(desc[A], desc[B], g);
    <span style="color:#ff0000">add_edge</span>(desc[A], desc[C], g);
    <span style="color:#ff0000">add_edge</span>(desc[A], desc[D], g);
    <span style="color:#ff0000">add_edge</span>(desc[B], desc[E], g);
    <span style="color:#ff0000">add_edge</span>(desc[C], desc[E], g);
    <span style="color:#ff0000">add_edge</span>(desc[D], desc[E], g);

    boost::print_graph(g, name.c_str());
}<span style="color: #000">#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

enum { A, B, C, D, E, N };
const std::string name = "ABCDE";

int main()
{
    Graph g;

    // 頂点を追加
    std::map&lt;int, Graph::vertex_descriptor&gt; desc;
    for (int i = 0; i &lt; N; ++i) {
        desc[i] = add_vertex(g);
    }

    // 辺を追加
    </span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">A --&gt; B C D 
B --&gt; E 
C --&gt; E 
D --&gt; E 
E --&gt; 
</span></code></pre>
※<code><span style="color: #000">add_vertex()</span></code>関数と<code><span style="color: #000">add_edge()</span></code>は、<code><span style="color: #000">boost::adjacency_list</span></code>以外のグラフ構造にも適用できるようにするため、名前空間の修飾なしで呼び出す。</p>
<p>参考：</p>
<ul>
<li><a href="http://d.hatena.ne.jp/eagle_raptor/20111221/1324478088" target="_blank">Boost.Graphで動的な頂点の追加削除 - ばるの日記</a></li>
</ul>
<h2><a href="http://boostjp.github.io/tips/bundle-property" name="bundle-property">任意のクラスをプロパティにする</a></h2>
<p>Boost.Graphのグラフ構造には、Property Mapによって頂点・辺・グラフに任意のプロパティを持たせられる。しかしながらこの方法は、プロパティが増えてくると管理しきれなくなってくるので、ひとまとめにしたくなるだろう。</p>
<p>そこで、Boost.Graphには<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/bundles.html" target="_blank">Bundleプロパティ</a>という機能が用意されている。これは、グラフ構造のプロパティ指定の場所にユーザー定義クラスを指定するという機能である。</p>
<p>後述のサンプルでは、以下のプロパティを設定している。</p>
<ul>
<li>頂点のBundleプロパティとして「名前」「人口」「郵便番号一覧」を持つ<code><span style="color: #000">City</span></code>(街)クラス</li>
<li>辺のBundleプロパティとして「名前」と「距離」を持つ<code><span style="color: #000">Highway</span></code>(高速道路)クラス</li>
<li>グラフのBundleプロパティとして「名前」を持つ<code><span style="color: #000">Country</span></code>(国)クラス</li>
</ul>
<p>そして、最短経路の計算の際に、<code><span style="color: #000">Highway</span></code>クラスの<code><span style="color: #000">distance</span></code>メンバ変数を辺の重みとして使用している。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">City</span> {
    std::string name;
    int population;
    std::vector&lt;int&gt; zipcodes;
};

struct <span style="color:#ff0000">Highway</span> {
    std::string name;
    double distance; // km
};

struct <span style="color:#ff0000">Country</span> {
    std::string name;
};

typedef boost::adjacency_list&lt;
    boost::listS, boost::vecS, boost::bidirectionalS,
    <span style="color:#ff0000">City</span>,    // 頂点のBundleプロパティ
    <span style="color:#ff0000">Highway</span>, // 辺のBundleプロパティ
    <span style="color:#ff0000">Country</span>  // グラフのBundleプロパティ
&gt; Map;

int main()
{
    Map map;

    // グラフのBundleプロパティを設定
    map[boost::graph_bundle].name = "Japan";

    // 街(頂点)を2つ追加
    Map::vertex_descriptor v1 = add_vertex(map);
    Map::vertex_descriptor v2 = add_vertex(map);

    // 頂点のBundleプロパティを設定
    map[v1].name = "Tokyo";
    map[v1].population = 13221169;
    map[v1].zipcodes.push_back(1500013);

    map[v2].name = "Nagoya";
    map[v2].population = 2267048;
    map[v2].zipcodes.push_back(4600006);

    // 辺を追加
    bool inserted = false;
    Map::edge_descriptor e;
    boost::tie(e, inserted) = add_edge(v1, v2, map);

    // 辺のBundleプロパティを設定
    map[e].name = "Tomei Expessway";
    map[e].distance = 325.5;

    // <span style="color:#ff0000">Highway</span>クラスのdistanceメンバを辺の重みとして計算
    std::vector&lt;double&gt; distance(boost::num_vertices(map));
    boost::dijkstra_shortest_paths(map, v1,
            boost::weight_map(boost::get(&amp;<span style="color:#ff0000">Highway</span>::distance, map)).
            distance_map(&amp;distance[0]));

    std::cout &lt;&lt; "Tokyo-Nagoya : " &lt;&lt; distance[v2] &lt;&lt; "km" &lt;&lt; std::endl;
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;

struct </span></code></pre>

出力</p>
<p><pre><code><span style="color: #000">Tokyo-Nagoya : 325.5km
</span></code></pre></p>
<h2><a href="http://boostjp.github.io/tips/dijkstra-shortest-paths" name="dijkstra-shortest-paths">ダイクストラ法で最短経路を求める</a></h2>
<p>ダイクストラ法で最短経路を求めるには、<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/dijkstra_shortest_paths.html" target="_blank"><code><span style="color: #000">boost::dijkstra_shortest_paths()</span></code></a>関数を使用する。</p>
<p>ここでは、以下の経路図で、頂点Sから頂点Zへの最短経路を求める。</p>
<p>経路図：</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/dijkstra_shortest_paths.png" /></p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">dijkstra_shortest_paths</span>.hpp&gt;
#include &lt;boost/assign/list_of.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt;                             Edge;
typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor   Vertex;

enum { S, A, B, C, D, E, F, Z, N };
const std::string Names = "SABCDEFZ";

// グラフを作る
Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = boost::assign::list_of&lt;Edge&gt;
        (S, A)
        (A, B)
        (B, C)
        (B, D)
        (C, E)
        (C, F)
        (D, F)
        (E, D)
        (F, E)
        (E, Z)
        (F, Z)
    ;

    const std::vector&lt;int&gt; weights = boost::assign::list_of
        (3)
        (1)
        (2)
        (3)
        (7)
        (12)
        (2)
        (11)
        (3)
        (2)
        (2)
    ;

    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    const Graph g = make_graph();
    const Vertex from = S; // 開始地点
    const Vertex to = Z; // 目的地

    // 最短経路を計算
    std::vector&lt;Vertex&gt; parents(boost::num_vertices(g));
    boost::<span style="color:#ff0000">dijkstra_shortest_paths</span>(g, from,
                boost::predecessor_map(&amp;parents[0]));

    // 経路なし
    if (parents[to] == to) {
        std::cout &lt;&lt; "no path" &lt;&lt; std::endl;
        return 1;
    }

    // 最短経路の頂点リストを作成
    std::deque&lt;Vertex&gt; route;
    for (Vertex v = to; v != from; v = parents[v]) {
        route.push_front(v);
    }
    route.push_front(from);

    // 最短経路を出力
    for (const Vertex v : route) {
        std::cout &lt;&lt; Names[v] &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/</span></code></pre>

出力</p>
<p><pre><code><span style="color: #000">S
A
B
D
F
Z
</span></code></pre>
この場合、SからZへの最短経路は、S, A, B, D, F, Zの順となる。</p>
<p><code><span style="color: #000">dijkstra_shortest_paths()</span></code>関数の第1引数はグラフ構造を表す変数への<code><span style="color: #000">const</span></code>参照、第2引数は開始地点の頂点、第3引数は先行ノードを格納する変数へのポインタである。</p>
<p>目的地から開始地点まで先行ノードを辿っていくことにより、最短経路を求めることができる。</p>
<h2><a href="http://boostjp.github.io/tips/distance-map" name="distance-map">最短経路の長さ(重みの合計)を求める</a></h2>
<p>最短経路の長さを求めるには<code><span style="color: #000">DistanceMap</span></code>を使用する。<code><span style="color: #000">DistanceMap</span></code>は、最短経路探索の結果として取得できる、開始地点から最短経路のある頂点までの距離を保存したものである。</p>
<p><code><span style="color: #000">DistanceMap</span></code>は、最短経路探索アルゴリズムに<code><span style="color: #000">boost::distance_map()</span></code>関数を使用して取得できる(他の名前付き引数に続けて記述する場合は、「<code><span style="color: #000">named_param.distance_map(...);</span></code>」のようにする)。</p>
<p>ここでは、先行ノードも一緒に求めているが、経路長のみが必要であれば、<code><span style="color: #000">DistanceMap</span></code>のみを計算してもよい。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">distance[to]</span>;
    std::cout &lt;&lt; "route length:" &lt;&lt; n &lt;&lt; std::endl;

    // 最短経路を出力
    for (const Vertex v : route) {
        std::cout &lt;&lt; Names[v] &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;
#include &lt;boost/assign/list_of.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt;                             Edge;
typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor   Vertex;

enum { S, A, B, C, D, E, F, Z, N };
const std::string Names = "SABCDEFZ";

// グラフを作る
Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = boost::assign::list_of&lt;Edge&gt;
        (S, A)
        (A, B)
        (B, C)
        (B, D)
        (C, E)
        (C, F)
        (D, F)
        (E, D)
        (F, E)
        (E, Z)
        (F, Z)
    ;

    const std::vector&lt;int&gt; weights = boost::assign::list_of
        (3)
        (1)
        (2)
        (3)
        (7)
        (12)
        (2)
        (11)
        (3)
        (2)
        (2)
    ;

    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    const Graph g = make_graph();
    const Vertex from = S; // 開始地点
    const Vertex to = Z; // 目的地

    std::vector&lt;Vertex&gt; parents(boost::num_vertices(g));
    std::vector&lt;std::size_t&gt; distance(boost::num_vertices(g));

    // 最短経路を計算
    boost::dijkstra_shortest_paths(g, from,
                boost::predecessor_map(&amp;parents[0]).distance_map(&amp;distance[0]));

    // 経路なし
    if (parents[to] == to) {
        std::cout &lt;&lt; "no path" &lt;&lt; std::endl;
        return 1;
    }

    // 最短経路の頂点リストを作成
    std::deque&lt;Vertex&gt; route;
    for (Vertex v = to; v != from; v = parents[v]) {
        route.push_front(v);
    }
    route.push_front(from);

    // 経路の長さを計算
    const std::size_t n = </span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">route length:11
S
A
B
D
F
Z
</span></code></pre></p>
<h2><a href="http://boostjp.github.io/tips/is-reachable" name="is-reachable">ある頂点に到達可能かどうかを調べる</a></h2>
<p>ある頂点に到達可能かどうかを調べるには、<code><span style="color: #000">&lt;boost/graph/graph_utility.hpp&gt;</span></code>で定義される<code><span style="color: #000">boost::is_reachable()</span></code>関数を使用する。この関数は、グラフ構造<code><span style="color: #000">g</span></code>において、頂点<code><span style="color: #000">x</span></code>が頂点<code><span style="color: #000">y</span></code>に到達可能かどうかを調べ、到達可能であれば<code><span style="color: #000">true</span></code>、そうでなければ<code><span style="color: #000">false</span></code>を返す。</p>
<p><code><span style="color: #000">boost::is_reachable()</span></code>の定義：</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">// &lt;boost/graph/graph_utility.hpp&gt;

namespace boost {
  // xからyに到達可能?
  template &lt;typename IncidenceGraph, typename VertexColorMap&gt;
  bool is_reachable(
           typename graph_traits&lt;IncidenceGraph&gt;::vertex_descriptor x,
           typename graph_traits&lt;IncidenceGraph&gt;::vertex_descriptor y,
           const IncidenceGraph&amp; g,
           VertexColorMap color // 各頂点が白で開始しなければならない
        );
}</span></code></pre>
</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">is_reachable</span>(A, E, g, color.data())) {
        std::cout &lt;&lt; "AからEに到達可能" &lt;&lt; std::endl;
    }
    else {
        assert(false);
    }

    // AからDに到達可能か調べる
    if (!boost::<span style="color:#ff0000">is_reachable</span>(A, D, g, color.data())) {
        std::cout &lt;&lt; "AからDに到達不可能" &lt;&lt; std::endl;
    }
    else {
        assert(false);
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;cassert&gt;

#include &lt;vector&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;
#include &lt;boost/assign/list_of.hpp&gt;

#include &lt;boost/detail/lightweight_test.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

enum { A, B, C, D, E, N };
const int vertex_count = N;

int main()
{
    const std::vector&lt;Edge&gt; edges = boost::assign::list_of&lt;Edge&gt;
        (A, B)(B, E)
        (A, C)(C, E)
    ; // Dはどこにも繋がっていない

    const Graph g(edges.begin(), edges.end(), vertex_count);

    // 全部白のカラーマップを作って渡す
    std::vector&lt;boost::default_color_type&gt; color(vertex_count, boost::white_color);

    // AからEに到達可能か調べる
    if (boost::</span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">AからEに到達可能
AからDに到達不可能
</span></code></pre></p>
<h2><a href="http://boostjp.github.io/tips/simple-shortest-path" name="simple-shortest-path">通過する辺が最も少ない経路を求める</a></h2>
<p>辺に重みのないグラフから最短経路を求めると、「最短単純路」という通過する辺が最も少ない経路が得られる。これは、たとえばソーシャルグラフから「Twitterで何回のRTで特定の情報に辿りつけたか」というような情報を抽出する用途に使える。</p>
<p>&lt;strike&gt;Boost.Graphの<code><span style="color: #000">boost::dijkstra_shortest_paths()</span></code>は重みのないグラフを与えるとコンパイルエラーになるので、辺の重みを全て1に設定することで代用できる。&lt;/strike&gt;</p>
<p>&lt;font color="red"&gt;※2014/02/16 修正：そのような場面では <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/breadth_first_search.html" target="_blank">Breadth-First Search</a> を使うべきである。&lt;/font&gt;</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/simple_shortest_path.png" /></p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">const std::vector&lt;int&gt; weights(edges.size(), 1);</span>

    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    const Graph g = make_graph();
    const Vertex from = S; // 開始地点
    const Vertex to = Z; // 目的地

    // 最短経路を計算
    std::vector&lt;Vertex&gt; parents(boost::num_vertices(g));
    boost::dijkstra_shortest_paths(g, from,
                boost::predecessor_map(&amp;parents[0]));

    // 経路なし
    if (parents[to] == to) {
        std::cout &lt;&lt; "no path" &lt;&lt; std::endl;
        return 1;
    }

    // 最短経路の頂点リストを作成
    std::deque&lt;Vertex&gt; route;
    for (Vertex v = to; v != from; v = parents[v]) {
        route.push_front(v);
    }
    route.push_front(from);

    // 最短経路を出力
    for (const Vertex v : route) {
        std::cout &lt;&lt; Names[v] &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt;                             Edge;
typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor   Vertex;

enum { S, A, B, C, D, E, F, G, Z, N };
const std::string Names = "SABCDEFGZ";

// グラフを作る
Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = {
        {S, A},
        {A, B},
        {B, C},
        {B, D},
        {C, E},
        {D, G},
        {E, D},
        {G, E},
        {E, F},
        {F, Z},
        {G, Z},
    };

    // 辺の重みは1
    </span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">S
A
B
D
G
Z
</span></code></pre></p>
<h2><a href="http://boostjp.github.io/tips/isomorphism" name="isomorphism">2つのグラフが同型か判定する</a></h2>
<p>2つのグラフが同型かを判定するには、<code><span style="color: #000">&lt;boost/graph/isomorphism.hpp&gt;</span></code>で定義される<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/isomorphism.html" target="_blank"><code><span style="color: #000">boost::isomorphism()</span></code></a>関数を使用する。この関数は、引数として2つのグラフをとり、それらが同型であれば<code><span style="color: #000">true</span></code>、そうでなければ<code><span style="color: #000">false</span></code>を返す。
ここでは、以下の2つのグラフを比較する。</p>
<p>g1:</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/isomorphism_1.png" /></p>
<p>g2:</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/isomorphism_2.png" /></p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">isomorphism</span>.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS&gt; Graph;
const int vertex_count = 12;

Graph make_graph1()
{
    const std::vector&lt;std::pair&lt;int, int&gt;&gt; edges = {
        { 0,  1}, { 1, 2},
        { 0,  2},
        { 3,  4}, { 4, 5},
        { 5,  6}, { 6, 3},
        { 7,  8}, { 8, 9},
        { 9, 10},
        {10, 11}, {11, 7}
    };
    return Graph(edges.begin(), edges.end(), vertex_count);
}

Graph make_graph2()
{
    const std::vector&lt;std::pair&lt;int, int&gt;&gt; edges = {
        { 9, 10}, {10, 11},
        {11,  9},
        { 0,  1}, { 1,  3},
        { 3,  2}, { 2,  0},
        { 4,  5}, { 5,  7},
        { 7,  8},
        { 8,  6}, { 6,  4}
    };
    return Graph(edges.begin(), edges.end(), vertex_count);
}

int main()
{
    const Graph g1 = make_graph1();
    const Graph g2 = make_graph2();

    const bool result = boost::<span style="color:#ff0000">isomorphism</span>(g1, g2);
    std::cout &lt;&lt; "isomorphic? " &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;boost/graph/</span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">isomorphic? true
</span></code></pre></p>
<h2><a href="http://boostjp.github.io/tips/minimum-spanning-tree" name="minimum-spanning-tree">最小全域木を作る</a></h2>
<p>グラフに含まれるすべての頂点を含む最小の部分グラフを、最小全域木(minimum spanning tree)と言う。</p>
<p>Boost.Graphには、最小全域木を作るためのアルゴリズムとして、以下の2つの関数が用意されている。</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>関数</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://boostjp.github.com/libs/graph/doc/kruskal_min_spanning_tree.html" target="_blank"><code><span style="color: #000">boost::kruskal_minimum_spanning_tree()</span></code></a></td>
<td>クラスカル法</td>
</tr>
<tr>
<td><a href="http://boostjp.github.com/libs/graph/doc/prim_minimum_spanning_tree.html" target="_blank"><code><span style="color: #000">boost::prim_minimum_spanning_tree()</span></code></a></td>
<td>プリム法</td>
</tr>
</tbody>
</table>
<p>これらを以下のグラフに適用すると</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/minimum_spanning_tree_1.png" /></p>
<p>以下のような最小全域木(赤の太線部分)が手に入る。</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/minimum_spanning_tree_2.png" /></p>
<p>それぞれの使い方は以下のようになる。</p>
<p><strong>クラスカル法</strong></p>
<p>クラスカル法によって最小全域木を求める<code><span style="color: #000">boost::kruskal_minimum_spanning_tree()</span></code>関数は、Output Iteratorで最小全域木の辺記述子(edge descriptor)を返す。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">kruskal_minimum_spanning_tree</span>(g, std::back_inserter(spanning_tree));

    for (const EdgeDesc&amp; e : spanning_tree) {
        std::cout &lt;&lt; "(" &lt;&lt; Name[boost::source(e, g)] &lt;&lt; ","
                         &lt;&lt; Name[boost::target(e, g)] &lt;&lt; ")" &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/kruskal_min_spanning_tree.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;
typedef boost::graph_traits&lt;Graph&gt;::edge_descriptor EdgeDesc;

std::string Name = "ABCDE";
enum {A, B, C, D, E, N};

Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = {
        {A, C},
        {B, D},
        {B, E},
        {C, B},
        {C, D},
        {D, E},
        {E, A}
    };

    const std::vector&lt;int&gt; weights = {
        1,
        1,
        2,
        7,
        3,
        1,
        1
    };
    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    const Graph g = make_graph();

    std::vector&lt;EdgeDesc&gt; spanning_tree;
    boost::</span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">(A,C)
(D,E)
(E,A)
(B,D)
</span></code></pre></p>
<p><strong>プリム法</strong></p>
<p>プリム法によって最小全域木を求める<code><span style="color: #000">boost::prim_minimum_spanning_tree()</span></code>関数は、先行ノードマップ(predecessor map)として最小全域木を返す。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;iostream&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/prim_minimum_spanning_tree.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;
typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor VertexDesc;

std::string Name = "ABCDE";
enum {A, B, C, D, E, N};

Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = {
        {A, C},
        {B, D},
        {B, E},
        {C, B},
        {C, D},
        {D, E},
        {E, A},
    }

    const std::vector&lt;int&gt; weights = {
        1,
        1,
        2,
        7,
        3,
        1,
        1,
    };
    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    Graph g = make_graph();

    std::vector&lt;VertexDesc&gt; parents(N);
    boost::prim_minimum_spanning_tree(g, &amp;parents[0]);

    for (std::size_t i = 0; i &lt; N; ++i) {
        if (parents[i] != i) {
            std::cout &lt;&lt; "parent[" &lt;&lt; Name[i] &lt;&lt; "] = " &lt;&lt; Name[parents[i]] &lt;&lt; std::endl;
        }
        else {
            std::cout &lt;&lt; "parent[" &lt;&lt; Name[i] &lt;&lt; "] = no parent" &lt;&lt; std::endl;
        }
    }
}</span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">parent[A] = no parent
parent[B] = D
parent[C] = A
parent[D] = E
parent[E] = A
</span></code></pre></p>
<h2><a href="http://boostjp.github.io/tips/topological-sort" name="topological-sort">トポロジカルソート</a></h2>
<p>無閉路有向グラフ(DAG : Directed Acyclic Graph)に順序を付けるトポロジカルソートは、<code><span style="color: #000">&lt;boost/graph/topological_sort.hpp&gt;</span></code>で定義される<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/topological_sort.html" target="_blank"><code><span style="color: #000">boost::topological_sort()</span></code></a>関数を使用する。</p>
<p>この関数は引数として、グラフ構造への<code><span style="color: #000">const</span></code>参照と、頂点リストを出力するOutput Iteratorをとる。(頂点リストは逆順で返されるため、<code><span style="color: #000">boost::adaptors::reversed</span></code>や<code><span style="color: #000">rbegin()</span></code>/<code><span style="color: #000">rend()</span></code>などで正順に直して使用する。)</p>
<p>ここでは、以下のグラフにトポロジカルソートを適用する：</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/topological_sort.png" /></p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">topological_sort</span>.hpp&gt;
#include &lt;boost/range/algorithm/for_each.hpp&gt;
#include &lt;boost/range/adaptor/reversed.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = {
        {0, 1}, {2, 4},
        {2, 5},
        {0, 3}, {1, 4},
        {4, 3}
    };
    return Graph(edges.begin(), edges.end(), 6);
}

int main()
{
    const Graph g = make_graph();

    std::vector&lt;int&gt; result;
    boost::<span style="color:#ff0000">topological_sort</span>(g, std::back_inserter(result));

    boost::for_each(result | boost::adaptors::reversed, [](int vertex) {
        std::cout &lt;&lt; vertex &lt;&lt; std::endl;
    });
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/</span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">2
5
0
1
4
3
</span></code></pre>
出力から、有向グラフgがトポロジカルソートによって「2 → 5 → 0 → 1 → 4 → 3」の順序が付けられたことがわかる。</p>
<p>なお、<code><span style="color: #000">boost::topological_sort()</span></code>関数に、閉路のある有向グラフを指定した場合、<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/exception.html#not_a_dag" target="_blank"><code><span style="color: #000">boost::not_a_dag</span></code></a>例外が投げられる。</p>
<h2><a href="http://boostjp.github.io/tips/euler-path" name="euler-path">一筆書きの経路を求める</a></h2>
<p>オイラー閉路というのを求めると、グラフの一筆書きの経路を得ることができる。ここでは、「サンタクロースの家」と呼ばれる無向グラフの一筆書きを求める。</p>
<p>Boost.Graphにはオイラー閉路のためのアルゴリズムは用意されていないが、以下のGitHubにある<code><span style="color: #000">shand::graph::euler_path()</span></code>関数を利用することで、一筆書きを容易に求められる。</p>
<ul>
<li><a href="https://github.com/faithandbrave/Shand/blob/master/shand/graph/euler_path.hpp" target="_blank">shand/graph/euler_path.hpp</a></li>
</ul>
<p><pre class="codehilite"><code class="language-cpp"><span style="color:#ff0000">euler_path</span>.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;

enum {A, B, C, D, E, N};
const std::string name = "ABCDE";

int main()
{
    typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS&gt; Graph;
    typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor vertex_desc;

    const std::vector&lt;std::pair&lt;int, int&gt; &gt; edges = {
        {A, B},
        {B, C},
        {C, A},
        {B, D},
        {B, E},
        {C, D},
        {D, E},
        {E, C}
    };

    const Graph g(edges.begin(), edges.end(), N);
    std::deque&lt;vertex_desc&gt; path;

    if (!shand::graph::<span style="color:#ff0000">euler_path</span>(g, E, [&amp;path](vertex_desc v) { path.push_front(v); })) {
        std::cout &lt;&lt; "euler path failed" &lt;&lt; std::endl;
        return 1;
    }

    BOOST_FOREACH (const vertex_desc&amp; v, path) {
        std::cout &lt;&lt; name[v] &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;shand/graph/</span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">E
B
A
C
B
D
C
E
D
</span></code></pre>
E, B, A, C, B, D, C, E, Dの順に頂点をたどれば一筆書きになることがわかった。</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/euler_path.png" /></p>
<h2><a href="http://boostjp.github.io/tips/write-graphviz" name="write-graphviz">グラフをGraphviz形式(.dot)で出力する</a></h2>
<p>グラフをGraphviz形式(.dot)で出力するには、<code><span style="color: #000">&lt;boost/graph/graphviz.hpp&gt;</span></code>をインクルードし、<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/write-graphviz.html" target="_blank"><code><span style="color: #000">boost::write_graphviz()</span></code></a>関数を使用する。この機能のために、別途ライブラリは必要としない。</p>
<p><code><span style="color: #000">write_graphviz()</span></code>関数の引数：</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>引数</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1引数</td>
<td>出力先の<code><span style="color: #000">std::ostream&amp;</span></code></td>
</tr>
<tr>
<td>第2引数</td>
<td>グラフ構造への<code><span style="color: #000">const&amp;</span></code></td>
</tr>
<tr>
<td>第3引数</td>
<td>出力方法のカスタマイズ方法 (ここでは、頂点名を出力するために<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/write-graphviz.html#concept:PropertyWriter" target="_blank"><code><span style="color: #000">make_label_writer()</span></code></a>を使用している)</td>
</tr>
</tbody>
</table>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graphviz.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

enum { A, B, C, D, E, N };
const std::string name = "ABCDE";

int main()
{
    const std::vector&lt;Edge&gt; edges = {
        {A, B}, {A, C}, {A, D},
        {B, E}, {C, E}, {D, E}
    };

    const Graph g(edges.begin(), edges.end(), N);

    // graphvizの形式(*.dot)で出力
    std::ofstream file("test.dot");
    boost::write_graphviz(file, g, boost::make_label_writer(name.c_str()));
}</span></code></pre>

出力されたtest.dotファイル：</p>
<p><pre><code><span style="color: #000">digraph G {
0[label="A"];
1[label="B"];
2[label="C"];
3[label="D"];
4[label="E"];
0-&gt;1 ;
0-&gt;2 ;
0-&gt;3 ;
1-&gt;4 ;
2-&gt;4 ;
3-&gt;4 ;
}
</span></code></pre></p>
<p>Graphvizのdotコマンドを使用してpngに変換：</p>
<p><pre><code><span style="color: #000">dot -Tpng test.dot -o test.png
</span></code></pre>
出力されたtest.png：</p>
<p><img alt="" src="https://raw.githubusercontent.com/boostjp/image/master/tips/graph/graphviz.png" /></p>
<p>追加資料：</p>
<ul>
<li><a href="http://d.hatena.ne.jp/faith_and_brave/20100416/1271388752" target="_blank">Boost.Graph Graphviz形式で重みを出力</a></li>
</ul>
<h2><a href="http://boostjp.github.io/tips/read-graphviz" name="read-graphviz">Graphviz形式(.dot)のデータを読み込む</a></h2>
<p>Graphviz形式(.dot)のデータを読み込むには、<code><span style="color: #000">&lt;boost/graph/graphviz.hpp&gt;</span></code>で定義される<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/read_graphviz.html" target="_blank"><code><span style="color: #000">boost::read_graphviz()</span></code></a>関数を使用する。この関数を使用するには、Boost Regex Libraryをリンクする必要がある。</p>
<p>ここでは、「[グラフをGraphviz形式(.dot)で出力する](#write-graphviz」で出力したtest.dotファイルを読み込む。</p>
<p><code><span style="color: #000">read_graphviz()</span></code>関数の引数：</p>
<table border="1" bordercolor="#888" style="border-collapse:collapse">
<thead>
<tr>
<th>引数</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1引数</td>
<td>入力元の<code><span style="color: #000">std::istream&amp;</span></code></td>
</tr>
<tr>
<td>第2引数</td>
<td>グラフ構造への参照</td>
</tr>
<tr>
<td>第3引数</td>
<td>DOT言語のプロパティを処理するための<code><span style="color: #000">boost::dynamic_properties</span></code>型変数への参照</td>
</tr>
</tbody>
</table>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graphviz.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;

enum { A, B, C, D, E, N };
const std::string name = "ABCDE";

int main()
{
    std::ifstream file("test.dot");

    Graph g;
    boost::dynamic_properties dp(boost::ignore_other_properties);
    boost::read_graphviz(file, g, dp);

    boost::print_graph(g, name.c_str());
}</span></code></pre>

出力：</p>
<p><pre><code><span style="color: #000">A --&gt; B C D
B --&gt; E
C --&gt; E
D --&gt; E
E --&gt;
</span></code></pre>
tested boost version is 1.51.0</p>
  </div>
</div>
            </div>
        </main>
    </body>
    <!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started -->
    <!--[if lt IE 7 ]>
        <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
        <script>
            window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
        </script>
    <![endif]-->
</html>
