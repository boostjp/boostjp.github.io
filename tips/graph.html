<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]--><!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]--><!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]--><!--[if gt IE 8]><!--><html class=no-js lang=en> <!--<![endif]--> <head><meta charset=UTF-8><title>グラフ - boostjp</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css><!-- <link rel="stylesheet" href="/static/css/root.css"> --><script src=//code.jquery.com/jquery-2.1.1.min.js></script><script src=//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js></script><!-- <script src="//platform.twitter.com/widgets.js"></script> --><!-- <script src="/static/js/root.js"></script> --><!--[if lt IE 9]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]--><script>
            document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/,'js');
        </script><style type=text/css>
.tree{
  -webkit-border-radius:4px;
  -moz-border-radius:4px;
  border-radius:4px;
  -webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);
  -moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);
  box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);
  background-color:#fbfbfb;
  border:1px solid #999;
  margin-bottom:10px;
  /*max-height:300px;*/
  /*min-height:20px;*/
  /*overflow-y:auto;*/
  padding:3px
}
.tree ul {
  padding-left:32px
}
.tree > ul{
  padding-left:0px
}
.tree a{
  display:inline;
  overflow:hidden;
  text-overflow:ellipsis;
  width:90%
}
.tree li{
  list-style-type:none;
  margin:0;
  padding:4px 0 0 2px;
  position:relative
}
.tree li::before,.tree li::after{
  content:'';
  left:-20px;
  position:absolute;
  right:auto
}
.tree li::before{
  border-left:1px solid #999;
  bottom:50px;
  height:100%;
  top:0;
  width:1px;
  -webkit-transition:"border-color 0.1s ease 0.1s";
  -moz-transition:"border-color 0.1s ease 0.1s";
  -o-transition:"border-color 0.1s ease 0.1s";
  transition:"border-color 0.1s ease 0.1s"
}
.tree li::after{
  border-top:1px solid #999;
  height:20px;
  top:13px;
  width:23px;
  -webkit-transition:"border-color 0.1s ease 0.1s";
  -moz-transition:"border-color 0.1s ease 0.1s";
  -o-transition:"border-color 0.1s ease 0.1s";
  transition:"border-color 0.1s ease 0.1s"
}
.tree li span{
  -moz-border-radius:5px;
  -webkit-border-radius:5px;
  border:1px solid #999;
  border-radius:5px;
  display:inline-block;
  line-height:14px;
  padding:2px 4px;
  text-decoration:none;
  -webkit-transition:color .2s ease .1s,background-color .2s ease .1s,border-color .3s ease .2s;
  -moz-transition:color .2s ease .1s,background-color .2s ease .1s,border-color .3s ease .2s;
  -o-transition:color .2s ease .1s,background-color .2s ease .1s,border-color .3s ease .2s;
  transition:color .2s ease .1s,background-color .2s ease .1s,border-color .3s ease .2s
}
.tree li.parent_li>span{cursor:pointer}
.tree li.parent_li>span:hover{
  background-color:#df8505;
  border:1px solid #c67605;
  color:#fff
}
.tree li.parent_li>span:hover+ul li::after{border-top-color:#f89406}
.tree li.parent_li>span:hover+ul li::before{border-left-color:#f89406}
.tree li.parent_li>span:hover+ul li span{
  background:#fddfb3;
  border:1px solid #faa937;
  color:#000
}
.tree li:last-child::before{height:30px}
.tree>ul>li::before,.tree>ul>li::after{border:0}
        </style><script>
function tree_onclick(e) {
    var children = $(this).parent('li.parent_li').find(' > ul > li');
    if (children.is(':visible')) {
        children.hide(100);
        $(this)
            .attr('title', 'Expand this branch')
            .find(' > i')
            .addClass('glyphicon-plus')
            .removeClass('glyphicon-minus');
    }
    else {
        children.show(100);
        $(this)
            .attr('title', 'Collapse this branch')
            .find(' > i')
            .addClass('glyphicon-minus')
            .removeClass('glyphicon-plus');
    }
    e.stopPropagation();
}
        </script></head> <body> <header> <nav class="navbar navbar-default" role=navigation> <div class=container-fluid> <div class=navbar-header> <button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=#navbar-collapse> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=/>boostjp : Boost日本語情報サイト</a> </div> <div class="collapse navbar-collapse" id=navbar-collapse> <form class="navbar-form navbar-right" role=search> <div class=form-group> <input type=text class=form-control placeholder=Search> </div> <button type=submit class="btn btn-default">検索</button> </form> </div> </div> </nav> </header> <main id=main role=main> <div class=container-fluid> <div class=row> <div class=col-md-3> <div class=tree> <ul> <li> <a href=/communities.html>コミュニティ</a> </li> <li> <a href=/howtobuild.html>Boostライブラリのビルド方法</a> </li> <li> <a href=/index.html>boostjp</a> </li> <li> <a href=/mailing-lists.html>メーリングリスト</a> </li> <li> <a href=/the-team.html>運営メンバ</a> </li> <li> <a href=/used_project.html>Boostを使用しているプロジェクト</a> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/archive.html>アーカイブ</a> <ul> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/archive/boost_docs.html>旧Boost日本語化プロジェクト</a> <ul> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> document <ul> <li style="display: none"> <a href=/archive/boost_docs/document/error_handling.html>エラーと例外のハンドリング</a> </li> <li style="display: none"> <a href=/archive/boost_docs/document/generic_exception_safety.html>ジェネリックコンポーネントにおける例外安全性</a> </li> <li style="display: none"> <a href=/archive/boost_docs/document/generic_programming.html>ジェネリックプログラミング手法</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/archive/boost_docs/libs.html>各ライブラリの翻訳ドキュメント</a> <ul> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/archive/boost_docs/libs/array.html>Array wrapper library</a> <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array.html>arrayクラス, 固定サイズ配列のSTLコンテナ</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array.hpp.html>array.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array1.cpp.html>array1.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array2.cpp.html>array2.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array3.cpp.html>array3.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array4.cpp.html>array4.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array5.cpp.html>array5.cpp</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> bind <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/bind/bind.html>bind.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/bind/bind_as_compose.cpp.html>bind_as_compose.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/bind/mem_fn.html>mem_fn.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/bind/ref.html>ref.hpp</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> compatibility <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/compatibility/index.html>Boost.Compatibilty ライブラリ</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> compose <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose.html>Compose Function Object Adapters</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose.hpp.html>boost/compose.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose1.cpp.html>compose1.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose2.cpp.html>compose2.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose3.cpp.html>compose3.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose4.cpp.html>compose4.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/index.html>非推奨： Compose library</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/print.hpp.html>libs/compose/print.hpp</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> concept_check <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/bibliography.html>参考文献</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/concept_check.html>The Boost Concept Check Library (BCCL)</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/concept_covering.html>コンセプトの充当化と原型</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/creating_concepts.html>コンセプト・チェック用クラスの作成</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/implementation.html>コンセプト・チェックの実装</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/prog_with_concepts.html>Programming with Concepts</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/reference.html>リファレンス</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/stl_concept_check.cpp.html>libs/concept_check/stl_concept_check.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/stl_concept_covering.cpp.html>libs/concept_check/stl_concept_covering.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/concept_check/using_concept_check.html>コンセプト・チェックの利用</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> conversion <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/conversion/cast.html>Header boost/cast.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/conversion/cast_test.cpp.html>libs/conversion/cast_test.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/conversion/index.html>Boost Conversion Library</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/conversion/lexical_cast.html>Header boost/lexical_cast.hpp</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> date_time <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/class_date.html>gregorian::date</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/class_date_duration.html>gregorian::date_duration</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/date_algorithms.html>Date Generators / Algorithms</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/dates_as_strings.cpp.html>dates_as_strings.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/days_alive.cpp.html>days_alive.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/days_till_new_year.cpp.html>days_till_new_year.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/gregorian.html>Gregorian Date System Documentation</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/index.html>Boost Date-Time Library Documentation</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/period_calc.cpp.html>period_calc.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/print_holidays.cpp.html>print_holidays.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/print_month.cpp.html>print_month.cpp</a> </li> </ul> </li> </ul> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/archive/cpp_online_reading.html>C++オンライン読書会</a> <ul> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_001.html>第1回 C++Now! 読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_002.html>第2回 C++Now! 読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_003.html>第3回 C++Now! 読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_004.html>第4回 C++Now! 読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_005.html>第5回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_006.html>第6回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_007.html>第7回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_008.html>第8回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_009.html>第9回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_010.html>第10回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_011.html>第11回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_012.html>第12回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_013.html>第13回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_014.html>第14回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_015.html>第15回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/request.html>読みたいC++資料リクエスト</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/archive/propose.html>提案予定プロジェクト</a> <ul> <li style="display: none"> <a href=/archive/propose/templ_rec_max.html>テンプレートの再帰上限数workaround(rejected)</a> </li> </ul> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/boostcon.html>BoostCon</a> <ul> <li style="display: none"> <a href=/boostcon/2010.html>BoostCon 2010</a> </li> <li style="display: none"> <a href=/boostcon/2011.html>BoostCon 2011</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/cppnow.html>C++Now!</a> <ul> <li style="display: none"> <a href=/cppnow/2012.html>C++Now! 2012</a> </li> <li style="display: none"> <a href=/cppnow/2013.html>C++Now! 2013</a> </li> <li style="display: none"> <a href=/cppnow/2014.html>C++Now! 2014</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document.html>ドキュメント</a> <ul> <li style="display: none"> <a href=/document/boost-range-algorithm-kansu-no-susume.html>Boost.Range アルゴリズム関数のすすめ</a> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization.html>Boost.Serialization</a> <ul> <li style="display: none"> <a href=/document/boostserialization/overview.html>Overview</a> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/other-classses.html>Other Classses</a> <ul> <li style="display: none"> <a href=/document/boostserialization/other-classses/extended_type_info.html>extended_type_info</a> </li> <li style="display: none"> <a href=/document/boostserialization/other-classses/singleton.html>singleton</a> </li> <li style="display: none"> <a href=/document/boostserialization/other-classses/void_cast.html>void_cast</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/reference.html>Reference</a> <ul> <li style="display: none"> <a href=/document/boostserialization/reference/archive-concepts.html>Archive Concepts</a> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/reference/serializableconcept.html>SerializableConcept</a> <ul> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/reference/serializableconcept/class-serialization-traits.html>Class Serialization Traits</a> <ul> <li style="display: none"> <a href=/document/boostserialization/reference/serializableconcept/class-serialization-traits/export-key.html>Export Key</a> </li> </ul> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/reference/special-considerations.html>Special Considerations</a> <ul> <li style="display: none"> <a href=/document/boostserialization/reference/special-considerations/exporting-class-serialization.html>Exporting Class Serialization</a> </li> </ul> </li> </ul> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/version.html>リリースノート</a> <ul> <li style="display: none"> <a href=/document/version/1_45_0.html>Boost 1.45.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_46_0.html>Boost 1.46.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_46_1.html>Boost 1.46.1リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_47_0.html>Boost 1.47.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_48_0.html>Boost 1.48.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_49_0.html>Boost 1.49.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_50_0.html>Boost 1.50.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_51_0.html>Boost 1.51.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_52_0.html>Boost 1.52.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_53_0.html>Boost 1.53.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_54_0.html>Boost 1.54.0リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_55_0.html>Boost 1.55.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_56_0.html>Boost 1.56.0リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_57_0.html>Boost 1.57.0リリースノート</a> </li> </ul> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> editors_doc <ul> <li style="display: none"> <a href=/editors_doc/start_editing.html>boostjpを編集するには</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/study_meeting.html>Boost.勉強会</a> <ul> <li style="display: none"> <a href=/study_meeting/idea.html>ネタ帳</a> </li> <li style="display: none"> <a href=/study_meeting/reversed_index.html>ライブラリ逆引き</a> </li> <li style="display: none"> <a href=/study_meeting/study1.html>Boost.勉強会 #1</a> </li> <li style="display: none"> <a href=/study_meeting/study10.html>Boost.勉強会 #10 東京</a> </li> <li style="display: none"> <a href=/study_meeting/study11.html>Boost.勉強会 #11 東京</a> </li> <li style="display: none"> <a href=/study_meeting/study12.html>Boost.勉強会 #12 大阪</a> </li> <li style="display: none"> <a href=/study_meeting/study13.html>Boost.勉強会 #13 仙台</a> </li> <li style="display: none"> <a href=/study_meeting/study14.html>Boost.勉強会 #14 東京</a> </li> <li style="display: none"> <a href=/study_meeting/study15.html>Boost.勉強会 #15 札幌</a> </li> <li style="display: none"> <a href=/study_meeting/study16.html>Boost.勉強会 #16 大阪</a> </li> <li style="display: none"> <a href=/study_meeting/study2.html>Boost.勉強会 #2</a> </li> <li style="display: none"> <a href=/study_meeting/study3.html>Boost.勉強会 #3 関西</a> </li> <li style="display: none"> <a href=/study_meeting/study4.html>Boost.勉強会 #4</a> </li> <li style="display: none"> <a href=/study_meeting/study5.html>Boost.勉強会 #5 名古屋</a> </li> <li style="display: none"> <a href=/study_meeting/study6.html>Boost.勉強会 #6 札幌</a> </li> <li style="display: none"> <a href=/study_meeting/study7.html>Boost.勉強会 #7 東京</a> </li> <li style="display: none"> <a href=/study_meeting/study8.html>Boost.勉強会 #8 大阪</a> </li> <li style="display: none"> <a href=/study_meeting/study9.html>Boost.勉強会 #9 つくば</a> </li> <li style="display: none"> <a href=/study_meeting/year-end-party2010-nagoya.html>Boost.忘年会 2010@名古屋</a> </li> <li style="display: none"> <a href=/study_meeting/year-end-party2010-sapporo.html>Boost.忘年会 2010@sapporo</a> </li> <li style="display: none"> <a href=/study_meeting/year-end-party2010-tokyo.html>Boost.忘年会 2010@東京</a> </li> </ul> </li> <li class="parent_li active"> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-minus"></i></span> <a href=/tips.html>Boost逆引きリファレンス</a> <ul> <li> <a href=/tips/array.html>配列</a> </li> <li> <a href=/tips/build.html>ビルドツール</a> </li> <li> <a href=/tips/build_link.html>ヘッダオンリー or ビルドが必要なライブラリ</a> </li> <li> <a href=/tips/circular_buffer.html>循環バッファ</a> </li> <li> <a href=/tips/config.html>コンパイラ間の差を吸収する</a> </li> <li> <a href=/tips/constcond_overload.html>コンパイル時条件によるオーバーロード</a> </li> <li> <a href=/tips/cxx11-boost-mapping.html>C++11とBoostの対応付け</a> </li> <li> <a href=/tips/date_time.html>日付の計算</a> </li> <li> <a href=/tips/dynamic_assert.html>実行時アサート</a> </li> <li> <a href=/tips/dynamic_bitset.html>サイズを動的に変更できるビット集合</a> </li> <li> <a href=/tips/dynamic_regex.html>動的な正規表現</a> </li> <li> <a href=/tips/dynamic_type.html>動的型</a> </li> <li> <a href=/tips/filesystem.html>ファイル／ディレクトリ操作</a> </li> <li> <a href=/tips/finite_state_machine.html>有限状態マシン</a> </li> <li> <a href=/tips/foreach.html>for each文</a> </li> <li> <a href=/tips/format.html>文字列フォーマット</a> </li> <li> <a href=/tips/function.html>関数ポインタと関数オブジェクトを統一的に扱う</a> </li> <li> <a href=/tips/geometry.html>計算幾何</a> </li> <li> <a href=/tips/graph.html>グラフ</a> </li> <li> <a href=/tips/hashmap.html>ハッシュ表</a> </li> <li> <a href=/tips/ini.html>iniファイルの読み込み／書き込み</a> </li> <li> <a href=/tips/initialize.html>組み込み型を必ず初期化する</a> </li> <li> <a href=/tips/interval_arithmetic.html>区間演算</a> </li> <li> <a href=/tips/io_state.html>ストリームの状態を戻す</a> </li> <li> <a href=/tips/iterator.html>イテレータを作る</a> </li> <li> <a href=/tips/json.html>JSONの読み込み／書き込み</a> </li> <li> <a href=/tips/lambda.html>無名関数</a> </li> <li> <a href=/tips/linear-algebra.html>線形代数</a> </li> <li> <a href=/tips/list.html>リスト処理の遅延評価</a> </li> <li> <a href=/tips/lockfree-queue.html>ロックフリーキュー</a> </li> <li> <a href=/tips/lockfree-stack.html>ロックフリースタック</a> </li> <li> <a href=/tips/logging.html>ロギング</a> </li> <li> <a href=/tips/math.html>数学</a> </li> <li> <a href=/tips/memory_mapped_file.html>メモリマップドファイル</a> </li> <li> <a href=/tips/move.html>ムーブ可能なクラスを定義する</a> </li> <li> <a href=/tips/mpi.html>MPI による並列計算</a> </li> <li> <a href=/tips/multi_array.html>多次元配列</a> </li> <li> <a href=/tips/multi_index.html>コンテナに複数の並び順を持たせる</a> </li> <li> <a href=/tips/multiprec-float.html>多倍長浮動小数点数</a> </li> <li> <a href=/tips/multiprec-int.html>多倍長整数</a> </li> <li> <a href=/tips/named_parameter.html>名前付き引数</a> </li> <li> <a href=/tips/noncopyable.html>クラスをコピー不可にする</a> </li> <li> <a href=/tips/noncopyable_container.html>コピー不可なオブジェクトを持ちまわる</a> </li> <li> <a href=/tips/operators.html>演算子を自動定義する</a> </li> <li> <a href=/tips/optional.html>無効値の統一的な表現</a> </li> <li> <a href=/tips/parser.html>構文解析</a> </li> <li> <a href=/tips/partial_eval.html>カリー化／部分適用</a> </li> <li> <a href=/tips/priority_sort.html>優先順位を付けて並べ替える</a> </li> <li> <a href=/tips/program_options.html>コマンドラインオプションの定義／取得</a> </li> <li> <a href=/tips/random.html>乱数</a> </li> <li> <a href=/tips/scope_guard.html>スコープを抜ける際に実行されるブロック</a> </li> <li> <a href=/tips/serialize.html>シリアライズ</a> </li> <li> <a href=/tips/signals.html>シグナル／スロット</a> </li> <li> <a href=/tips/smart_ptr.html>リソースを自動的に解放する</a> </li> <li> <a href=/tips/static_assert.html>コンパイル時アサート</a> </li> <li> <a href=/tips/static_regex.html>静的な正規表現</a> </li> <li> <a href=/tips/statistics.html>統計処理</a> </li> <li> <a href=/tips/string_algo.html>文字列操作</a> </li> <li> <a href=/tips/template_page.html>テンプレートページ</a> </li> <li> <a href=/tips/thread.html>スレッド</a> </li> <li> <a href=/tips/timer.html>処理時間の計測</a> </li> <li> <a href=/tips/tuple.html>タプル</a> </li> <li> <a href=/tips/type_traits.html>型特性</a> </li> <li> <a href=/tips/unit_test.html>単体テスト</a> </li> <li> <a href=/tips/uuid.html>オブジェクトにユニークなIDを付ける</a> </li> <li> <a href=/tips/variant.html>ユーザー定義型を扱える型安全な共用体</a> </li> <li> <a href=/tips/version.html>Boostのバージョンを調べる</a> </li> <li> <a href=/tips/xml.html>XMLの読み込み／書き込み</a> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/tips/network.html>ネットワーク</a> <ul> <li style="display: none"> <a href=/tips/network/tcp.html>ネットワーク - TCP</a> </li> </ul> </li> </ul> </li> </ul> </div> </div> <div class=col-md-9> <div class=row> <ol class=breadcrumb> <li> <a href=/tips.html>Boost逆引きリファレンス</a> </li> <li class=active> グラフ </li> </ol> </div> <div class=row> <h1>グラフ</h1> <p>グラフ構造とそれに対する操作を行うには、<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/index.html target=_blank>Boost Graph Library</a>を使用する。</p> <h2>インデックス</h2> <ul> <li><a href=http://boostjp.github.io/tips/graph.html#define-graph>グラフ型を定義する</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#add-vertex-edge>頂点と辺を追加する</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#bundle-property>任意のクラスをプロパティにする</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#dijkstra-shortest-paths>ダイクストラ法で最短経路を求める</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#distance-map>最短経路の長さ(重みの合計)を求める</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#is-reachable>ある頂点に到達可能かどうかを調べる</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#simple-shortest-path>通過する辺が最も少ない経路を求める</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#isomorphism>2つのグラフが同型か判定する</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#minimum-spanning-tree>最小全域木を作る</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#topological-sort>トポロジカルソート</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#euler-path>一筆書きの経路を求める</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#write-graphviz>グラフをGraphviz形式(.dot)で出力する</a></li> <li><a href=http://boostjp.github.io/tips/graph.html#read-graphviz>Graphviz形式(.dot)のデータを読み込む</a></li> </ul> <h2><a href=http://boostjp.github.io/tips/define-graph name=define-graph>グラフ型を定義する</a></h2> <p>Boost.Graphで標準的に使用する、グラフ構造のためのクラス<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/using_adjacency_list.html target=_blank><code><span style="color: #000">boost::adjacency_list</span></code></a>は、様々な目的に利用できるようカスタマイズが可能になっている。</p> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">template &lt;class OutEdgeListS = vecS,
          class VertexListS = vecS,
          class DirectedS = directedS,
          class VertexProperties = no_property,
          class EdgeProperties = no_property,
          class GraphProperties = no_property,
          class EdgeListS = listS&gt;
class adjacency_list;</span></code></pre> </p> <p>設定例：</p> <p>以下は、無向グラフを定義する例：</p> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">typedef
    boost::adjacency_list&lt;
        boost::listS,
        boost::vecS,
        boost::undirectedS
    &gt;
Graph;</span></code></pre> 有向グラフで、辺に重みを付ける例：</p> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">typedef
    boost::adjacency_list&lt;
        boost::listS,
        boost::vecS,
        boost::directedS,
        boost::no_property,
        boost::property&lt;boost::edge_weight_t, int&gt;
    &gt;
Graph;</span></code></pre> テンプレートパラメータの説明：</p> <table border=1 bordercolor=#888 style=border-collapse:collapse> <thead> <tr> <th>パラメータ</th> <th>説明</th> <th>デフォルト</th> </tr> </thead> <tbody> <tr> <td><code><span style="color: #000">OutEdgeList</span></code></td> <td>グラフの隣接構造(入辺と出辺)を表すためのコンテナを指定する</td> <td><code><span style="color: #000">vecS</span></code> (<code><span style="color: #000">std::vector</span></code>)</td> </tr> <tr> <td><code><span style="color: #000">VertexList</span></code></td> <td>グラフの頂点集合を表すためのコンテナを指定する</td> <td><code><span style="color: #000">vecS</span></code> (<code><span style="color: #000">std::vector</span></code>)</td> </tr> <tr> <td><code><span style="color: #000">DirectedS</span></code></td> <td>有向グラフか無向グラフかを選択する。<br> <code><span style="color: #000">directedS</span></code> : 有向グラフ<br> <code><span style="color: #000">undirectedS</span></code> : 無向グラフ<br> <code><span style="color: #000">bidirectionalS</span></code> : 双方向グラフ(有向で、辺が2本)</td> <td><code><span style="color: #000">directedS</span></code> (有向グラフ)</td> </tr> <tr> <td><code><span style="color: #000">VertexProperties</span></code></td> <td>頂点のカスタムプロパティを指定する</td> <td><code><span style="color: #000">no_property</span></code></td> </tr> <tr> <td><code><span style="color: #000">EdgeProperties</span></code></td> <td>辺のカスタムプロパティを指定する</td> <td><code><span style="color: #000">no_property</span></code></td> </tr> <tr> <td><code><span style="color: #000">GraphProperties</span></code></td> <td>グラフオブジェクトのカスタムプロパティを指定する</td> <td><code><span style="color: #000">no_property</span></code></td> </tr> <tr> <td><code><span style="color: #000">EdgeListS</span></code></td> <td>グラフの辺リストを表すためのコンテナを指定する。 このコンテナは、<code><span style="color: #000">bidirectionalS</span></code>もしくは<code><span style="color: #000">undirectedS</span></code>の場合に実際に辺を格納するために使用され、<code><span style="color: #000">OutEdgeList</span></code>はコンテナの要素を指すオブジェクトを格納する。<code><span style="color: #000">directedS</span></code>の場合は<code><span style="color: #000">OutEdgeList</span></code>に直接格納されるため、このパラメータは使用しない。</td> <td><code><span style="color: #000">listS</span></code> (<code><span style="color: #000">std::list</span></code>)</td> </tr> </tbody> </table> <p><strong>コンテナの選択</strong></p> <p><code><span style="color: #000">OutEdgeList</span></code>, <code><span style="color: #000">VertexList</span></code>, <code><span style="color: #000">EdgeListS</span></code>パラメータでのコンテナの指定には、以下を指定できる：</p> <table border=1 bordercolor=#888 style=border-collapse:collapse> <thead> <tr> <th>指定可能なパラメータ</th> <th>説明</th> </tr> </thead> <tbody> <tr> <td><code><span style="color: #000">vecS</span></code></td> <td><code><span style="color: #000">std::vector</span></code></td> </tr> <tr> <td><code><span style="color: #000">listS</span></code></td> <td><code><span style="color: #000">std::list</span></code></td> </tr> <tr> <td><code><span style="color: #000">slistS</span></code></td> <td><code><span style="color: #000">std::slist</span></code> (非標準)</td> </tr> <tr> <td><code><span style="color: #000">setS</span></code></td> <td><code><span style="color: #000">std::set</span></code></td> </tr> <tr> <td><code><span style="color: #000">multisetS</span></code></td> <td><code><span style="color: #000">std::multiset</span></code></td> </tr> <tr> <td><code><span style="color: #000">hash_setS</span></code></td> <td><code><span style="color: #000">boost::unordered_set</span></code></td> </tr> <tr> <td><code><span style="color: #000">hash_multisetS</span></code></td> <td><code><span style="color: #000">boost::unordered_multiset</span></code></td> </tr> </tbody> </table> <p><strong>プロパティの選択</strong></p> <p><code><span style="color: #000">VertexProperties</span></code>, <code><span style="color: #000">EdgeProperties</span></code>, <code><span style="color: #000">GraphProperties</span></code>に指定可能な、標準提供されているプロパティは以下：</p> <p>頂点プロパティ</p> <table border=1 bordercolor=#888 style=border-collapse:collapse> <thead> <tr> <th>プロパティ</th> <th>説明</th> </tr> </thead> <tbody> <tr> <td><code><span style="color: #000">vertex_index_t</span></code></td> <td>順番</td> </tr> <tr> <td><code><span style="color: #000">vertex_index1_t</span></code></td> <td>順番</td> </tr> <tr> <td><code><span style="color: #000">vertex_index2_t</span></code></td> <td>順番</td> </tr> <tr> <td><code><span style="color: #000">vertex_name_t</span></code></td> <td>名前</td> </tr> <tr> <td><code><span style="color: #000">vertex_distance_t</span></code></td> <td>距離</td> </tr> <tr> <td><code><span style="color: #000">vertex_root_t</span></code></td> <td>ダイクストラや幅優先木での根を示す</td> </tr> <tr> <td><code><span style="color: #000">vertex_all_t</span></code></td> <td>頂点に関連づけられた全てのプロパティ</td> </tr> <tr> <td><code><span style="color: #000">vertex_color_t</span></code></td> <td>色</td> </tr> <tr> <td><code><span style="color: #000">vertex_rank_t</span></code></td> <td>ランク</td> </tr> <tr> <td><code><span style="color: #000">vertex_predecessor_t</span></code></td> <td>先行ノード</td> </tr> <tr> <td><code><span style="color: #000">vertex_isomorphism_t</span></code></td> <td>同型情報</td> </tr> <tr> <td><code><span style="color: #000">vertex_invariant_t</span></code></td> <td>不変量(<a href=http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%A4%89%E9%87%8F target=_blank>Wikipedia:不変量</a>)</td> </tr> <tr> <td><code><span style="color: #000">vertex_invariant1_t</span></code></td> <td>不変量</td> </tr> <tr> <td><code><span style="color: #000">vertex_invariant2_t</span></code></td> <td>不変量</td> </tr> <tr> <td><code><span style="color: #000">vertex_degree_t</span></code></td> <td>次数(節点についてる辺の数)</td> </tr> <tr> <td><code><span style="color: #000">vertex_out_degree_t</span></code></td> <td>出次数(節点から出てる辺の数。無向の場合は次数と同じ)</td> </tr> <tr> <td><code><span style="color: #000">vertex_in_degree_t</span></code></td> <td>入次数(節点に入る辺の数。無効の場合は次数と同じ)</td> </tr> <tr> <td><code><span style="color: #000">vertex_discover_time_t</span></code></td> <td>深さ優先探索などでの発見された順番</td> </tr> <tr> <td><code><span style="color: #000">vertex_finish_time_t</span></code></td> <td>深さ優先探索などでの探索が終わった順番</td> </tr> </tbody> </table> <p>辺プロパティ</p> <table border=1 bordercolor=#888 style=border-collapse:collapse> <thead> <tr> <th>プロパティ</th> <th>説明</th> </tr> </thead> <tbody> <tr> <td><code><span style="color: #000">edge_index_t</span></code></td> <td>順番</td> </tr> <tr> <td><code><span style="color: #000">edge_name_t</span></code></td> <td>名前</td> </tr> <tr> <td><code><span style="color: #000">edge_weight_t</span></code></td> <td>重み</td> </tr> <tr> <td><code><span style="color: #000">edge_weight2_t</span></code></td> <td>重み</td> </tr> <tr> <td><code><span style="color: #000">edge_capacity_t</span></code></td> <td>キャパシティ</td> </tr> <tr> <td><code><span style="color: #000">edge_residual_capacity_t</span></code></td> <td>残りキャパシティ</td> </tr> <tr> <td><code><span style="color: #000">edge_reverse_t</span></code></td> <td>最大流アルゴリズムで使用する、向きが逆になった辺か否かを示す</td> </tr> <tr> <td><code><span style="color: #000">edge_all_t</span></code></td> <td>辺に関連づけられた全てのプロパティ</td> </tr> </tbody> </table> <p>グラフプロパティ</p> <table border=1 bordercolor=#888 style=border-collapse:collapse> <thead> <tr> <th>プロパティ</th> <th>説明</th> </tr> </thead> <tbody> <tr> <td><code><span style="color: #000">graph_name_t</span></code></td> <td>名前</td> </tr> <tr> <td><code><span style="color: #000">graph_all_t</span></code></td> <td>グラフ自体に関連づけられた全てのプロパティ</td> </tr> </tbody> </table> <h2><a href=http://boostjp.github.io/tips/add-vertex-edge name=add-vertex-edge>頂点と辺を追加する</a></h2> <p>頂点と辺を追加する方法としては、コンストラクタを使用するものと、<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/MutableGraph.html target=_blank><code><span style="color: #000">boost::add_vertex()</span></code>関数と<code><span style="color: #000">boost::add_edge()</span></code>関数</a>を使用して動的に追加するものの2つがある。</p> <p><strong>1. コンストラクタを使用する</strong></p> <p>Boost.Graphのグラフ構造クラスは、コンストラクタで辺の範囲と頂点数をとる。</p> <p>これを使用することで、シンプルにグラフを構築できる。</p> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

enum { A, B, C, D, E, N };
const std::string name = "ABCDE";

int main()
{
    const std::vector&lt;Edge&gt; edges = {
        {A, B}, {A, C}, {A, D},
        {B, E}, {C, E}, {D, E}
    };

    const Graph g(edges.begin(), edges.end(), N);

    boost::print_graph(g, name.c_str());
}</span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">A --&gt; B C D 
B --&gt; E 
C --&gt; E 
D --&gt; E 
E --&gt; 
</span></code></pre></p> <p><strong>2. 動的に追加する</strong></p> <p>コンストラクタは初期化時のみ使用可能なため、動的に頂点や辺を追加する必要がある場合には、頂点と追加する<code><span style="color: #000">boost::add_vertex()</span></code>関数、辺を追加する<code><span style="color: #000">boost::add_edge()</span></code>関数を使用する。</p> <p>頂点を追加する<code><span style="color: #000">boost::add_vertex()</span></code>関数は、<code><span style="color: #000">for</span></code>文や<code><span style="color: #000">while</span></code>文でループして、必要な頂点数分だけ呼び出して使用する。戻り値として、頂点記述子が返される。</p> <p>辺を追加する<code><span style="color: #000">boost::add_edge()</span></code>関数は、追加する辺の2つの頂点を指定して使用する。順番は、<code><span style="color: #000">source</span></code>、<code><span style="color: #000">target</span></code>の順である。</p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>add_edge</span>(desc[A], desc[B], g);
    <span style=color:#ff0000>add_edge</span>(desc[A], desc[C], g);
    <span style=color:#ff0000>add_edge</span>(desc[A], desc[D], g);
    <span style=color:#ff0000>add_edge</span>(desc[B], desc[E], g);
    <span style=color:#ff0000>add_edge</span>(desc[C], desc[E], g);
    <span style=color:#ff0000>add_edge</span>(desc[D], desc[E], g);

    boost::print_graph(g, name.c_str());
}<span style="color: #000">#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

enum { A, B, C, D, E, N };
const std::string name = "ABCDE";

int main()
{
    Graph g;

    // 頂点を追加
    std::map&lt;int, Graph::vertex_descriptor&gt; desc;
    for (int i = 0; i &lt; N; ++i) {
        desc[i] = add_vertex(g);
    }

    // 辺を追加
    </span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">A --&gt; B C D 
B --&gt; E 
C --&gt; E 
D --&gt; E 
E --&gt; 
</span></code></pre> ※<code><span style="color: #000">add_vertex()</span></code>関数と<code><span style="color: #000">add_edge()</span></code>は、<code><span style="color: #000">boost::adjacency_list</span></code>以外のグラフ構造にも適用できるようにするため、名前空間の修飾なしで呼び出す。</p> <p>参考：</p> <ul> <li><a href=http://d.hatena.ne.jp/eagle_raptor/20111221/1324478088 target=_blank>Boost.Graphで動的な頂点の追加削除 - ばるの日記</a></li> </ul> <h2><a href=http://boostjp.github.io/tips/bundle-property name=bundle-property>任意のクラスをプロパティにする</a></h2> <p>Boost.Graphのグラフ構造には、Property Mapによって頂点・辺・グラフに任意のプロパティを持たせられる。しかしながらこの方法は、プロパティが増えてくると管理しきれなくなってくるので、ひとまとめにしたくなるだろう。</p> <p>そこで、Boost.Graphには<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/bundles.html target=_blank>Bundleプロパティ</a>という機能が用意されている。これは、グラフ構造のプロパティ指定の場所にユーザー定義クラスを指定するという機能である。</p> <p>後述のサンプルでは、以下のプロパティを設定している。</p> <ul> <li>頂点のBundleプロパティとして「名前」「人口」「郵便番号一覧」を持つ<code><span style="color: #000">City</span></code>(街)クラス</li> <li>辺のBundleプロパティとして「名前」と「距離」を持つ<code><span style="color: #000">Highway</span></code>(高速道路)クラス</li> <li>グラフのBundleプロパティとして「名前」を持つ<code><span style="color: #000">Country</span></code>(国)クラス</li> </ul> <p>そして、最短経路の計算の際に、<code><span style="color: #000">Highway</span></code>クラスの<code><span style="color: #000">distance</span></code>メンバ変数を辺の重みとして使用している。</p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>City</span> {
    std::string name;
    int population;
    std::vector&lt;int&gt; zipcodes;
};

struct <span style=color:#ff0000>Highway</span> {
    std::string name;
    double distance; // km
};

struct <span style=color:#ff0000>Country</span> {
    std::string name;
};

typedef boost::adjacency_list&lt;
    boost::listS, boost::vecS, boost::bidirectionalS,
    <span style=color:#ff0000>City</span>,    // 頂点のBundleプロパティ
    <span style=color:#ff0000>Highway</span>, // 辺のBundleプロパティ
    <span style=color:#ff0000>Country</span>  // グラフのBundleプロパティ
&gt; Map;

int main()
{
    Map map;

    // グラフのBundleプロパティを設定
    map[boost::graph_bundle].name = "Japan";

    // 街(頂点)を2つ追加
    Map::vertex_descriptor v1 = add_vertex(map);
    Map::vertex_descriptor v2 = add_vertex(map);

    // 頂点のBundleプロパティを設定
    map[v1].name = "Tokyo";
    map[v1].population = 13221169;
    map[v1].zipcodes.push_back(1500013);

    map[v2].name = "Nagoya";
    map[v2].population = 2267048;
    map[v2].zipcodes.push_back(4600006);

    // 辺を追加
    bool inserted = false;
    Map::edge_descriptor e;
    boost::tie(e, inserted) = add_edge(v1, v2, map);

    // 辺のBundleプロパティを設定
    map[e].name = "Tomei Expessway";
    map[e].distance = 325.5;

    // <span style=color:#ff0000>Highway</span>クラスのdistanceメンバを辺の重みとして計算
    std::vector&lt;double&gt; distance(boost::num_vertices(map));
    boost::dijkstra_shortest_paths(map, v1,
            boost::weight_map(boost::get(&amp;<span style=color:#ff0000>Highway</span>::distance, map)).
            distance_map(&amp;distance[0]));

    std::cout &lt;&lt; "Tokyo-Nagoya : " &lt;&lt; distance[v2] &lt;&lt; "km" &lt;&lt; std::endl;
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;

struct </span></code></pre> 出力</p> <p><pre><code><span style="color: #000">Tokyo-Nagoya : 325.5km
</span></code></pre></p> <h2><a href=http://boostjp.github.io/tips/dijkstra-shortest-paths name=dijkstra-shortest-paths>ダイクストラ法で最短経路を求める</a></h2> <p>ダイクストラ法で最短経路を求めるには、<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/dijkstra_shortest_paths.html target=_blank><code><span style="color: #000">boost::dijkstra_shortest_paths()</span></code></a>関数を使用する。</p> <p>ここでは、以下の経路図で、頂点Sから頂点Zへの最短経路を求める。</p> <p>経路図：</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/dijkstra_shortest_paths.png></p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>dijkstra_shortest_paths</span>.hpp&gt;
#include &lt;boost/assign/list_of.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt;                             Edge;
typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor   Vertex;

enum { S, A, B, C, D, E, F, Z, N };
const std::string Names = "SABCDEFZ";

// グラフを作る
Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = boost::assign::list_of&lt;Edge&gt;
        (S, A)
        (A, B)
        (B, C)
        (B, D)
        (C, E)
        (C, F)
        (D, F)
        (E, D)
        (F, E)
        (E, Z)
        (F, Z)
    ;

    const std::vector&lt;int&gt; weights = boost::assign::list_of
        (3)
        (1)
        (2)
        (3)
        (7)
        (12)
        (2)
        (11)
        (3)
        (2)
        (2)
    ;

    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    const Graph g = make_graph();
    const Vertex from = S; // 開始地点
    const Vertex to = Z; // 目的地

    // 最短経路を計算
    std::vector&lt;Vertex&gt; parents(boost::num_vertices(g));
    boost::<span style=color:#ff0000>dijkstra_shortest_paths</span>(g, from,
                boost::predecessor_map(&amp;parents[0]));

    // 経路なし
    if (parents[to] == to) {
        std::cout &lt;&lt; "no path" &lt;&lt; std::endl;
        return 1;
    }

    // 最短経路の頂点リストを作成
    std::deque&lt;Vertex&gt; route;
    for (Vertex v = to; v != from; v = parents[v]) {
        route.push_front(v);
    }
    route.push_front(from);

    // 最短経路を出力
    for (const Vertex v : route) {
        std::cout &lt;&lt; Names[v] &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/</span></code></pre> 出力</p> <p><pre><code><span style="color: #000">S
A
B
D
F
Z
</span></code></pre> この場合、SからZへの最短経路は、S, A, B, D, F, Zの順となる。</p> <p><code><span style="color: #000">dijkstra_shortest_paths()</span></code>関数の第1引数はグラフ構造を表す変数への<code><span style="color: #000">const</span></code>参照、第2引数は開始地点の頂点、第3引数は先行ノードを格納する変数へのポインタである。</p> <p>目的地から開始地点まで先行ノードを辿っていくことにより、最短経路を求めることができる。</p> <h2><a href=http://boostjp.github.io/tips/distance-map name=distance-map>最短経路の長さ(重みの合計)を求める</a></h2> <p>最短経路の長さを求めるには<code><span style="color: #000">DistanceMap</span></code>を使用する。<code><span style="color: #000">DistanceMap</span></code>は、最短経路探索の結果として取得できる、開始地点から最短経路のある頂点までの距離を保存したものである。</p> <p><code><span style="color: #000">DistanceMap</span></code>は、最短経路探索アルゴリズムに<code><span style="color: #000">boost::distance_map()</span></code>関数を使用して取得できる(他の名前付き引数に続けて記述する場合は、「<code><span style="color: #000">named_param.distance_map(...);</span></code>」のようにする)。</p> <p>ここでは、先行ノードも一緒に求めているが、経路長のみが必要であれば、<code><span style="color: #000">DistanceMap</span></code>のみを計算してもよい。</p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>distance[to]</span>;
    std::cout &lt;&lt; "route length:" &lt;&lt; n &lt;&lt; std::endl;

    // 最短経路を出力
    for (const Vertex v : route) {
        std::cout &lt;&lt; Names[v] &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;
#include &lt;boost/assign/list_of.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt;                             Edge;
typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor   Vertex;

enum { S, A, B, C, D, E, F, Z, N };
const std::string Names = "SABCDEFZ";

// グラフを作る
Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = boost::assign::list_of&lt;Edge&gt;
        (S, A)
        (A, B)
        (B, C)
        (B, D)
        (C, E)
        (C, F)
        (D, F)
        (E, D)
        (F, E)
        (E, Z)
        (F, Z)
    ;

    const std::vector&lt;int&gt; weights = boost::assign::list_of
        (3)
        (1)
        (2)
        (3)
        (7)
        (12)
        (2)
        (11)
        (3)
        (2)
        (2)
    ;

    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    const Graph g = make_graph();
    const Vertex from = S; // 開始地点
    const Vertex to = Z; // 目的地

    std::vector&lt;Vertex&gt; parents(boost::num_vertices(g));
    std::vector&lt;std::size_t&gt; distance(boost::num_vertices(g));

    // 最短経路を計算
    boost::dijkstra_shortest_paths(g, from,
                boost::predecessor_map(&amp;parents[0]).distance_map(&amp;distance[0]));

    // 経路なし
    if (parents[to] == to) {
        std::cout &lt;&lt; "no path" &lt;&lt; std::endl;
        return 1;
    }

    // 最短経路の頂点リストを作成
    std::deque&lt;Vertex&gt; route;
    for (Vertex v = to; v != from; v = parents[v]) {
        route.push_front(v);
    }
    route.push_front(from);

    // 経路の長さを計算
    const std::size_t n = </span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">route length:11
S
A
B
D
F
Z
</span></code></pre></p> <h2><a href=http://boostjp.github.io/tips/is-reachable name=is-reachable>ある頂点に到達可能かどうかを調べる</a></h2> <p>ある頂点に到達可能かどうかを調べるには、<code><span style="color: #000">&lt;boost/graph/graph_utility.hpp&gt;</span></code>で定義される<code><span style="color: #000">boost::is_reachable()</span></code>関数を使用する。この関数は、グラフ構造<code><span style="color: #000">g</span></code>において、頂点<code><span style="color: #000">x</span></code>が頂点<code><span style="color: #000">y</span></code>に到達可能かどうかを調べ、到達可能であれば<code><span style="color: #000">true</span></code>、そうでなければ<code><span style="color: #000">false</span></code>を返す。</p> <p><code><span style="color: #000">boost::is_reachable()</span></code>の定義：</p> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">// &lt;boost/graph/graph_utility.hpp&gt;

namespace boost {
  // xからyに到達可能?
  template &lt;typename IncidenceGraph, typename VertexColorMap&gt;
  bool is_reachable(
           typename graph_traits&lt;IncidenceGraph&gt;::vertex_descriptor x,
           typename graph_traits&lt;IncidenceGraph&gt;::vertex_descriptor y,
           const IncidenceGraph&amp; g,
           VertexColorMap color // 各頂点が白で開始しなければならない
        );
}</span></code></pre> </p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>is_reachable</span>(A, E, g, color.data())) {
        std::cout &lt;&lt; "AからEに到達可能" &lt;&lt; std::endl;
    }
    else {
        assert(false);
    }

    // AからDに到達可能か調べる
    if (!boost::<span style=color:#ff0000>is_reachable</span>(A, D, g, color.data())) {
        std::cout &lt;&lt; "AからDに到達不可能" &lt;&lt; std::endl;
    }
    else {
        assert(false);
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;cassert&gt;

#include &lt;vector&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;
#include &lt;boost/assign/list_of.hpp&gt;

#include &lt;boost/detail/lightweight_test.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

enum { A, B, C, D, E, N };
const int vertex_count = N;

int main()
{
    const std::vector&lt;Edge&gt; edges = boost::assign::list_of&lt;Edge&gt;
        (A, B)(B, E)
        (A, C)(C, E)
    ; // Dはどこにも繋がっていない

    const Graph g(edges.begin(), edges.end(), vertex_count);

    // 全部白のカラーマップを作って渡す
    std::vector&lt;boost::default_color_type&gt; color(vertex_count, boost::white_color);

    // AからEに到達可能か調べる
    if (boost::</span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">AからEに到達可能
AからDに到達不可能
</span></code></pre></p> <h2><a href=http://boostjp.github.io/tips/simple-shortest-path name=simple-shortest-path>通過する辺が最も少ない経路を求める</a></h2> <p>辺に重みのないグラフから最短経路を求めると、「最短単純路」という通過する辺が最も少ない経路が得られる。これは、たとえばソーシャルグラフから「Twitterで何回のRTで特定の情報に辿りつけたか」というような情報を抽出する用途に使える。</p> <p>&lt;strike&gt;Boost.Graphの<code><span style="color: #000">boost::dijkstra_shortest_paths()</span></code>は重みのないグラフを与えるとコンパイルエラーになるので、辺の重みを全て1に設定することで代用できる。&lt;/strike&gt;</p> <p>&lt;font color="red"&gt;※2014/02/16 修正：そのような場面では <a href=http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/breadth_first_search.html target=_blank>Breadth-First Search</a> を使うべきである。&lt;/font&gt;</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/simple_shortest_path.png></p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>const std::vector&lt;int&gt; weights(edges.size(), 1);</span>

    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    const Graph g = make_graph();
    const Vertex from = S; // 開始地点
    const Vertex to = Z; // 目的地

    // 最短経路を計算
    std::vector&lt;Vertex&gt; parents(boost::num_vertices(g));
    boost::dijkstra_shortest_paths(g, from,
                boost::predecessor_map(&amp;parents[0]));

    // 経路なし
    if (parents[to] == to) {
        std::cout &lt;&lt; "no path" &lt;&lt; std::endl;
        return 1;
    }

    // 最短経路の頂点リストを作成
    std::deque&lt;Vertex&gt; route;
    for (Vertex v = to; v != from; v = parents[v]) {
        route.push_front(v);
    }
    route.push_front(from);

    // 最短経路を出力
    for (const Vertex v : route) {
        std::cout &lt;&lt; Names[v] &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt;                             Edge;
typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor   Vertex;

enum { S, A, B, C, D, E, F, G, Z, N };
const std::string Names = "SABCDEFGZ";

// グラフを作る
Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = {
        {S, A},
        {A, B},
        {B, C},
        {B, D},
        {C, E},
        {D, G},
        {E, D},
        {G, E},
        {E, F},
        {F, Z},
        {G, Z},
    };

    // 辺の重みは1
    </span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">S
A
B
D
G
Z
</span></code></pre></p> <h2><a href=http://boostjp.github.io/tips/isomorphism name=isomorphism>2つのグラフが同型か判定する</a></h2> <p>2つのグラフが同型かを判定するには、<code><span style="color: #000">&lt;boost/graph/isomorphism.hpp&gt;</span></code>で定義される<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/isomorphism.html target=_blank><code><span style="color: #000">boost::isomorphism()</span></code></a>関数を使用する。この関数は、引数として2つのグラフをとり、それらが同型であれば<code><span style="color: #000">true</span></code>、そうでなければ<code><span style="color: #000">false</span></code>を返す。 ここでは、以下の2つのグラフを比較する。</p> <p>g1:</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/isomorphism_1.png></p> <p>g2:</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/isomorphism_2.png></p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>isomorphism</span>.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS&gt; Graph;
const int vertex_count = 12;

Graph make_graph1()
{
    const std::vector&lt;std::pair&lt;int, int&gt;&gt; edges = {
        { 0,  1}, { 1, 2},
        { 0,  2},
        { 3,  4}, { 4, 5},
        { 5,  6}, { 6, 3},
        { 7,  8}, { 8, 9},
        { 9, 10},
        {10, 11}, {11, 7}
    };
    return Graph(edges.begin(), edges.end(), vertex_count);
}

Graph make_graph2()
{
    const std::vector&lt;std::pair&lt;int, int&gt;&gt; edges = {
        { 9, 10}, {10, 11},
        {11,  9},
        { 0,  1}, { 1,  3},
        { 3,  2}, { 2,  0},
        { 4,  5}, { 5,  7},
        { 7,  8},
        { 8,  6}, { 6,  4}
    };
    return Graph(edges.begin(), edges.end(), vertex_count);
}

int main()
{
    const Graph g1 = make_graph1();
    const Graph g2 = make_graph2();

    const bool result = boost::<span style=color:#ff0000>isomorphism</span>(g1, g2);
    std::cout &lt;&lt; "isomorphic? " &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;boost/graph/</span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">isomorphic? true
</span></code></pre></p> <h2><a href=http://boostjp.github.io/tips/minimum-spanning-tree name=minimum-spanning-tree>最小全域木を作る</a></h2> <p>グラフに含まれるすべての頂点を含む最小の部分グラフを、最小全域木(minimum spanning tree)と言う。</p> <p>Boost.Graphには、最小全域木を作るためのアルゴリズムとして、以下の2つの関数が用意されている。</p> <table border=1 bordercolor=#888 style=border-collapse:collapse> <thead> <tr> <th>関数</th> <th>説明</th> </tr> </thead> <tbody> <tr> <td><a href=http://boostjp.github.com/libs/graph/doc/kruskal_min_spanning_tree.html target=_blank><code><span style="color: #000">boost::kruskal_minimum_spanning_tree()</span></code></a></td> <td>クラスカル法</td> </tr> <tr> <td><a href=http://boostjp.github.com/libs/graph/doc/prim_minimum_spanning_tree.html target=_blank><code><span style="color: #000">boost::prim_minimum_spanning_tree()</span></code></a></td> <td>プリム法</td> </tr> </tbody> </table> <p>これらを以下のグラフに適用すると</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/minimum_spanning_tree_1.png></p> <p>以下のような最小全域木(赤の太線部分)が手に入る。</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/minimum_spanning_tree_2.png></p> <p>それぞれの使い方は以下のようになる。</p> <p><strong>クラスカル法</strong></p> <p>クラスカル法によって最小全域木を求める<code><span style="color: #000">boost::kruskal_minimum_spanning_tree()</span></code>関数は、Output Iteratorで最小全域木の辺記述子(edge descriptor)を返す。</p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>kruskal_minimum_spanning_tree</span>(g, std::back_inserter(spanning_tree));

    for (const EdgeDesc&amp; e : spanning_tree) {
        std::cout &lt;&lt; "(" &lt;&lt; Name[boost::source(e, g)] &lt;&lt; ","
                         &lt;&lt; Name[boost::target(e, g)] &lt;&lt; ")" &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/kruskal_min_spanning_tree.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;
typedef boost::graph_traits&lt;Graph&gt;::edge_descriptor EdgeDesc;

std::string Name = "ABCDE";
enum {A, B, C, D, E, N};

Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = {
        {A, C},
        {B, D},
        {B, E},
        {C, B},
        {C, D},
        {D, E},
        {E, A}
    };

    const std::vector&lt;int&gt; weights = {
        1,
        1,
        2,
        7,
        3,
        1,
        1
    };
    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    const Graph g = make_graph();

    std::vector&lt;EdgeDesc&gt; spanning_tree;
    boost::</span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">(A,C)
(D,E)
(E,A)
(B,D)
</span></code></pre></p> <p><strong>プリム法</strong></p> <p>プリム法によって最小全域木を求める<code><span style="color: #000">boost::prim_minimum_spanning_tree()</span></code>関数は、先行ノードマップ(predecessor map)として最小全域木を返す。</p> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">#include &lt;iostream&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/prim_minimum_spanning_tree.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;
typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor VertexDesc;

std::string Name = "ABCDE";
enum {A, B, C, D, E, N};

Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = {
        {A, C},
        {B, D},
        {B, E},
        {C, B},
        {C, D},
        {D, E},
        {E, A},
    }

    const std::vector&lt;int&gt; weights = {
        1,
        1,
        2,
        7,
        3,
        1,
        1,
    };
    return Graph(edges.begin(), edges.end(), weights.begin(), N);
}

int main()
{
    Graph g = make_graph();

    std::vector&lt;VertexDesc&gt; parents(N);
    boost::prim_minimum_spanning_tree(g, &amp;parents[0]);

    for (std::size_t i = 0; i &lt; N; ++i) {
        if (parents[i] != i) {
            std::cout &lt;&lt; "parent[" &lt;&lt; Name[i] &lt;&lt; "] = " &lt;&lt; Name[parents[i]] &lt;&lt; std::endl;
        }
        else {
            std::cout &lt;&lt; "parent[" &lt;&lt; Name[i] &lt;&lt; "] = no parent" &lt;&lt; std::endl;
        }
    }
}</span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">parent[A] = no parent
parent[B] = D
parent[C] = A
parent[D] = E
parent[E] = A
</span></code></pre></p> <h2><a href=http://boostjp.github.io/tips/topological-sort name=topological-sort>トポロジカルソート</a></h2> <p>無閉路有向グラフ(DAG : Directed Acyclic Graph)に順序を付けるトポロジカルソートは、<code><span style="color: #000">&lt;boost/graph/topological_sort.hpp&gt;</span></code>で定義される<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/topological_sort.html target=_blank><code><span style="color: #000">boost::topological_sort()</span></code></a>関数を使用する。</p> <p>この関数は引数として、グラフ構造への<code><span style="color: #000">const</span></code>参照と、頂点リストを出力するOutput Iteratorをとる。(頂点リストは逆順で返されるため、<code><span style="color: #000">boost::adaptors::reversed</span></code>や<code><span style="color: #000">rbegin()</span></code>/<code><span style="color: #000">rend()</span></code>などで正順に直して使用する。)</p> <p>ここでは、以下のグラフにトポロジカルソートを適用する：</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/topological_sort.png></p> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>topological_sort</span>.hpp&gt;
#include &lt;boost/range/algorithm/for_each.hpp&gt;
#include &lt;boost/range/adaptor/reversed.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

Graph make_graph()
{
    const std::vector&lt;Edge&gt; edges = {
        {0, 1}, {2, 4},
        {2, 5},
        {0, 3}, {1, 4},
        {4, 3}
    };
    return Graph(edges.begin(), edges.end(), 6);
}

int main()
{
    const Graph g = make_graph();

    std::vector&lt;int&gt; result;
    boost::<span style=color:#ff0000>topological_sort</span>(g, std::back_inserter(result));

    boost::for_each(result | boost::adaptors::reversed, [](int vertex) {
        std::cout &lt;&lt; vertex &lt;&lt; std::endl;
    });
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/</span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">2
5
0
1
4
3
</span></code></pre> 出力から、有向グラフgがトポロジカルソートによって「2 → 5 → 0 → 1 → 4 → 3」の順序が付けられたことがわかる。</p> <p>なお、<code><span style="color: #000">boost::topological_sort()</span></code>関数に、閉路のある有向グラフを指定した場合、<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/exception.html#not_a_dag target=_blank><code><span style="color: #000">boost::not_a_dag</span></code></a>例外が投げられる。</p> <h2><a href=http://boostjp.github.io/tips/euler-path name=euler-path>一筆書きの経路を求める</a></h2> <p>オイラー閉路というのを求めると、グラフの一筆書きの経路を得ることができる。ここでは、「サンタクロースの家」と呼ばれる無向グラフの一筆書きを求める。</p> <p>Boost.Graphにはオイラー閉路のためのアルゴリズムは用意されていないが、以下のGitHubにある<code><span style="color: #000">shand::graph::euler_path()</span></code>関数を利用することで、一筆書きを容易に求められる。</p> <ul> <li><a href=https://github.com/faithandbrave/Shand/blob/master/shand/graph/euler_path.hpp target=_blank>shand/graph/euler_path.hpp</a></li> </ul> <p><pre class=codehilite><code class=language-cpp><span style=color:#ff0000>euler_path</span>.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;

enum {A, B, C, D, E, N};
const std::string name = "ABCDE";

int main()
{
    typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS&gt; Graph;
    typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor vertex_desc;

    const std::vector&lt;std::pair&lt;int, int&gt; &gt; edges = {
        {A, B},
        {B, C},
        {C, A},
        {B, D},
        {B, E},
        {C, D},
        {D, E},
        {E, C}
    };

    const Graph g(edges.begin(), edges.end(), N);
    std::deque&lt;vertex_desc&gt; path;

    if (!shand::graph::<span style=color:#ff0000>euler_path</span>(g, E, [&amp;path](vertex_desc v) { path.push_front(v); })) {
        std::cout &lt;&lt; "euler path failed" &lt;&lt; std::endl;
        return 1;
    }

    BOOST_FOREACH (const vertex_desc&amp; v, path) {
        std::cout &lt;&lt; name[v] &lt;&lt; std::endl;
    }
}<span style="color: #000">#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;shand/graph/</span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">E
B
A
C
B
D
C
E
D
</span></code></pre> E, B, A, C, B, D, C, E, Dの順に頂点をたどれば一筆書きになることがわかった。</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/euler_path.png></p> <h2><a href=http://boostjp.github.io/tips/write-graphviz name=write-graphviz>グラフをGraphviz形式(.dot)で出力する</a></h2> <p>グラフをGraphviz形式(.dot)で出力するには、<code><span style="color: #000">&lt;boost/graph/graphviz.hpp&gt;</span></code>をインクルードし、<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/write-graphviz.html target=_blank><code><span style="color: #000">boost::write_graphviz()</span></code></a>関数を使用する。この機能のために、別途ライブラリは必要としない。</p> <p><code><span style="color: #000">write_graphviz()</span></code>関数の引数：</p> <table border=1 bordercolor=#888 style=border-collapse:collapse> <thead> <tr> <th>引数</th> <th>説明</th> </tr> </thead> <tbody> <tr> <td>第1引数</td> <td>出力先の<code><span style="color: #000">std::ostream&amp;</span></code></td> </tr> <tr> <td>第2引数</td> <td>グラフ構造への<code><span style="color: #000">const&amp;</span></code></td> </tr> <tr> <td>第3引数</td> <td>出力方法のカスタマイズ方法 (ここでは、頂点名を出力するために<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/write-graphviz.html#concept:PropertyWriter target=_blank><code><span style="color: #000">make_label_writer()</span></code></a>を使用している)</td> </tr> </tbody> </table> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graphviz.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;
typedef std::pair&lt;int, int&gt; Edge;

enum { A, B, C, D, E, N };
const std::string name = "ABCDE";

int main()
{
    const std::vector&lt;Edge&gt; edges = {
        {A, B}, {A, C}, {A, D},
        {B, E}, {C, E}, {D, E}
    };

    const Graph g(edges.begin(), edges.end(), N);

    // graphvizの形式(*.dot)で出力
    std::ofstream file("test.dot");
    boost::write_graphviz(file, g, boost::make_label_writer(name.c_str()));
}</span></code></pre> 出力されたtest.dotファイル：</p> <p><pre><code><span style="color: #000">digraph G {
0[label="A"];
1[label="B"];
2[label="C"];
3[label="D"];
4[label="E"];
0-&gt;1 ;
0-&gt;2 ;
0-&gt;3 ;
1-&gt;4 ;
2-&gt;4 ;
3-&gt;4 ;
}
</span></code></pre></p> <p>Graphvizのdotコマンドを使用してpngに変換：</p> <p><pre><code><span style="color: #000">dot -Tpng test.dot -o test.png
</span></code></pre> 出力されたtest.png：</p> <p><img alt src=https://raw.githubusercontent.com/boostjp/image/master/tips/graph/graphviz.png></p> <p>追加資料：</p> <ul> <li><a href=http://d.hatena.ne.jp/faith_and_brave/20100416/1271388752 target=_blank>Boost.Graph Graphviz形式で重みを出力</a></li> </ul> <h2><a href=http://boostjp.github.io/tips/read-graphviz name=read-graphviz>Graphviz形式(.dot)のデータを読み込む</a></h2> <p>Graphviz形式(.dot)のデータを読み込むには、<code><span style="color: #000">&lt;boost/graph/graphviz.hpp&gt;</span></code>で定義される<a href=http://www.boost.org/doc/libs/release/libs/graph/doc/read_graphviz.html target=_blank><code><span style="color: #000">boost::read_graphviz()</span></code></a>関数を使用する。この関数を使用するには、Boost Regex Libraryをリンクする必要がある。</p> <p>ここでは、「[グラフをGraphviz形式(.dot)で出力する](#write-graphviz」で出力したtest.dotファイルを読み込む。</p> <p><code><span style="color: #000">read_graphviz()</span></code>関数の引数：</p> <table border=1 bordercolor=#888 style=border-collapse:collapse> <thead> <tr> <th>引数</th> <th>説明</th> </tr> </thead> <tbody> <tr> <td>第1引数</td> <td>入力元の<code><span style="color: #000">std::istream&amp;</span></code></td> </tr> <tr> <td>第2引数</td> <td>グラフ構造への参照</td> </tr> <tr> <td>第3引数</td> <td>DOT言語のプロパティを処理するための<code><span style="color: #000">boost::dynamic_properties</span></code>型変数への参照</td> </tr> </tbody> </table> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graphviz.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;

typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS&gt; Graph;

enum { A, B, C, D, E, N };
const std::string name = "ABCDE";

int main()
{
    std::ifstream file("test.dot");

    Graph g;
    boost::dynamic_properties dp(boost::ignore_other_properties);
    boost::read_graphviz(file, g, dp);

    boost::print_graph(g, name.c_str());
}</span></code></pre> 出力：</p> <p><pre><code><span style="color: #000">A --&gt; B C D
B --&gt; E
C --&gt; E
D --&gt; E
E --&gt;
</span></code></pre> tested boost version is 1.51.0</p> </div> </div> </div> </div> </main> </body> <!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --> <!--[if lt IE 7 ]>
        <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
        <script>
            window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
        </script>
    <![endif]--> </html>