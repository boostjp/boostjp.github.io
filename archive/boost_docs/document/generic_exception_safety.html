<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en"> <!--<![endif]-->
    <head>
        <meta charset="UTF-8">

        <title>generic_exception_safety</title>

        <meta name="viewport" content="width=device-width,initial-scale=1">

<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
<!-- <link rel="stylesheet" href="/static/css/root.css"> -->

<script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<!-- <script src="//platform.twitter.com/widgets.js"></script> -->

<!-- <script src="/static/js/root.js"></script> -->


        <!--[if lt IE 9]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

        <script>
            document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/,'js');
        </script>
    </head>
    <body>
<header>
  <nav class="navbar navbar-default" role="navigation">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#boostjp-navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">boostjp : Boost日本語情報サイト</a>
      </div>

      <div class="collapse navbar-collapse" id="boostjp-navbar-collapse">
        <form class="navbar-form navbar-right" role="search">
          <div class="form-group">
            <input type="text" class="form-control" placeholder="Search">
          </div>
          <button type="submit" class="btn btn-default">検索</button>
        </form>
      </div>
    </div>
  </nav>
</header>

        <main id="main" role="main">
            <div class="container-fluid">
<div class="row">
  <div class="col-md-2">
<ul><li><a href="/study_meeting.html">study_meeting</a></li><li><a href="/communities.html">communities</a></li><li><a href="/archive.html">archive</a></li><li><a href="/document.html">document</a></li><li><a href="/boostcon.html">boostcon</a></li><li><a href="/tips.html">tips</a></li><li><a href="/the-team.html">the-team</a></li><li><a href="/cppnow.html">cppnow</a></li><li><a href="/mailing-lists.html">mailing-lists</a></li><li><a href="/howtobuild.html">howtobuild</a></li><li><a href="/used_project.html">used_project</a></li><li><a href="/index.html">index</a></li><li><a href="/tips/noncopyable.html">noncopyable</a></li><li><a href="/tips/move.html">move</a></li><li><a href="/tips/math.html">math</a></li><li><a href="/tips/initialize.html">initialize</a></li><li><a href="/tips/string_algo.html">string_algo</a></li><li><a href="/tips/signals.html">signals</a></li><li><a href="/tips/mpi.html">mpi</a></li><li><a href="/tips/lockfree-queue.html">lockfree-queue</a></li><li><a href="/tips/logging.html">logging</a></li><li><a href="/tips/version.html">version</a></li><li><a href="/tips/format.html">format</a></li><li><a href="/tips/multi_index.html">multi_index</a></li><li><a href="/tips/ini.html">ini</a></li><li><a href="/tips/filesystem.html">filesystem</a></li><li><a href="/tips/partial_eval.html">partial_eval</a></li><li><a href="/tips/dynamic_assert.html">dynamic_assert</a></li><li><a href="/tips/multiprec-int.html">multiprec-int</a></li><li><a href="/tips/finite_state_machine.html">finite_state_machine</a></li><li><a href="/tips/geometry.html">geometry</a></li><li><a href="/tips/tuple.html">tuple</a></li><li><a href="/tips/dynamic_type.html">dynamic_type</a></li><li><a href="/tips/linear-algebra.html">linear-algebra</a></li><li><a href="/tips/dynamic_bitset.html">dynamic_bitset</a></li><li><a href="/tips/timer.html">timer</a></li><li><a href="/tips/named_parameter.html">named_parameter</a></li><li><a href="/tips/io_state.html">io_state</a></li><li><a href="/tips/scope_guard.html">scope_guard</a></li><li><a href="/tips/interval_arithmetic.html">interval_arithmetic</a></li><li><a href="/tips/date_time.html">date_time</a></li><li><a href="/tips/lockfree-stack.html">lockfree-stack</a></li><li><a href="/tips/program_options.html">program_options</a></li><li><a href="/tips/hashmap.html">hashmap</a></li><li><a href="/tips/multi_array.html">multi_array</a></li><li><a href="/tips/serialize.html">serialize</a></li><li><a href="/tips/list.html">list</a></li><li><a href="/tips/statistics.html">statistics</a></li><li><a href="/tips/memory_mapped_file.html">memory_mapped_file</a></li><li><a href="/tips/priority_sort.html">priority_sort</a></li><li><a href="/tips/static_assert.html">static_assert</a></li><li><a href="/tips/constcond_overload.html">constcond_overload</a></li><li><a href="/tips/uuid.html">uuid</a></li><li><a href="/tips/lambda.html">lambda</a></li><li><a href="/tips/network.html">network</a></li><li><a href="/tips/random.html">random</a></li><li><a href="/tips/parser.html">parser</a></li><li><a href="/tips/graph.html">graph</a></li><li><a href="/tips/array.html">array</a></li><li><a href="/tips/build_link.html">build_link</a></li><li><a href="/tips/thread.html">thread</a></li><li><a href="/tips/optional.html">optional</a></li><li><a href="/tips/static_regex.html">static_regex</a></li><li><a href="/tips/unit_test.html">unit_test</a></li><li><a href="/tips/operators.html">operators</a></li><li><a href="/tips/noncopyable_container.html">noncopyable_container</a></li><li><a href="/tips/cxx11-boost-mapping.html">cxx11-boost-mapping</a></li><li><a href="/tips/foreach.html">foreach</a></li><li><a href="/tips/config.html">config</a></li><li><a href="/tips/iterator.html">iterator</a></li><li><a href="/tips/build.html">build</a></li><li><a href="/tips/dynamic_regex.html">dynamic_regex</a></li><li><a href="/tips/json.html">json</a></li><li><a href="/tips/smart_ptr.html">smart_ptr</a></li><li><a href="/tips/xml.html">xml</a></li><li><a href="/tips/circular_buffer.html">circular_buffer</a></li><li><a href="/tips/type_traits.html">type_traits</a></li><li><a href="/tips/function.html">function</a></li><li><a href="/tips/template_page.html">template_page</a></li><li><a href="/tips/variant.html">variant</a></li><li><a href="/tips/multiprec-float.html">multiprec-float</a></li><li><a href="/editors_doc/start_editing.html">start_editing</a></li><li><a href="/boostcon/2011.html">2011</a></li><li><a href="/boostcon/2010.html">2010</a></li><li><a href="/archive/propose.html">propose</a></li><li><a href="/archive/boost_docs.html">boost_docs</a></li><li><a href="/archive/cpp_online_reading.html">cpp_online_reading</a></li><li><a href="/cppnow/2014.html">2014</a></li><li><a href="/cppnow/2012.html">2012</a></li><li><a href="/cppnow/2013.html">2013</a></li><li><a href="/document/version.html">version</a></li><li><a href="/document/boostserialization.html">boostserialization</a></li><li><a href="/document/boost-range-algorithm-kansu-no-susume.html">boost-range-algorithm-kansu-no-susume</a></li><li><a href="/study_meeting/study5.html">study5</a></li><li><a href="/study_meeting/study6.html">study6</a></li><li><a href="/study_meeting/year-end-party2010-sapporo.html">year-end-party2010-sapporo</a></li><li><a href="/study_meeting/idea.html">idea</a></li><li><a href="/study_meeting/study14.html">study14</a></li><li><a href="/study_meeting/study13.html">study13</a></li><li><a href="/study_meeting/study10.html">study10</a></li><li><a href="/study_meeting/study4.html">study4</a></li><li><a href="/study_meeting/study16.html">study16</a></li><li><a href="/study_meeting/study8.html">study8</a></li><li><a href="/study_meeting/study11.html">study11</a></li><li><a href="/study_meeting/year-end-party2010-tokyo.html">year-end-party2010-tokyo</a></li><li><a href="/study_meeting/study12.html">study12</a></li><li><a href="/study_meeting/study9.html">study9</a></li><li><a href="/study_meeting/reversed_index.html">reversed_index</a></li><li><a href="/study_meeting/study7.html">study7</a></li><li><a href="/study_meeting/study1.html">study1</a></li><li><a href="/study_meeting/study3.html">study3</a></li><li><a href="/study_meeting/study15.html">study15</a></li><li><a href="/study_meeting/study2.html">study2</a></li><li><a href="/study_meeting/year-end-party2010-nagoya.html">year-end-party2010-nagoya</a></li></ul>
  </div>
  <div class="col-md-10">
<h1>ジェネリックコンポーネントにおける例外安全性</h1>
<p>C++標準ライブラリのために規定した例外安全性の経験から学んだこと</p>
<ul>
<li>David Abrahams</li>
<li>david.abrahams@rcn.com</li>
<li>翻訳元：<a href="http://www.boost.org/community/exception_safety.html" target="_blank">http://www.boost.org/community/exception_safety.html</a></li>
</ul>
<p><strong>概要</strong></p>
<p>この文書は実世界の必要性に対する応答の中で蓄積された知識を表す: つまり、 C++ 標準テンプレートライブラリは、役立つ、そして明確な例外との相互作用を示し、 エラー捕捉の機構は C++ 言語の中核に組み込まれている。 この文書では、例外安全性の意味を探求し、例外と汎用性についての驚くべき神話を明らかにし、 プログラムの正当性を理由付けるための価値ある道具について述べ、 例外安全性を実証するための自動化されたテストの手続きを概説する。</p>
<p>Keywords: exception-safety, exceptions, STL, C++</p>
<h2>1 例外安全性とは何か</h2>
<p>簡単に言えば、コンポーネントの例外安全性とは、 実行中に例外が投げられたとき、正当な振る舞いを示すことを意味する。 ほとんどの人にとって、「正当な」という用語は、エラー捕捉に対する通常の例外全てを含む: つまり、資源は漏れるべきではないし、プログラムは実行を継続できるように、 明確な状態であり続けるべきである。多くのコンポーネントにとって、 これはまた、エラーに出会った時に呼び出し元に報告されるような例外も含む。</p>
<p>より公式に言えば、コンポーネントの中から例外が投げられたときに、 もしその不変性が損なわれないなら、そのコンポーネントは最小限の例外安全性を持っていると言える。 後に見るが、通常、少なくとも3種類の異なる例外安全性が区別されている。 これらの区別は巨大なシステムの振る舞いについて記述し、理由付けるのに役立つのである。</p>
<p>汎用コンポーネントでは、通常我々は、さらに、 <em>例外中立性</em> という期待をもつ。 これは、コンポーネントの型パラメータによって投げられた例外は、 そのコンポーネントの呼び出し元まで、変わることなく伝えられるべきである、 ということを意味する。</p>
<h2>2 神話と迷信</h2>
<p>例外安全性は、これまでのところ簡単なものに見える: それは、より伝統的なエラー捕捉の技術を使ったコードに期待する以上のことを、 何も構築したりはしない。しかし、心理学的な観点からこの用語を調べてみることは、価値があるだろう。 C++ が例外を持つ以前は、誰も「エラー安全性」について語らなかった。</p>
<p>まるで例外は、正しいコードに対する <em>ミステリアスな攻撃</em> であり、 我々が自らをその攻撃から守らなければいけないようなものであると見なされているかのようである。 言うまでもなく、これはエラー捕捉との健全な関係に繋がらない! 標準化の間、変更に対する幅広いサポートを要求する民主的な過程で、 私は広く支持された多くの迷信に出会った。 汎用コンポーネントにおける例外安全性の議論を始めるために、 それらのいくつかを見ておくことは意味のあることだろう。</p>
<p>「テンプレートと例外の相互作用は、良く理解できない。」 これら両方が言語の新しい特徴であると考える人々から良く聞かれるこの神話は、 簡単に却下できる: そこには、相互作用はないのである。 テンプレートは、一度実体化されれば、全ての面で通常のクラスや関数と同じように機能する。 例外と関連したテンプレートの振る舞いを考えるための単純な方法は、 そのテンプレートの特別版の実体化がどう機能するかについて考えることである。 最後に、テンプレートの汎用性は、何も特別なことを引き起こさない。 コンポーネントのクライアントは操作の一部を提供するが(この操作は、もし特別版でないなら、 任意の例外を投げるだろう)、我々が良く親しんだ仮想関数や、 単純な関数ポインタを使った操作についても、同じことなのである。</p>
<p>「例外安全性をもつ汎用コンテナを書くのが不可能であることは、 良く知られている」 この主張は、Tom Cargill による文書、 [^4] に関連してよく聞かれる。そこで彼は、汎用スタックテンプレートに対する例外安全性の問題について探求している。 彼の文書で、 Cargill は多くの役立つ問題を掲げているが、 残念ながらそれらの問題に対する解決法を提供できていない。彼は解決は不可能である、と提案して結論付けている。不幸にも彼の文書は、 多くの人に、そのような空論の 「証拠」 として読まれてしまった。 しかしこの文書が出版されてから、例外安全な汎用コンテナの多くの実例があったのである。 C++ 標準ライブラリコンテナもその中にはいる。</p>
<p>「例外を扱うとコードは遅くなり、テンプレートは本質的に 可能な限りのパフォーマンスを得るために使われる。」 C++ の優れた実装は、例外が投げられるまでにその例外を扱うひとつの命令サイクルを費やすことはしないで、 例外は関数呼び出しの同じようなスピードで捕捉可能である [^7]。 それだけで、例外を使ったプログラムに、 エラーの可能性を無視したプログラムと同等のパフォーマンスを提供している。 例外を使うと実際は、結果的に別の理由で「伝統的な」エラー捕捉の方法よりも早くなる。 まず、 catch 節はコンパイラに、どのコードがエラー捕捉に費やされるかを明確に示す。 このため、通常の実行パスから分離することが可能であり、参照の局所性が改善する。 次に、「伝統的な」エラー捕捉を使ったコードは典型的に、単一の関数を呼び出した後、いつも返り値を検査しなければならない。 例外を使えば、このオーバヘッドは完全に消える。</p>
<p>「例外はプログラムの振る舞いを推論することを難しくしてしまう」 通常、この神話が支持されて引用されるのは、 スタック巻き戻しの間に「隠れた」実行パスを通る、という意味においてである。 隠れた実行パスはローカル変数が関数から戻る前に破棄されることを期待している C++ プログラマにとっては、なにも新しいものではない。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">ErrorCode f( int&amp; result )         // 1 
{                                  // 2 
    X x;                           // 3 
    ErrorCode err = x.g( result ); // 4 
    if ( err != kNoError )         // 5 
        return err;                // 6 
    // ...More code here... 
    return kNoError;               // 7 
}</span></code></pre>

上の例では、6行目と7行目に <code><span style="color: #000">X::~X</span></code> の「隠れた」呼び出しがある。 そう考えれば、例外を使うことで、エラー捕捉に対して、明白なコードの無駄は存在しない。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">int f()                 // 1 
{                       // 2 
    X x;                // 3 
    int result = x.g(); // 4 
    // ...More code here... 
    return result;      // 5 
} </span></code></pre>

例外をより良く知っている多くのプログラマにとって、2番目の例は実際は最初の例よりも、 読みやすく理解しやすい。 「隠れた」コードパスは同じくローカル変数のデストラクタを呼び出している。 更にこれは、冷害が起こった場合にそれぞれの関数呼び出しの後に、 潜在的なリターン文があるかのような、正確に振る舞う単純なパターンに従うのである。 通常の実行パスはエラー捕捉によって分かりにくくならないので、可読性は向上し、 返り値は自然なやり方で使えるように解放されるのである。 例外が正確さを向上することが出来る、さらに重要なやり方がある: それは、 単純なクラス不変性を可能にすることによる。 最初の例では、もし <code><span style="color: #000">X</span></code> のコンストラクタが資源を確保する必要があるなら、 失敗を報告する手だてはない: C++ ではコンストラクタは返り値を持てないからである。 例外を使わない場合は通常、資源を要求するクラスが構築の仕事を完了する、 別の初期化関数を含まなければならない、という結果になる。 プログラマはそのため、クラス <code><span style="color: #000">X</span></code> のオブジェクトが使われるとき、 完全な <code><span style="color: #000">X</span></code> を手にしたのか、それともどこかで構築に失敗したものを手にしたのか、 決して確信をもてない(或いは更に悪いことに、誰かが単に初期化関数を呼び忘れたのかもしれない。)</p>
<h2>3 例外安全性の契約的原則</h2>
<p>非汎用的なコンポーネントは例外安全として記述することが出来るが、 汎用的なコンポーネントの場合は、クライアントによる構造化が可能なので、 例外安全性は通常、コンポーネントとクライアントの契約に依存する。 例えば、汎用的コンポーネントの設計者はコンポーネントのデストラクタで使われる演算が、 どんな例外も投げないことを要求するだろう。汎用的コンポーネントはその代わり、次の保証のうちのひとつを提供するだろう。</p>
<ul>
<li><em>基本的保証</em> : コンポーネントの不変性は保持され、資源漏れはない。</li>
<li><em>強い保証</em> : 演算は成功して完了するか、例外を投げるかのどちらかである。 例外を投げる場合、プログラムの状態は演算が始まる前の状態と全く同じである。</li>
<li><em>例外不送出保証</em> : 演算は例外を投げない。</li>
</ul>
<p><em>基本的保証</em> は、全てのコンポーネントに負わせることの出来る、 例外安全性に対する単純で最小限の基準である。 例外の後でもまだコンポーネントは以前のように使うことが出来ると述べているに過ぎない。 重要なことだが、不変性の保持によって、スタック巻き戻しの一部として潜在的に、 コンポーネントを破棄することが出来るのである。 この保証は実際には、見た目ほど役立つものではない。 もしコンポーネントが多くの有効状態を持つなら、例外の後にコンポーネントの状態が、 またはその状態だけが有効な状態なのかどうか知ることは出来ない。 この場合、回復のための選択肢は限られている: コンポーネントの破棄か、 さらに使う前に、ある既知の状態にコンポーネントをリセットするかである。 次の例を考えてみよう:</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class X&gt; 
void print_random_sequence() 
{ 
    std::vector&lt;X&gt; v(10); // A vector of 10 items 
    try { 
        // Provides only the basic guarantee 
        v.insert( v.begin(), X() ); 
    } 
    catch(...) {} // ignore any exceptions above 
    // print the vector's contents 
    std::cout "(" &lt;&lt; v.size() &lt;&lt; ") "; 
    std::copy( v.begin(), v.end(), 
    std::ostream_iterator&lt;X&gt;( std::cout, " " ) ); 
} </span></code></pre>

我々はみんな、例外後に v が有効であることを知っているので、 この関数は <code><span style="color: #000">X</span></code> のどんなランダムなシーケンスでも出力することが出来る。これはクラッシュしないと言う意味で「安全」ではあるが、出力の内容は予想できないものである。</p>
<p><em>強い保証</em> は、「責任を持つか、巻き戻すか」という意味論を完全に提供する。 C++ 標準コンテナの場合、これは例えばもし例外が投げられても全てのイテレータは有効なままであることを意味する。 我々はまた、コンテナが例外が投げられる前と全く同じ要素を持っていることも知っている。 失敗したら、なんの効果も及ぼさない処理は、明らかに利点がある: 例外が発生した場合でも、 プログラムの状態は単純で予測可能なのである。 C++ 標準ライブラリでは、ノードを使うコンテナ、<code><span style="color: #000">list</span></code>, <code><span style="color: #000">set</span></code>, <code><span style="color: #000">multiset</span></code>, <code><span style="color: #000">map</span></code>, <code><span style="color: #000">multimap</span></code> のほとんど全ての演算が強い保証を提供している。)</p>
<p><em>例外不送出保証</em> は最も強いものであり、演算は例外を投げないことを保証されている、 というものである: これは常に成功して完了する。 この保証はほとんどのデストラクタにとって必要なものであり、 C++ 標準ライブラリコンポーネントのデストラクタは実際にすべて、 例外を投げないことを保証されている。 例外不送出保証、他の理由で重要となることを我々は見るだろう。</p>
<h2>4 法的論争</h2>
<p>契約がより複雑になることは避けられない: その代わり整理することが可能である。 C++ 標準ライブラリには、任意の型引数にひとつの保証を与え、 例外を投げないというクライアント型からの約束が追加されれれば、より強い保証を与えているものもある。 例えば、標準コンテナ操作 <code><span style="color: #000">vector&lt;T&gt;::erase</span></code> はどんな <code><span style="color: #000">T</span></code> にも <em>基本的保証</em> を与えるが、コピーコンストラクタとコピー代入演算子が例外を投げないなら、 <em>例外不送出保証</em> を与えている。</p>
<h2>5 コンポーネントはどのレベルの例外安全性を規定する必要があるか</h2>
<p>クライアントの観点から、可能な限り最も強いレベルの安全性が理想的である。 もちろん <em>例外不送出保証</em> は多くの演算に対して不可能であるが、 強い保証についてはどうだろうか? 例えば、 <code><span style="color: #000">vector&lt;T&gt;::insert</span></code> に対してちょっとした振る舞いが欲しいと仮定しよう。  <code><span style="color: #000">vector</span></code> の中間への挿入は、新しい要素のための場所を作るために、 挿入点以降の要素を、次の位置にコピーする必要がある。 もし要素のコピーが失敗に終われば、操作の巻き戻しは既に行われたコピーの「取り消し」を必要とする。</p>
<p>ひとつの可能な選択肢は、新しい配列の内容を、毎回新しいメモリで構築して、 成功したときのみ古い内容を破棄するように <code><span style="color: #000">insert</span></code> を再定義することである。 残念ながら、このアプローチにはコストがかかる: <code><span style="color: #000">vector</span></code> の終端付近での挿入は、 以前ではほとんどコピーを行う必要がなかったが、 このアプローチでは全ての要素をコピーしなければいけない。 <em>基本的保証</em> はこの操作に対する「自然な」水準の安全性である。 パフォーマンスを脅かすことなく保証を与えているのである。 実際ライブラリの全ての演算は、層のような「自然な」水準の安全性を提供している。</p>
<p>パフォーマンスの要求は基準の草案の中では、確立した部分であり、 パフォーマンスは STL の基本的な目的であるので、 これらの要求の中で提供されうる、より強い安全性を明記する試みは為されなかった。 全てのライブラリが <em>強い保証</em> を与えているわけではないが、 <em>基本的保証</em> を提供する、標準コンテナほとんどの演算は、上に述べた、 「新たなコピーを作る」という戦略を使うことで、強い保証を持つことが出来る。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class Container, class BasicOp&gt; 
void MakeOperationStrong( Container&amp; c, const BasicOp&amp; op ) 
{ 
    Container tmp(c); // Copy c 
    op(tmp); // Work on the copy 
    c.swap(tmp); // Cannot fail
}</span></code></pre>

この技は、より強い保証を提供する(そして異なるパフォーマンス特性を提供する)、 似たようなコンテナを作るためのラッパクラスに導入することが出来る。</p>
<h2>6 私たちは、私たちが得ることができる全てを得るべきか</h2>
<p>特殊な実装を考えれば、安全性についての自然な水準を判断することを望めるだろう。 コンポーネントに対する要求を確立するのにこれを使うことで、 実装が制限されるという危険性が生じる。 我々が使いたくなるような、より効率的な実装を誰かが作り上げても、 それが我々の持つ例外安全性への要求を満たしていないことに気づくかもしれない。 STL が扱っているデータ構造とアルゴリズムという、よく研究された領域では、 このようなことに誰も期待を寄せないかもしれないが、 それでも実際、より優れたものが作られている。最近の <em>introsort</em> アルゴリズムは、その良い例である [^6]。 これは、既に確立した <em>quicksort</em> に対して、最悪の計算量を必要とするような場合での、 大幅な改善を示している。 実際に標準コンポーネントの要求がどの程度のものなのかを決定するために、 実世界の典型的な場合を考えた。 選ばれたテストケースは 「合成コンテナ」である。 2つ以上の標準コンテナの合成である、そのコンテナは広く必要とされているだけでなく、 巨大なシステムで不変性を維持することについての単純で代表的な事例である。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">// SearchableStack - A stack which can be efficiently searched 
// for any value. 
template &lt;class T&gt; 
class SearchableStack 
{ 
 public: 
    void push(const T&amp; t);           // O(log n) 
    void pop(); // O(log n) 
    bool contains(const T&amp; t) const; // O(log n) 
    const T&amp; top() const;            // O(1) 
 private: 
    std::set&lt;T&gt; set_impl; 
    std::list&lt;std::set&lt;T&gt;::iterator&gt; list_impl; 
}; </span></code></pre>

ここでは、<code><span style="color: #000">list</span></code> は <code><span style="color: #000">set</span></code> のイテレータのスタックとして振る舞う: 全ての要素は最初に <code><span style="color: #000">set</span></code> に入り、その結果その位置が <code><span style="color: #000">list</span></code> に入れられる。 不変性というのは、簡単なことである: <code><span style="color: #000">set</span></code> と <code><span style="color: #000">list</span></code> は常に、 同じ要素数を持ち、<code><span style="color: #000">set</span></code> 全ての要素は <code><span style="color: #000">list</span></code> の要素により参照されている、ということである。 以下の <code><span style="color: #000">push</span></code> 関数の実装は、 <code><span style="color: #000">set</span></code> と <code><span style="color: #000">list</span></code> によって提供される自然な水準の例外安全性で、 <em>強い保証</em> を提供するために設計されたものである。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">template &lt;class T&gt;                                // 1
void SearchableStack&lt;T&gt;::push(const T&amp; t)         // 2
{                                                 // 3
    set&lt;T&gt;::iterator i = set_impl.insert(t);      // 4
    try                                           // 5
    {                                             // 6
        list_impl.push_back(i);                   // 7
    }                                             // 8
    catch(...)                                    // 9
    {                                             // 10
        set_impl.erase(i);                        // 11
        throw;                                    // 12
    }                                             // 13
}                                                 // 14</span></code></pre>

このコードは実際に、ライブラリの何を要求するだろうか? 非 <code><span style="color: #000">const</span></code> 演算が行われる行を調べてみる必要がある。</p>
<ul>
<li>4行目: 挿入が失敗したが、 <code><span style="color: #000">set_impl</span></code>がその過程で変更されている場合、 不変性は保たれない。そこで、<code><span style="color: #000">set&lt;T&gt;::insert</span></code> からの <em>強い保証</em> に頼ることが出来なければならない。</li>
<li>7行目: 同様に <code><span style="color: #000">push_back</span></code> が失敗して <code><span style="color: #000">list_impl</span></code> がその過程で変更されているなら、不変性は保たれない。 そこで、<code><span style="color: #000">list&lt;T&gt;::insert</span></code> からの <em>強い保証</em> に頼ることが出来なければならない。</li>
<li>11行目: ここで4行目の挿入を「巻き戻し」ている。もしこの操作が失敗すれば、 不変性を回復することは出来ないだろう。結局 <code><span style="color: #000">set&lt;T&gt;::erase</span></code> からの <em>例外不送出保証</em> に頼ることになる。</li>
<li>11行目: 同じ理由で、 <code><span style="color: #000">i</span></code> を <code><span style="color: #000">erase</span></code> 関数に渡すことが出来るということにも、 頼らなければならない: <code><span style="color: #000">set&lt;T&gt;::iterator</span></code> からの、 <em>例外不送出保証</em> に頼る必要があるのである。</li>
</ul>
<p>私は標準化の際にこの方法で問題を扱うことで、多くを学んだ。 まず、合成コンテナに対して明示された保証は、実際はそのコンポーネントからのより強い保証 (11行目の <em>例外不送出保証</em> )に依存するということである。 また、この単純な例を実装するために、自然な水準の例外安全性を全ての面で利用した。 そして、この分析は、以前私が、演算をそれぞれ独立したものと考えていたときには見逃していた、 イテレータへの要求を明らかにした。 結論は、可能な限り自然な水準の例外安全性を提供すべきだ、ということである。 より速く、しかしより安全ではない実装は常に、標準コンポーネントの拡張として提供されるべきである。</p>
<h2>7 例外安全性の自動テスト</h2>
<p>標準化の過程の一部として、私は STL での例外安全な参照の実装を作った。 エラー捕捉コードは実際にかなり厳密にテストされたが、 エラー状態を起こすことが難しいので、そのテストは部分的である。 初めて実行されたときにクラッシュしたエラー捕捉コードを考えるというのは、 とても一般的である-出荷される製品では。実装が実際に宣伝通りに動くという確信を強めるために、 私は自動化されたテストスイートを設計した。これは同僚の Matt Arnold の精緻な技術に基づいている。</p>
<p>テストプログラムは基本的なところから始まった: 特にグローバル演算子 <code><span style="color: #000">new</span></code> と<code><span style="color: #000">delete</span></code>についての強化と計測である。 出来る限り多くの潜在的な問題を明らかにするために選ばれた型引数で、 コンポーネント(コンテナとアルゴリズム)の実体が作られた。 例えば、全ての型引数にはヒープ領域にメモリを割り当てられるポインタが与えられた。 そのため、コンテナに格納されたオブジェクトをリークさせることは、 メモリリークとして検出された。</p>
<p>最後に、ポインタが間違って示す可能性のある場合に、その都度、 演算に例外を投げさせることが出来るような仕組みを設計した。 クライアントが提供し、例外を投げることが許されている全ての演算の最初に、 <code><span style="color: #000">ThisCanThrow</span></code> の呼び出しが加えられた。 <code><span style="color: #000">ThisCanThrow</span></code> の呼び出しはまた、 テストされる汎用的演算が例外を投げるかもしれない全ての場所にも加えられた。 例えば、より機能を強化したものに置き換えられた、グローバル演算子 <code><span style="color: #000">new</span></code> である。</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">// Use this as a type parameter, e.g. vector&lt;TestClass&gt; 
struct TestClass 
{ 
    TestClass( int v = 0 ) 
        : p( ThisCanThrow(), new int( v ) ) {} 
    TestClass( const TestClass&amp; rhs ) 
        : p( ThisCanThrow(), new int( *rhs.p ) ) {} 
    const TestClass&amp; operator=( const TestClass&amp; rhs ) 
        { ThisCanThrow(); *p = *rhs.p; } 
    bool operator==( const TestClass&amp; rhs ) 
        { ThisCanThrow(); return *p == *rhs.p; } 
    ...etc... 
    ~TestClass() { delete p; } 
};</span></code></pre>
</p>
<p><code><span style="color: #000">ThisCanThrow</span></code> は単に、「throw カウンタ」をデクリメントするだけであり、 もしそれが <code><span style="color: #000">0</span></code> になったら、例外を投げる。 テスト毎に、外側のループで、徐々に大きな値にカウンターを設定して開始し、 演算のテストが完了するまで繰り返し試す、という形を取った。 結果は、失敗する可能性がある実行パスに沿って、連続的なステップで、オペレーションが例外を投げた。 例えば、 <em>強い保証</em> をテストするのに使われた関数の単純なバージョンがある:</p>
<p><pre class="codehilite"><code class="language-cpp"><span style="color: #000">extern int gThrowCounter; // The throw counter
void ThisCanThrow() 
{ 
    if (gThrowCounter-- == 0) 
        throw 0; 
} 

template &lt;class Value, class Operation&gt; 
void StrongCheck(const Value&amp; v, const Operation&amp; op) 
{ 
    bool succeeded = false; 
    for (long nextThrowCount = 0; !succeeded; ++nextThrowCount) 
    { 
        Value duplicate = v; 
        try 
        { 
            gThrowCounter = nextThrowCount; 
            op( duplicate ); // Try the operation 
            succeeded = true; 
        } 
        catch(...) // Catch all exceptions 
        { 
            bool unchanged = duplicate == v; // Test strong guarantee 
            assert( unchanged ); 
        } 
        // Specialize as desired for each container type, to check 
        // integrity. For example, size() == distance(begin(),end()) 
        CheckInvariant(v); // Check any invariant 
    } 
}</span></code></pre>

注意すべきは、この種のテストは非汎用的なコンポーネントより、汎用的なものの方が 遙かに簡単で、煩わしさのないものである、ということである。 これは、テストに特化した型引数を、 テストされるコンポーネントのソースコードを変更することなく使うことが出来るからである。 また上の <code><span style="color: #000">StrongCheck</span></code> のような汎用関数が広範な値と演算のテストを行うのに役立つ。</p>
<h2>8 さらにくわしく知るための資料</h2>
<p>私が知る限り、現在 STL の利用可能な例外安全性には2種類の記述しかない。 STL の例外安全の実装のリファレンスでの、オリジナルの仕様 [^2] は、非公式な仕様であり、単純で自明(そして冗長)である。 そこでは、この文書で概説してきた、基本的と強い保証の区別が使われている。 それは明らかに、資源漏れを禁止していて、最終的な C++ 標準と比べ、多くの面で同じなのだが、 保証という点では実質的に異なる。 私はこの文書の改訂版が速やかに作られることを望んでいる。 C++ 標準での例外安全性の記述[^1] はほんの少しだけ公式なものであるが、読みにくい「規格化」 で構成されていて、ウェブ上ではほとんど見ることが出来ない。とくに、資源漏れについては直接は全く扱われていない。 それが規格であるという利点を持っているに過ぎない。</p>
<p>例外安全の実装[^5] に関するオリジナルのリファレンスは、SGI STL の古いバージョンである。 これは限られた能力の C++ コンパイラのために設計された。 これは完全な STL の実装ではないが、コードは読みやすいし、 役立つ基底クラスのテクニックを、コンストラクタでの例外捕捉をなくすために説明している。 参照の実装を検証するために使われた完全なテストスイート<a href="http://boostjp.github.io/archive/boost_docs/document/実践としては、この関数はあまりにも貧弱なランダムシーケンス製作器である!">^3</a> は、引き続き SGI STL の最近のバージョン全てで使われている。 そして他のベンダの実装をテスト(通らなかった)するのにも使われている。 文書で注記されているように、それは隠れたコンパイラのバグを明らかにするのに、特に最適化と例外捕捉コードが相互作用するような場所では、強力であるだろう。</p>
<h2>参考文献</h2>
<ol>
<li>International Standard ISO/IEC 14882, Information Technology-Programming Languages-C++, Document Number ISO/IEC 14882-1998, available from <a href="http://webstore.ansi.org/ansidocstore/default.asp" target="_blank">http://webstore.ansi.org/ansidocstore/default.asp</a>.</li>
<li>D. Abrahams, Exception Safety in STLport, available at <a href="http://www.stlport.org/doc/exception_safety.html" target="_blank">http://www.stlport.org/doc/exception_safety.html</a>.</li>
<li>D. Abrahams and B. Fomitchev, Exception Handling Test Suite, available at <a href="http://www.stlport.org/doc/eh_testsuite.html" target="_blank">http://www.stlport.org/doc/eh_testsuite.html</a>.</li>
<li>Tom Cargill, "Exception Handling: A False Sense of Security," C++ Report, Nov-Dec 1994, also available at <a href="http://www.awl.com/cp/mec++-cargill.html" target="_blank">http://www.awl.com/cp/mec++-cargill.html</a>.</li>
<li>B. Fomitchev, Adapted SGI STL Version 1.0, with exception handling code by D. Abrahams, available at <a href="http://www.metabyte.com/~fbp/stl/old.html" target="_blank">http://www.metabyte.com/~fbp/stl/old.html</a>.</li>
<li>D. R. Musser, "Introspective Sorting and Selection Algorithms," Software-Practice and Experience 27(8):983-993, 1997.</li>
<li>Bjarne Stroustrup, The Design And Evolution of C++. Addison Wesley, Reading, MA, 1995, ISBN 0-201-54330-3, Section 16.9.1.</li>
</ol>
<h2>脚注</h2>
<p>[^1]: おそらく Cargill の場合、解決に対する最も大きな障害は、 彼が、不幸な組み合わせの選択をしてしまったということであった: 彼がコンテナのために選んだインタフェースは、彼が要求する安全性の特徴と一致しないものだったのだ。 どちらかを変更すれば、彼は問題を解決できただろう。</p>
<p>[^2]: C++ でデストラクタから例外が投げられることは通常進められない。 デストラクタは、それ自身他の例外によって引き起こされるスタック巻き戻しの途中で呼び出されるかもしれないからである。 2番目の例外がデストラクタを越えて伝えられることが可能なら、 問題はすぐに解決する。</p>
<p>[^4]: 変更操作を行うアルゴリズムが通常、 <em>強い保証</em> を提供できないことは、 注目に値する: ある範囲の変更された要素を巻き戻すために、 例外を投げるかもしれない <code><span style="color: #000">operator=</span></code> を使って、以前の状態に戻さなければならないのである。 C++ 標準ライブラリでは、この規則はほとんど守られていて、 巻き戻しの振る舞いは破棄だけで成立している: 例外は、<code><span style="color: #000">uninitialized_copy</span></code>, <code><span style="color: #000">uninitialized_fill</span></code>, <code><span style="color: #000">uninitialized_fill_n</span></code>。</p>
<p>[^5]: C++ 標準ライブラリのクライアントが提供する全ての型引数は、 デストラクタが例外を投げないことを要求される。 その代わりに、 C++ 標準ライブラリの全てのコンポーネントは少なくとも <em>基本的保証</em> を提供するのである。</p>
<p>[^6]: 変更操作を行う多くのアルゴリズムに対して C++ 規格では 似たような整理が為されている。しかし規格化の過程で時間の制約は全く考えられていない。</p>
<p>[^7]: 要素の <code><span style="color: #000">Compare</span></code> がコピー時に例外を投げるかもしれないような連想コンテナは、この技を使っていない。 スワップ関数が失敗するかもしれないからである。</p>
<p>[^8]: これは、たびたび望まれ、しかしまだ見知らぬ <code><span style="color: #000">container_traits&lt;&gt;</span></code> テンプレートのもう一つの潜在的な利用を示している。 例外安全性の制約を満たす、コンテナの自動選択である。</p>
<p>[^9]: <code><span style="color: #000">set&lt;T&gt;</span></code> に対する要求を減らし、 例外時の問題を減らすために、 <code><span style="color: #000">erase</span></code> を <code><span style="color: #000">try</span></code>/<code><span style="color: #000">catch</span></code> ブロックに入れようとするかもしれない。 しかし結局、問題なのである。 まず、<code><span style="color: #000">erase</span></code> は失敗し、この場合必要な結果を産み出すための実行可能な代替案は存在しない。 また、より一般には、型引数が多様なので、汎用コンポーネントにたいして、 どんな選択肢も成功する保証はめったになされるものではない。</p>
<p>[^10]: STL の設計の有力な哲学は、全ての利用にとって基本的でない機能は、その機能が必要なときに、基本のコンポーネントを適応することで得られる限り、 効率を求めないでいく、ということである。 これはそのような哲学に端を発しているが、 <em>基本的保証</em> でさえ、 既にその保証を持っていない基本のコンポーネントを適応して、そのような保証を得ることは難しいか、不可能である。</p>
<p>[^11]: メモリシステムをどのようにして守るかについての素晴らしい議論が、 次のものに書かれている: Steve Maguire, Writing Solid Code, Microsoft Press, Redmond, WA, 1993, ISBN 1-55615- 551-4.</p>
<p>[^12]: この技は、テストされる操作が例外中立であることを必要とすることに注意すること。 もし操作が例外から回復して、処理を続けようとするなら、<code><span style="color: #000">throw</span></code> カウンタは負の値になるだろう。 そしてその後の失敗するかもしれない操作は、例外安全性に対してテストされない。</p>
<p>[^13]: 例外安全性を導入した規格草案に対する変更は、 変更される単語の数が多いという理由だけで修正が拒否されるような、 草案作成の過程のかなり遅い時期に為された。 不幸にも、この結果、簡潔さを求める余り、ある程度妥協したものとなった。 Greg Colvin はこれらの変更の範囲を最小化するために必要な、 賢い言語-法実務についての責任がある。</p>
  </div>
</div>
            </div>
        </main>
    </body>
    <!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started -->
    <!--[if lt IE 7 ]>
        <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
        <script>
            window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
        </script>
    <![endif]-->
</html>
