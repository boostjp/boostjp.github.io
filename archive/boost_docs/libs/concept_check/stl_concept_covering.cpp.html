<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]--><!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]--><!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]--><!--[if gt IE 8]><!--><html class=no-js lang=en> <!--<![endif]--> <head><meta charset=UTF-8><title>libs/concept_check/stl_concept_covering.cpp - boostjp</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css><!-- <link rel="stylesheet" href="/static/css/root.css"> --><script src=//code.jquery.com/jquery-2.1.1.min.js></script><script src=//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js></script><!-- <script src="//platform.twitter.com/widgets.js"></script> --><!-- <script src="/static/js/root.js"></script> --><!--[if lt IE 9]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]--><script>
            document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/,'js');
        </script><style type=text/css>
.tree{
  -webkit-border-radius:4px;
  -moz-border-radius:4px;
  border-radius:4px;
  -webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);
  -moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);
  box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);
  background-color:#fbfbfb;
  border:1px solid #999;
  margin-bottom:10px;
  /*max-height:300px;*/
  /*min-height:20px;*/
  /*overflow-y:auto;*/
  padding:3px
}
.tree ul {
  padding-left:32px
}
.tree > ul{
  padding-left:0px
}
.tree a{
  display:inline;
  overflow:hidden;
  text-overflow:ellipsis;
  width:90%
}
.tree li{
  list-style-type:none;
  margin:0;
  padding:4px 0 0 2px;
  position:relative
}
.tree li::before,.tree li::after{
  content:'';
  left:-20px;
  position:absolute;
  right:auto
}
.tree li::before{
  border-left:1px solid #999;
  bottom:50px;
  height:100%;
  top:0;
  width:1px;
  -webkit-transition:"border-color 0.1s ease 0.1s";
  -moz-transition:"border-color 0.1s ease 0.1s";
  -o-transition:"border-color 0.1s ease 0.1s";
  transition:"border-color 0.1s ease 0.1s"
}
.tree li::after{
  border-top:1px solid #999;
  height:20px;
  top:13px;
  width:23px;
  -webkit-transition:"border-color 0.1s ease 0.1s";
  -moz-transition:"border-color 0.1s ease 0.1s";
  -o-transition:"border-color 0.1s ease 0.1s";
  transition:"border-color 0.1s ease 0.1s"
}
.tree li span{
  -moz-border-radius:5px;
  -webkit-border-radius:5px;
  border:1px solid #999;
  border-radius:5px;
  display:inline-block;
  line-height:14px;
  padding:2px 4px;
  text-decoration:none;
  -webkit-transition:color .2s ease .1s,background-color .2s ease .1s,border-color .3s ease .2s;
  -moz-transition:color .2s ease .1s,background-color .2s ease .1s,border-color .3s ease .2s;
  -o-transition:color .2s ease .1s,background-color .2s ease .1s,border-color .3s ease .2s;
  transition:color .2s ease .1s,background-color .2s ease .1s,border-color .3s ease .2s
}
.tree li.parent_li>span{cursor:pointer}
.tree li.parent_li>span:hover{
  background-color:#df8505;
  border:1px solid #c67605;
  color:#fff
}
.tree li.parent_li>span:hover+ul li::after{border-top-color:#f89406}
.tree li.parent_li>span:hover+ul li::before{border-left-color:#f89406}
.tree li.parent_li>span:hover+ul li span{
  background:#fddfb3;
  border:1px solid #faa937;
  color:#000
}
.tree li:last-child::before{height:30px}
.tree>ul>li::before,.tree>ul>li::after{border:0}
        </style><script>
function tree_onclick(e) {
    var children = $(this).parent('li.parent_li').find(' > ul > li');
    if (children.is(':visible')) {
        children.hide(100);
        $(this)
            .attr('title', 'Expand this branch')
            .find(' > i')
            .addClass('glyphicon-plus')
            .removeClass('glyphicon-minus');
    }
    else {
        children.show(100);
        $(this)
            .attr('title', 'Collapse this branch')
            .find(' > i')
            .addClass('glyphicon-minus')
            .removeClass('glyphicon-plus');
    }
    e.stopPropagation();
}
        </script></head> <body> <header> <nav class="navbar navbar-default" role=navigation> <div class=container-fluid> <div class=navbar-header> <button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=#navbar-collapse> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> <a class=navbar-brand href=/>boostjp : Boost日本語情報サイト</a> </div> <div class="collapse navbar-collapse" id=navbar-collapse> <form class="navbar-form navbar-right" role=search> <div class=form-group> <input type=text class=form-control placeholder=Search> </div> <button type=submit class="btn btn-default">検索</button> </form> </div> </div> </nav> </header> <main id=main role=main> <div class=container-fluid> <div class=row> <div class=col-md-3> <div class=tree> <ul> <li> <a href=/communities.html>コミュニティ</a> </li> <li> <a href=/howtobuild.html>Boostライブラリのビルド方法</a> </li> <li> <a href=/index.html>boostjp</a> </li> <li> <a href=/mailing-lists.html>メーリングリスト</a> </li> <li> <a href=/the-team.html>運営メンバ</a> </li> <li> <a href=/used_project.html>Boostを使用しているプロジェクト</a> </li> <li class="parent_li active"> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-minus"></i></span> <a href=/archive.html>アーカイブ</a> <ul> <li class="parent_li active"> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-minus"></i></span> <a href=/archive/boost_docs.html>旧Boost日本語化プロジェクト</a> <ul> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> document <ul> <li style="display: none"> <a href=/archive/boost_docs/document/error_handling.html>エラーと例外のハンドリング</a> </li> <li style="display: none"> <a href=/archive/boost_docs/document/generic_exception_safety.html>ジェネリックコンポーネントにおける例外安全性</a> </li> <li style="display: none"> <a href=/archive/boost_docs/document/generic_programming.html>ジェネリックプログラミング手法</a> </li> </ul> </li> <li class="parent_li active"> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-minus"></i></span> libs <ul> <li> <a href=/archive/boost_docs/libs/libraries.html>各ライブラリの翻訳ドキュメント</a> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> array <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array.html>arrayクラス, 固定サイズ配列のSTLコンテナ</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array.hpp.html>array.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array1.cpp.html>array1.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array2.cpp.html>array2.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array3.cpp.html>array3.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array4.cpp.html>array4.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/array5.cpp.html>array5.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/array/index.html>Array wrapper library</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> bind <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/bind/bind.html>bind.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/bind/bind_as_compose.cpp.html>bind_as_compose.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/bind/mem_fn.html>mem_fn.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/bind/ref.html>ref.hpp</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> compatibility <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/compatibility/index.html>Boost.Compatibilty ライブラリ</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> compose <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose.html>Compose Function Object Adapters</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose.hpp.html>boost/compose.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose1.cpp.html>compose1.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose2.cpp.html>compose2.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose3.cpp.html>compose3.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/compose4.cpp.html>compose4.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/index.html>非推奨： Compose library</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/compose/print.hpp.html>libs/compose/print.hpp</a> </li> </ul> </li> <li class="parent_li active"> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-minus"></i></span> concept_check <ul> <li> <a href=/archive/boost_docs/libs/concept_check/bibliography.html>参考文献</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/concept_check.html>The Boost Concept Check Library (BCCL)</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/concept_covering.html>コンセプトの充当化と原型</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/creating_concepts.html>コンセプト・チェック用クラスの作成</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/implementation.html>コンセプト・チェックの実装</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/prog_with_concepts.html>Programming with Concepts</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/reference.html>リファレンス</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/stl_concept_check.cpp.html>libs/concept_check/stl_concept_check.cpp</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/stl_concept_covering.cpp.html>libs/concept_check/stl_concept_covering.cpp</a> </li> <li> <a href=/archive/boost_docs/libs/concept_check/using_concept_check.html>コンセプト・チェックの利用</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> conversion <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/conversion/cast.html>Header boost/cast.hpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/conversion/cast_test.cpp.html>libs/conversion/cast_test.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/conversion/index.html>Boost Conversion Library</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/conversion/lexical_cast.html>Header boost/lexical_cast.hpp</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> date_time <ul> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/class_date.html>gregorian::date</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/class_date_duration.html>gregorian::date_duration</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/date_algorithms.html>Date Generators / Algorithms</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/dates_as_strings.cpp.html>dates_as_strings.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/days_alive.cpp.html>days_alive.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/days_till_new_year.cpp.html>days_till_new_year.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/gregorian.html>Gregorian Date System Documentation</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/index.html>Boost Date-Time Library Documentation</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/period_calc.cpp.html>period_calc.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/print_holidays.cpp.html>print_holidays.cpp</a> </li> <li style="display: none"> <a href=/archive/boost_docs/libs/date_time/print_month.cpp.html>print_month.cpp</a> </li> </ul> </li> </ul> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/archive/cpp_online_reading.html>C++オンライン読書会</a> <ul> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_001.html>第1回 C++Now! 読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_002.html>第2回 C++Now! 読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_003.html>第3回 C++Now! 読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_004.html>第4回 C++Now! 読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_005.html>第5回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_006.html>第6回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_007.html>第7回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_008.html>第8回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_009.html>第9回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_010.html>第10回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_011.html>第11回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_012.html>第12回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_013.html>第13回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_014.html>第14回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/archive_015.html>第15回 C++オンライン読書会</a> </li> <li style="display: none"> <a href=/archive/cpp_online_reading/request.html>読みたいC++資料リクエスト</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/archive/propose.html>提案予定プロジェクト</a> <ul> <li style="display: none"> <a href=/archive/propose/templ_rec_max.html>テンプレートの再帰上限数workaround(rejected)</a> </li> </ul> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/boostcon.html>BoostCon</a> <ul> <li style="display: none"> <a href=/boostcon/2010.html>BoostCon 2010</a> </li> <li style="display: none"> <a href=/boostcon/2011.html>BoostCon 2011</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/cppnow.html>C++Now!</a> <ul> <li style="display: none"> <a href=/cppnow/2012.html>C++Now! 2012</a> </li> <li style="display: none"> <a href=/cppnow/2013.html>C++Now! 2013</a> </li> <li style="display: none"> <a href=/cppnow/2014.html>C++Now! 2014</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document.html>ドキュメント</a> <ul> <li style="display: none"> <a href=/document/boost-range-algorithm-kansu-no-susume.html>Boost.Range アルゴリズム関数のすすめ</a> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization.html>Boost.Serialization</a> <ul> <li style="display: none"> <a href=/document/boostserialization/overview.html>Overview</a> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/other-classses.html>Other Classses</a> <ul> <li style="display: none"> <a href=/document/boostserialization/other-classses/extended_type_info.html>extended_type_info</a> </li> <li style="display: none"> <a href=/document/boostserialization/other-classses/singleton.html>singleton</a> </li> <li style="display: none"> <a href=/document/boostserialization/other-classses/void_cast.html>void_cast</a> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/reference.html>Reference</a> <ul> <li style="display: none"> <a href=/document/boostserialization/reference/archive-concepts.html>Archive Concepts</a> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/reference/serializableconcept.html>SerializableConcept</a> <ul> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/reference/serializableconcept/class-serialization-traits.html>Class Serialization Traits</a> <ul> <li style="display: none"> <a href=/document/boostserialization/reference/serializableconcept/class-serialization-traits/export-key.html>Export Key</a> </li> </ul> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/boostserialization/reference/special-considerations.html>Special Considerations</a> <ul> <li style="display: none"> <a href=/document/boostserialization/reference/special-considerations/exporting-class-serialization.html>Exporting Class Serialization</a> </li> </ul> </li> </ul> </li> </ul> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/document/version.html>リリースノート</a> <ul> <li style="display: none"> <a href=/document/version/1_45_0.html>Boost 1.45.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_46_0.html>Boost 1.46.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_46_1.html>Boost 1.46.1リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_47_0.html>Boost 1.47.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_48_0.html>Boost 1.48.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_49_0.html>Boost 1.49.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_50_0.html>Boost 1.50.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_51_0.html>Boost 1.51.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_52_0.html>Boost 1.52.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_53_0.html>Boost 1.53.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_54_0.html>Boost 1.54.0リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_55_0.html>Boost 1.55.0 リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_56_0.html>Boost 1.56.0リリースノート</a> </li> <li style="display: none"> <a href=/document/version/1_57_0.html>Boost 1.57.0リリースノート</a> </li> </ul> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> editors_doc <ul> <li style="display: none"> <a href=/editors_doc/start_editing.html>boostjpを編集するには</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/study_meeting.html>Boost.勉強会</a> <ul> <li style="display: none"> <a href=/study_meeting/idea.html>ネタ帳</a> </li> <li style="display: none"> <a href=/study_meeting/reversed_index.html>ライブラリ逆引き</a> </li> <li style="display: none"> <a href=/study_meeting/study1.html>Boost.勉強会 #1</a> </li> <li style="display: none"> <a href=/study_meeting/study10.html>Boost.勉強会 #10 東京</a> </li> <li style="display: none"> <a href=/study_meeting/study11.html>Boost.勉強会 #11 東京</a> </li> <li style="display: none"> <a href=/study_meeting/study12.html>Boost.勉強会 #12 大阪</a> </li> <li style="display: none"> <a href=/study_meeting/study13.html>Boost.勉強会 #13 仙台</a> </li> <li style="display: none"> <a href=/study_meeting/study14.html>Boost.勉強会 #14 東京</a> </li> <li style="display: none"> <a href=/study_meeting/study15.html>Boost.勉強会 #15 札幌</a> </li> <li style="display: none"> <a href=/study_meeting/study16.html>Boost.勉強会 #16 大阪</a> </li> <li style="display: none"> <a href=/study_meeting/study2.html>Boost.勉強会 #2</a> </li> <li style="display: none"> <a href=/study_meeting/study3.html>Boost.勉強会 #3 関西</a> </li> <li style="display: none"> <a href=/study_meeting/study4.html>Boost.勉強会 #4</a> </li> <li style="display: none"> <a href=/study_meeting/study5.html>Boost.勉強会 #5 名古屋</a> </li> <li style="display: none"> <a href=/study_meeting/study6.html>Boost.勉強会 #6 札幌</a> </li> <li style="display: none"> <a href=/study_meeting/study7.html>Boost.勉強会 #7 東京</a> </li> <li style="display: none"> <a href=/study_meeting/study8.html>Boost.勉強会 #8 大阪</a> </li> <li style="display: none"> <a href=/study_meeting/study9.html>Boost.勉強会 #9 つくば</a> </li> <li style="display: none"> <a href=/study_meeting/year-end-party2010-nagoya.html>Boost.忘年会 2010@名古屋</a> </li> <li style="display: none"> <a href=/study_meeting/year-end-party2010-sapporo.html>Boost.忘年会 2010@sapporo</a> </li> <li style="display: none"> <a href=/study_meeting/year-end-party2010-tokyo.html>Boost.忘年会 2010@東京</a> </li> </ul> </li> <li class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/tips.html>Boost逆引きリファレンス</a> <ul> <li style="display: none"> <a href=/tips/array.html>配列</a> </li> <li style="display: none"> <a href=/tips/build.html>ビルドツール</a> </li> <li style="display: none"> <a href=/tips/build_link.html>ヘッダオンリー or ビルドが必要なライブラリ</a> </li> <li style="display: none"> <a href=/tips/circular_buffer.html>循環バッファ</a> </li> <li style="display: none"> <a href=/tips/config.html>コンパイラ間の差を吸収する</a> </li> <li style="display: none"> <a href=/tips/constcond_overload.html>コンパイル時条件によるオーバーロード</a> </li> <li style="display: none"> <a href=/tips/cxx11-boost-mapping.html>C++11とBoostの対応付け</a> </li> <li style="display: none"> <a href=/tips/date_time.html>日付の計算</a> </li> <li style="display: none"> <a href=/tips/dynamic_assert.html>実行時アサート</a> </li> <li style="display: none"> <a href=/tips/dynamic_bitset.html>サイズを動的に変更できるビット集合</a> </li> <li style="display: none"> <a href=/tips/dynamic_regex.html>動的な正規表現</a> </li> <li style="display: none"> <a href=/tips/dynamic_type.html>動的型</a> </li> <li style="display: none"> <a href=/tips/filesystem.html>ファイル／ディレクトリ操作</a> </li> <li style="display: none"> <a href=/tips/finite_state_machine.html>有限状態マシン</a> </li> <li style="display: none"> <a href=/tips/foreach.html>for each文</a> </li> <li style="display: none"> <a href=/tips/format.html>文字列フォーマット</a> </li> <li style="display: none"> <a href=/tips/function.html>関数ポインタと関数オブジェクトを統一的に扱う</a> </li> <li style="display: none"> <a href=/tips/geometry.html>計算幾何</a> </li> <li style="display: none"> <a href=/tips/graph.html>グラフ</a> </li> <li style="display: none"> <a href=/tips/hashmap.html>ハッシュ表</a> </li> <li style="display: none"> <a href=/tips/ini.html>iniファイルの読み込み／書き込み</a> </li> <li style="display: none"> <a href=/tips/initialize.html>組み込み型を必ず初期化する</a> </li> <li style="display: none"> <a href=/tips/interval_arithmetic.html>区間演算</a> </li> <li style="display: none"> <a href=/tips/io_state.html>ストリームの状態を戻す</a> </li> <li style="display: none"> <a href=/tips/iterator.html>イテレータを作る</a> </li> <li style="display: none"> <a href=/tips/json.html>JSONの読み込み／書き込み</a> </li> <li style="display: none"> <a href=/tips/lambda.html>無名関数</a> </li> <li style="display: none"> <a href=/tips/linear-algebra.html>線形代数</a> </li> <li style="display: none"> <a href=/tips/list.html>リスト処理の遅延評価</a> </li> <li style="display: none"> <a href=/tips/lockfree-queue.html>ロックフリーキュー</a> </li> <li style="display: none"> <a href=/tips/lockfree-stack.html>ロックフリースタック</a> </li> <li style="display: none"> <a href=/tips/logging.html>ロギング</a> </li> <li style="display: none"> <a href=/tips/math.html>数学</a> </li> <li style="display: none"> <a href=/tips/memory_mapped_file.html>メモリマップドファイル</a> </li> <li style="display: none"> <a href=/tips/move.html>ムーブ可能なクラスを定義する</a> </li> <li style="display: none"> <a href=/tips/mpi.html>MPI による並列計算</a> </li> <li style="display: none"> <a href=/tips/multi_array.html>多次元配列</a> </li> <li style="display: none"> <a href=/tips/multi_index.html>コンテナに複数の並び順を持たせる</a> </li> <li style="display: none"> <a href=/tips/multiprec-float.html>多倍長浮動小数点数</a> </li> <li style="display: none"> <a href=/tips/multiprec-int.html>多倍長整数</a> </li> <li style="display: none"> <a href=/tips/named_parameter.html>名前付き引数</a> </li> <li style="display: none"> <a href=/tips/noncopyable.html>クラスをコピー不可にする</a> </li> <li style="display: none"> <a href=/tips/noncopyable_container.html>コピー不可なオブジェクトを持ちまわる</a> </li> <li style="display: none"> <a href=/tips/operators.html>演算子を自動定義する</a> </li> <li style="display: none"> <a href=/tips/optional.html>無効値の統一的な表現</a> </li> <li style="display: none"> <a href=/tips/parser.html>構文解析</a> </li> <li style="display: none"> <a href=/tips/partial_eval.html>カリー化／部分適用</a> </li> <li style="display: none"> <a href=/tips/priority_sort.html>優先順位を付けて並べ替える</a> </li> <li style="display: none"> <a href=/tips/program_options.html>コマンドラインオプションの定義／取得</a> </li> <li style="display: none"> <a href=/tips/random.html>乱数</a> </li> <li style="display: none"> <a href=/tips/scope_guard.html>スコープを抜ける際に実行されるブロック</a> </li> <li style="display: none"> <a href=/tips/serialize.html>シリアライズ</a> </li> <li style="display: none"> <a href=/tips/signals.html>シグナル／スロット</a> </li> <li style="display: none"> <a href=/tips/smart_ptr.html>リソースを自動的に解放する</a> </li> <li style="display: none"> <a href=/tips/static_assert.html>コンパイル時アサート</a> </li> <li style="display: none"> <a href=/tips/static_regex.html>静的な正規表現</a> </li> <li style="display: none"> <a href=/tips/statistics.html>統計処理</a> </li> <li style="display: none"> <a href=/tips/string_algo.html>文字列操作</a> </li> <li style="display: none"> <a href=/tips/template_page.html>テンプレートページ</a> </li> <li style="display: none"> <a href=/tips/thread.html>スレッド</a> </li> <li style="display: none"> <a href=/tips/timer.html>処理時間の計測</a> </li> <li style="display: none"> <a href=/tips/tuple.html>タプル</a> </li> <li style="display: none"> <a href=/tips/type_traits.html>型特性</a> </li> <li style="display: none"> <a href=/tips/unit_test.html>単体テスト</a> </li> <li style="display: none"> <a href=/tips/uuid.html>オブジェクトにユニークなIDを付ける</a> </li> <li style="display: none"> <a href=/tips/variant.html>ユーザー定義型を扱える型安全な共用体</a> </li> <li style="display: none"> <a href=/tips/version.html>Boostのバージョンを調べる</a> </li> <li style="display: none"> <a href=/tips/xml.html>XMLの読み込み／書き込み</a> </li> <li style="display: none" class="parent_li "> <span onclick="tree_onclick.call(this, event)"><i class="glyphicon glyphicon-plus"></i></span> <a href=/tips/network.html>ネットワーク</a> <ul> <li style="display: none"> <a href=/tips/network/tcp.html>ネットワーク - TCP</a> </li> </ul> </li> </ul> </li> </ul> </div> </div> <div class=col-md-9> <div class=row> <ol class=breadcrumb> <li> <a href=/archive.html>アーカイブ</a> </li> <li> <a href=/archive/boost_docs.html>旧Boost日本語化プロジェクト</a> </li> <li> libs </li> <li> concept_check </li> <li class=active> libs/concept_check/stl_concept_covering.cpp </li> </ol> </div> <div class=row> <h1>libs/concept_check/stl_concept_covering.cpp</h1> <p><pre class=codehilite><code class=language-cpp><span style="color: #000">// (C) Copyright Jeremy Siek 2000-2002. Permission to copy, use, modify,
// sell and distribute this software is granted provided this
// copyright notice appears in all copies. This software is provided
// "as is" without express or implied warranty, and with no claim as
// to its suitability for any purpose.

#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;boost/concept_check.hpp&gt;
#include &lt;boost/concept_archetype.hpp&gt;

/*

 This file uses the archetype classes to find out which concepts
 actually *cover* the STL algorithms true requirements. The
 archetypes/concepts chosen do not necessarily match the C++ standard
 or the SGI STL documentation, but instead were chosen based on the
 minimal concepts that current STL implementations require, which in
 many cases is less stringent than the standard. In some places there
 was significant differences in the implementations' requirements and
 in those places macros were used to select different requirements,
 the purpose being to document what the requirements of various
 implementations are.  It is an open issue as to whether the C++
 standard should be changed to reflect these weaker requirements.

*/

boost::detail::dummy_constructor dummy_cons;

// This is a special concept needed for std::swap_ranges.
// It is mutually convertible, and also SGIAssignable
template &lt;class T&gt;
class mutually_convertible_archetype
{
private:
  mutually_convertible_archetype() { }
public:
  mutually_convertible_archetype(const mutually_convertible_archetype&amp;) { }
  mutually_convertible_archetype&amp; 
  operator=(const mutually_convertible_archetype&amp;)
    { return *this; }
  mutually_convertible_archetype(boost::detail::dummy_constructor) { }

  template &lt;class U&gt;
  mutually_convertible_archetype&amp; 
  operator=(const mutually_convertible_archetype&lt;U&gt;&amp;)
    { return *this; }

};


// for std::accumulate
namespace accum
{
  typedef boost::sgi_assignable_archetype&lt;&gt; Ret;
  struct T {
    T(const Ret&amp;) { }
    T(boost::detail::dummy_constructor x) { }
  };
  typedef boost::null_archetype&lt;&gt; Tin;
  Ret operator+(const T&amp;, const Tin&amp;) {
    return Ret(dummy_cons);
  }
}

// for std::inner_product
namespace inner_prod
{
  typedef boost::sgi_assignable_archetype&lt;&gt; RetAdd;
  typedef boost::sgi_assignable_archetype&lt;&gt; RetMult;
  struct T {
    T(const RetAdd&amp;) { }
    T(boost::detail::dummy_constructor x) { }
  };
  typedef boost::null_archetype&lt;int&gt; Tin1;
  typedef boost::null_archetype&lt;char&gt; Tin2;
}

namespace boost { // so Koenig lookup will find

  inner_prod::RetMult
  operator*(const inner_prod::Tin1&amp;, const inner_prod::Tin2&amp;) {
    return inner_prod::RetMult(dummy_cons);
  }
  inner_prod::RetAdd 
  operator+(const inner_prod::T&amp;, 
            const inner_prod::RetMult&amp;) {
    return inner_prod::RetAdd(dummy_cons);
  }
}


// for std::partial_sum and adj_diff
namespace part_sum
{
  typedef boost::null_archetype&lt;&gt; Tout;
  typedef boost::sgi_assignable_archetype&lt;
    boost::convertible_to_archetype&lt;Tout&gt; &gt; Ret;
  class Tin {
  public:
    Tin(const Ret&amp;) { }
    Tin(boost::detail::dummy_constructor x) { }  
    operator const Tout&amp;() const { return boost::static_object&lt;Tout&gt;::get(); }
  private:
    Tin() { }
  };
  Ret operator+(const Tin&amp;, const Tin&amp;) {
    return Ret(dummy_cons);
  }
  Ret operator-(const Tin&amp;, const Tin&amp;) {
    return Ret(dummy_cons);
  }
}

// for std::power

namespace power_stuff {
  struct monoid_archetype {
    monoid_archetype(boost::detail::dummy_constructor x) { }  
  };

  boost::multipliable_archetype&lt;monoid_archetype&gt;
  identity_element
  (std::multiplies&lt; boost::multipliable_archetype&lt;monoid_archetype&gt; &gt;) 
  {
    return boost::multipliable_archetype&lt;monoid_archetype&gt;(dummy_cons);
  }
}

struct tag1 { };
struct tag2 { };

int
main()
{
  using namespace boost;

  //===========================================================================
  // Non-mutating Algorithms
  {
    input_iterator_archetype&lt; 
      convertible_to_archetype&lt; null_archetype&lt;&gt;  &gt; &gt; in;
    unary_function_archetype&lt; null_archetype&lt;&gt; , null_archetype&lt;&gt; &gt; 
      f(dummy_cons);
    std::for_each(in, in, f);
  }
  {
    typedef equality_comparable2_first_archetype&lt;&gt; Left;
    input_iterator_archetype&lt; Left &gt; in;
    equality_comparable2_second_archetype&lt;&gt; value(dummy_cons);
    in = std::find(in, in, value);
  }
  {
    input_iterator_archetype&lt; 
      convertible_to_archetype&lt; null_archetype&lt;&gt;  &gt; &gt; in;
    unary_predicate_archetype&lt; null_archetype&lt;&gt;  &gt; pred(dummy_cons);
    in = std::find_if(in, in, pred);
  }
  {
    forward_iterator_archetype&lt; equality_comparable_archetype&lt;&gt; &gt; fo;
    fo = std::adjacent_find(fo, fo);
  }
  {
    forward_iterator_archetype&lt; 
      convertible_to_archetype&lt; null_archetype&lt;&gt;  &gt; &gt; fo;
    binary_predicate_archetype&lt;null_archetype&lt;&gt; , null_archetype&lt;&gt; &gt; 
      pred(dummy_cons);
    fo = std::adjacent_find(fo, fo, pred);
  }
  {
    typedef equal_op_first_archetype&lt;&gt; Left;
    input_iterator_archetype&lt;Left&gt; in;
    typedef equal_op_second_archetype&lt;&gt; Right;
    forward_iterator_archetype&lt;Right&gt; fo;
    in = std::find_first_of(in, in, fo, fo);
  }
  {
    typedef equal_op_first_archetype&lt;&gt; Left;
    typedef input_iterator_archetype&lt;Left&gt; InIter;
    InIter in;
    function_requires&lt; InputIteratorConcept&lt;InIter&gt; &gt;();
    equal_op_second_archetype&lt;&gt; value(dummy_cons);
    std::iterator_traits&lt;InIter&gt;::difference_type
      n = std::count(in, in, value);
    ignore_unused_variable_warning(n);
  }
  {
    typedef input_iterator_archetype&lt;
      convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; &gt; InIter;
    InIter in;
    unary_predicate_archetype&lt;null_archetype&lt;&gt; &gt; pred(dummy_cons);
    std::iterator_traits&lt;InIter&gt;::difference_type
      n = std::count_if(in, in, pred);
    ignore_unused_variable_warning(n);
  }
  {
    typedef equal_op_first_archetype&lt;&gt; Left;
    typedef input_iterator_archetype&lt;Left&gt; InIter1;
    InIter1 in1;
    typedef equal_op_second_archetype&lt;&gt; Right;
    typedef input_iterator_archetype&lt;Right&gt; InIter2;
    InIter2 in2;
    std::pair&lt;InIter1, InIter2&gt; p = std::mismatch(in1, in1, in2);
    ignore_unused_variable_warning(p);
  }
  {
    typedef input_iterator_archetype&lt;
      convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; &gt; InIter;
    InIter in1, in2;
    binary_predicate_archetype&lt;null_archetype&lt;&gt; , null_archetype&lt;&gt; &gt; 
      pred(dummy_cons);
    std::pair&lt;InIter, InIter&gt; p = std::mismatch(in1, in1, in2, pred);
    ignore_unused_variable_warning(p);
  }
  {
    typedef equality_comparable2_first_archetype&lt;&gt; Left;
    input_iterator_archetype&lt;Left&gt; in1;
    typedef equality_comparable2_second_archetype&lt;&gt; Right;
    input_iterator_archetype&lt;Right&gt; in2;
    bool b = std::equal(in1, in1, in2);
    ignore_unused_variable_warning(b);
  }
  {
    input_iterator_archetype&lt; convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; &gt;
      in1, in2;
    binary_predicate_archetype&lt;null_archetype&lt;&gt; , null_archetype&lt;&gt; &gt; 
      pred(dummy_cons);
    bool b = std::equal(in1, in1, in2, pred);
    ignore_unused_variable_warning(b);
  }
  {
    typedef equality_comparable2_first_archetype&lt;&gt; Left;
    forward_iterator_archetype&lt;Left&gt; fo1;
    typedef equality_comparable2_second_archetype&lt;&gt; Right;
    forward_iterator_archetype&lt;Right&gt; fo2;
    fo1 = std::search(fo1, fo1, fo2, fo2);
  }
  {
    typedef equality_comparable2_first_archetype&lt; 
      convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; &gt; Left;
    forward_iterator_archetype&lt;Left&gt; fo1;
    typedef equality_comparable2_second_archetype&lt;
      convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; &gt; Right;
    forward_iterator_archetype&lt;Right&gt; fo2;
    binary_predicate_archetype&lt;null_archetype&lt;&gt; , null_archetype&lt;&gt; &gt; 
      pred(dummy_cons);
    fo1 = std::search(fo1, fo1, fo2, fo2, pred);
  }
  {
    typedef equality_comparable2_first_archetype&lt;&gt; Left;
    forward_iterator_archetype&lt;Left&gt; fo;
    equality_comparable2_second_archetype&lt;&gt; value(dummy_cons);
    int n = 1;
    fo = std::search_n(fo, fo, n, value);
  }
  {
    forward_iterator_archetype&lt; 
      convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; &gt; fo;
    convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; value(dummy_cons);
    binary_predicate_archetype&lt;null_archetype&lt;&gt; , null_archetype&lt;&gt; &gt; 
      pred(dummy_cons);
    int n = 1;
    fo = std::search_n(fo, fo, n, value, pred);
  }
  {
    typedef equality_comparable2_first_archetype&lt;&gt; Left;
    forward_iterator_archetype&lt;Left&gt; fo1;
    typedef equality_comparable2_second_archetype&lt;null_archetype&lt;&gt; &gt; Right;
    forward_iterator_archetype&lt;Right&gt; fo2;
    fo1 = std::find_end(fo1, fo1, fo2, fo2);
  }
  {
    // equality comparable required because find_end() calls search
    typedef equality_comparable2_first_archetype&lt;
      convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; &gt; Left;
    forward_iterator_archetype&lt;Left&gt; fo1;
    typedef equality_comparable2_second_archetype&lt;
      convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; &gt; Right;
    forward_iterator_archetype&lt;Right&gt; fo2;
    binary_predicate_archetype&lt;null_archetype&lt;&gt; , null_archetype&lt;&gt; &gt; 
      pred(dummy_cons);
    fo1 = std::find_end(fo1, fo1, fo2, fo2, pred);
  }

  //===========================================================================
  // Mutating Algorithms

  {
    typedef null_archetype&lt;&gt; OutT;
    typedef convertible_to_archetype&lt;OutT&gt; InT;
    input_iterator_archetype&lt;InT&gt; in;
    output_iterator_archetype&lt;OutT&gt; out(dummy_cons);
    out = std::copy(in, in, out);
  }
  {
    typedef assignable_archetype&lt;&gt; OutT;
    typedef convertible_to_archetype&lt;OutT&gt; InT;
    bidirectional_iterator_archetype&lt;InT&gt; bid_in;
    mutable_bidirectional_iterator_archetype&lt;OutT&gt; bid_out;
    bid_out = std::copy_backward(bid_in, bid_in, bid_out);
  }
  {
    sgi_assignable_archetype&lt;&gt; a(dummy_cons), b(dummy_cons);
    std::swap(a, b);
  }
  {
    typedef sgi_assignable_archetype&lt;&gt; T;
    mutable_forward_iterator_archetype&lt;T&gt; a, b;
    std::iter_swap(a, b);
  }
  {
    typedef mutually_convertible_archetype&lt;int&gt; Tin;
    typedef mutually_convertible_archetype&lt;char&gt; Tout;
    mutable_forward_iterator_archetype&lt;Tin&gt; fi1;
    mutable_forward_iterator_archetype&lt;Tout&gt; fi2;
    fi2 = std::swap_ranges(fi1, fi1, fi2);
  }
  {
    typedef convertible_to_archetype&lt;null_archetype&lt;&gt; &gt; Tin;
    typedef null_archetype&lt;&gt; Tout;
    input_iterator_archetype&lt;Tin&gt; in;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    unary_function_archetype&lt;null_archetype&lt;&gt; , 
      convertible_to_archetype&lt;Tout&gt; &gt; op(dummy_cons);
    out = std::transform(in, in, out, op);
  }
  {
    typedef convertible_to_archetype&lt;null_archetype&lt;int&gt; &gt; Tin1;
    typedef convertible_to_archetype&lt;null_archetype&lt;char&gt; &gt; Tin2;
    typedef null_archetype&lt;&gt; Tout;
    input_iterator_archetype&lt;Tin1&gt; in1;
    input_iterator_archetype&lt;Tin2&gt; in2;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    binary_function_archetype&lt;null_archetype&lt;int&gt;, null_archetype&lt;char&gt;,
      convertible_to_archetype&lt;Tout&gt; &gt; op(dummy_cons);
    out = std::transform(in1, in1, in2, out, op);
  }
  {
    typedef equality_comparable2_first_archetype&lt;
      assignable_archetype&lt;&gt; &gt; FT;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    equality_comparable2_second_archetype&lt;
      convertible_to_archetype&lt;FT&gt; &gt; value(dummy_cons);
    std::replace(fi, fi, value, value);
  }
  {
    typedef null_archetype&lt;&gt; PredArg;
    typedef assignable_archetype&lt; 
      convertible_to_archetype&lt;PredArg&gt; &gt; FT;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    unary_predicate_archetype&lt;PredArg&gt; pred(dummy_cons);
    convertible_to_archetype&lt;FT&gt; value(dummy_cons);
    std::replace_if(fi, fi, pred, value);
  }
  {
#if 0
    // Issue, the use of ?: inside replace_copy() complicates things
    typedef equal_op_first_archetype&lt;&gt; Tin;
    typedef null_archetype&lt;&gt; Tout;
    typedef equal_op_second_archetype&lt; convertible_to_archetype&lt;Tout&gt; &gt; T;
    input_iterator_archetype&lt;Tin&gt; in;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    T value(dummy_cons);
    out = std::replace_copy(in, in, out, value, value);
#else
    typedef null_archetype&lt;&gt; Tout;
    typedef equal_op_second_archetype&lt; convertible_to_archetype&lt;Tout&gt; &gt; T;
    // Adding convertible to T for Tin solves the problem, so would
    // making T convertible to Tin. Not sure what the right way to
    // express the requirement would be. Also, perhaps the
    // implementation's use of ?: is invalid.
    typedef equal_op_first_archetype&lt; convertible_to_archetype&lt;T&gt; &gt; Tin;
    input_iterator_archetype&lt;Tin&gt; in;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    T value(dummy_cons);
    out = std::replace_copy(in, in, out, value, value);
#endif
  }
  {
    // The issue of ?: also affects this function
    typedef null_archetype&lt;int&gt; PredArg;
    typedef null_archetype&lt;char&gt; Tout;
    typedef convertible_to_archetype&lt;Tout, 
      convertible_to_archetype&lt;PredArg&gt; &gt; T;
    typedef convertible_to_archetype&lt;PredArg,
      convertible_to_archetype&lt;Tout,
      convertible_to_archetype&lt;T&gt; &gt; &gt; Tin;
    input_iterator_archetype&lt;Tin&gt; in;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    unary_predicate_archetype&lt;PredArg&gt; pred(dummy_cons);
    T value(dummy_cons);
    out = std::replace_copy_if(in, in, out, pred, value);
  }
  {
    typedef assignable_archetype&lt;&gt; FT;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    typedef convertible_to_archetype&lt;FT&gt; T;
    T value(dummy_cons);
    std::fill(fi, fi, value);
  }  
  {
    typedef null_archetype&lt;&gt; Tout;
    typedef convertible_to_archetype&lt;Tout&gt; T;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    T value(dummy_cons);
    int n = 1;
    out = std::fill_n(out, n, value);
  }
  {
    typedef assignable_archetype&lt;&gt; FT;
    typedef convertible_to_archetype&lt;FT&gt; Ret;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    generator_archetype&lt;Ret&gt; gen;
    std::generate(fi, fi, gen);
  }
  {
    typedef assignable_archetype&lt;&gt; FT;
    typedef convertible_to_archetype&lt;FT&gt; Ret;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    generator_archetype&lt;Ret&gt; gen;
    int n = 1;
    std::generate_n(fi, n, gen);
  }
  {
    typedef assignable_archetype&lt; equality_comparable2_first_archetype&lt;&gt; &gt; FT;
    typedef equality_comparable2_second_archetype&lt;&gt; T;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    T value(dummy_cons);
    fi = std::remove(fi, fi, value);
  }
  {
    typedef assignable_archetype&lt;&gt; FT;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    typedef null_archetype&lt;&gt; PredArg;
    unary_predicate_archetype&lt;PredArg&gt; pred(dummy_cons);
    fi = std::remove_if(fi, fi, pred);
  }
  {
    typedef null_archetype&lt;&gt; Tout;
    typedef equality_comparable2_first_archetype&lt;
      convertible_to_archetype&lt;Tout&gt; &gt; Tin;
    typedef equality_comparable2_second_archetype&lt;&gt; T;
    input_iterator_archetype&lt;Tin&gt; in;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    T value(dummy_cons);
    out = std::remove_copy(in, in, out, value);
  }
  {
    typedef null_archetype&lt;int&gt; Tout;
    typedef null_archetype&lt;char&gt; PredArg;
    typedef convertible_to_archetype&lt;PredArg,
      convertible_to_archetype&lt;Tout&gt; &gt; Tin;
    input_iterator_archetype&lt;Tin&gt; in;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    unary_predicate_archetype&lt;PredArg&gt; pred(dummy_cons);
    out = std::remove_copy_if(in, in, out, pred);
  }
  {
    typedef sgi_assignable_archetype&lt; equality_comparable_archetype&lt;&gt; &gt; T;
    mutable_forward_iterator_archetype&lt;T&gt; fi;
    fi = std::unique(fi, fi);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
    typedef sgi_assignable_archetype&lt; 
      convertible_to_archetype&lt;Arg1,
      convertible_to_archetype&lt;Arg2&gt; &gt; &gt; FT;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    binary_predicate_archetype&lt;Arg1, Arg2&gt; pred(dummy_cons);
    fi = std::unique(fi, fi, pred);
  }
  {
    typedef equality_comparable_archetype&lt; sgi_assignable_archetype&lt;&gt; &gt; T;
    input_iterator_archetype&lt;T&gt; in;
    output_iterator_archetype&lt;T&gt; out(dummy_cons);
    out = std::unique_copy(in, in, out);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
    typedef null_archetype&lt;short&gt; Tout;
    typedef sgi_assignable_archetype&lt; 
      convertible_to_archetype&lt;Tout,
      convertible_to_archetype&lt;Arg1,
      convertible_to_archetype&lt;Arg2&gt; &gt; &gt; &gt; Tin;
    input_iterator_archetype&lt;Tin&gt; in;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    binary_predicate_archetype&lt;Arg1, Arg2&gt; pred(dummy_cons);
    out = std::unique_copy(in, in, out, pred);
  }
  {
    typedef sgi_assignable_archetype&lt;&gt; T;
    mutable_bidirectional_iterator_archetype&lt;T&gt; bi;
    std::reverse(bi, bi);
  }
  {
    typedef null_archetype&lt;&gt; Tout;
    typedef convertible_to_archetype&lt;Tout&gt; Tin;
    bidirectional_iterator_archetype&lt;Tin&gt; bi;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    out = std::reverse_copy(bi, bi, out);
  }
  {
    typedef sgi_assignable_archetype&lt;&gt; T;
    mutable_forward_iterator_archetype&lt;T&gt; fi;
    // Issue, SGI STL is not have void return type, C++ standard does
    std::rotate(fi, fi, fi);
  }
  {
    typedef null_archetype&lt;&gt; Tout;
    typedef convertible_to_archetype&lt;Tout&gt; FT;
    forward_iterator_archetype&lt;FT&gt; fi;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    out = std::rotate_copy(fi, fi, fi, out);
  }
  {
    typedef sgi_assignable_archetype&lt;&gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    std::random_shuffle(ri, ri);
  }
  {
    typedef sgi_assignable_archetype&lt;&gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    unary_function_archetype&lt;std::ptrdiff_t, std::ptrdiff_t&gt; ran(dummy_cons);
    std::random_shuffle(ri, ri, ran);
  }
  {
    typedef null_archetype&lt;&gt; PredArg;
    typedef sgi_assignable_archetype&lt;convertible_to_archetype&lt;PredArg&gt; &gt; FT;
    mutable_bidirectional_iterator_archetype&lt;FT&gt; bi;
    unary_predicate_archetype&lt;PredArg&gt; pred(dummy_cons);
    bi = std::partition(bi, bi, pred);
  }
  {
    typedef null_archetype&lt;&gt; PredArg;
    typedef sgi_assignable_archetype&lt;convertible_to_archetype&lt;PredArg&gt; &gt; FT;
    mutable_forward_iterator_archetype&lt;FT&gt; fi;
    unary_predicate_archetype&lt;PredArg&gt; pred(dummy_cons);
    fi = std::stable_partition(fi, fi, pred);
  }

  //===========================================================================
  // Sorting Algorithms
  {
    typedef sgi_assignable_archetype&lt; 
      less_than_comparable_archetype&lt;&gt; &gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    std::sort(ri, ri);
  }
  {
    typedef null_archetype&lt;&gt; Arg;
    typedef sgi_assignable_archetype&lt; 
      convertible_to_archetype&lt;Arg&gt; &gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    std::sort(ri, ri, comp);
  }
  {
    typedef less_than_comparable_archetype&lt; 
        sgi_assignable_archetype&lt;&gt; &gt; ValueType;
    mutable_random_access_iterator_archetype&lt;ValueType&gt; ri;
    std::stable_sort(ri, ri);
  }
  {
    typedef null_archetype&lt;&gt; Arg;
    typedef sgi_assignable_archetype&lt;
      convertible_to_archetype&lt;Arg&gt; &gt; ValueType;
    mutable_random_access_iterator_archetype&lt;ValueType&gt; ri;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    std::stable_sort(ri, ri, comp);
  }
  {
    typedef sgi_assignable_archetype&lt; 
      less_than_comparable_archetype&lt;&gt; &gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    std::partial_sort(ri, ri, ri);
  }

  {
    typedef null_archetype&lt;&gt; Arg;
    typedef sgi_assignable_archetype&lt; 
      convertible_to_archetype&lt;Arg&gt; &gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    std::partial_sort(ri, ri, ri, comp);
  }
  {
    // This could be formulated so that the two iterators are not
    // required to have the same value type, but it is messy.
    typedef sgi_assignable_archetype&lt; 
      less_than_comparable_archetype&lt;&gt; &gt; T;
    input_iterator_archetype&lt;T&gt; in;
    mutable_random_access_iterator_archetype&lt;T&gt; ri_out;
    ri_out = std::partial_sort_copy(in, in , ri_out, ri_out);
  }
  {
    typedef null_archetype&lt;&gt; Arg;
    typedef sgi_assignable_archetype&lt;
      convertible_to_archetype&lt;Arg&gt; &gt; T;
    input_iterator_archetype&lt;T&gt; in;
    mutable_random_access_iterator_archetype&lt;T&gt; ri_out;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    ri_out = std::partial_sort_copy(in, in , ri_out, ri_out, comp);
  }
  {
    typedef sgi_assignable_archetype&lt; less_than_comparable_archetype&lt;&gt; &gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    std::nth_element(ri, ri, ri);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
    typedef sgi_assignable_archetype&lt;
      convertible_to_archetype&lt;Arg1,
      convertible_to_archetype&lt;Arg2&gt; &gt; &gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    binary_predicate_archetype&lt;Arg1, Arg2&gt; comp(dummy_cons);
    std::nth_element(ri, ri, ri, comp);
  }
  {
#if defined(__GNUC__)
    typedef less_than_op_first_archetype&lt;&gt; FT;
    typedef less_than_op_second_archetype&lt;&gt; T;
#elif defined(__KCC)
    // The KAI version of this uses a one-argument less-than function
    // object.
    typedef less_than_comparable_archetype&lt;&gt; T;
    typedef convertible_to_archetype&lt;T&gt; FT;
#endif
    forward_iterator_archetype&lt;FT&gt; fi;
    T value(dummy_cons);
    fi = std::lower_bound(fi, fi, value);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
    typedef convertible_to_archetype&lt;Arg1&gt; FT;
    typedef convertible_to_archetype&lt;Arg2&gt; T;
    forward_iterator_archetype&lt;FT&gt; fi;
    T value(dummy_cons);
    binary_predicate_archetype&lt;Arg1, Arg2&gt; comp(dummy_cons);
    fi = std::lower_bound(fi, fi, value, comp);
  }
  {
#if defined(__GNUC__)
    // Note, order of T,FT is flipped from lower_bound
    typedef less_than_op_second_archetype&lt;&gt; FT;
    typedef less_than_op_first_archetype&lt;&gt; T;
#elif defined(__KCC)
    typedef less_than_comparable_archetype&lt;&gt; T;
    typedef convertible_to_archetype&lt;T&gt; FT;
#endif
    forward_iterator_archetype&lt;FT&gt; fi;
    T value(dummy_cons);
    fi = std::upper_bound(fi, fi, value);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
    // Note, order of T,FT is flipped from lower_bound
    typedef convertible_to_archetype&lt;Arg1&gt; T;
    typedef convertible_to_archetype&lt;Arg2&gt; FT;
    forward_iterator_archetype&lt;FT&gt; fi;
    T value(dummy_cons);
    binary_predicate_archetype&lt;Arg1, Arg2&gt; comp(dummy_cons);
    fi = std::upper_bound(fi, fi, value, comp);
  }
  {
#if defined(__GNUC__)
    typedef less_than_op_first_archetype&lt;
      less_than_op_second_archetype&lt; null_archetype&lt;&gt;, optag2&gt;, optag1&gt; FT;
    typedef less_than_op_second_archetype&lt;
      less_than_op_first_archetype&lt; null_archetype&lt;&gt;, optag2&gt;, optag1&gt; T;
#elif defined(__KCC)
    typedef less_than_comparable_archetype&lt;&gt; T;
    typedef convertible_to_archetype&lt;T&gt; FT;
#endif
    typedef forward_iterator_archetype&lt;FT&gt; FIter;
    FIter fi;
    T value(dummy_cons);
    std::pair&lt;FIter,FIter&gt; p = std::equal_range(fi, fi, value);
    ignore_unused_variable_warning(p);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
    typedef convertible_to_archetype&lt;Arg1,
      convertible_to_archetype&lt;Arg2&gt; &gt; FT;
    typedef convertible_to_archetype&lt;Arg2,
      convertible_to_archetype&lt;Arg1&gt; &gt; T;
    typedef forward_iterator_archetype&lt;FT&gt; FIter;
    FIter fi;
    T value(dummy_cons);
    binary_predicate_archetype&lt;Arg1, Arg2&gt; comp(dummy_cons);
    std::pair&lt;FIter,FIter&gt; p = std::equal_range(fi, fi, value, comp);
    ignore_unused_variable_warning(p);
  }
  {
#if defined(__GNUC__)
    typedef less_than_op_first_archetype&lt;
      less_than_op_second_archetype&lt;null_archetype&lt;&gt;, optag2&gt;, optag1&gt; FT;
    typedef less_than_op_second_archetype&lt;
      less_than_op_first_archetype&lt;null_archetype&lt;&gt;, optag2&gt;, optag1&gt; T;
#elif defined(__KCC)
    typedef less_than_op_first_archetype&lt; less_than_comparable_archetype&lt;&gt; &gt; T;
    typedef less_than_op_second_archetype&lt; convertible_to_archetype&lt;T&gt; &gt; FT;
#endif
    forward_iterator_archetype&lt;FT&gt; fi;
    T value(dummy_cons);
    bool b = std::binary_search(fi, fi, value);
    ignore_unused_variable_warning(b);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
#if defined(__GNUC__) || defined(__KCC)
    typedef convertible_to_archetype&lt;Arg1,
      convertible_to_archetype&lt;Arg2&gt; &gt; FT;
    typedef convertible_to_archetype&lt;Arg2,
      convertible_to_archetype&lt;Arg1&gt; &gt; T;
#endif
    typedef forward_iterator_archetype&lt;FT&gt; FIter;
    FIter fi;
    T value(dummy_cons);
    binary_predicate_archetype&lt;Arg1, Arg2&gt; comp(dummy_cons);
    bool b = std::binary_search(fi, fi, value, comp);
    ignore_unused_variable_warning(b);
  }
  {
    typedef null_archetype&lt;&gt; Tout;
#if defined(__GNUC__) || defined(__KCC)
    typedef less_than_op_first_archetype&lt;
      less_than_op_second_archetype&lt;
      convertible_to_archetype&lt;Tout&gt;, optag2&gt;, optag1 &gt; Tin1;
    typedef less_than_op_second_archetype&lt;
      less_than_op_first_archetype&lt;
      convertible_to_archetype&lt;Tout&gt;, optag2&gt; ,optag1&gt; Tin2;
#endif
    input_iterator_archetype&lt;Tin1&gt; in1;
    input_iterator_archetype&lt;Tin2&gt; in2;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    out = std::merge(in1, in1, in2, in2, out);
    out = std::set_union(in1, in1, in2, in2, out);
    out = std::set_intersection(in1, in1, in2, in2, out);
    out = std::set_difference(in1, in1, in2, in2, out);
    out = std::set_symmetric_difference(in1, in1, in2, in2, out);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
    typedef null_archetype&lt;short&gt; Tout;
#if defined(__GNUC__) || defined(__KCC)
    typedef convertible_to_archetype&lt;Tout,
      convertible_to_archetype&lt;Arg1,
      convertible_to_archetype&lt;Arg2&gt; &gt; &gt; Tin1;
    typedef convertible_to_archetype&lt;Tout,
      convertible_to_archetype&lt;Arg2,
      convertible_to_archetype&lt;Arg1&gt; &gt; &gt; Tin2;
#endif
    input_iterator_archetype&lt;Tin1&gt; in1;
    input_iterator_archetype&lt;Tin2&gt; in2;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    binary_predicate_archetype&lt;Arg1, Arg2&gt; comp(dummy_cons);
    out = std::merge(in1, in1, in2, in2, out, comp);
    out = std::set_union(in1, in1, in2, in2, out, comp);
    out = std::set_intersection(in1, in1, in2, in2, out, comp);
    out = std::set_difference(in1, in1, in2, in2, out, comp);
    out = std::set_symmetric_difference(in1, in1, in2, in2, out, comp);
  }
  {
    typedef sgi_assignable_archetype&lt; 
      less_than_comparable_archetype&lt;&gt; &gt; T;
    mutable_bidirectional_iterator_archetype&lt;T&gt; bi;
    std::inplace_merge(bi, bi, bi);
  }
  {
    typedef null_archetype&lt;&gt; Arg;
    typedef sgi_assignable_archetype&lt; 
      convertible_to_archetype&lt;Arg&gt; &gt; T;
    mutable_bidirectional_iterator_archetype&lt;T&gt; bi;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    std::inplace_merge(bi, bi, bi, comp);
  }
  {
#if defined(__GNUC__) || defined(__KCC)
    typedef less_than_op_first_archetype&lt;
      less_than_op_second_archetype&lt;null_archetype&lt;&gt;, optag1&gt;, optag2&gt; Tin1;
    typedef less_than_op_second_archetype&lt;
      less_than_op_first_archetype&lt;null_archetype&lt;&gt;, optag1&gt;, optag2&gt; Tin2;
#endif
    input_iterator_archetype&lt;Tin1&gt; in1;
    input_iterator_archetype&lt;Tin2&gt; in2;
    bool b = std::includes(in1, in1, in2, in2);
    b = std::lexicographical_compare(in1, in1, in2, in2);
    ignore_unused_variable_warning(b);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
#if defined(__GNUC__) || defined(__KCC)
    typedef convertible_to_archetype&lt;Arg1,
      convertible_to_archetype&lt;Arg2&gt; &gt; Tin1;
    typedef convertible_to_archetype&lt;Arg2,
      convertible_to_archetype&lt;Arg1&gt; &gt; Tin2;
#endif
    input_iterator_archetype&lt;Tin1&gt; in1;
    input_iterator_archetype&lt;Tin2&gt; in2;
    binary_predicate_archetype&lt;Arg1, Arg2&gt; comp(dummy_cons);
    bool b = std::includes(in1, in1, in2, in2, comp);
    b = std::lexicographical_compare(in1, in1, in2, in2, comp);
    ignore_unused_variable_warning(b);
  }
  {
    typedef sgi_assignable_archetype&lt;
      less_than_comparable_archetype&lt;&gt; &gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    std::push_heap(ri, ri);
    std::pop_heap(ri, ri);
    std::make_heap(ri, ri);
    std::sort_heap(ri, ri);
  }
  {
    typedef null_archetype&lt;&gt; Arg;
    typedef sgi_assignable_archetype&lt; 
      convertible_to_archetype&lt;Arg&gt; &gt; T;
    mutable_random_access_iterator_archetype&lt;T&gt; ri;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    std::push_heap(ri, ri, comp);
    std::pop_heap(ri, ri, comp);
    std::make_heap(ri, ri, comp);
    std::sort_heap(ri, ri, comp);
  }
  {
    typedef less_than_comparable_archetype&lt;&gt; T;
    T a(dummy_cons), b(dummy_cons);
    const T&amp; c = std::min(a, b);
    const T&amp; d = std::max(a, b);
    ignore_unused_variable_warning(c);
    ignore_unused_variable_warning(d);
  }
  {
    typedef null_archetype&lt;&gt; Arg;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    typedef convertible_to_archetype&lt;Arg&gt; T;
    T a(dummy_cons), b(dummy_cons);
    const T&amp; c = std::min(a, b, comp);
    const T&amp; d = std::max(a, b, comp);
    ignore_unused_variable_warning(c);
    ignore_unused_variable_warning(d);
  }
  {
    typedef less_than_comparable_archetype&lt;&gt; T;
    forward_iterator_archetype&lt;T&gt; fi;
    fi = std::min_element(fi, fi);
    fi = std::max_element(fi, fi);
  }
  {
    typedef null_archetype&lt;&gt; Arg;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    typedef convertible_to_archetype&lt;Arg&gt; T;
    forward_iterator_archetype&lt;T&gt; fi;
    fi = std::min_element(fi, fi, comp);
    fi = std::max_element(fi, fi, comp);
  }
  {
    typedef sgi_assignable_archetype&lt;
      less_than_comparable_archetype&lt;&gt; &gt; T;
    mutable_bidirectional_iterator_archetype&lt;T&gt; bi;
    bool b = std::next_permutation(bi, bi);
    b = std::prev_permutation(bi, bi);
    ignore_unused_variable_warning(b);
  }
  {
    typedef null_archetype&lt;&gt; Arg;
    binary_predicate_archetype&lt;Arg, Arg&gt; comp(dummy_cons);
    typedef sgi_assignable_archetype&lt;
      convertible_to_archetype&lt;Arg&gt; &gt; T;
    mutable_bidirectional_iterator_archetype&lt;T&gt; bi;
    bool b = std::next_permutation(bi, bi, comp);
    b = std::prev_permutation(bi, bi, comp);
    ignore_unused_variable_warning(b);
  }
  //===========================================================================
  // Generalized Numeric Algorithms

  {
    // Bummer, couldn't use plus_op because of a problem with
    // mutually recursive types.
    input_iterator_archetype&lt;accum::Tin&gt; in;
    accum::T init(dummy_cons);
    init = std::accumulate(in, in, init);
  }
  {
    typedef null_archetype&lt;int&gt; Arg1;
    typedef null_archetype&lt;char&gt; Arg2;
    typedef sgi_assignable_archetype&lt;
      convertible_to_archetype&lt;Arg1&gt; &gt; T;
    typedef convertible_to_archetype&lt;T&gt; Ret;
    typedef convertible_to_archetype&lt;Arg2&gt; Tin;
    input_iterator_archetype&lt;Tin&gt; in;
    T init(dummy_cons);
    binary_function_archetype&lt;Arg1, Arg2, Ret&gt; op(dummy_cons);
    init = std::accumulate(in, in, init, op);
  }
  {
    input_iterator_archetype&lt;inner_prod::Tin1&gt; in1;
    input_iterator_archetype&lt;inner_prod::Tin2&gt; in2;
    inner_prod::T init(dummy_cons);
    init = std::inner_product(in1, in1, in2, init);
  }
  {
    typedef null_archetype&lt;int&gt; MultArg1;
    typedef null_archetype&lt;char&gt; MultArg2;
    typedef null_archetype&lt;short&gt; AddArg1;
    typedef null_archetype&lt;long&gt; AddArg2;
    typedef sgi_assignable_archetype&lt;
      convertible_to_archetype&lt;AddArg1&gt; &gt; T;
    typedef convertible_to_archetype&lt;AddArg2&gt; RetMult;
    typedef convertible_to_archetype&lt;T&gt; RetAdd;
    typedef convertible_to_archetype&lt;MultArg1&gt; Tin1;
    typedef convertible_to_archetype&lt;MultArg2&gt; Tin2;
    input_iterator_archetype&lt;Tin1&gt; in1;
    input_iterator_archetype&lt;Tin2&gt; in2;
    T init(dummy_cons);
    binary_function_archetype&lt;MultArg1, MultArg2, RetMult&gt; mult_op(dummy_cons);
    binary_function_archetype&lt;AddArg1, AddArg2, RetAdd&gt; add_op(dummy_cons);
    init = std::inner_product(in1, in1, in2, init, add_op, mult_op);
  }
  {
    input_iterator_archetype&lt;part_sum::Tin&gt; in;
    output_iterator_archetype&lt;part_sum::Tout&gt; out(dummy_cons);
    out = std::partial_sum(in, in, out);
  }
  {
    typedef null_archetype&lt;int&gt; Arg;
    typedef null_archetype&lt;char&gt; Tout;
    typedef sgi_assignable_archetype&lt;
      convertible_to_archetype&lt;Arg,
      convertible_to_archetype&lt;Tout&gt; &gt; &gt; Tin;
    typedef convertible_to_archetype&lt;Tout,
      convertible_to_archetype&lt;Tin&gt; &gt; Ret;
    input_iterator_archetype&lt;Tin&gt; in;
    output_iterator_archetype&lt;Tout&gt; out(dummy_cons);
    binary_function_archetype&lt;Arg, Arg, Ret&gt; add_op(dummy_cons);
    out = std::partial_sum(in, in, out, add_op);
    binary_function_archetype&lt;Arg, Arg, Ret&gt; subtract_op(dummy_cons);
    out = std::adjacent_difference(in, in, out, subtract_op);
  }
  {
    input_iterator_archetype&lt;part_sum::Tin&gt; in;
    output_iterator_archetype&lt;part_sum::Tout&gt; out(dummy_cons);
    out = std::adjacent_difference(in, in, out);
  }
  return 0;
}</span></code></pre> </p> </div> </div> </div> </div> </main> </body> <!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --> <!--[if lt IE 7 ]>
        <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
        <script>
            window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
        </script>
    <![endif]--> </html>